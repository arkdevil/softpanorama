─ SOFTPAN.TALKS (2:463/18.1) ─────────────────────────────────── SOFTPAN.TALKS ─
 Msg  : 144 of 192
 From : dk@farm.cs.kiev.ua          2:463/10                Sat 13 Mar 93 12:24
 To   : All
 Subj : (1) Re: What's new in Dylan? Is it even OO?
────────────────────────────────────────────────────────────────────────────────
.REPLYADDR dk@farm.cs.kiev.ua
.REPLYTO 2:463/10 Uucp
X-RealName: Dmitry S. Kohmanyuk


        OOP как новая религия ;)

>From bh@anarres.CS.Berkeley.EDU  Sat Mar 13 12:46:28 1993

Path:
farmua!relay1!csoft!kiae!relcom!fuug!mcsun!marble.uknet.ac.uk!warwick!pipex!doc.
ic.ac.uk!agate!anarres.CS.Berkeley.EDU!bh
From: bh@anarres.CS.Berkeley.EDU (Brian Harvey)
Newsgroups: comp.lang.dylan
Subject: Re: What's new in Dylan? Is it even OO?
Date: 13 Mar 1993 02:22:21 GMT
Organization: University of California, Berkeley
Lines: 166
Message-ID: <1nrggt$pcl@agate.berkeley.edu>
References: <137450016@otter.hpl.hp.com> <C3spK1.E7B@cs.bham.ac.uk>
<JROBBINS.93Mar12144906@kingston.cs.ucla.edu>
NNTP-Posting-Host: anarres.cs.berkeley.edu


Well, as luck would have it, it just so happens that today I gave my
standard lecture on OOP to my data structures class, and it's all about
these very issues, so I thought I'd share it with you and see how many
flames it will attract.

Here goes:

                   What Is Object Oriented Programming?

As you know, any time you get six computer scientists together and ask
them any question whatsoever, you always get at least half a dozen
different answers -- unless the question is "What do you think about
object-oriented programming," in which case they all say "It's the
greatest thing ever invented!"

What can this mean?

Actually, what it means is that they're not all talking about the same
thing.  Each has taken his or her favorite idea and called it "OOP."
So this lecture can't really live up to its title, because there really
is no such thing as OOP.  Instead, this will be a lecture about the
various types of computer scientist, and what each type means by OOP.

There are four types; I'll describe them from low to high on the
evolutionary scale.

1.  The Paranoid.

Some computer scientists think that the most important thing in all of
computer science is to ensure that you can't possibly ever make a mistake
in writing a computer program, no matter how stupid or careless you are.
To this end, they judge their tools not by what the tool *allows* you to
do, but by what it *prevents* you from doing.  The more prevention, the
better they like it.  Computer scientists of this class tend to like
Pascal, and/or to have several alphabetically consecutive letters in
their names.

A type-1 computer scientist, asked what's so great about C++, will
say something like this:  In C, you can create structs, which are new
data types containing fields.  What's OOPy in C++ is that you can
declare certain fields of a struct to be *private*, which means that
only a few specially privileged procedures, associated with that
object type, are allowed to make reference to those fields.  This is
an OOPy feature because it doesn't allow the C++ program to do anything
that the corresponding C program couldn't have done; instead it *restricts*
what the C++ program can do.  Isn't that great?


2 and 3.  Failed Religions.

Categories 2 and 3 are computer scientists who have established a religion
in which some programming technique or style is deemed to be immoral.  The
result is a more elegant form of programming.  However, the result is also
a form of programming that really doesn't cut the mustard -- you just can't
get practical work done in it.  So, instead of admitting that they were
wrong, these computer scientists reinvent the forbidden feature under some
other name, and call it OOP.  Details follow:


2.  The Religion of Strong Typing.

One failed religion in computer science is the one that says that every
variable must have a "type" associated with it, and can never take on
any value outside of that type.  This restriction is alleged to prevent
bugs by preventing the use of a variable for a purpose other than the
one originally intended.

So, for example, members of this religion don't like programs such as

        (define (square x)
          (* x x))

because this program is too sloppy about the type of the variable x.
Instead they want you to write this:

        int square_of_int(int x) {
            return x * x;
        }

        float square_of_float(float x) {
            return x * x;
        }

This religion elevates an accident of history, concerning the ways in which
numbers are represented inside computers, to a principle.

But of course it's intolerable to have to define many different procedures
that all do the same thing, just because the types are different.  OOP to
the rescue!  A type-2 computer scientist will explain that C++ is OOPy
because it provides *overloading*, a feature that allows the two procedures
above to be given the *same name*.  C++ figures out automatically which one
to use by checing the type of the actual argument.  (You still have to
define the procedure twice; the amazing feature is that you can use the
same name for both.)

[Anecdote:  A colleague of mine once explained at a faculty meeting that
we should teach our introductory CS course using C++ instead of Scheme,
because in C++, supposing you want to be able to have linked lists of
integers, and you also want to be able to have linked lists of floating
point numbers, you only have to write the implementation of linked lists
once!]


3.  The Religion of Referential Transparency.

Some computer scientists believe that you should be able to read a program
and understand the thing to which a particular use of a particular symbol
refers, just from the text of the program, without thinking about the
context in which it's used.  For example, these computer scientists reject
the use of dynamic scope, because the variable associated with a given
symbol under dynamic scope may depend on which procedure *invoked* the
procedure in which it occurs, something that can't be known until the
program is running.  Under lexical scope, by contrast, the variable
associated with a given symbol in a given context depends only on the
location of that context within the text of the program -- whether, that
is, the procedure in which it occurs is *defined* within some other
procedure.

The trouble is that sometimes the meaning of a symbol *should* depend
on the context in which it's used.  So these computer scientists have
had to fall back on the idea of *inheritance*, whereby the meaning of
a symbol used within a method of one class may depend on definitions
in some other class from which this one inherits.  A dynamic change in
the methods or instance variables of that other class modifies the
meaning of symbols used in the child class.

(This aspect of inheritance is really more relevant to a dynamic OOP
language like CLOS or Dylan than to one like C++, in which everything
is defined ahead of time.  Type-3 computer scientists are often Lisp fans.)


4.  OOP as Metaphor.

The fourth category of computer scientists focuses not on technical
capabilities but on ways of thinking.  People in this category know
that every language is technically equivalent to every other language;
one is better suited than another to some task because it allows the
*programmer* to understand the task more easily, not because it allows
the *computer* to solve it more easily.

Certain problems are most naturally understood as an interaction among
independent actors.  The paradigmatic example is simulation.  You want
to decide whether to add a lane to the Bay Bridge, or turn an existing
lane into a carpool lane, so you write a computer program to simulate
the traffic.  This program's most natural form is one in which each
car (that is, each driver, really) carries out actions in parallel with
every other one.  Each driver is affected by the actions of other
nearby drivers, but each acts separately and each has a separate
intelligence.  There is no one taskmaster overhead moving all of the
cars.

Another example of a naturally object-oriented task is a window system.
The user wants to be able to manipulate any window, e.g., to move or
resize it.  The most natural thing is for the user to address a request
directly to the window, not to some overall operating system that
manages all the windows.  (It doesn't matter that behind the scenes
there is indeed, probably, one operating system; what matters is the
metaphor through which the user uses the system.)

What feature does a type-4 computer scientist single out as the one
that makes C++ OOPy?  None!  To a type-4 computer scientist, there is
nothing OOPy about C++, because it doesn't use a message-passing
metaphor.  You don't ask objects to do things; your one program
calls procedures with objects as (passive) arguments.  The only
OOP language is Smalltalk!


--
((setter reply-address) *my-mail* "dk%farm.cs.kiev.ua@ussr.eu.net") #| cs:dk |#
