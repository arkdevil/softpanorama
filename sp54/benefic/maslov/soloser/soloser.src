procedure main
 parameters argv1
 private kh[3]
 private kp[3]
 private bcs[3]
 private key

 kh[1] = 51
 kh[2] = 105
 kh[3] = 122
 kp[1] = 165
 kp[2] = 50
 kp[3] = 195

 if pcount() > 0
    parsaf(argv1, kh)  /* get and decrypt demo number */
    key = safhea(bcs, kp)
    parsaf(key, kp)
    @ MAXROW(), 0 say "key: " + key
    return
 else
    @ MAXROW(), 0 say "soloser <demo number>"
 endif

 return

function parsaf
 parameters hen, km
 private k
 private bh[3]

 digsaf(hen, bh)
 for k = 1 to 3 step 1
     bcs[k] = numxor(bh[k], km[k]) /* was xor(bh[k], km[k]) */
 next
 return ""

function digsaf
 parameters hen,bm
 private hek

 hek = hen
 hen = substr(hek,7) + substr(hek,1,6)
 z1 = ascpos(hen,1)
 z2 = ascpos(hen,6)
 z3 = z1 - z2 + 48
 hen = posrepl(hen,chr(z2),1)
 hen = posrepl(hen,chr(z3),6)
 p1 = substr(hen,1,5)
 p22 = substr(hen,6,3)
 w2 = round(val(p1),0)
 bm[2] = round(val(p22),0)
 bm[1] = round(w2 % 256,0)
 bm[3] = round((w2 - bm[1]) / 256,0)
 return ""

function safhea
 parameters bm, km
 private k
 private bh[3]

 for k = 1 to 3 step 1
     bh[k] = numxor(bm[k], km[k]) /* was xor(bm[k], km[k]) */
 next
 hen = safdig(bh)
 return hen

function safdig
 parameters bm

 w2 = bm[3] * 256 + bm[1]
 p1 = ntoc(w2,10,5,"0")
 p22 = ntoc(bm[2],10,3,"0")
 z1 = substr(p1,1,1)
 z2 = substr(p22,1,1)
 z3 = chr(asc(z1) + asc(z2) - 48)
 p1 = posrepl(p1,z3,1)
 p22 = posrepl(p22,z1,1)
 hen = substr(p1,3) + p22 + substr(p1,1,2)
 return hen

procedure errorsys
 return
