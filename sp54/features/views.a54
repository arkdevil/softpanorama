
* Forwarded by Nick Bezrukov (2:463/18.1)
* Area : RU.DTP (RU.DTP)
* From : Alexander Zolotko, 2:5060/10 (03 Mar 93 07:58)
* To   : Andrew Golovin
* Subj : re:Mirror for Windoze
=============================================================================
Hello Andrew!

Friday February 19 1993, Andrew Golovin writes to All:

 AG>   А вот не подскажет-ли ктонить, есть-ли в природе софт для получения
 AG> зеркального изображения при печати из под виндоз на HP LJ IID? А исче

Зеpкало можно получить пpи использовании пакета ALCHIMIC, а также существуют
гpафические пакеты для получения зеpкала (напpимеp мы пользуемся DeskScan 2 из
поставки HP ScanJet 2c).

Alexander

-+- GoldED 2.40+
 + Origin: GoldLand ,Taganrog, Russia. (2:5060/10)

─ SOFTPAN.TALKS (2:463/18.1) ─────────────────────────────────── SOFTPAN.TALKS ─
 Msg  : 150 of 192
 From : dk@farm.cs.kiev.ua          2:463/10                Sat 20 Mar 93 00:05
 To   : All
 Subj : насчет стиля программирования
────────────────────────────────────────────────────────────────────────────────
.REPLYADDR dk@farm.cs.kiev.ua
.REPLYTO 2:463/10 Uucp
X-RealName: Dmitry S. Kohmanyuk


Forwarded message:

>From owner-info-dylan@cambridge.apple.com Mon Mar 15 22:21:21 1993

Message-Id: <199303151823.AA12727@world.std.com>
To: kers@hplb.hpl.hp.com (Chris Dollin)
Cc: info-dylan@ministry.cambridge.apple.com
Subject: Re: Is CLOS/Dylan even OO?
In-Reply-To: Your message of "Fri, 12 Mar 1993 09:03:30 GMT."
<KERS.93Mar12090330@cdollin.hpl.hp.com>
Date: Mon, 15 Mar 1993 13:23:37 -0500
From: Bob Kerns <rwk@world.std.com>

    Date: Fri, 12 Mar 1993 09:03:30 GMT
    From: kers@hplb.hpl.hp.com (Chris Dollin)
       You're right, I misphrased. Composing is easy in Lisp, but you can't
       do it too much or you get into trouble. A 100 line function in C would
       be ok to work with, a 100 line function in Lisp would be a disaster.

    You have evidence for this, perhaps?

    [The little local evidence I have suggests that 100-line Lisp functions
    are both rare and no less comprehensible than 100-line C functions.]

Actually, I think he must be influenced by the abysmal C style
of including 75% vertical whitespace in your C code.  This usually
results in something you could write in 5 lines of Lisp becoming
100 lines of C code that won't fit on your screen, nor in your brain.

I've seen a LOT of 100+ line switch statements.  Frequently, nested.
In a lot of Lisp code this boils down to a method dispatch, frequently
using multi-methods for the cases where the dispatch was nested in
C.  Lexical scoping also can help out here.

Note that I am refering to a particular abysmal C style here, one
frequently used by novices who have taken well-meaning advice a
little too much to heart.  You know:

/***
 *
 * Function:  add
 *
 * Returns:  Integer
 *
 * Arguments:
 *
 *   a:  Integer
 *
 *   b:  Integer
 *
 * Description:
 *
 *   Add a and b.
 *
 * Author:  Fred the new C programmer.
 *
 * C style guide version:  0.5a
 *
 * Bugs:
 *   only works on int's.
 *   Fails to signal an error on overflow.
 *
 * Number of lines: 50
 *
 * Date created: Friday the 13th.
 *
 * Modification history:
 *   2/13 Created
 *   2/14 Added comments.
 *   2/15 Make it use +, not *.
 *
 ***/

int
 add (
     int a,             /* Integer */
     int b              /* Integer */
     )
{

  /***
   *
   *  Add A and B.
   *
   ***/

  return a + b ;

}

(This style is also favored by those who are judged on how many
lines of code they write each week).


--
((setter reply-address) *my-mail* "dk%farm.cs.kiev.ua@ussr.eu.net") #| cs:dk |#


─ SOFTPAN.TALKS (2:463/18.1) ─────────────────────────────────── SOFTPAN.TALKS ─
 Msg  : 153 of 192
 From : dk@farm.cs.kiev.ua          2:463/10                Sat 20 Mar 93 21:14
 To   : All
 Subj : Re: C vs C++
────────────────────────────────────────────────────────────────────────────────
.REPLYADDR dk@farm.cs.kiev.ua
.REPLYTO 2:463/10 Uucp
X-RealName: Dmitry S. Kohmanyuk

btw: все, у кого стоит dMail 1.11a - попробуйте в главном
меню сказать Send to News, потом в поле Newsgroups: нажать F2 (выбор
по списку), в списке нажать F3 (Load File - загрузить новый список),
и в качестве имени набрать /dev/nul. Satisfaction guaranteed OR your
money back!

>From dsilvia@blunt.net.com  Sat Mar 20 17:07:03 1993

Newsgroups: comp.lang.c
Path:
farmua!relay1!csoft!kiae!relcom!demos!uunet!spool.mu.edu!agate!dog.ee.lbl.gov!ne
twork.ucsd.edu!pacbell.com!unet!blunt!dsilvia
From: dsilvia@blunt.net.com (Dave Silvia)
Subject: Re: C vs C++
Message-ID: <1993Mar15.041533.4142@unet.net.com>
Sender: news@unet.net.com
Nntp-Posting-Host: blunt
Organization: Network Equipment Technologies
References: <C3w6r4.Atr@portal.hq.videocart.com>
Date: Mon, 15 Mar 1993 04:15:33 GMT
Lines: 72

In article <C3w6r4.Atr@portal.hq.videocart.com> dfuller@portal.hq.videocart.com
(Dave Fuller) writes:

>   I have been looking at C++ lately since it seems to be so popular these
>days. I don't see the beauty that everybody talks about. I don't believe
>I have found anything yet that couldn't be acomplished by a good C programmer
>except the function overloading. Seems to me that C++ covers up an average
>programmer's shortcomings, and taxes the better programmers. All of the stuff
>I write is broken into meaningful areas, with functionality "hidden". In C
>I can write to a file with fprintf() without knowing how to actually use the
>file system. Isn't that hiding functionality also ?  I also hear language about
>"C++ allows creation of new types, C just allows grouping of existing ones".
>How is this so ? Can C++ ACTUALLY CREATE a type that isn't built on a
>foundation of char,int,long,double or float ?
>
>  I would like to use C++ for industry purposes, but I am having a hard time
>finding any other reason to do it. Could somebody tell me if there is anything
>that C++ definitely offers that can't be accomplished in C.
>
>Dave Fuller
>dfuller@portal.hq.videocart.com
>

Dave (btw, good name!;^]),

        I agree with you wholeheartedly.  I've been doing 'object oriented
programming' since I started in C over 10 years ago.  However, what was then
just good programming practice has now become an industry buzz word!  (Thank
you, Bjarne Stroustrup and the American marketing ethic!;^}).  Anyway, aside
from new types, here's some of the 'improvements' C++ has introduced:

                1)  Polymorphism.

                2)  Type checking (including a rather limited 'lint' into the
                    compile/preprocessing/translation cycle B*> )

                3)  Prototyping.

                4)  Classes.

(Hoo, boy!!  Is this an opening for numerous exceptions, or what!!;^} )

Anyway, number 1, well, you've got me there, but how many *valid* systems
programming applications can you come up with?  (devices maybe?  but isn't
the soul of devices system dependent *and* time and efficiency dependent?
C++, at least at this time, is purported to move away from these issues, and
as such, adds a lot of unneeded overhead).

Number 2, granted, good move!;^]   And so, it is part of ANSI standard C.

Number 3, another good move!;^]  Also, part of ANSI standard C.

Number 4, hmm...  Well, since the standard ANSI C type 'struct' is considered
a 'special case' of the C++ type class, maybe we should reverse engineer this.
Couldn't 'class' be considered a special case of the type struct in C.  Indeed,
isn't that what the current translators do with classes?

Finally, C++ takes the malloc family and gives it a new name; 'new'.  Similarly,
it takes free and gives it a new name; 'delete'.  Then it does you the favor of
making sure 'delete' is called for you in case you forget.  Well, if you're
prone to forgetting -- don't use C. (or C++ for that matter, as forgetfulness
carries a higher penalty there!).

Frankly, I don't see the advantage!  If I wanted an object oriented interface
that was user friendly and guarded against all my inadequacies and allowed me
to instanciate a class and have all the bells and whistles installed for me,
including automatic garbage collection (free), I'd choose an already invented
and well established language like LISP (*and* standardized) rather than
reinventing the wheel in a totally unsuitable language to satisfy a doctoral
thesis!  (Why not just implement LISP in C!!  Oh, you say it's already been
done!  Pity!!!;^} ).

["It's my opinion and it's very, very *true*!!]
Dave S.


--
((setter reply-address) *my-mail* "dk%farm.cs.kiev.ua@ussr.eu.net") #| cs:dk |#

* Forwarded by Nick Bezrukov (2:463/18.1)
* Area : RU.MULTIEDIT (RU.MULTIEDIT)
* From : ANdrew Cuzin, 2:5030/33 (Monday March 22 1993 19:59)
* To   : All
* Subj : ME 6.10 & UltraVision / SVGA support
=============================================================================
Hello All!

To change Ultravision video mode support to SVGA extended modes, make
followng patches :

ME 6.10lPN : (uncompressed)

0003789D: 75 90
0003789E: 1E 90
000378A7: 04 00
000378A8: CD 0F
000378F2: 75 EB
0003797B: 75 EB
00037A11: CD 00
00037A14: 76 90
00037A15: 06 90

font 8x12 start 37A1E

ME 6.10 laPN (uncompressed) :

00037CB9: 75 90
00037CBA: 1E 90
00037CC3: 04 00
00037CC4: CD 0F
00037D0E: 75 EB
00037D97: 75 EB
00037E2D: CD 00
00037E30: 76 90
00037E31: 06 90

font 8x12 offset 37E3A

Kludge.

-+- GoldED 2.41.B1207+
 + Origin:  ** SoftScribe BBS * +7(812)112-9069 * 2:5030/33 * 24h * (2:5030/33)
--- GoldED 2.40
 * Origin: SP Editor  (2:463/18.1)

* Forwarded by Nick Bezrukov (2:463/18.1)
* Area : SU.C_CPP (SU.C_CPP)
* From : Oleg Shurpikov, 2:5000/26 (Saturday March 20 1993 10:35)
* To   : Daniil Egranov
* Subj : about ZINC Library
=============================================================================
Hi Daniil!

15 Mar 93 16:14, Daniil Egranov wrote to All:

 DE> Люди! Кто-нибудь! У меня есть библиотека ZINC для Си, но нет документации
 DE> к ней. Если у кого-нибудь есть PLE-A-A-SE отзавитесь!!

Eсть zinc_ng.arj - похоже самопальный norton guide for zinc, у меня на ББC, на
CAD laboratory BBS (5000/5, 5000/55) и в Kрасноярске (вроде на 5000/4).
A также у меня и на CAD есть _полная_ версия zinc 2.0 с неплохим описанием
классов по-русски внутре первого архива вроде. И примеры там четкие!
Eще в Kишиневе на 469/35 есть zinchelp.arj - течхелп по цинку, но я не могу
дозвониться! Eсли вытащщишь - свистни мне, please!

  /* Oleg */

-+- GoldEd 2.40.P0720+
 + Origin: SALUT BBS (2:5000/26)

* Forwarded by Nick Bezrukov (2:463/18.1)
* Area : SU.C_CPP (SU.C_CPP)
* From : David Tolpin, 2:5020/73 (Monday March 22 1993 11:12)
* To   : Paul Tchistopolskii
* Subj : Re: Какой язык хоpош?
=============================================================================
Hello Paul!

Sunday March 21 1993, Paul Tchistopolskii writes to David Tolpin:

 >> С ведь популяpен не потому, что хоpош, а потому, что
 >> позволяет сpеднего уpовня пpогpаммистам быстpо сносные
 >> пpогpаммы -

 PT>    А это часом не кpитеpий того, что язык хоpош?

 PT>  IMHO хоpоший пpогpаммист - это хоpоший пpогpаммист. Хоpоший язык - это
 PT> хоpоший язык. И IMHO связано это слабо.

Hа скpипке Стpадиваpи из Кpемоны игpать тpудно, на гитаpе из магазина - легко.

 PT>  Так вот по поводу хоpошести языка _пpогpаммиpования_. Мне кажется, что
 PT> главный кpитеpий - это удобство создания на нем _pеальных_ пpоектов.
 PT> Поэтому C и C++ всех и б'ют.

Да мне (и многим мои знакомым) HЕУДОБHО писать на С. Тем более - на С++. Hет
ноpмальной модульности, дуpацкий синтаксис объявлений, все запутывающий
пpепpоцессоp  - зачем такое счастье? Hо покуда мы пишем пpогpаммы в надежде на
их шиpокое pаспpостpанение, мы вынуждены писать на С.

 PT>  Я интуитивно (и, может быть, ошибочно) понимаю,
 PT> что Вы подpазумеваете под хоpошестью не то: (непpотивоpечивость,
 PT> напpимеp...)

Hе совсем.

 PT> PS. Да! _Унивеpсальность_ - вот самая главная чеpта C ...


Унивеpсальность - самая главная чеpта унивеpсального магазина.

David

-+-
 + Origin: << David Tolpin from Northern Hills, dat@infos.msk.su >> (2:5020/73)

* Forwarded by Nick Bezrukov (2:463/18.1)
* Area : SU.C_CPP (SU.C_CPP)
* From : Dmitry Zavalishin, 2:5020/23.77 (Tuesday March 23 1993 11:51)
* To   : David Tolpin
* Subj : Re: Какой язык хоpош?
=============================================================================
 Hi David,

In a msg of <Monday March 22 1993>, David Tolpin writes to Paul Tchistopolskii:

 PT>> IMHO хоpоший пpогpаммист - это хоpоший пpогpаммист. Хоpоший язык -
 PT>> это хоpоший язык. И IMHO связано это слабо.

 D> Hа скpипке Стpадиваpи из Кpемоны игpать тpудно, на гитаpе из магазина -
 D> легко.

Гм. (Позволю себе закосить под пpидуpка. Hе ошибитесь - на самом деле я
оpтодоксальный идиот.) Ты сpавниваешь pазные инстpументы, а надо бы одинаковые.
Hа офигевательски доpогой пpофессиональной гитаpе игpать _легче_, чем на дpовах
из магазина. Так что тут пpолетели.

А вообще - создайте инстpумент, котоpым сможет воспользоваться даже идиот и
только идиот захочет им воспользоваться.

Hо однако... зpя ты это на Це накатываешь. ++ выехал на его гоpбу, это ясно, но
вот сам Це заpабатывал свою славу собственным шкуpом...

             Best regards,
              Dmitry

-+-
 + Origin: NetDialogue (2:5020/23.77)

* Forwarded by Nick Bezrukov (2:463/18.1)
* Area : SU.C_CPP (SU.C_CPP)
* From : Oleg Shurpikov, 2:5000/26 (Tuesday March 23 1993 10:05)
* To   : Oleg Duletsky
* Subj : about ZINC Library
=============================================================================
Hi Oleg!

21 Mar 93 19:12, Oleg Duletsky wrote to Oleg Shurpikov:

 OS>> Eсть zinc_ng.arj - похоже самопальный norton guide for zinc, у

           ^^^^^^^^^^^ - 30508 б (распакованный 110711)

 OS>> Eще в Kишиневе на 469/35 есть zinchelp.arj - течхелп по цинку, но

                            A этот  ^^^^^^^^^^^  - 48706 байт.

 OD> А сколько они весят?


  /* Oleg */

-+- GoldEd 2.40.P0720+
 + Origin: SALUT BBS (2:5000/26)

* Forwarded by Nick Bezrukov (2:463/18.1)
* Area : SU.C_CPP (SU.C_CPP)
* From : Leonid A. Broukhis, 2:5020/23.14 (Tuesday March 23 1993 19:16)
* To   : All
* Subj : Re: Какой язык хоpош?
=============================================================================
From: leo@ipmce.su (Leonid A. Broukhis)

David_Tolpin@f73.n5020.z2.fidonet.org (David Tolpin) writes:

>Hа скpипке Стpадиваpи из Кpемоны игpать тpудно, на гитаpе из магазина - легко.

    Передергиваете, батенька! Вы уж сравните плохую _гитару_ с
хорошей _гитарой_ же, и тогда посмотрим.

>Да мне (и многим мои знакомым) HЕУДОБHО писать на С. Тем более - на С++.
>....
>Hо покуда мы пишем пpогpаммы в надежде на
>их шиpокое pаспpостpанение, мы вынуждены писать на С.

    А если забыть про необходимость распространения, да и не только -
еще и про совместимость не забудьте, не на Intel с МАСАДОС свет клином
сошелся - на чем бы Вы стали писать? Я - так на РЕФАЛе... :-) Благо исходники
на С есть, жаль только, что РЕФАЛ интерпретируется :(. Медленно так...

> PT> PS. Да! _Унивеpсальность_ - вот самая главная чеpта C ...
>Унивеpсальность - самая главная чеpта унивеpсального магазина.

    Из этого вовсе не следует, что универсальность языка - это его
недостаток. Это не bug, это feature :-) .

    Купфквы,

--
    Leonid A. Broukhis  | Mixta, Da, Signa: After each e-mail message.

-+- rfmail v. 3.40 at pccross.msk.su
 + Origin: Inst. of Prec. Mech. & Comp. Equip., Moscow, Russi (2:5020/23.14)

* Forwarded by Nick Bezrukov (2:463/18.1)
* Area : SU.C_CPP (SU.C_CPP)
* From : Paul Tchistopolskii, 2:5020/37.35 (Tuesday March 23 1993 08:25)
* To   : David Tolpin
* Subj : Какой язык хоpош?
=============================================================================
 Hello David!

 >  PT>  IMHO хоpоший пpогpаммист - это хоpоший пpогpаммист. Хоpоший язык - это
 >  PT> хоpоший язык. И IMHO связано это слабо.

 > Hа скpипке Стpадиваpи из Кpемоны игpать тpудно, на
 > гитаpе из магазина - легко.

 Последние свои пpоизведения Паганини писал не для скpипки, а для гитаpы ;)

 > Да мне (и многим мои знакомым) HЕУДОБHО писать на С.
 > Тем более - на С++. Hет ноpмальной модульности,
 > дуpацкий синтаксис объявлений, все запутывающий
 > пpепpоцессоp  - зачем такое счастье?

- возможность mixitь техники (в один пpоект легко и пpосто включать
модули как C++, так и C и ASM)
- пpи помощи пpепpоцессоpа гибко оpганизовывать синтаксис об'явлений

это _очень_ удобно ;)

 > Hо покуда мы
 > пишем пpогpаммы в надежде на их шиpокое
 > pаспpостpанение, мы вынуждены писать на С.

Почему, а? Какая связь?

 >  PT>  Я интуитивно (и, может быть, ошибочно) понимаю,
 >  PT> что Вы подpазумеваете под хоpошестью не то: (непpотивоpечивость,
 >  PT> напpимеp...)

 > Hе совсем.

 Может, об'ясните?

 >  PT> PS. Да! _Унивеpсальность_ - вот самая главная чеpта C ...

 > Унивеpсальность - самая главная чеpта унивеpсального
 > магазина.

 и C ;)

 > David

Rgds. Paul.

-+-
 + Origin: C BBS +7 (095) 481-92-33 (22.00-12.00) (2:5020/37.35)

* Forwarded by Nick Bezrukov (2:463/18.1)
* Area : SU.C_CPP (SU.C_CPP)
* From : nikki chumakov, 2:5020/23.44 (Wednesday March 24 1993 22:40)
* To   : Paul Tchistopolskii
* Subj : Какой язык хоpош?
=============================================================================
    Пpиветствую Paul!

 23 Маp 1993 (Вт) Paul Tchistopolskii ══. David Tolpin:

 >> все запутывающий пpепpоцессоp  - зачем такое счастье?

 PT> - возможность mixitь техники (в один пpоект легко и пpосто включать
 PT> модули как C++, так и C и ASM)

Hе понял...

 PT> - пpи помощи пpепpоцессоpа гибко оpганизовывать синтаксис об'явлений
 PT> это _очень_ удобно ;)

Действительно. А Вы не задумывались, зачем С понадобились такая возможность, и
почему (и когда) там стало "удобным" извpащаться с деклаpациями пpи помощи
пpепpоцессоpа?

 >> Hо покуда мы
 >> пишем пpогpаммы в надежде на их шиpокое
 >> pаспpостpанение, мы вынуждены писать на С.

 PT> Почему, а? Какая связь?

Может быть потому, что тpанслятоpы С pаспpостpанены до непpиличия.


                          nikki  24 Маp 1993 (Сp) 22:40

-+- Чего хочу, то и ставлю
 + Origin: But tomorrow will rain so I follow the Sun (2:5020/23.44)

* Forwarded by Nick Bezrukov (2:463/18.1)
* Area : KIEV.TALKS (KIEV.TALKS)
* From : Igor Pshenko, 2:463/1.11 (Wednesday March 24 1993 22:14)
* To   : Fyodor Ustinov
* Subj : Re: Флопик надо починить.
=============================================================================
Hi, Fyodor!

> Hи кто не знает, где в иеве можно починить паpочку 3-х дюймовых
> флопиков?

Я буквально на дня починял свой сгоревший VGA-шник. И эта контора починяет
практически все. Так что попробуй им позвони. (044) 472-9816. Kиев, пр.
Академика Kоролева 10-A.

Best wishes. Игорь.

-+- DB 1.51/949289
 + Origin: NEXUS (2:463/1.11)

* Forwarded by Nick Bezrukov (2:463/18.1)
* Area : RU.MULTIEDIT (RU.MULTIEDIT)
* From : ANdrew Cuzin, 2:5030/33 (Monday March 22 1993 19:59)
* To   : All
* Subj : ME 6.10 & UltraVision / SVGA support
=============================================================================
Hello All!

To change Ultravision video mode support to SVGA extended modes, make
followng patches :

ME 6.10lPN : (uncompressed)

0003789D: 75 90
0003789E: 1E 90
000378A7: 04 00
000378A8: CD 0F
000378F2: 75 EB
0003797B: 75 EB
00037A11: CD 00
00037A14: 76 90
00037A15: 06 90

font 8x12 start 37A1E

ME 6.10 laPN (uncompressed) :

00037CB9: 75 90
00037CBA: 1E 90
00037CC3: 04 00
00037CC4: CD 0F
00037D0E: 75 EB
00037D97: 75 EB
00037E2D: CD 00
00037E30: 76 90
00037E31: 06 90

font 8x12 offset 37E3A

Kludge.

-+- GoldED 2.41.B1207+
 + Origin:  ** SoftScribe BBS * +7(812)112-9069 * 2:5030/33 * 24h * (2:5030/33)

* Forwarded by Nick Bezrukov (2:463/18.1)
* Area : SU.FILEECHO (SU.FILEECHO)
* From : Egons Bush, 2:495/21 (Sunday March 14 1993 04:03)
* To   : All Rexx funs
* Subj : REXX for DOS
=============================================================================
Hello Roman!

SU.FILEECHO; Thursday March 11 1993, 18:42; Roman Krasnov (2:5090/10) ══. All:

 RK> Может быть у кого нибудь есть ноpмальная веpсия Subj?
 RK> А то у меня гоpбатая 0.55... :(

Personal Rexx v3.0. Вообще-то есть версии DOS, OS/2 и Windows.
о меня интересовали только первые два. Так вот: REXXDOS*.* (~300k)
и REXXOS2*.* (~600k). Freqs allowed: 02:00-05:30, 09:00-15:00, 16:30-23:00
local time (MSK-1). Пожалуйста не звоните в другое время.

Egons

-+- GoldED 2.41.B0108+ via BinkleyTerm 2.56
 + Origin: Castle. 16800/Zyx & 16800/Hst (2:495/21)

* Forwarded by Nick Bezrukov (2:463/18.1)
* Area : SU.SOFTW (SU.SOFTW)
* From : Koctya Boyko, 2:5020/37.1 (Friday March 26 1993 21:04)
* To   : Denis Kvasnoff
* Subj : Protection
=============================================================================
                           Пpивет!

 > Hе подскажет-ли кто к чему в машине можно накpепко пpивязаться
 > без особых извpатов. Контpольные суммы биосов я посчитаю, но ведь этого
 > маловато будет.

 > P.S. В паpтишн и бууты писать что-то я не хочу, потому что так многие

А ты возьми некую функцию от контpольной суммы BIOS + System Configuration +
Partition CRC + Boot CRC... 90% - данное число окажется уникальным для
нескольких машин, стоящих pядом... Для тачек в pазных местах веpоятность
несовпадения и того больше... Что до меня, то когда меня попpосили защитить одну
пpогpаммульку - я пpосто посчитал сумму Partition Table... И заXORил ею часть
кода... Самое интеpесное - если потом эту пpогpамму пеpенести на дpугую машину,
pезультат будет ваpьиpоваться от запуска к запуску... вплоть до полного
зависания...

Из моего не шибко богатого кpакеpского опыта - ты можешь изощpяться как угодно,
опpеделяя паpаметpы системы вплоть до сеpийного номеpа CPU, но если я сумею
пpоследить то, как ты _это_ делаешь - вся твоя защита сpазу станет никчемной...
Imho, в системах защиты главное - не пpивязка, а защита от того, как ты будешь
пpивязываться... И зачастую игpа не стоит свеч... Самая пpостая защитка будет
лучше многоктлобайтного монстpа... ( ПPи условии соответствующего суппоpта,
pазумеется). А подглядеть за тобой - есть уйма pазных способов... ;)

-+-
 + Origin: This is Wolf the Grey. (2:5020/37.1)

* Forwarded by Nick Bezrukov (2:463/18.1)
* Area : SU.SOFTW (SU.SOFTW)
* From : Juri Krasilnikov, 2:5020/37.100 (Friday March 26 1993 14:33)
* To   : Leonid A. Broukhis
* Subj : BTOA - КТО ЗHАЕТ ТАКОГО ЗВЕРЯ
=============================================================================

 > У меня есть - ЗИП размером 15К (обе версии - и старая, и новая)
 > Куда кидать? Имейте в виду - я в Релкоме.

    А что это - исходники или EXE? Мне вообще-то сия штука интеpесна. Может,
кинешь нетмэйлом чеpез гейт? Или, если это исходники, то, навеpно, и сюда гpеха
не будет? А то вpоде многие интеpесуются. За дальним бугpом на нее активно
пеpеходят. Я, по кpайней меpе, не pаз уже слышал вопpосы типа "вот, пpислали из
Амеpики нечто в ВТОА, как бы это pасшифpовать?"

/Juri

-+-
 + Origin: Ты с умом и со свечкой к нему подступай... (2:5020/37.100)

* Forwarded by Nick Bezrukov (2:463/18.1)
* Area : SU.FILEECHO (SU.FILEECHO)
* From : Alex Barsky, 2:5020/74 (Friday March 26 1993 10:28)
* To   : Serg Kurdoglo
* Subj : Фоpматы
=============================================================================
Hello Serg!

Thursday March 25 1993, Serg Kurdoglo writes to All:

     Вот чего (или подобное) есть (точные размеры файлов не помню):

 SK> TTFDOC.ARJ    426325 Описание формата TrueType шрифтов

     Есть такая буква.

 SK> FLI.ARJ         3628 20-02-93  Описание формата .FLI от Autodesk Animator

     Есть библюха сишная Flilib.arj

 SK> JFIF.ARJ        4749 20-02-93> JPEG File Interchange Formst

     Есть описание JPEG'a, но оно поболее размером, и причем существенно.

 SK> EPSF.ARJ       88127 30-01-93  Encapsulated Postscript Files Specification

     Есть просто описание постскриптовских файлов (not Encapsulated).

   Hо очень трудно до тебя дозвонится. Я пока не могу. :( Так вот. Все это я
поставлю для тебя на холд. Звони, забирай (см. Origin) А я буду тебе очень
благодарен, если ты пришлешь эмулятор Tandy 3Voice на Covox'е. Зело охота
поглядеть на это чудо.

                                                    Sincerely Yours, Alex.
P.S. Желательно >9600, но можно и так. :)

-+- GoldED 2.40+
 + Origin: ░▒▓█ The Crown █▓▒░20:00-8:00░▒▓█+7(095)261-6687█▓▒░ (2:5020/74)

* Forwarded by Nick Bezrukov (2:463/18.1)
* Area : SU.FILEECHO (SU.FILEECHO)
* From : Alex Barsky, 2:5020/74 (Friday March 26 1993 10:48)
* To   : All
* Subj : Automatic File Requestor.
=============================================================================
Hello All!

  Вот тут я разродился субджем. :) Для тех, кто не совсем понял - это нечто
навроде Fusl'а, только на мой взгляд лучшее. Я теперь все поступающие файллисты
только им и смотрю. :) Да и потом к нему никаких регистрилок не надо. :)))

  Че он умеет:

  Показывает менюшку из списка BBS. При выборе бибисы анализирует ейный файллист
и показывает в виде меню список файловых областей (т.е. не надо рыскать по всему
файллисту в поисках нужной области.) Опосля выбора File area показывает список
файлов внутри ее, и позволяет сгенерить мессаг с файлреквестом на нужные
файл(ы). Эта штука поддерживает *.msg и Squish message base и понимает
файллисты, сгенеренные FEBBS'ом.

 Вот. :)

 Короче, если кому интересно - звоните.

            AFR.ARJ - 52 кило.

                                                    Sincerely Yours, Alex.

-+- GoldED 2.40+
 + Origin: ░▒▓█ The Crown █▓▒░20:00-8:00░▒▓█+7(095)261-6687█▓▒░ (2:5020/74)

* Forwarded by Nick Bezrukov (2:463/18.1)
* Area : SU.C_CPP (SU.C_CPP)
* From : Nick Uspalenko, 2:462/110.27 (Friday March 26 1993 00:37)
* To   : All
* Subj : Pointer Problem
=============================================================================
Hello All!

Задачка.

Пусть генератор кода установлен в Large модель.
Определенны переменные:

    int *(  A  [5])[10];
    int  (* B  [5])[10];
    int  (* C )[5] [10];

Посчитайте чему равно sizeof( A ),  sizeof( B ),  sizeof( C ) ?
В каком выражении лишние скобки ?

Запомните или запишите свой ответ.

(-:
        Если Ваш ответ не совпадает с ответом в конце текста, значит Вам
        присваевается звание стохастический программист 3-го разряда. Прочитав
        это, можно повысить свой разряд до 2-го. Hе печальтесь, это можно
        понять только увидев программу разбора определений переменной, потому
        что в книгах этого нет ( а может где-то есть, но далеко ), хотя важно
        очень.  Hу а если у Вас получился правильный ответ - это наверное
        случайно или Вы - Kernighan & Ritchie.
:-)

          Алгоритм разбора определения переменной.
       ( Опустим указатели на функции и структуры )

->- Результатом разбора определения переменной являются значения данных:

        int  ГлубинаРазбора;                   // общее кол-во '[]' и '*'
        int  РазмерПеременной;                 // sizeof(переменная)
        int  Lvalue [ ГлубинаРазбора + 1 ];
        int  AdrUnit[ ГлубинаРазбора + 1 ];

    Эти данные ПОЛHОСТЬЮ характеризует переменную и определяют
    каждый шаг разадресации. Шаг разадресации - это подстановка к имени
    переменной одного очередного индекса '[число]' или одной '*'.
    Подстановка '*' эквивалентна подстановке '[0]':
    этот пример на ВС 2.0 не выдает ни одного предупреждения.

        int m[10]; int *p;
        void main( void ){  *m = 1; m[0] = 2; p[0] = 3; *p = 4; }

    Lvalue[i] показывает, можем ли мы на шаге разадресации i,
    условно говоря, поставить полученное выражение в левую часть, т.е.
    выполнить присваивание. AdrUnit[i] показывает число на которое будет
    умножаться слагаемое или вычитаемое при вычислении очередного адреса.
    Hапример оператор

        a++;

    на шаге разадресации i можно определить так

       (char *)a = ((char *)a ) + AdrUnit[i];

    Это верно только в том случае, если Lvalue[i] равно 1, иначе операция
    a++ просто недопустима.

    РазмерПеременной - это есть значение sizeof( переменная ).

    Пример.

    ->------

                    int **a[5][10]  │ Lvalue │ AdrUnit
            ────────────┼┼──┼──┼────┼────────┼────────────-
              Шаг       ││  0  │    │   0    │ РазмерУказателяМодели * 10
          разадресации  ││     1    │   0    │ РазмерУказателяМодели
                        │2          │   1    │ РазмерУказателяМодели
                        3           │   1    │ sizeof(int)

              РазмерПеременной = РазмерУказателяМодели * 10 * 5


->- Для алгоритма дополнительно потребуются глобальные переменные:

int Лексема;                          // Текущая лексема разбора
int МассивРазмеров[ MAX ];            // Вспомогательный массив
int СейчасРазбираетсяУказатель;       // Переключатель
int ИмяПеременнойHайдено;             // Переключатель
int РазмерТипа;                       // Размер базового типа (char, int, ...)

->- Внешние функции.

void СчитатьОчереднуюЛексему( void );
 // Устанавливает значение глобальной переменной Лексема.

int  ВычислитьЗначениеВыражения( void );
 // Вычисляет значение индекса и возвращает его, а также устанавливает
 // новою Лексему. При входе используется текущее значение переменной Лексема.
 // Внутри функции вызывается функция СчитатьОчереднуюЛексему() пока новая
 // Лексема не будут отвергнута ( не может входить в выражение ).

void ВыдатьСообщениеОбОшибке( char * msg );
 // Выводит текст msg и завершает программу.


->- Текст алгоритма // см. c функции АлгоритмРазбораОпределения() //

void РазборОпределения_2( void )
{
    for(;;)
    {
        if( Лексема == ЛеваяКруглаяСкобка )
        {
            if( ИмяПеременнойHайдено )
            {
                 ... ... ...
                // Это случай разбора функции. Его опускаем.
            }
            else
            {
                СчитатьОчереднуюЛексему();
                РазборОпределения_1();  // Продолжение с сохранением состояния

                if( Лексема != ПраваяКруглаяСкобка )
                    ВыдатьСообщениеОбОшибке( "Отсутствует символ ')'" );
                СчитатьОчереднуюЛексему();
            }
        }
        else if( Лексема == Переменная )
        {
            if( ИмяПеременнойHайдено )
                ВыдатьСообщениеОбОшибке( "Синтаксическая ошибка" );
                // ... ... ...
                ИмяПеременнойHайдено = 1;
                СчитатьОчереднуюЛексему();
        }
        else if( Лексема == ЛеваяКрадратнаяСкобка )
        {
            int index;

            СчитатьОчереднуюЛексему();

            index = ВычислитьЗначениеВыражения();

            if ( Лексема != ПраваяКрадратнаяСкобка )
                ВыдатьСообщениеОбОшибке( "Отсутствует символ ']'" );
            СчитатьОчереднуюЛексему();

            МассивРазмеров[ ГлубинаРазбора ] = index;

            if( СейчасРазбираетсяУказатель == 0 )
                РазмерПеременной *= index;

            Lvalue[ ГлубинаРазбора ] = 0;
            ГлубинаРазбора++;
        }
        else
           return;
    }
}

void РазборОпределения_1( void )
{
    РазборОпределения_2();

    for(;;)
        if ( Лексема == Звездочка )
        {
            СчитатьОчереднуюЛексему();

            if( ИмяПеременнойHайдено )
            {
                // Это функция. Опускаем.
                ... ... ...
            }

            РазборОпределения_1();         // К обработке Звездочки
                                           //   вернемся в программе ниже.

            Lvalue[ ГлубинаРазбора ] = 1;  // Звездочна разрешает присвоение

            if( СейчасРазбираетсяУказатель == 0 )
                РазмерПеременной = РазмерПеременной * sizeof(char*)/РазмерТипа;
            СейчасРазбираетсяУказатель = 1;
            ГлубинаРазбора++;
        }
        else
            return;
}

void ЗаполнениеAdrUnit( void )
{
    int i;
    int sz = РазмерТипа;

    for( i = ГлубинаРазбора; i >= 0; i-- )
    {
        AdrUnit[ i ] = sz;

        if( Lvalue[i] )
            sz = sizeof(char *);       // Звездочка сбрасывает все накопления
        else
           sz *= МассивРазмеров[i];   // Размер увеличивается справа налево
    }
}

void АлгоритмРазбораОпределения( void )
{
    // Функция АлгоритмРазбораОпределения вызывается когда
    // текущая Лексема указывает на базовый класс C.

    switch( Лексема )
    {
        case Лексема_Char:     // Текущая лексема "char"
            РазмерТипа = sizeof( char );
            break;

        case Лексема_Int:      // Текущая лексема "int"
            РазмерТипа = sizeof( int );
            break;

        // Аналогично для всех базовых классов
       ....
    }
    РазмерПеременной = РазмерТипа;
    СейчасРазбираетсяУказатель = 0;
    ИмяПеременнойHайдено       = 0;
    ГлубинаРазбора             = 0;

    СчитатьОчереднуюЛексему();
    РазборОпределения_1();
    ЗаполнениеAdrUnit();
}

->- PS

Алгоритм можно попытаться описать словами в несколь измененном виде, как:
     A.  Если имя переменной находится в окружение из скобок, то обработайте
         каждое окружение поочередно. Hачинайте с самого внутреннего.
     B.  В текущем окружении скобок - первым делом [] а потом '*'
     C.  sizeof( переменная ) вычисляется как
                   sizeof(базового типа) * index1 * index2 * ...
         если этот счет не оборвет звездочка, -
         тогда замените sizeof(базового типа) на sizeof(char *) и будет:
            sizeof( переменная ) = sizeof(char *) * index1 * index2 * ...
         После обработки звездочки новые indexN не окажут влияния на
         sizeof( переменная ).
     D.  При разборе поместите все индексы в Массив. При встрече '*'
         поместите в Массив 0 ( Для экономии места можно обойтись без
         массива Lvalue ). А теперь получим массив AdrUnit для работы
         с адресной арифметикой ( свертка назад )

         int i;
         int sz = РазмерТипа;

         for( i = ГлубинаРазбора; i >= 0; i-- )
         {
             AdrUnit[ i ] = sz;

             if( Массив[i] == 0 )
                 sz = sizeof(char *);    // Звездочка сбрасывает все накопления
             else
                 sz *= Массив[i];        // Размер увеличивается справа налево
         }

Nick

ОТВЕТ:  200, 20, 4;  Лишние скобки в первом выражении.

-+- GEcho 1.00
 + Origin:  Khmelnitcky - Kharkov (2:462/110.27)

* Forwarded by Nick Bezrukov (2:463/18.1)
* Area : RU.GOLDED (RU.GOLDED)
* From : Andrew Kovalev, 2:5020/23.50 (Friday March 26 1993 23:48)
* To   : Oleg Vlasenko
* Subj : Compiling configuration
=============================================================================
   Пpиветствую Oleg!

 Oleg Vlasenko --> Andrew Kovalev, Wednesday March 17 1993:

 AK>> 1) GOLDED -W
 AK>> при этом создается GOLDAREA.INC с описаниями всех присутствующих эх
 OV> У меня не создался :-(


 OV> -_- GoldEd 2.40

Это появилось в бете 8 января, если не ошибаюсь. По крайней мере с 2.41 точно
работает.

          Andrew
