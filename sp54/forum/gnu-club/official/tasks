General Summary of GNU Tasks

1) Writing the kernel.

A couple of additional experienced system writers could be
helpful here; but they need to be in Boston or at least
on the Arpanet in order to be able to take part.  We are using
a message-passing architecture on top of which Unix system
calls will be implemented by libraries.

2) Writing the new compiler.

Although I have a portable C and Pascal compiler, it has a
serious drawback: it is a very large program, and intrinsically
cannot be made smaller.  It is also very hard to bootstrap.
Therefore, work is getting under weigh on a new compiler.
People with experience in compilers could help in the effort;
most easily if they are near L.A. or D.C.

If you are interested in this, call Chris Pettus at
(213) 202-8925, or Velu Sinha at (301) 699-8155.

3) Writing a source-level debugger.

It would be nice to have a new debugger for two reasons:
dbx has many deficiencies, and dbx may not be available for
GNU to distribute.  This is a large project, but not nearly
as hard as the compiler because efficiency is not so important.

4) Writing nroff-related utilities.

Part of nroff has been written and the rest of it is being
worked on, but the related utilities such as eqn and tbl,
and duplicates of the standard macro packages, need to be written.

I do not have a high opinion of nroff, and plan to distribute
tex as well.  But nroff, etc, are important to have for compatibility.
These are medium size projects, a little tricky to get right
because `right' means balancing `compatible enough to do the right thing
with people's actual source files' with `not having the the stupid bugs
of the originals'.

5) Data base software.

I've never used a data base system, so I don't really know what
they do.  But since so many people want one, it is a good thing
to contribute to GNU.  A data base system would be more useful
if it could accept as input the data bases used by other widely
used data base systems such as dbase.  A compatible command
language might be a good idea, but you might also be able to
design a superior command language.

6) Graphics software.

It is not clear what sorts of graphics software there ought to
be for GNU.  A package for drawing in three dimensions with
clipping and rotation would certainly be desirable.  Graph-drawing
packages will also be useful.  Someday there will be a window
system for GNU, but it is probably not possible to write much
of it yet because kernel interfaces it will need to use have
not been decided.  Some internal parts of the window system
could be written now.

If you are interested in working on graphics, ask me to put you
in touch with other people who are.

7) Writing other utilities.

There are still some other utilities needed.  These projects range
from small to medium-large, and do not require much communication
with the rest of the GNU project; just send it when it is done.  No
especial commitment is needed: if you give up, eventually I'll find
someone else to do it.

However, the remaining unfinished utilities are mostly
not vital ones, just nice to have.

You should also write a document for a utility you write.

8) Adapting, improving or finishing utilities.

There are a few utilities that have been partially finished, or which
exist but lack some of the needed features.  Finishing or Extending a
utility is the same sort of project as writing a new utility, with
one difference: I will have to send you the stuff to start with.  If
you can get it over a network, that's easy.  If not, I'm willing to
send you the existing utility's code to start with, but this is a lot of
work, so please ask only if you are really going to do the job.

Utilities needing work include ar (finished except for one
tricky part), awk (half finished), diff (needs features),
grep (needs features), lex (needs conversion from ratfor to C),
ls (needs features), sed (needs elimination of arbitrary limits).

9) Writing libraries.

Most of the standard C library functions are still needed.
They fall into two classes: a) stdio and b) everything else.

stdio is a medium size project that is very important and needs
a lot of care.  It is important that the person writing stdio
promise to get it finished.

The other libraries are small to medium projects, about like
writing random utilities.

You should also write a document for a library you write.

10) Major Documentation Projects

Documentation needs to be written for these programs:

awk, csh, ed, eqn, lex, ls, make, nroff, sh, tbl, yacc.

These are significant documentation projects.
Documentation should be written in a language called
"texinfo", which can serve as tex input using a special macro package,
and can also be turned into info files for on-line reference
using a special program.

11) Converting documentation

Many existing documentation files are either in nroff format
or are just text files.  They need to be converted to texinfo.
This is pretty easy to do, but you need to get the originals.
The comments about sending code for unfinished utilities
(see 8, above) apply here.
