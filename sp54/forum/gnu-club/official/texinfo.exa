@node [top, ar, , (DIR)]

@chapter Shell Commands
...
@menu
* ar::		operate on @defn[archive] files.
...
* ranlib::	make subroutine library randomly accessible
* rm::		delete files
* rmdir::  	delete directories
...
@end menu

... more nodes ...

@node [rm, rmdir, ranlib, top]

@section Deleting Files with @code[rm]

@defn[Deleting] a file name means causing the file name to be
removed from the directory.  Subsequent attempts to use that name to
access the file will fail.  If all of a file's names are deleted,
the file data can no longer be accessed in any way, and its storage
will eventually be used for other files.

@example
rm @var[FILE1] @var[FILE2]...
@end example

deletes the files @var[FILE1], @var[FILE2], and so on.
Files may be specified with wildcards; @note[wildcards].

@subsection Switches

@example
@code[-a]
@end example

means to delete every file in the system.  The other
arguments do not matter when @code[-a] is used.

@subsection Bugs

@code[rm] does not know how to delete a file whose name
contains the string @code[@#$%&].

@subsection Author

Alfred E. Von Neumann

@node [rmdir, sed, rm, top]

@section Deleting Directories with @code[rmdir]

... more nodes ...

@node [wildcards, ...]

@section Using Wildcards in File Specifications
...
--------------------------------------------------
Now some explanation.
   @node [NAME, NEXT, PREVIOUS, UP]
starts a "node" named NAME.  It also identifies three other nodes
as being the next node, the previous node, and the parent node
of the node being defined.  `rm' is documented with a single node
because that node is still reasonably small.  For a more complicated
program with many switches, and other syntax, you might want a node
for switches and a node for the rest of the syntax; or even a node
for each command or feature or switch, perhaps with an additional
layer of nodes for larger categories as their parents.

The sectioning commands @chapter, @section, @subsection and
@subsubsection divide the printed manual into sections.  For Info
file output, they just generate the argument line as a line of
output.  Every @node should be folloed by a blank line and a
sectioning command, but other sectioning commands can appear within
nodes.

@menu starts a menu listing the child nodes of the node that contains
the menu.  End with @end menu.  The words appearing before the double
colons should be the names of other nodes in the file.  The menu text
is copied straight into the Info file.  When a printed manual is made,
the menu is omitted completely.

@note[NODENAME] generates a cross-reference to the node named
NODENAME.  In a printed manual, this generates a sentence containing
page and section numbers.  In an info file, this generates special
text that is a signal to the Info program.  The @note construct
should be followed by a period or comma.

@code[TEXT] causes TEXT to appear inside of `...'.  Use this for
in-line samples of program input or output.  Out-of-line samples
should use @example instead; lines between @example and @end example
will be indented in the Info file.

@defn[TEXT] causes TEXT to appear inside of "...".  Use it for
the introduction of a new technical term.  In a printed manual,
TEXT appears in a slanted font.

@var[TEXT] indicates that TEXT is the name of a metasyntactic variable.
Write the text in lower case; it will be converted to upper case
when the Info file is made.  In a printed manual, TEXT appears
in a slanted font.

@refill should appear at the end of any paragraph that needs to be
filled in order to look good in an Info file.  Usually this would
be because the processing of @code, @var, @note, etc. will make some
lines too short.
