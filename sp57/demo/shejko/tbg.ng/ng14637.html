<HTML>
<HEAD><TITLE>Турбо-Бейсик - Long Entry</TITLE></HEAD>
<BODY>

<A HREF="ng141f7.html">[&lt;&lt;Previous Entry]</A>
<A HREF="ngcca6.html">[^^Up^^]</A>
<A HREF="ng155c1.html">[Next Entry&gt;&gt;]</A>
<A HREF="menu.html" >[Menu]</A>
<A HREF="info.html">[About The Guide]</A>
<HR>
<PRE>

<B>      Пересылка параметров с помощью значений или ссылок.</B>

      Имеется некоторое  малоуловимое,но важное отличие между функциями
 и процедурами,понять которое можно исходя из отличий в  обработке  при
 прогоне программы (см. таблицу 4-4).


<B>          Таблица 4-4.Отличия процедур и функций.</B>
<B> ---------------------------------------------------------------------</B>
<B> Действие                      Функция             Процедура</B>
<B> ---------------------------------------------------------------------</B>
<B> Возвращает значение           Да                  Нет</B>
<B> Вызов                         Вызывается внут-    Использует оператор</B>
<B>                             ри выражения        CALL</B>
<B> Пересылка параметра           С помощью значе-    С помощью значения</B>
<B>                             ния                 или ссылки</B>
<B> Переменные умолчания          SHARED              STATIC</B>
<B> Аргументы массива             Нет                 Да</B>
<B> ---------------------------------------------------------------------</B>

 Теперь рассмотрим короткую программу:

<B>      DEF FNCul(radius,height) STATIC</B>
<B>      FNCul=radius * radius * 3.14159 * height</B>
<B>      END DEF</B>
<B>      r=4.7:h=12.1</B>
<B>      vol=FNCul(r,h)</B>

 Здесь значения передавались в функцию с помощью переменных r и h (этот
 способ передачи называется pass-by-reference  (пересылка  ссылкой)).Но
 можно  в качестве фактических переменных передать просто константы 4.7
 и 12.1 (способ называется pass-by-valye  (пересылка значением)),причем
 значением считается и выражение,например:

<B>      v=FNCul(r,h * 2+4.1)</B>

 Метод pass-by-value  означает,что  при выполнении функции в памяти ре-
 зервируется место под числовое значение  фактического  параметра,в  то
 время как при втором методе пересылки функция получает адрес фактичес-
 кого параметра.
      Так вот,при вызове процедуры по методу pass-by-reference,процеду-
 ра,зная адрес переменной,может изменить ее  значение,в  то  время  как
 функция этого не может,например:

<B>      a=0:b=2:c=3</B>
<B>      CALL Add(a,b,c,total)</B>
<B>      PRINT a,total</B>
<B>      END</B>
<B>      SUB Add(i,j,k,sum) STATIC</B>
<B>      sum=i+j+k</B>
<B>      END SUB</B>

 После вызова  процедуры Add значение переменной total изменится и ста-
 нет равным a+b+c,а значение a останется неизменным.

<B>      DEF FNDumm(a,b,c)</B>
<B>      a=a+b+c</B>
<B>      END DEF</B>
<B>      x=1:y=2:z=3</B>
<B>      t=FNDumm(x,u,z)</B>
<B>      PRINT x</B>

 А в  этом  случае  значение x останется неизменным.  Поэтому в функции
 нельзя обрабатывать элементы массивов.  Если Вы не  хотите  пересылать
 переменную  в  процедуры ссылкой (pass-byreference),то заключите пере-
 менную в скобки.Это побудит Turbo-Basic анализировать ее как значение.

<B>                   Локальные переменные.</B>

      В интерпретирующем Basic все переменные программы  являются  гло-
 бальными.Это означает,что любая переменная (используемая даже в незна-
 чительной подпрограмме) доступна из любого места программы.
      Turbo-Basic внутри  функций  и процедур позволяет иметь локальные
 переменные (т.е.  переменную,существующую лишь там,где она объявлена).
 Существование  только  этого факта является достаточной причиной,чтобы
 не прибегать к помощи подпрограмм,а использовать только функции и про-
 цедуры.Рассмотрим пример:

<B>      DEF FNAdd</B>
<B>      LOCAL x,y,total</B>
<B>      FOR x=1 TO 12</B>
<B>      FOR y=1 TO 30</B>
<B>          total=total+receipts(x,y)</B>
<B>        NEXT y</B>
<B>      NEXT x</B>
<B>      FNAdd=total</B>
<B>      END DEF</B>
<B>      x=35</B>
<B>      ap=FNAdd</B>
<B>      PRINT x</B>

 Т.к. переменные x,y,total в  функции  Add  объявлены  локальными  (это
 должно быть сделано до выполнения операторов в функции или процедуре),
 то они 'живы' только во время работы функции и не влияют на  одноимен-
 ные  переменные в самой программе.Поэтому оператор PRINT x распечатает
 значение 35.Аналогичным образом могут быть объявлены и локальные  мас-
 сивы:

<B>      SUB Dammy</B>
<B>      LOCAL a,mas()</B>
<B>      DIM mas(50)</B>
<B>      .</B>
<B>      .</B>
<B>      .</B>
<B>      ERASE mas</B>
<B>      END SUB</B>

 Как только заканчивается работа функции или процедуры,локальные  пере-
 менные теряют свои значения и при новом обращении к функции они прини-
 мают нулевое значение.

<B>                    Совместный атрибут.</B>

      Процедуры и функции могут объявлять переменные с помощью совмест-
 ного атрибута,делая эти переменные глобальными:

<B>      DEF FNDummy</B>
<B>      SHARED a</B>
<B>      a=6</B>
<B>      FNDummy=a</B>
<B>      END DEF</B>
<B>      PRINT FNDummy,a</B>
</PRE>

</BODY>
</HTML>
