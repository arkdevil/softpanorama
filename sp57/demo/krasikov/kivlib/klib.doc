            ╒════════════════════════════════════════════════╕
            │╒══════════════════════════════════════════════╕│
            ││  БИБЛИОТЕКА ФУНКЦИЙ РАЗНЫХ И ЧАСТО ПОЛЕЗНЫХ  ││
            │╘══════════════════════════════════════════════╛│
            │                                                │
            │           █  █ █ █   █  █     █ ████           │
            │           █ █  █ █   █  █     █ █   █          │
            │           ██   █  █ █   █     █ ████           │
            │           █ █  █  █ █   █     █ █   █          │
            │           █  █ █   █    █████ █ ████           │
            │                                                │
            │    COPYRIGHT (C) 1992-93    KIV without Co     │
            ╘════════════════════════════════════════════════╛

      Все библиотечные функции могут использоваться как в режиме C,
                           так и в режиме C++.
                       Компилятор - Borland C++ 3.1
              БИБЛИОТЕКА НЕ РАБОТАЕТ ДЛЯ HUGE МОДЕЛИ ПАМЯТИ

             Типы, определения и т.д. (defines.h, structs.h)

         Определены различные структуры данных DOS - MCB,  CVT,  DPB и
    другие, определены типы word, byte, pointer, Bool.
         Определены макросы выделения отдельных байт из слов и слов из
    long'ов, преобразования типа.

                     Информационные функции (info.h):

         Переменная unsigned PROCESSOR - доступна лишь при  компиляции
    с измененным модулем начальной загрузки. Определяет тип процессора
    и режим его работы:
         Младший байт - 0 - Intel 8088
                        1 - Intel 8086
                        2 - NEC V20
                        3 - NEC V30
                        4 - Intel 80188
                        5 - Intel 80186
                        6 - Intel 80286
                        7 - Intel 80386 и старше
         При младшем байте,  равном 7,  в старшем байте содержится код
    режима работы процессора -
                        0 - обычный режим работы
                        1 - Virtual86 с IOPL, равным 3
                        2 - Virtual86 с IOPL, меньшим 3
         Источник: Спесивцев А.В.,  Вегнер В.А.,  Крутяков А.Ю.  и др.
    "Защита информации  в  персональных  ЭВМ"  - М.,"Радио и связь",МП
    "Веста",1992.-192 с.

         int UnderWindows() - возвращает значение 1 в  случае  запуска
    программы в окне DOS в среде Microsoft Windows.

         display_type() - возвращает тип дисплея в системе. Детектиру-
    ются монохромный MDPA,  CGA,  EGA mono,  EGA color,  VGA mono, VGA
    color, MCGA mono, MCGA color, PGC.

         computer_type() -  возвращает  тип компьютера.  Детектируются
    XT, AT, PC, PCjr, PS/2-30, PS/2-80, XT-640.

         compbios_date(struct date *) - дата BIOS'а.

         char bootdrive() - возвращает имя диска,  с которого происхо-
    дила загрузка компьютера.

         floppy_type(int) -  возвращает  тип  дисковода - 360K,  720K,
    1.2M, 1.44M для первого и второго дисководов.

         get_CVT() -  возвращает  указатель на таблицу векторной связи
    DOS. Формат CVT и другие,  используемые в  библиотеке,  описаны  в
    файле structs.h.

         firstMCB() - возвращает указатель на первый блок MCB.
         nextMCB(MCBtype far *) - возвращает  указатель  на  следующий
    MCB в цепочке, позволяя таким образом пройти ее всю.

         int existDriver(char  *  name)  - возвращает единицу,  если в
    системе загружен символьный драйвер с именем name. Не отрабатывает
    загрузку драйвера в верхние адреса памяти.

         getDPB(int) - возвращает указатель на таблицу параметров дис-
    ка, принимая его номер - 0 - текущий, 1 - A и т.д.

         getFirstDPB(CVTtype *) - возвращает указатель на первую  таб-
    лицу DPB.
         getNextDPB(DPBtype *) - возвращает указатель на следующий DPB
    в цепочке.

         ZenithBIOS() и  CompaqBIOS() - возвращают 1,  если BIOS соот-
    ветственно Zenith или Compaq.

         EnhKbd() - возвращает 1 при установленной расширенной клавиа-
    туре.


                        Работа с диском (disk.h):

         char substDrive(char Drive) - если Drive - subst-диск,  возв-
    ращает имя диска, к каталогу которого он привязан.

         void checkDisk(unsigned char dr, unsigned int * Status,
                        unsigned char * media,  int * error) - получе-
    ние информации  о  диске  с  помощью функций IOCTL - media байте и
    статусе (при ошибке код ошибки  устанавливается  в  error).  Номер
    диска - 1 - A, 2 - B и т.д. Проверка на "физичность" диска -
    (Status & 0x9200) != 0 => SUBST/ASSIGN/NETWORK
         Значение медиа-байта:
         media         0 => 320/360K
                       1 => 1.2 M
                       2 => 720 K
                       3 => SD 8"
                       4 => DD 8"
                       5 => fixed;
                       6 => tape
                       7 => 1.44M

         int cdecl DiskParam(unsigned char drv, unsigned int * tracks,
                    unsigned char * heads,  unsigned char  *  secs)  -
    выдает информацию о диске - число дорожек,  головок и секторов.  В
    случае ошибки возвращает ее код.

         int validBoot(BootRec  far  *  B)  -  проверка  на   верность
    BOOT-записи - по последним двум байтам.

         DPT * get_dpt() - возвращает указатель на DPT.

         void disk_cfg(DISK_CONFIG *) - возвращает информацию о диско-
    вой системе в компьютере (на физическом уровне).

         HDPT far * get_hdp(int) - возвращает адрес таблицы параметров
    жесткого диска.

         int getmboot(MBOOT *  master_boot,  int  drive)  -  считывает
    MASTER BOOT с жесткого диска (drive=0 - первый жесткий диск).  При
    ошибке возвращает ее код.

         unsigned int  RootSector(char) - возвращает номер сектора,  в
    котором начинается корневой каталог диска.

        long absSector(char drive,  unsigned int Cluster) -  переводит
    значение номера кластера в абсолютный номер сектора.

        long FindEntry(char * path, int * Num, unsigned int * Clust) -
    по имени файла  (каталога)  path  находит  его  начальный  кластер
    Cluster и его номер в File Entry table.

         Многие из  приведенных  выше  функций  используют информацию,
    приведенную в книге Фролов А.В.,  Фролов Г.В. Операционная система
    MS-DOS - М.:"ДИАЛОГ-МИФИ", 1991.


        Функции перехвата прерываний клавиатуры и таймера (int.h)

         Set09Int(int far  (*Proc)(int))  -  заменяет прерывание 9h на
    пользовательскую функцию,  получающую скан-код нажатой  клавиши  в
    качестве параметра.  При возврате функцией ненулевого значения уп-
    равление передается старому обработчику 9 прерывания.  Для  отмены
    перехвата передайте  функции  Set09Int  в  качестве параметра NULL
    (при выходе из программы это выполняется автоматически).

         Set08Int(void far (*Proc)()) - добавляет к обработчику преры-
    вания 8h пользовательскую функцию.  Для отмены перехвата передайте
    функции Set08Int в качестве параметра NULL (при выходе из програм-
    мы это выполняется автоматически).


                         Упаковка данных (pack.h)

         unsigned PackLZ(unsigned char far * input, unsigned length,
                         unsigned char far * output) - производит упа-
    ковку length байт из input в output LZW-методом.  Возвращает длину
    упакованных данных,  либо 0 - данные не пакуются, либо 0xFFFF - не
    хватает памяти.  Для упаковки следует отводить буфер (output) раз-
    мером length байт.

         unsigned UnpackLZ(unsigned char far * input, unsigned char
                           far *  output)  -  распаковка   упакованных
    функцией PackLZ данных. Возвращает число байт в распакованном мас-
    сиве, либо 0xFFFF - недостаток памяти, либо 0 - внутренняя ошибка.
    Под распаковываемый массив (если Вы не знаете его точного размера)
    следует отводить побольше памяти!

                      Работа с COM-портом (serial.h)
         Вся работа идет через номер базового порта, получаемого функ-
    цией
         unsigned int GetSerialPort(int Num) - это значение в дальней-
    шем передается во все остальные функции.  Если возвращен 0 -  этот
    порт недоступен !

         unsigned char InitSerial(unsigned int Port, long speed,
                                  unsigned char flags) - инициализация
    COM-порта (детали см. в документации по COM-портам).

         unsigned char  StatusSerial(unsigned int Port) - возврат сос-
    тояния COM-порта.

         int OKtoSendSerial(unsigned int Port) - готовность к передаче
    данных.

         SendSerial(unsigned int  Port,  unsigned  char A) - пересылка
    байта.

         int OKtoReceiveSerial(unsigned int Port) - наличие полученных
    данных.

         unsigned char  ReceiveSerial(unsigned  int  Port) - получение
    байта.

         int ConnectSerial(unsigned int Port,  int Kbd, int del) - ус-
    тановление связи  между  двумя  машинами (на второй в это же время
    должна быть запущена та же функция).  Kbd -  возможность  прервать
    связь по  нажатию клавиши,  del - автоматически прекратить попытки
    связи через минуту. Возвращаемое значение : 0 - связь установлена,
    1 - прервана клавиатурой, 2 - вышел лимит времени.

         int far  cdecl  MainSerial(unsigned  int  Port) - запускается
    сразу после ConnectSerial - на одной машине будет возвращен 0,  на
    другой - 1.

         SendBuffer(unsigned int Port, void far * buf,
                    unsigned int count) - посылка массива данных.

         ReceiveBuffer(unsigned int Port, void far * buf,
                    unsigned int count) - получение массива данных.


        Работа с таймером с высокой степенью разрешения (mtimer.h)

         Init_Timer() - инициализация таймера (режим с высоким  разре-
    шением) (при загрузке производится автоматически).

         Restore_Timer() - восстановление  нормального  режима  работы
    таймера (при выходе из программы выполняется автоматически).

         unsigned long ReadTimer()  -  считывание  текущего  показания
    таймера.

         unsigned long ElapsedTime(unsigned long Start,  unsigned long
    Stop) - время в микросекундах между Start и Stop.

         ВНИМАНИЕ! ПРИ РАБОТЕ В РЕЖИМЕ ВЫСОКОГО РАЗРЕШЕНИЯ ТАЙМЕРА НЕ-
    ВЕРНО ОТРАБАТЫВАЕТСЯ ФУНКЦИЯ delay.

                       Различные утилиты (utils.h)
         Здесь приведена куча разнородных функций самого разного  наз-
    начения - поэтому они тематически не расположены.


         unsigned int BMsearch(void * buf, int buflen, void * key,
                              int keys)  -  поиск  в буфере buf длиной
    buflen ключа key длиной keys - и возвращает его смещение в буфере.
    При неудачном поиске возвращается: 0xFFFF - не найден, 0xFFFE - не
    хватает памяти.

         long searchFile(char * filename, void * key, int keys,
                         unsigned int BUFSIZE) - ищем в файле с именем
    filename смещение, где записано key (длиной keys), для чтения фай-
    ла выделяем буфер размером BUFSIZE. Если ошибка, то возвращаем:
            -1  не могу открыть файл
	    -2  не хватает памяти для буфера BUFSIZE
	    -3  не найдено
	    -4  слишком мал буфер

          long searchFilePos(char * filename, void * key, int keys,
                             unsigned int BUFSIZE,  long Pos) - аналог
    searchFile,  но ищем, начиная со смещения Pos; еще одна ошибка: -5
    - Pos > длины файла.


          char *  newS(char  * s) - выделяем память для новой строки и
    копируем в нее строку s - а потому ее надо удалять с использовани-
    ем free.

          char * forceExtension(char * pathname, char * ext) - у имени
    файла pathname расширение заменяется на ext.
          char * addBackSlash(char * str) - заканчиваем строку '\'.
          char * defaultExtension(char * pathname,  char * ext) - если
    имеется только  имя файла (нет разделяющей точки) - добавляем рас-
    ширение ext.
          Эти функции  дописывают в имеющиеся строки - следите,  чтобы
    было место !


          char * _forceExtension(char * pathname, char * ext)
          char * _addBackSlash(char * str)
          char * _defaultExtension(char * pathname, char * ext)
           Эти функции вызывают alloc - не забудьте освободить память,
    а также проверить, не вернулся ли NULL - значит, мало памяти !


          char * justPathName(char * fullpath) - размещаем  в  динами-
    ческой памяти только путь к файлу

          char * justFileName(char * path, char * name) - в name выде-
    ляем только имя файла - следите, чтобы name имел хотя бы 13 байт.

          char * StrRUpCase(char * r)
          unsigned char  RUpCase(unsigned char r) - переводим строку и
    отдельную букву в верхний регистр, работая кроме английского языка
    с русским - альтернативная кодировка.

          char * _hexB(char * s, unsigned char B);
          char * hexB(unsigned char B);
          char * _hexW(char * s, unsigned int W);
          char * hexW(unsigned int W);
          char * _hexP(char * s, void far * p);
          char * hexP(void far * p);
         Преобразование значений в 16-ричный вид. Если функция, то пи-
    шем в данную нам память, если нет - используем malloc.

          char * delSpaces(char * s) - удаление начальных  и  конечных
    пробелов в строке.

          void Reboot();
          void DisableKbd();
          void EnableKbd();
          void NumLockOn(int Yes);
          void CapsLockOn(int Yes);
          void ScrollLockOn(int Yes);  - у этих функций  все  ясно  из
    названия.


                     Функции для работы с XMS (xms.h)


         Для работы с XMS памятью при помощи драйвера, поддерживающего
    стандарт XMS (например,  himem.sys), предназначены следующие функ-
    ции библиотеки KIVLIB.

         int XMSinstalled() - проверка того, что драйвер действительно
    установлен и  обращение к XMS возможно (при этом возвращаемое зна-
    чение 1).

         void getXMSmem(unsigned int * Total,  unsigned int * Block) -
    тестируется количество доступной XMS памяти с системе -  ее  коли-
    чество (в  килобайтах)  помещается  в Total,  а размер наибольшего
    свободного блока - в Block.

         unsigned int allocXMS(unsigned int Mem) - позволяет  выделить
    Вам Mem килобайт XMS,  возвращает handle выделенного блока памяти.
    При ошибке возвращает 0.  Отметим, что выделенная память автомати-
    чески при  выходе  из программы НЕ ОСВОБОЖДАЕТСЯ!  Вы должны перед
    выходом освободить ее сами.  Второе замечание касается происшедшей
    при  любом  обращении  ошибки  - все функции при этом возвращают 0
    (если специально не оговорено иное) - Вы можете  получить  ее  код
    функцией

         unsigned char XMSerror()

         но после  ее  вызова информация о последней ошибке стирается.
    Строку сообщения об ошибке Вы можете получить, использовав функцию

         const char * XMSerrorMSG(unsigned char Error)

         Изменить количество выделенной памяти Вы можете функцией

         int reallocXMS(unsigned int handle, unsigned int mem)

         а освободить выделенную память - функцией

         int freeXMS(unsigned int handle)

         Низкоуровневое перемещение информации из обычной в XMS-память
    и обратно (а также между блоками XMS-памяти) возможно функцией

         int moveXMS(EMMSTRUCT  far * M),  которая принимает указатель
    на структуру, описанную в xms.h -
         typedef struct ___EMMSTRUCT___ {
                  unsigned long size; //долно быть четно!
                  unsigned int  soh;  //handle источника
                  unsigned long soo;  //смещение в источнике
                  unsigned int  dsh;  //handle приемника
                  unsigned long dso;  //смещение в приемнике
                  }  EMMSTRUCT;
         При этом если какой-либо handle равен 0,  это  означает,  что
    используется обычная  память  и  поле  смещения представляет собой
    просто дальний указатель.
         Перемещение блоков  любого  размера  (не обязательно четного)
    производится при помощи функций
         int mem2xms(void far * Buf, unsigned int Count,
                            unsigned int handle,unsigned long offset)
         int xms2mem(unsigned int handle, unsigned long offset,
                            void far * Buf, unsigned int Count)

         Прочие функции, описанные в xms.h, достаточно специфичны и об
    их использовании  более  детально Вы узнаете из описания стандарта
    XMS 2.0.

         ВНИМАНИЕ! ПРИ РАБОТЕ С XMS ТРЕБУЕТСЯ КАК МИНИМУМ 1 Kb  СТЕКА.
    СТРОЯ СВОИ ПРОГРАММЫ, НЕ ЗАБЫВАЙТЕ ОБ ЭТОМ!


                  Видеофункции (fastw.h, wins.h, mnu.h)

         Видеофункции низкого уровня описаны  в  файле  fastw.h.Это  -
    функции вывода строки на экран с определенными аттрибутами, чтение
    строки и строки атрибутов с экрана,  сохранение  и  восстановление
    части экрана в буфере.  Названия функций достаточно прозрачны и не
    нуждаются в особых пояснениях.  Следует отметить  лишь  следующее:
         1. Функции работают только в текстовых режимах.
         2. Проверки на выход за границу экрана не делается.
         3. Настройка внутренних переменных на видеорежим производится
    автоматически при загрузке программы, но при любом изменении виде-
    орежима Вы должны вызвать функцию check_vid(),  реинициализирующую
    внутренние переменные.
         4. Проверка на "снег" не производится.

         Приведены также функции сохранения и изменения формы курсора,
    а также функция изменения аттрибута мигания символа на  16-цветный
    фон (при выходе из программы автоматически не восстанавливается!).

         В файле wins.h описана структура Window, представляющая собой
    окно в текстовом режиме - с разными цветами,  сохранением содержи-
    мого окна  при его стирании и т.п.  Следует отметить,  что функция
    deleteWindow работает с уже удаленным окном - удаляя его из  памя-
    ти, функции типа erase...  - удаляют окно с экрана, но не из памя-
    ти, а функция wipeWindow делает и то и другое.

         Приведены также несколько функций высокого уровня -  редакти-
    рования строки (в том числе и в окне),  просмотра текста в памяти,
    функции messageWindow - окна сообщений,  закрывающиеся при нажатии
    на любую клавишу и возвращающие,  какая клавиша была нажата (функ-
    цией bioskey(0)) - при этом строка текста может  содержать  символ
    \n, трактующийся, как начало новой строки, и символ \003 - при на-
    чале строки с него строка будет отцентрирована в окне.

         Функция PickListV позволяет производить выбор типа ListBox  -
    передаваемая в качестве параметра функция должна возвращать строку
    для выбора по ее номеру.  Расширение использования этой функции  -
    выбор файла  по заданной маске функцией GetFileName (только приго-
    товьте в name достаточно места!).

         В файле mnu.h описаны структуры и функции, позволяющие созда-
    вать ниспадающие  меню - меню создаются в памяти,  и поэтому после
    выхода тревуется освобождение памяти - рекурсивным  вызовом  функ-
    ций. Как это делается, показано в демонстрационной программе.

                   Музыкальное сопровождение (music.h)
         Функции музыкального сопровождения позволяют проигрывать  ме-
    лодию, записанную по правилам оператора PLAY языка BASIC.  Некото-
    рые мелодии в виде #define приведены в файле  music.h.  Вы  можете
    проиграть мелодию  при помощи функции PlayString (параметр StopKbd
    позволяет Вам прекратить звучание по нажатию любой клавиши  -  при
    этом функция вернет 1),  либо из представленных во внутреннем фор-
    мате данных - их получить можно,  записав мелодию в файл - функция
    PlayToFile (этот  файл  в  дальнейшем  переводится  в OBJ утилитой
    bgiobj) - функцией PlayProc.  Для этой цели в  библиотеке  имеются
    готовые псевдофункции-мелодии.
         Исполнение мелодии в фоновом режиме доступно при помощи функ-
    ции SetPlay,  ее  прекращение  (мелодия  исполняется циклически) -
    StopPlay или,  если хочется доиграть ее до конца -  StopPlayAtEnd.
    Заметим, что  при таком исполнении используется модуль mtimer - со
    всеми вытекающими из этого предупреждениями.
         Просьба учесть,  что когда в детстве автора учили  играть  на
    баяне, от  отсутствия слуха у ученика учитель преждевременно посе-
    дел. Вся музыка - подаяния других,  а потому просьба автора в  не-
    верной музыке  не винить,  а если Вы вышлете ему правильное нотное
    переложение приведенных (и других) мелодий  -  автор  будет  очень
    благодарен. Адрес - 252142,  ГСП,  Киев-680, ул.Кржижановского, 3,
    Институт проблем материаловедения АН Украины,отд.44.Красикову И.В.

                Русификация в программе (только текстовый режим!)
                           EGA и VGA мониторы!
         Для этого  существуют  функции  загрузки  русского  шрифта  -
    LoadRusFontN, где N - 8,14,16 - соответственно шрифты 8x8,  8x14 и
    8x16. Загружать шрифт следует при  каждом  изменении  видеорежима.
    Что грузить и когда - решать Вам.  А клавиатура русифицируется од-
    ной строкой: RusSwitch=<скан-код клавиши-переключателя>.
         Во многом  написанию  этого модуля способствовала аналогичная
    программа на Turbo Pascal Сергея Варюхи (SoftPanorama 45).

                 Работа с манипулятором "мышь" (mouse.h)
         Функции для работы с мышью достаточно прозрачно названы, поэ-
    тому упомянем только об основных особенностях.
         Мышь в текстовом режиме отрабатывается функциями,  начинающи-
    мися с Text...  При этом координаты мыши возвращаются (передаются)
    в т.н. "текселах" - знакоместах.
         Для графического режима имеется набор псевдофункций, содержа-
    щих курсоры мыши разной формы (нарисованные при помощи весьма пос-
    редственных художественных способностей автора) для  использования
    в функции MouseSetShapeProc.
         Перед тем как использовать функции мыши,  убедитесь,  что она
    есть - иначе автор ни за что не ручается...
         И последнее - с гарантией поддерживается Microsoft Mouse, все
    остальное - в принципе тоже, но все может быть...
         И не рекомендуется  испытывать  реентерабельность  прерывания
    33h - не стоит использовать функции мыши в присоединенном функцией
    MouseSetHandler обработчике. Кстати, присоединенный обработчик при
    выходе из программы отключается автоматически.





                            БИБЛИОТЕКА КЛАССОВ
                            (kobj.h, files.h)

         Библиотека классов,  входящая в состав KIVLIB,  содержит раз-
    личные классы, базирующиеся на двух основных - Kobject и written.
         Ниже приведена иерархическая схема библиотеки классов:

        ┌───────┐          ┌─────┐     ┌──────┐
        │written├──────┬──>│KWmem├────>│KWPmem│
        └───────┘      │   └─────┘     └──────┘
                    ┌──┴─┐
             ┌─────>│Kmem│
             │      └────┘
        ┌────┴──┐   ┌───────────┐   ┌────────────┐
        │Kobject├┬─>│Kcollection├──>│KScollection│
        └───────┘│  └───────────┘   └────────────┘
        ┌───────┐└──┬───┐  ┌──────┐
        │Kpoint │<──┤   ├─>│Ktime │
        └───────┘   │   │  └──────┘
        ┌───────┐   │   │  ┌──────┐
        │Krect  │<──┘   └─>│Kdate │
        └───────┘          └──────┘

        ┌───────┐         ┌────────┐       ┌───────────┐
        │ file  ├────┬───>│dos_file├──────>│ data_file │
        └───────┘    │    └────────┘       └───────────┘
                     │    ┌────────┐
                     └───>│xms_file│
                          └────────┘


         Базовый класс Kobject является абстрактным классом,  содержит
    виртуальную функцию shutDown() и статическую destroy(Kobject*).
         Желателен порядок удаления динамически распределенных экземп-
    ляров класса через вызов Kobject::destroy,  которая вызывает функ-
    цию shutDown соответствующего класса и затем - деструктор.

         Kcollection предназначен  для  создания упорядоченных списков
    экземпляров классов,  порожденных от Kobject. В конструкторе зада-
    ются начальный размер коллекции,  ее приращение при выходе за пре-
    делы начального размера и возможность иметь дубликаты (т.е. объек-
    ты с  теми  же адресами).  Если Вы ставите параметр dup=1,  будьте
    предельно осторожны при удалении объектов!
         Виртуальная функция  error  по  умолчанию  вызывает  выход из
    программы - Вы можете переписать ее. Она получает код ошибки - ко-
    ды приведены в файле kobj.h.

         KScollection представляет собой коллекцию  с  сортировкой  по
    определенному ключу  -  для этого Вы должны переписать виртуальные
    функции keyOf и Compare.

         Kdate и  Ktime  представляют собой классы для работы с кален-
    дарными датами и временем. Конструкторы по умолчанию создают клас-
    сы с текущей датой и временем создания класса.

         Kpoint и Krect - классы точка и прямоугольник - заготовки под
    дальнейшее развитие. Что это такое - вполне ясно из файла kobj.h.

         Kmem - класс-кусок памяти. А класс KWmem позволяет этот кусок
    писать на  диск  (или  куда-нибудь  еще)  с использованием потомка
    класса file.  Класс же KWPmem при этом еще и проводит упаковку па-
    мяти при записи на диск и распаковку при считывании.

         Возможность записи-считывания  дает  наследование  от  класса
    written. Вам только надо переписать  виртуальные  функции  read  и
    write для корректной записи и чтения и прилинковать (для использо-
    вания операторов << и >>) класс строкой FILE_LINK(ИМЯ_КЛАССА).

         Класс file - базовый абстрактный класс,  от которого порожден
    класс dos_file, представляющий собой обычный дисковый файл и класс
    xms_file - файл в XMS-памяти (в отличие от dos_file, с заранее за-
    данным размером). Все файлы открываются в двоичной моде.

         Класс data_file,  порожденный от dos_file, представляет собой
    файл, который может быть приписан к EXE-файлу  (при  инициализации
    EXE-часть и,  при наличии,  оверлейная,  пропускаются и смещение 0
    фактически относится к НАЧАЛУ ДАННЫХ).  Таким образом, Ваши данные
    могут быть размещены в одном файле с загрузочным модулем.





         БЕЗ ОШИБОК ПРОГРАММЫ МОГ БЫ ПИСАТЬ ТОЛЬКО БОГ -  ЕСЛИ  БЫ  ОН
    ЭТИМ ЗАНИМАЛСЯ,  А ПОТОМУ О ВСЕХ ЗАМЕЧЕННЫХ ОШИБКАХ (НЕ СЧИТАЯ МУ-
    ЗЫКИ - СМ. ПРИМЕЧАНИЕ ВЫШЕ) - СООБЩАЙТЕ АВТОРУ -
                      ТЕЛ. (044) 444-13-19,  КРАСИКОВ И.В.

    P.S.  И, пожалуйста, не лезьте внутрь с целью изменить Copyright -
    как правило, это приведет к неработоспособности библиотеки.

