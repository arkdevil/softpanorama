From relay1.cs.kiev.ua!rtech!aviion!galagan!galagan.ts.kiev.ua!michael Sun Oct 17 10:28:15 1993
Received: by softp.kiev.ua (UUPC/@ v5.09gamma, 14Mar93);
          Sun, 17 Oct 1993 10:28:15 +0300
Received: by relay1.cs.kiev.ua; Wed, 13 Oct 93 20:11:03 +0200
Received: by ts.kiev.ua; Wed, 13 Oct 93 19:31:48 +0200
Received: by galagan.ts.kiev.ua (UUPC/@ v5.00, 25Nov92);
          Wed, 13 Oct 1993 18:58:37 +0200
To: bnn@softp.kiev.ua
Message-Id: <AAwE3liGV1@galagan.ts.kiev.ua>
Organization: TECHNOSOFT
From: Michael Reviakin <michael@galagan.ts.kiev.ua>
Date: Wed, 13 Oct 93 18:58:34 +0200
X-Mailer: BML [MS/DOS Beauty Mail v.1.36]
Subject: SoftPanorama
Lines: 610
Status: RO


       Система логического программирования Prolog-plus
                   (расширенная аннотация)

              Михаил Ревякин, МНЦТП "ТЕХНОСОФТ"
    Украина, Киев 252207, просп. Академика Глушкова 44
    Email : michael@galagan.ts.kiev.ua
    Тел : (044) 266 07 45

    Имеется целый ряд приложений,  для которых программы реше-
ния задач требуют значительных ресурсов памяти и / или большо-
го объема данных (например промышленное планирование и состав-
ление расписаний,  экспертные системы, дедуктивные базы данных
и т.д.).  В первую очередь для таких приложений, но не только,
разработана  экспериментальная система логическая программиро-
вания Prolog-plus.

    В системе Prolog-plus реализованы такие новые особенности:
  - модифицированный "реляционно-ориентированный" язык;
  - высокоуровневый интерфейс с базами данных;
  - модифицированный механизм управления логическим выводом;
  - контроль зацикливания процедуры логического вывода;
  - управление виртуальной памятью;
  - встроенная система управления базами данных.

    Язык системы Prolog-plus имеет модульную структуру.  Прог-
рамма  интегрируется  из отдельно компилируемых модулей и зап-
росов.  Модуль состоит из отношений, каждое из которых образо-
вано  из множества правил с одинаковым именем предиката и рав-
ным числом аргументов головы правила.

    Интерфейс с базами данных  системы  Prolog-plus  позволяет
обрабатывать отношения базы данных (в смысле стандартного фор-
мата файлов .DBF) как факты обычного Prolog-а  с  естественным
синтаксисом. Например: если пользователь хочет получать данные
о клиентах он записывает:
    DBF.CLIENTS(_surname, _firstname, _company, _phone)
где DBF - имя псевдо-модуля базы данных.  Спецификация отноше-
ния требует соответствия с полями отношения базы данных (пози-
ционное представление), неполный список аргументов также допу-
стим:
    DBF.CLIENTS(SURNAME=_name, TELEPHONE=_phone)
где "SURNAME" и "TELEPHONE" - имена  полей  отношения. Для эф-
фективной обработки отношений с большим числом записей исполь-
зуется квалификатор индекса:
    DBF.CLIENTS(SURNAME=_name, TELEPHONE=_phone)/index NAME
где NAME - имя индексного файла. Переменные, которые соответс-
твуют ключевым полям должны иметь значения.

    Модифицированный механизм  управления  логическим  выводом
системы  Prolog-plus эффективно замещает управляющую директиву
"Cut" стандартного Prolog-а. Предположим что в правиле (в ори-
гинальной нотации Prolog-а):
    P(...) :- Q(...), R(...), S(...).
нас интересует только одно решение предиката R.  В этом случае
необходимо "сообщить" интерпретатору, что после первого успеш-
ного вычисления предиката R необходимо "забыть" другие альтер-
нативы его вычисления. Используется следующая конструкция:
    P(...) :- Q(...), R(...)/unique, S(...).
В смысле Процедурной семантики,  квалификатор "/unique"  уста-
навливает  последнюю  точку возврата после решения предиката R
такой, какой она была до решения предиката R, "забывает" внут-
ренние точки возврата предиката R.

    Процедура логического вывода системы Prolog-plus обеспечи-
вает контроль зацикливания,  что позволяет решать некоторые из
задач, прежде неразрешимых для обычного Prolog-а.
    Когда интерпретатор рассматривает подцель, которая выведе-
на из эквивалентной ей, последняя отвергается (ее решение объ-
является неудачным),  и выполняется возврат к ближайшей точке,
содержащей альтернативу.
    Усиленная таким механизмом,  процедура логического  вывода
все-же не является полной (в некоторых случаях бесконечное вы-
числение все-же возможно), однако появляются новые возможности
в решении некоторых практически полезных задач. Например: мож-
но определять симметричные и транзитивные отношения:
    P(X, Y):-P(Y, X).
    P(X, Y):-P(X, Z), P(Z, Y).
с гарантией  того,  что вычисления будут завершены за конечное
время.  Этот  механизм,  также,  позволяет  решать  задачу  об
"Обезьяне  и  банане"  в  классической постановке (см.  пример
программы).

    Диспетчер виртуальный  памяти  системы  Prolog-plus   пре-
доставляет исполнительный стек интерпретатора, размер которого
ограничен только размером дисковой памяти. Кроме того, не име-
ется значительных ограничений на количество и размер модулей и
файлов базы данных. Диспетчер виртуальный памяти автоматически
открывает, организует порядок обработки и закрывает их. Благо-
даря виртуальной организации памяти межмодульный  интерфейс  и
интерфейс с базами данных скрыты от пользователя.

    В настоящее   время   разработана   альфа-версия   системы
Prolog-plus. Реализация выполнена на языке Modula-2 для персо-
нальных компьютеров DEC Professional 350 под управлением  опе-
рационной системы P/OS ,  и для IBM - совместимых под управле-
нием операционной системы MS DOS. Система Prolog-plus - интег-
рированная среда, которая содержит: многооконный текстовый ре-
дактор,  транслятор модулей и  запросов,  исполняющую  систему
(интерпретатор),  встроенную систему управления базой данных с
Query-By-Example - подобным языком  запросов,  вспомогательные
утилиты.

     * * * * * * * * * * * * * * * * * * * * * * * * * *

      Система логического программирования Prolog-plus

                        Михаил Ревякин
   Международный Научный Центр Технологии Программирования
                     "Т Е Х Н О С О Ф Т"

    Украина, Киев 252207, просп. Академика Глушкова 44
    Email : michael@galagan.ts.kiev.ua
    Тел : (044) 266 07 45


    Аннотация

    В этой работе представлены некоторые возможности и особен-
ности  экспериментальной  системы логического программирования
Prolog-plus. Предложены новая семантика логического программи-
рования  и  язык.  Язык имеет модульную структуру,  "реляцион-
но-ориентированный" синтаксис,  модифицированный механизм  уп-
равления  логическим выводом и ряд расширений,  обеспечивающих
высокоуровневый интерфейс с базами данны.  Отношения базы дан-
ных (в смысле стандартного формата файлов .DBF) обрабатываются
как факты обычного Prolog-а с естественным синтаксисом.  Моди-
фицированная  процедура  логического вывода обеспечивает конт-
роль зацикливания исполняюшей системы,  который позволяет  ре-
шать некоторые из задач,  прежде неразрешимых для "стандартно-
го" Prolog-а. Система работает под управлением диспетчера вир-
туальной памяти. Это позволяет сделать межмодульнй интерфейс и
интерфуйс с базами данных скрытым от пользователя и  выполнять
логические вычисления большого объема.

    Все возможности и особенности системы Prolog-Plus, описан-
ные в этой работе, реализованы и протестированы.


    Ключевые слова

    Реляционная семантика,  Модули,  Интерфейс баз данных, Уп-
равление логическим выводом, Контроль зацикливания, Управление
виртуальной памятью.


    Введение

    Результаты, изложенные в этой работе, являются продолжени-
ем университетского дипломного проекта, выполненного автором в
1991 году. В настоящее время это часть исследовательского про-
екта, начатого в 1992 году в Международном Научном Центре Тех-
нологии Программирования "ТЕХНОСОФТ".
    Мы предполагали,  без ограничений на "стандартный" Prolog,
разработать  некоторые полезные свойства,  с тем чтобы сделать
методы логического программирования более  привлекательными  в
практическом применении.
    Проблемы Prolog-а известны достаточно хорошо; некоторые из
них неразрешимы теоретически (неполнота процедуры  логического
вывода),  некоторые  из их - плата за эффективность (директива
управления выводом "Cut"), другие-же представляют собой объек-
тивные  ограничения  (ограничение  памяти и производительности
компьютера).  Довольно серьезной проблемой для Prolog-а  явля-
ется взаимодействие с другими системами программирования. Этот
список не претендует на обобщение,  но представляет  серьезные
препятствия для пользователей Prolog-а.
    С самого начала мы не пытались найти решение какой-либо из
этих проблем в целом,  однако мы предполагали "срезать  острые
углы"  этих проблем,  сделать некоторые из их не столь сущест-
венными.


    I. Реляционная семантика Prolog-а.

    Во всякой логической программе,  множестро всех  фактов  с
одинаковым  именем предиката и числом аргументов,  будем пони-
мать как отношение,  определенное  в  экстенсиональной  форме.
Например, факты:
    P(a, b).
    P(a, c).
    P(b, d).
    P(c, d).
будем понимать как отношение P, содержащее кортежи <a, b>, <a,
c>, <b, d>, <c, d>.

    Множество всех правил с одинаковым именем предиката головы
и числом аргументов будем понимать как отношение, определенное
в интенсиональной форме. Например, правила:
    R(X, Y):-P(X, Y).
    R(X, Y):-P(X, Z), R(Z, Y).
будм понимать как отношение R, содержимое которого формируется
из кортежей <X,  Y> , где значения X и Y удовлетворяют запросу
Prolog-а:
    ?-R(X, Y).

    Определенная таким образом Реляционная семантика в некото-
ром смысле - "метасемантика",  поскольку приведенное определе-
ние  включает вычисление Prolog-запроса,  однако такое понятие
может быть полезно как некоторая парадигма.

    Эта семантика напоминает Fixpoint семантику Prolog-а,  од-
нако  рассматривает не единичные предложения Prolog-а,  а мно-
жество предложений,  интерпретируемые как  экстенсиональные  и
интенсиональные отношения. В этом контексте можно любой преди-
кат в теле предложения  рассматривать  как  реляционный  поток
данных.  Любое  правило  программы вычисляет некоторое подмно-
жество отношения,  а все правила,  чьи имя предиката головы  и
количество аргументов одинаковы - вычисляют все отношение, пу-
тем объединения этих подмножеств.


    II. Модифицированная директива управления логическим выво-
        дом.

    В смысле Реляционной семантики, любой предикат в теле пра-
вила можно рассматривать как вызов процедуры, которая вычисля-
ет соответствующее отношение. В таком случае естественно иметь
возможность контролировать количество  элементов  вычисляемого
отношения. Предположим, что в правиле:

    P(...) :- Q(...), R(...), S(...).

в определенном  предикатом R отношении,  нас интересует только
один элемент (кортеж),  или точно известно относительно  этого
отношения,  что  оно содержит только один элемент,  но имеются
"неперспективные" альтернативы его вычисления, которые требуют
значительных  ресурсов,  или  приводят к зацикливанию.  В этом
случае необходимо "сообщить" исполняющей  системе,  что  после
первого  успешного  вычисления предиката R она должна "забыть"
другие нежелательные альтернативы.  Будем  использовать  такую
конструкцию:

     P(...) :- Q(...), R(...)/unique, S(...).

В смысле Процедурной семантики,  квалификатор "/unique"  уста-
навливает  последнюю  точку возврата после решения предиката R
такой, какой она была до решения предиката R, "забывает" внут-
ренние точки возврата предиката R.

    В этом случае, очевидно, сохраняется вычислительная эффек-
тивность  выполнения стандартной директивы Prolog-а "Cut",  но
при этом допускается непроцедурная семантика этой конструкции.
Используя эту конструкцию,  мы утверждаем, что только одно ре-
шение предиката R (или только один элемент отношения,  опреде-
ленного предикатом R) интересует нас.

    Существует еще  один положительный эффект от использования
этого механизма:  что касается управления памятью,  становится
возможным выполнять эффективную сборку мусора в памяти интерп-
ретатора.  После  вычисления  подцели,  квалифицированной  как
/unique,  цепочка фреймов в исполнительном стеке,  построенная
для вычисления этой подцели содержит только  значения  "выход-
ных"  параметров.  Другая  информация (включая точки возврата,
списки восстанавления контекста,  локальные контексты и  т.д.)
становится ненужной для дальнейших вычислений.  Эти фреймы мо-
гут быть эффективно сжаты.

    Что касается нашего опыта,  в течение одного года эксплуа-
тируя систему Prolog-plus, мы ни разу не использовали директи-
ву "Cut".


    III. Контроль зацикливания.

    В этой части работы рассматривается метод вычисления задач
"расширенного" класса, решаемых системой Prolog-plus. Мы будем
понимать "расширение" в смысле некоторого множества задач, не-
разрешимых  для стандартного Prolog.  Эти задачи,  будучи пра-
вильно сформулированы в логическом смысле,  приводят стандарт-
ный  Prolog к зацикливанию.  В этом случае исполняющая система
имеет дело с бесконечным деревом поиска.  Это дерево  содержит
бесконечную ветвь,  попав в которую исполняющая система не мо-
жет из нее выйти. Например :

     P(a, b).                    (1)
     P(b, c).                    (2)
     R(X, Y):-R(X, Z), R(Z, Y).  (3)
     R(X, Y):-P(X, Y).           (4)
   ?-R(a, c).                    (5)

     Рис 1.             R(a, c)
                   ┌────┴────┐ (3)
                   R(a, Z)   R(Z, c)
                   :
                   R(a, Z')
              ┌────┴────┐ (3)
              R(a, Z")  R(Z", Z')
              :

Будем считать что узлы дерева поиска помечены соответствующими
подцелями,  то есть именем предиката и его аргументами. Проце-
дура  формирования дерева поиска детерминирована,  поэтому все
сегменты между двумя одинаково  помеченными  узлами  на  одной
ветви  дерева  поиска  будут  также  одинаковыми.  Кроме того,
поскольку переименование переменных не имеют влияние на проце-
дуру унификации, поэтому будет правильно рассматривать "семан-
тически",  а не  только  синтаксечески  эквивалентные  подцели
(метки дерева поиска).  Семантически эквивалентная подцель мо-
жет быть получена из другой переименованием переменных.

    Фактически, переменные в метках узла дерева  поиска  могут
быть  связаны между собой или им могут быть присвоены значения
динамически в течение выполнения запроса. Но для нас представ-
ляет интерес только одна структура,  которая соответствуют мо-
менту решения  соответствующей  подцели  (то  есть  когда  был
расширен соответствующий узел дерева поиска).

    Исполняющая система  Prolog-а сохраняет все связывания пе-
ременных в списке восстановления для перебора с возвратом, так
что мы можем легко восстановить структуру, нас интересующую.

    Критерий контроля зацикливания состоит в следующем: до то-
го,  как будет предпринята попытка решить любую  из  подцелей,
будем   пытаться  найти  подцель,  семантически  эквивалентную
рассматриваемой,  на текущей ветви дерева поиска.  Если  такая
подцель будет найдена, то необходимо оставить эту ветвь дерева
поиска.  Поскольку фаза формирования узла дерева поиска  соот-
ветствует успешному решению подцели,  то будет достаточно обь-
явить решение этй подцели неудачным,  и система выберет другую
альтернативу.

    Усиленная таким  механизмом,  процедура логического вывода
все-же не будет обладать свойством полноты (в некоторых случа-
ях зацикливание возможно),  однако это позволяет формулировать
и решать некоторые практически полезные задачи,  ранее не под-
дававшиеся решению.  Например, можно определять симметричные и
транзитивные отношения:

     P(X, Y):-P(Y, X).
     P(X, Y):-P(X, Z), P(Z, Y).

с гарантией того,  что вычисления будут завершены.  Этот меха-
низм позволяет решать "Задачу об обезьяне и банане" в  класси-
ческой постановке (см. пример программы в главе IV).


    IV. "Реляционно-ориентированный" язык логического програм-
         мирования.

    Язык систем Prolog-plus имеет модульную  структуру.  Прог-
рамма  интегрируется  из отдельно компилируемых модулей и зап-
росов. Основное понятие этого языка - отношение.

  < module > ::=
    'Module' < module_name >
       < module_interface >
       < module_body >
    'end'

интерфейс модуля состоит из одной или двух частей:

  < module_interface > ::=
      'Export' < export_list >
     ['Import' < import_list >]

список экспорта  содержит  имена  отношений,   которые   могут
использоваться вне этого модуля:

  < export_list > ::=
      < relation_name > |
      < relation_name > ',' < export_list >

список импорта содержит имена модулей,  из которых  импортиру-
ются внешние отношения, используемые в этом модуле:

  < import_list > ::=
      < module_name > |
      < module_name > ',' < import_list >

тело модуля - множество отношений:

  < module_body > ::=
      < relation > |
      < relation > < module_body >

  < relation > ::=
      'Relation' < relation_name >
        < relation_body >
      'end'

тело отношения - множество правил:

  < relation_body > ::=
      < clause > |
      < clause >
      < relation_body >
  < clause > ::=
      < arguments > 'if'
        [< clause_body >]

кроме множества модулей, программа содержит запрос:

  < query > ::=
      'Query' < query_name > < arguments >
        < clause_body >
      'end'

тело правила содержат последовательность сингулярных (еди-
ничных) предложений:

  < clause_body > ::=
      < singular > |
      < singular > < clause_body >

сингулярное предложение может быть простое или составное:

  < singular > ::=
      < atom > |
      < compound >

составные предложения  -  системно-предопределенные  синтакси-
ческие структуры со специальной семантикой:

  < compound > ::=
      < atom > '/UNIQUE' |
      'NOT' < atom > |
      'SET' < atom > ',' < var > ',' < var > |
      'MIN' < atom > ',' < var > ',' < var > |
      'MAX' < atom > ',' < var > ',' < var > |
      'SUM' < atom > ',' < var > ',' < var > |
      'AVG' < atom > ',' < var > ',' < var >

составные предложения интерпретируются системой следующим  об-
разом:

    P(...)/unique      - устанавливает  текущую точку возврата
                         после решения предиката P такой,  ка-
                         кой  она  была  до решения предиката,
                         "забывает" внутренние точки  возврата
                         предиката P;
    NOT P(...)         - определяет отрицание по неудаче;
    SET P(...), _x, _X - определяет список _X значений переме-
                         нной _x;
    MIN P(...), _x, _X - определяет минимум (максимум) _X зна-
    MAX P(...), _x, _X   чения переменной _x ;
    SUM P(...), _x, _X - определяет cумму _X значений перемен-
                         ной _x;
    AVG P(...), _x, _X - определяет среднее _X  значений пере-
                         менной _x.

простое предложение - спецификация отношения, с необязательным
префиксом:

  < atom > ::=
      [< module_spec > '.'] < relation_name > < arguments >

спецификация модуля  -  имя  модуля или префикс отношения базы
данных:

  < module_spec > ::= < module_name > | '$'

отношения базы  данных  обрабатываются   как   обычные   факты
Prolog-а с естественным синтаксисом. Пользователь должен толь-
ко записать спецификацию отношения и ничего  более.  Например:
если пользователь хочет получать данные о клиентах, хранящиеся
в обычном файле .DBF он записывает:

     DBF.CLIENTS(_surname,_firstname,_company,_phone).

где DBF - имя псевдо-модуля базы данных.  Спецификация отноше-
ния требует соответствия с полями отношения базы данных (пози-
ционное представление), неполный список аргументов также допу-
стим:

    DBF.CLIENTS(SURNAME=_name, TELEPHONE=_phone)

где "SURNAME" и "TELEPHONE" - имена  полей  отношения. Для эф-
фективной обработки отношений с большим числом записей исполь-
зуется квалификатор индекса:

    DBF.CLIENTS(SURNAME=_name, TELEPHONE=_phone)/index NAME

где NAME - имя индексного файла. Переменные, которые соответс-
твуют ключевым полям должны иметь значения.

    Все остальные конструкции языка задаются аналогично  стан-
дартному Prolog-у, включая структурные термы и списки, за иск-
лючением представления переменных.

переменная - идентификатор с обязательным префиксом:

  < var > ::= '_' < identifier >

Если строковая константа - идентификатор то ее можно не заклю-
чать в кавычки, например :

     Person(Robinson), но
     Person("De Morgan").


    Пример модуля и запроса:

    Module Monkey
      Export Climb
      Relation State
      (* начальное состояние, обезьяна в точке a, стул в    *)
      (* точке b, бананы над точкой c                       *)
        (a, b, c, [])
      (* обезьяна может переносить стул если она и стул     *)
      (* находятся в одной точке                            *)
        (_x1, _x1, _z, [carry(_x0, _x1);_s]) if
           State(_x0, _x0, _z, _s)
      (* обезьяна может ходить при любом условии            *)
        (_x1, _y, _z, [walk(_x0, _x1);_s]) if
           State(_x0, _y, _z, _s)
      end
      Relation Climb
      (* обезьяна может сорвать банан если она и стул       *)
      (* находятся под бананом                              *)
        ([climb;_s])
           State(_x, _x, _x, _s)
      end
    end
    Query Monkey(_z)
      Monkey.Climb(_z)
      put(_z)
    end

ответом будет список:  [climb,  carry(b,  c), walk(a, b)], что
можно интерпретировать как: идти из точки "a" в точку "b", за-
тем нести стул из точки "b" в точку "c",  и тогда подняться на
стул и сорвать банан.

    Обратите внимание,  что эта программа не может быть выпол-
нена успешно стандартным интерпретатором Prolog-а,  дерево по-
иска этой задачи содержит бесконечную ветвь,  и  интерпретатор
стандартного Prolog-а не сможет из нее выйти.


    V. Управление виртуальной памятью.

    Первоначально диспетчер  виртуальной памяти разрабатывался
для того,  чтобы обеспечить способность  выполнения вычислений
большого объема, но как оказалось, виртуальная адресация весь-
ма полезна для организации  межмодульного интерфейса и  интер-
фейса с базами данных.

    Модульная структура   языка   обеспечивается    раздельной
трансляцией каждого модуля и запроса.  Более того, разработан-
ный диспетчер виртуальной памяти обеспечивает обработку перет-
ранслированных  модулей  без  перекомпонования всей программы,
вследствие динамического связывания во время выполнения.

    Диспетчер виртуальной памяти системы Пролог-плюс реализует
неоднородное адресное пространство. Доступ может быть осущест-
влен к стеку исполняющей системы, двоичному модулю  программы,
отношению  базы данных.  В любом случае, загруженная  страница
виртуальной памяти остается в основной памяти до тех пор, пока
она  не будет вытеснена  другой, в течении  всей сессии работы
системы (не только в течении вычисления одного запроса). Такой
подход обаспечивает в некотором смысле "виртуальную операцион-
ную среду". Пользователь не управляет файловой системой непос-
редственно. Система автоматически определяет и выполняет необ-
ходимые файловые операции (открытия, закрытия, чтения, записи)
в зависимости от состояния диспетчера.

    Стратегия загрузки / выгрузки основана  на системе приори-
тетов страниц виртуальной памяти. Приоритет страницы определя-
ется по времени последнего доступа, при необходимости вытесня-
ется более "старая" страница.

    Система не накладывает ограничений  на количество одновре-
менно обрабатываемых файлов двоичных модулей программ и файлов
отношений базы данных. Система приоритетов  распространяется и
на целые файлы. В ситуации, когда очередной файл не может быть
открыт, система находит файл с наименьшим приоритетом, модифи-
цирует его содержание на диске и закрывает.

    Диспетчер виртуальной памяти системы Prolog-plus обеспечи-
вает стек исполняющей системы, размер которого ограничен толь-
ко размером внешней памяти (диска).


    VI. Реализация.

    В настоящее   время   разработана   альфа-версия   системы
Prolog-plus. Реализация выполнена на языке Modula-2 для персо-
нальных компьютеров DEC Professional 350 под управлением  опе-
рационной системы P/OS ,  и для IBM - совместимых под управле-
нием операционной системы MS DOS.

    Система Prolog-plus  - интегрированная среда,  которая со-
держит:
  - многооконный текстовый редактор;
  - транслятор модулей и запросов;
  - исполняющую систему (интерпретатор);
  - встроенную систему управления реляционной базой  данных  с
    Query-By-Example - подобным языком запросов;
  - вспомогательные утилиты.


    Литература

    M.Bruynooghe
      The memory Management of Prolog Implementations.
      Logic programming.
        Academic Press, New York, 1982.

    C.J.Hogger
      Introduction to Logic Programming.
        Academic Press, London, 1984.

    S.Ceri, G.Gottlob, L.Tanka
      Logic Programming and Databases.
        Springer-Verlag, Berlin, Neidelberg, 1990.

    M.Reviakin
      Logic Programming System Prolog-plus
        Proc. of the ICLP'93, MIT Press,
        Cambridge, Massachusetts, 1993.


