                              ВВЕДЕНИЕ

         Датой рождения наиболее популярного диалогового языка прог-
    раммирования Бейсик считается 1 мая 1964 г. Более чем 25 лет тому
    назад сотрудникам Дартмутского колледжа во главе с Дж.Кемени и Т.
    Куртцем удалось запустить разработанный ими интерпретатор и выпол-
    нить первую Бейсик-программу.
         Развитие нового алгоритмического языка на первом этапе дикто-
    валось, в основном, шестью авторскими редакциями (Дартмут, 1965 -
    1975 гг.), разработки которых поддерживались фирмой General Elec-
    tric. Массовому распространению Бейсика содействовал интерес, ко-
    торый проявили к нему такие передовые производители мини-ЭВМ, как
    Digital Equipment Corporation (PDP/8, PDP/11), Hewlett-Packard
    (HP-21X, HP-2000), Wang Laboratories (Wang-2200). Среди оригиналь-
    ных разработок для отечественных ЭВМ того периода наиболее извест-
    ны реализации Бейсик-компилятора на ЭВМ типа М-20 (Горьковский
    университет, 1970г.), интерпретирующих систем BASIC-6 на ЭВМ БЭСМ-
    6 (Вычислительный центр СО АН СССР, 1972 г.) и Бейсик-ГАММА на ЭВМ
    Минск-32 (Институт математики АН БССР,1974 г.).
         Второе поколение Бейсик-систем (1975 - 1985 гг.) тесно связано
    с появлением первых персональных ЭВМ, которые сначала обладали срав-
    нительно малой оперативной памятью (32 - 64 Кб). Для них Бейсик-ин-
    терпретатор стал поистине золотой жилой. Именно с него начал свою
    карьеру Билл Гейтс, основавший фирму Microsoft Corp. В середине
    70-х годов он разработал интерпретатор BASIC-80, который функциони-
    ровал на наиболее популярных восьмиразрядных микропроцессорах того
    времени Zilog-80 и Intel-8080.
         Игровая ориентация бытовых ПЭВМ привела к появлению таких язы-
    ковых средств как элементы машинной графики, процедуры организации
    звуковых эффектов и взаимодействия с активными внешними устройства-
    ми. Для Бейсик-систем того времени уже характерны достаточно разви-
    тые процедуры обработки текстовой информации и управления файлами.
    Наиболее полно эти возможности представлены в одной из лучших вер-
    сий второго поколения - GW BASIC'е. Среди оригинальных отечествен-
    ных разработок того периода отметим серию интерпретаторов компили-
    рующего типа Бейсик/F, Бейсик/Fs и Бейсик/Fsc, разработанных на
    Рижском производственном об'единении ВЭФ и доведенных до уровня
    программного продукта.
         В 1984-85 гг. наметились два новых подхода к развитию систем
    программирования на базе Бейсика. Один из них, активно поддерживае-
    мый фирмами Microsoft Corp. и Borland International, был направлен
    на создание быстрых систем компилирующего типа, обеспечивающих дос-
    таточно комфортабельные условия работы для пользователей. Для под-
    держания Бейсика на уровне современности в его состав включались
    наиболее распространенные элементы структурного программирования,
    вводились новые типы данных, предпринимались усилия по организации
    взаимодействия с внешними процедурами, по раздельной компиляции мо-
    дулей и использованию библиотек программ. Так появились серии
    Quck- и Turbo-систем, которые вплотную приблизились по своим воз-
    можностям к профессиональным системам программирования на базе язы-
    ков Паскаль и Си.
         Второе направление, связанное с принципиальным совершенствова-
    нием структуры языка и попыткой его стандартизации, было положено
    авторами Бейсика, которые 20 лет спустя опубликовали книгу "Back
    to BASIC". В ней была изложена версия, получившая название "истин-
    ного Бейсика" (True BASIC). С основными положениями этой версии на-
    ши читатели могут познакомиться по переводу книги Э.Кэтлина (Прог-
    раммирование на языке БЕЙСИК : Версия True BASIC.- М.: Мир,1990).
    Среди других версий, которые были реализованы на IBM PC и примыкали
    ко второму направлению, следует отметить системы BASIC-Standard
    (поставлялась в комплекте с ПЭВМ Роботрон-1910) и Better BASIC (раз-
    работка американской фирмы Summit Software Technology).
         Трезво оценивая обстановку, сложившуюся к концу 1990 г. на рын-
    ке программных продуктов вокруг Бейсик-систем третьего поколения, я
    отдал предпочтение более распространенным реализациям фирм Microsoft
    Corp. (GW BASIC, Quick BASIC)  и Borland International (Turbo BASIC).
         Среди систем, описание которых включено в настоящую книгу, ин-
    терпретатор GW BASIC морально устарел. Под его управлением программы
    выполняются примерно в 10 раз медленнее. Он плохо использует ресурсы
    ПЭВМ, так как предоставляет пользователю только 64 Кб оперативной
    памяти. Однако эта система активно эксплуатировалась более пяти лет,
    и под ее управлением разработано очень богатое программное хозяйство.
    Его использование в значительной мере облегчается тем, что входной
    язык GW-системы практически полностью перекрывается языковыми сред-
    ствами систем Quick и Turbo BASIC.
         В книге не ставится задача сравнения описываемых систем. Со-
    поставления такого рода достаточно сложны, так как приходится учи-
    тывать класс решаемых задач, принимать во внимание зачастую проти-
    воречивые критерии, экспериментировать с различными режимами рабо-
    ты и т.п.
         С некоторыми курьезами самого тривиального тестирования компи-
    ляторов по быстродействию изготавливаемых программ мне пришлось
    столкнуться совсем недавно. В одном из выпусков журнала Mikropro-
    zessortechnik (1990, Heft 8) была приведена серия простейших BASIC-
    тестов с результатами их прогона на IBM PC/AT (см. табл.1).

                                                      Таблица 1
    ┌───────┬────────────────────────────────────────────────────────┐
    │ Номер │               Время прогона в сек                      │
    │ теста ├──────────┬──────────┬────────────────┬─────────────────┤
    │       │ Quick-2.0│ Quick-4.0│ Turbo BASIC-2.0│ Turbo Pascal-5.0│
    ├───────┼──────────┼──────────┼────────────────┼─────────────────┤
    │   1   │   0.441  │  0.378   │     0.439      │     0.445       │
    │   2   │   6.641  │  1.980   │     2.363      │     5.998       │
    │   3   │  16.148  │  4.558   │     4.228      │     6.598       │
    │   4   │  34.328  │ 12.027   │    17.848      │    10.392       │
    │   5   │   1.648  │  1.308   │     1.593      │     1.480       │
    │   6   │   1.867  │  1.980   │     1.812      │     1.980       │
    └───────┴──────────┴──────────┴────────────────┴─────────────────┘

         Из этой таблицы можно было заключить, что версия Quick-4.0,
    как правило, изготавливает более скоростные программы. Поскольку
    среди доступных мне версий имелись и другие реализации, то возникло
    естественное желание расширить таблицу 1. И вот, что из этого вышло.
         Первую же неожиданность принесло тестирование программы PROG1,
    когда при I%=4096 (по замыслу автора журнальной публикации цикл дол-
    жен был выполняться 30000 раз) возникло переполнение в строке 60.
    Экспресс-анализ показал, что это вполне естественно, так как значе-
    ние X% при каждом повторении цикла возрастало на 8. Для выхода из
    создавшегося положения можно было сократить число повторений до
    3000, изменить начальное значение Y% или подкорректировать формулу
    в строке 60 :

                    60  X% = X% + (Y% * 2% - Y%) \ Y%

         Однако только этим дело не ограничилось. При малом числе пов-
    торений цикла (3000) на частоте 12 мггц время работы теста в Turbo-
    системе оказалось отрицательным (порядка -0.1E-03). Распечатка по-
    казаний таймера перед началом цикла (20 PRINT TIMER) и по его окон-
    чанию (80 PRINT TIMER) показала, что полтергейст здесь не при чем.
    Причина неправильного хронометража заключалась в округлении доста-
    точно большого числа (дело было вечером), которое происходило в
    20-й строке из-за несовпадения типов переменных. После замены T на
    переменную T# эффект "сверхскорости" испарился.
         Остальные тесты прошли без приключений, но получившиеся цифры
    (см. табл.2) в большинстве случаев свидетельствовали в пользу Tur-
    bo-системы.

                                                      Таблица 2
    ┌───────┬──────────────────┬──────────────────┬──────────────────┐
    │ Номер │    GW - 3.23     │   Quick - 4.0    │   Turbo - 1.1    │
    │ теста ├────────┬─────────┼────────┬─────────┼────────┬─────────┤
    │       │ 8 Мггц │ 12 Мггц │ 8 Мггц │ 12 Мггц │ 8 Мггц │ 12 Мггц │
    ├───────┼────────┼─────────┼────────┼─────────┼────────┼─────────┤
    │   1   │  4.84  │   3.18  │   1.54 │   0.23  │  0.33  │   0.06  │
    │   2   │ 37.35  │  24.55  │   6.37 │   4.61  │  3.41  │   2.42  │
    │   3   │ 69.92  │  45.58  │   8.35 │   5.82  │  6.43  │   4.45  │
    │   4   │ 71.13  │  56.58  │  12.03 │  10.60  │ 13.29  │   9.78  │
    │   5   │  9.29  │   6.15  │   2.19 │   1.43  │  1.76  │   1.21  │
    │   6   │  3.07  │   2.42  │   2.36 │   1.70  │  1.65  │   1.65  │
    │   7   │  4.28  │   2.81  │   0.39 │   0.28  │  0.11  │   0.006 │
    └───────┴────────┴─────────┴────────┴─────────┴────────┴─────────┘

         Однако некоторые обстоятельства вызывали сомнение в достовер-
    ности и этих результатов. Исключим подозрение, что разные исследо-
    ватели представляли интересы конкурирующих фирм. Но ведь данные
    таблиц 1 и 2 могли расходиться, во-первых, из-за несоответствия
    параметров технических средств. Во-вторых, у каждой из систем про-
    граммирования имеется довольно много управляемых характеристик
    (размер стека, динамический контроль индексов и переполнения, ими-
    тация сопроцессора и т.п.), влияющих на быстродействие программы.
         Более точные измерения времени работы тех или иных компонент
    можно было получить, исключив из общих показаний таймера накладные
    расходы по организации циклов. Для этой цели и был добавлен тест
    PROG7, выполнявший "пустой" цикл 20000 раз.
         Продолжая эксперименты с тестами, я обнаружил ряд эффектов,
    происхождение которых затрудняюсь об'яснить. Например, для теста
    PROG4 увеличение окна Run до полного экрана приводило к замедлению
    времени работы программы примерно вдвое (9.78 -> 20.76, 13.29 ->
    25.15). Какие-то разумные оправдания этому можно было бы придумать:
    тест печати, площадь вывода резко увеличилась ... Но почему анало-
    гичные действия существенно сокращали время вывода графической ин-
    формации (PROG5, 1.70 -> 1.15) ? Влияло на время выполнения тестов
    и наличие номеров программных строк, которые я включил из-за GW-си-
    стемы. В Quick- и Turbo-системах программы без номеров строк выпол-
    нялись чуть-чуть быстрее. Округление при запоминании показаний тай-
    мера приводило к тому, что два последовательных прогона одной и той
    же программы давали разброс результатов в пределах до 5%. Как после
    этого можно было доверять 4-й или 5-й значащим цифрам ?
         Для дотошных читателей, желающих провести самостоятельное ис-
    следование сообщаю некоторые технические детали своего эксперимен-
    та. Машина AT-286 с тактовыми частотами 8 и 12 мггц, сопроцессор
    80287, оперативная память 1 Мб, монитор EGA-256, винчестер со вре-
    менем доступа 70 млсек. Распечатки тестовых программ приведены в
    приложении D. В каждой из них рекомендуется заменить переменную T
    на переменную с удвоенной точностью. Результаты тестовых прогонов,
    приведенные в табл.2, получены при трансляции в оперативную память.
         Оценивая свое отношение к описываемым системам, выскажу нес-
    колько положений дискуссионного характера :

      1.Систему GW BASIC целесообразно эксплуатировать только на ПЭВМ с
        ограниченными ресурсами (отсутствует винчестер, об'ем оператив-
        ной памяти менее 512 кБ).

      2.Quick-системы выглядят самыми мощными, но и самыми громоздкими.
        Их авторы уделили большое внимание средствам отладки, межязыко-
        вому общению и разделению этапов конструирования программ (тран-
        сляция, сборка модулей, работа с библиотеками).

      3.Turbo-системы более практичны и быстры. В них лучше продуманы
        средства общения с пользователем, а в последних версиях появи-
        лись очень удобные элементы контекстной подсказки и новые воз-
        можности для отладки программ. Так что учебный процесс целесо-
        образнее ориентировать на версию Turbo BASIC - 2.0, которая,
        к сожалению, еще не получила достаточного распространения в
        нашей стране.