             1.2.Типы данных и форматы их представления

     1.2.1.Литеральные константы числового и символьного типов

         Константы представляют собой об'екты, чьи значения не могут
    быть изменены в процессе выполнения программы. Эпитет "литераль-
    ный", который чаще применяется в машинно-ориентированных языках
    (автокод, ассемблер), связывают с константой, значение которой
    в явном виде указано в тексте программы.
         В описываемых версиях литеральные константы принадлежат
    двум множествам - числовому и символьному. Первое множество пред-
    ставлено четырьмя типами числовых констант - целыми числами нор-
    мальной или удвоенной длины, вещественными числами с одинарной
    или удвоенной точностью.
         Целые числа нормальной длины принадлежат диапазону [-32768,
    32767] и представляются в ЭВМ двухбайтовыми двоичными числами в
    дополнительном коде. В программе целочисленные константы этого
    типа могут быть заданы десятичными числами, запись которых завер-
    шается символом % , или числами в других системах счисления -
    двоичной, восьмеричной или шестнадцатеричной. К последним прибе-
    гают в случае задания беззнаковых констант, логических шкал или
    адресов оперативной памяти. Двоичные константы начинаются с сим-
    волов &B и могут содержать от одной до шестнадцати двоичных цифр.
    Восьмеричные константы начинаются с комбинации &O и не должны пре-
    восходить свое максимальное значение - &O177777. Шестнадцатеричные
    константы начинаются символами &H и должны принадлежать диапазону
    от &H0 до &HFFFF.
         Целые числа удвоенной длины принадлежат диапазону
    [-2147483648,2147483647] и представляются в ЭВМ четырехбайтовыми
    двоичными числами в дополнительном коде. Запись целочисленных
    констант этого типа заканчивается символом &. Указанные констан-
    ты могут использоваться только в Quick- и Turbo-системах.
         Для представления вещественных чисел с одинарной точностью
    используется четырехбайтовый стандарт американского института ин-
    женеров по электротехнике и радиоэлектронике (формат IEEE). Он под-
    держивается сопроцессорами 8087(80287) и похож на формат, извест-
    ный нам по ЭВМ DEC-овской серии (отечественный эквивалент - СМ/4).
    В памяти ЭВМ вещественное число такого типа имеет следующий вид :

                               76543210
                              ┌────────┐
        байт с адресом 4k   - │mmmmmmmm├─────────────────────┐
                              ├────────┤                     │
        байт с адресом 4k+1 - │mmmmmmmm├─────────────┐       │
                              ├────────┤             │       │
        байт с адресом 4k+2 - │pmmmmmmm├─────┐       │       │
                              ├────────┤     │       │       │
        байт с адресом 4k+3 - │sppppppp│     │       │       │
                              └────┬───┘     │       │       │
                                   │         │       │       │
                              ┌────┴─────────┴───────┴───────┴───┐
                              │s ppppppp pmmmmmmm mmmmmmm mmmmmmm│
                              └─┴───────┴────────┴───────┴───────┘

    Здесь :
       s - знак числа (0 - положительное число, 1 - отрицательное);
       p - смещенный двоичный порядок (p = P + 127, 0 <= p < 255);
       m - усеченная двоичная мантисса без старшего двоичного разря-
           да (m = M - 1,  1 <=  M  < 2).
    Вещественное число x в формате IEEE представляется выражением
    вида :

                x = (-1)^s * M * 2^P

    Смещение порядка обеспечивает возможность работать только с по-
    ложительными значениями p, что несколько упрощает выполнение
    арифметических операций с плавающей запятой. Отсутствие старшей
    единицы в мантиссе, характерное для нормализованного числа, по-
    зволяет дополнительно хранить в памяти еще один младший разряд
    мантиссы, что несколько увеличивает точность представления чисел.
         Вещественные константы с одинарной точностью по модулю при-
    надлежат диапазону [1.2 E-38 , 3.4 E+38] и могут содержать до 7
    значащих цифр. Характерной особенностью в записи вещественных
    чисел является наличие точки, отделяющей целую часть числа от
    дробной, и/или множителя вида E+p или E-p. Иногда запись констант
    такого типа сопровождают символом "!" ( 0.3141593E+1! , 15! ) .
         Для хранения вещественных чисел с удвоенной точностью в си-
    стемах фирмы Microsoft обычно используются восьмибайтовые поля,
    которые отличаются от выше описанного короткого формата IEEE
    только наличием более длинной мантиссы. Это дает возможность за-
    писывать константы, содержащие до 16 - 17 десятичных значащих
    цифр и принадлежащих тому же самому диапазону допустимых чисел.
    Для обозначения такого формата в фирменных руководствах исполь-
    зуется термин Microsoft Binary Format (сокращенно - MBF). Одна-
    ко сопроцессор 8087 (80287) не поддерживает формат MBF. Поэто-
    му в версии Quick BASIC наряду с 8-байтовым форматом MBF может
    использоваться более прогрессивнный расширенный стандарт IEEE :

       63 62 ..... 52  51 ................................ 0
      ┌──────────────────────────────────────────────────────┐
      │s  ppppppppppp  mmmmmmmmmm.......................mmmm │
      └─┴─────────────┴──────────┴───────┴───────────────────┘

    Вещественное число x в этом формате представляется в виде :

       x = (-1)^s * M * 2^P  = (-1)^s * (m+1) * 2^(p-1023)

         Расширенный формат IEEE поддерживается сопроцессорами и
    обеспечивает работу с 17-разрядными десятичными числами, по мо-
    дулю принадлежащими диапазону [4.19E-307 , 1.67E+308 ].
         Запись вещественных констант с удвоенной точностью заканчи-
    вается символом # .
         Символьные (строковые, текстовые) константы, включаемые в
    текст программы, обычно заключаются в кавычки. Исключение могут
    составлять символьные константы, задаваемые в списках оператов
    DATA, где признаки начала и конца текстового значения выполняют
    окаймляющие запятые. Максимальная длина текстовой константы ог-
    раничена лишь емкостью соответствующей программной строки.
         В текстовых константах могут использоваться любые отобража-
    емые символы алфавита, которые можно набрать на клавиатуре. Если
    внутри константы необходимо задать кавычку, то приходится наби-
    рать две подряд идущие кавычки, которые во внутреннем представ-
    лении константы рассматриваются как один символ.


              1.2.2. Числовые и символьные переменные

         В отличие от констант переменные представляют такие об'ек-
    ты, значения которых могут изменяться в процессе выполнения про-
    граммы. Каждая переменная снабжается уникальным именем - иденти-
    фикатором, содержащим от одного до 40 алфавитно-цифровых симолов
    и начинающимся с буквы. Большие и малые буквы в именах перемен-
    ных не различаются. В идентификаторах должны использоваться
    только буквы латинского алфавита. Это важно помнить при наборе
    программы, так как многие латинские и русские буквы имеют сход-
    ные начертания, но в памяти ЭВМ им соответствуют различные коды,
    и русские символы в именах любой Бейсик-системой будут отвергну-
    ты. В идентификаторах переменных допускается употребление точек.
    Обычно ими пользуются в тех случаях, когда имя образовано из нес-
    кольких слов. Например - Max.Coord, Min.X.Y, End.of.Text и т.п.
         Переменные называются числовыми, если они могут принимать
    только числовые значения. По способу представления соответствую-
    щих значений числовые переменные подразделяются на четыре типа -
    целочисленные переменные со значениями нормальной (2 байта) или
    удвоенной  (4 байта) длины  и вещественные переменные со значе-
    ниями обычной (4 байта) и удвоенной (8 байтов) точности. Четырех-
    байтовые переменные целого типа допускаются только в Quick- и
    Turbo-системах.
         Значением переменной символьного типа является цепочка любых
    символов алфавита s1 s2 ... , количество которых рассматривается
    как "длина" переменной. Эта длина может находиться в интервале
    от нуля ("пустая" переменная) до максимального значения, допусти-
    мого системой программирования. Для GW BASIC максимальная длина
    равна 255, для систем Quick и Turbo - 32767. Об'ясняется это тем,
    что для хранения k-символьного значения текстовой переменной в
    GW-системе используется k+3 байта, а в остальных системах - k+4
    байта.  Один или два байта из числа дополнительных хранят длину
    символьной переменной, а два оставшихся используются в качестве
    относительного адреса текущего значения переменной в так называ-
    емой "куче". Куча представляет собой участок оперативной памяти,
    отведенный для хранения значений всех символьных переменных. Как
    только символьной переменной присваивается новое значение, имею-
    щее длину,отличную от предыдущей, оно располагается в куче на
    свободном месте, а поле с прежним значением освобождается. Ука-
    занная технология приводит к тому, что в куче образуется довольно
    много свободных участков, расположенных не подряд. Поэтому время
    от времени содержимое кучи приходится реорганизовывать с целью
    группировки свободных участков в поле со сплошной адресацией.
    Такая процедура носит название "уборки мусора" и может произво-
    как по запросу системы, так и по требованию программы (см. функ-
    цию FRE).
         Тип числовой или символьной переменной может быть указан
    либо явно - с помощью специального символа, завершающего имя пе-
    ременной, либо неявно - по принадлежности первого символа иден-
    тификатора заданному диапазону букв.
         В качестве конечного символа идентификатора используются
    знаки % (двухбайтовый целочисленный тип), & (четырехбайтовый це-
    лочисленный тип), ! (четырехбайтовый вещественный тип), # (вось-
    мибайтовый вещественный тип) или $ (символьный тип).
         Неявное об'явление типа переменной осуществляется с помощью
    операторов DEFINT (двухбайтовый целочисленный), DEFLNG (четырех-
    байтовый целочисленный), DEFSNG (четырехбайтовый вещественный),
    DEFDBL (восьмибайтовый вещественный) и DEFSTR (символьный тип).
         Все эти операторы имеют одинаковый формат :

                     DEFINT   a1[-a2], b1[-b2]....
                     DEFLNG   a1[-a2], b1[-b2]....
                     DEFSNG   a1[-a2], b1[-b2]....
                     DEFDBL   a1[-a2], b1[-b2]....
                     DEFSTR   a1[-a2], b1[-b2]....

        Здесь a1 - буква или диапазон букв (a1 - a2) латинского ал-
    фавита, с которых может начинаться имя переменной соответствую-
    щего типа. Следует отметить, что на переменные, описанные явным
    способом, действие указанных операторов не распространяется. По-
    этому в программе наряду с оператором "DEFSNG C-F" могут суще-
    ствовать и целочисленные переменные с именами COR% , DLINA& .
    Неявное описание типа распространяется только на те переменные,
    имена которых не завершаются указанными выше спецсимволами.
         Quick BASIC позволяет об'являть типы переменных и несколько
    иными способами с привлечением описателей INTEGER (целые,2 байта),
    LONG (целые,4 байта), SINGLE (вещественные,4 байта), DOUBLE (ве-
    щественные,8 байтов) и STRING (строковые). Такие возможности ис-
    пользуются в операторах COMMON, DIM, REDIM, SHARED, TYPE  и бу-
    дут более подробно рассмотрены в соответствующих разделах.
         Перед выполнением программы производится "очистка" всех пе-
    ременных. Числовым переменным при этом присваиваются нулевые зна-
    чения. Длина каждой переменной символьного типа при чистке уста-
    навливается также в нуль, таким образом всем текстовым перемен-
    ным присваивается значение "пусто".

                    1.2.3. Именованные константы

         Версия Quick BASIC допускает употребление констант, которые
    подобно переменным снабжаются именами. Об'явление именованных
    констант осуществляется с помощью оператора CONST, имеющего сле-
    дующий формат :

                     CONST  nc1 = e1 [,nc2 = e2  ...]

    Здесь nc - идентификатор константы, который строится по тем же
    правилам, что и имя переменной. Выражение e , определяющее зна-
    чение константы, может включать литеральные и ранее определенные
    именованные константы, об'единенные знаками операций соответст-
    ствующего типа. Выражения такого рода принято называть констант-
    ными.
         Turbo BASIC тоже допускает употребление именованных констант,
    принимающих целочисленные значения. Имена таких констант начинают-
    ся с символа "%". Для установления соответствия между именем кон-
    станты и ее значением используется конструкция, напоминающая опе-
    ратор присваивания :

                            %N =  255

         Преимущество от использования именованной константы заклю-
    чается в том, что имя константы может быть существенно короче ее
    значения ( CONST PI = 3.14159265# ). При многократном употребле-
    нии такой константы экономится время набора текста программы.
    Во-вторых, изменение значения именованной константы связано с
    перенабором только одного оператора, тогда как в случае исполь-
    зования литеральных констант модификацию пришлось бы выполнять
    многократно.
         Именованная константа может употребляться в любом месте про-
    граммы, где используется обычная переменная, за исключением левой
    части оператора присваивания, списка операторов ввода и фактичес-
    ких аргументов подпрограммы, соответствующих выходным параметрам.


                         1.2.4.Массивы

         Массивы представляют собой организованный набор однотипных
    переменных, компактно расположенных в оперативной памяти. Все
    элементы одного массива снабжаются общим идентификатором, вслед
    за которым в круглых скобках записываются один или несколько ин-
    дексов, определяющих местоположение элемента в массиве.
         Наиболее просто организованы одномерные массивы, являющиеся
    эквивалентами векторов. Все их элементы пронумерованы последова-
    тельными натуральными числами, которые и выполняют роль индексов.
    Минимальное значение индекса устанавливается либо по умолчанию,
    либо задается явным или неявным образом.
         Максимальное значение индекса обычно указывается при об'яв-
    лении массива. Для необ'явленных массивов максимальный индекс
    принимается равным 10.
         Двумерные массивы являются аналогами матриц. Первый индекс
    элемента двумерного массива определяет номер строки, а второй -
    номер столбца, на пересечении которых расположен элемент. Строки
    и столбцы нумеруются либо от единого, установленного заранее мини-
    мального значения индекса, либо от граничного значения, заданного
    одновременно с об'явлением массива.
         Количество индексов в многомерных массивах, вообще говоря,
    ограничено (см.табл.4). В Turbo- и Quick-системах размеры массива
    не должны превышать 64 кБ. В GW BASIC'е массивы и программа должны
    помещаться в одном сегменте длиной не более 64 кБ.

                                                  Таблица 4
     ┌────────────────────────┬────────┬────────────┬──────────┐
     │ Характеристика         │   GW   │   Turbo    │  Quick   │
     ├────────────────────────┼────────┼────────────┼──────────┤
     │ Максимальное количество│        │            │          │
     │        индексов        │   255  │       8    │     60   │
     │                        │        │            │          │
     │ Минимальный индекс     │     0  │   любой    │   любой  │
     │                        │        │            │          │
     │  Максимальный индекс   │  16387 │   32767    │   32767  │
     └────────────────────────┴────────┴────────────┴──────────┘


         По умолчанию во всех трех системах минимальным значением
    индекса считается 0. Для изменения этой границы используется опе-
    ратор OPTION BASE :

                    OPTION BASE   0
                    OPTION BASE   1

    Оператор OPTION BASE должен находиться среди первых операторов
    программы до об'явления какого-либо массива. В системе GW BASIC
    отсчет индексов всегда ведется от нуля, т.е. действие оператора
    OPTION BASE игнорируется. Система Quick BASIC позволяет по умол-
    чанию ограничить минимальное значение индекса либо нулем, либо
    единицей. Входной язык Turbo BASIC позволяет использовать в ка-
    честве минимальной границы любое число из диапазона [0 , 32767]:

                    OPTION BASE 1990

         В системах Quick и Turbo BASIC при об'явлении конкретного
    массива наряду с максимальным значением индекса можно указать
    и его минимальную границу. Оператор DIM, используемый для этой
    цели, имеет свой формат в каждой из систем :

     GW    :   DIM  V (I1max,I2max,... )

     Turbo :   DIM [ STATIC ] V ([I1min:]I1max,[I2min:]I2max,... )
               DIM [ DYNAMIC ] V ([I1min:]I1max,[I2min:]I2max,... )

     Quick :  DIM [ SHARED ] V ([I1min TO]I1max,[I2min TO]I2max,
                                ... ) [ AS  type ]

         Значение минимального индекса в Quick-системе может быть и от-
    рицательным.
         Атрибуты STATIC или DYNAMIC определяют способ выделения
    оперативной памяти под массив и вытекающие из этого возможности
    освобождения занимаемого участка или его использования для дру-
    гих целей. Статическим массивам память выделяется во время ком-
    пиляции. Такой массив нельзя переопределить или уничтожить. По
    умолчанию массивы, границы которых заданы константными выраже-
    ниями, в Turbo-системе считаются статическими. Выделение памяти
    для хранения динамических массивов осуществляется во время вы-
    полнения программы. Динамические массивы можно многократно пе-
    реопределять и уничтожать. Если в операторе DIM граница массива
    задана значением переменной, то такой массив считается динами-
    ческим. Например :

           INPUT "Введите размерность массива TOR"; N
           DIM  TOR(N)

         К динамическим причисляются и все массивы, об'являемые ло-
    кальными в подпрограммах (см. оператор LOCAL). Система Turbo
    BASIC дает пользователю возможность установить свое правило
    предпочтения для выбора динамического или статического способа
    распределения памяти под массивы. Для этой цели предназначены
    метаоператоры $STATIC и $DYNAMIC. Аналогичные команды, изменяю-
    щие режим работы компилятора, имеются и в системе Quick BASIC.
    Один из указанных метаоператоров помещается в начале программы
    и, тем самым, устанавливается соответствующее правило умолчания.
    Например :
                     $DYNAMIC
                     .........
                     DIM A(50)

         Способ распределения памяти под массивы, являющиеся внут-
    ренними в подпрограммах или функциях, в Quick BASIC'е может за-
    даваться с помощью атрибутов STATIC или DYNAMIC, записываемых в
    конце заголовка соответствующей процедуры (см. операторы SUB и
    FUNCTION).
         Удаление динамического массива из памяти выполняет оператор
    ERASE :
                     ERASE    CENA,TEXT$


         Системы GW и Turbo BASIC позволяют многократно переопреде-
    лять размеры динамического массива. Для этого старый массив дол-
    жен быть предварительно удален (ERASE), после чего его имя можно
    снова использовать  в операторе DIM.
         Применение оператора ERASE к статическому массиву приводит
    к инициализации (сбросу) значений всех его элементов.
         В Quick-системе переопределение динамических массивов осу-
    ществляется с помощью оператора REDIM даже без их предваритель-
    ного уничтожения (ERASE) :

      REDIM [ SHARED ] V([I1min TO] I1max,...) [ AS type ],....

    Атрибут SHARED в операторах DIM и REDIM используется в подпро-
    граммах и внешних функциях для указания массивов общего пользо-
    вания, доступных двум программным модулям.
         Операторы DIM и REDIM позволяют в Quick-системе наряду с
    размерами массивов об'явить и тип его элементов :

                   DIM   ABC(-10 TO 20) AS SINGLE

    Характеристика type может задаваться служебными словами INTEGER,
    LONG, SINGLE, DOUBLE, STRING, определяющими один из описанных
    ранее стандартных форматов. Наряду с этим в Quick BASIC'е эле-
    ментами массива могут быть переменные типа "запись", структура
    которых описывается с помощью операторов TYPE - END TYPE (см.
    раздел 1.2.5).


                 1.2.5.Составные данные (записи)

         При работе с файлами в качестве неделимых единиц обмена
    информацией выступают записи, составными частями которых являют-
    ся последовательные поля с данными разных типов. В GW и Turbo-
    версиях такого рода записи помещаются в буфер, связанный с фай-
    лом прямого доступа. Последовательные поля этого буфера рассмат-
    риваются как символьные переменные фиксированной длины, которые
    описываются в операторе FIELD.
         Шаг вперед по сравнению с этими версиями сделан в системе
    Quick BASIC - 4.0, где появился новый тип переменных - "записи",
    структура которых описывается с помощью конструкции TYPE - END
    TYPE :

               TYPE  struc
                     V1  AS  type1
                     V2  AS  type2
                     ..............
                END TYPE

    Здесь struc - идентификатор шаблона (структуры) записи, которая
    состоит из последовательных полей с именами V1,V2,... . Тип дан-
    ного, который может находиться на поле Vi, описывается либо с
    помощью атрибутов INTEGER, LONG, SINGLE, DOUBLE, STRING, либо
    путем ссылки на имя шаблона другой ранее описанной переменной ти-
    па "запись". В последнем случае поле Vi, в свою очередь, является
    составным, то есть само имеет структуру типа "запись".
         Описание символьных полей в записях всегда сопровождается
    указанием их длины в байтах :

             TYPE   book
                    avtor  AS STRING 20
                    naimenovanie  AS STRING 100
                    izdatelstvo AS STRING 15
                    god AS INTEGER
                    cena AS SINGLE
              END TYPE

    Перенос структуры записи, об'явленной выше указанным способом,
    на конкретную переменную или массив с именем V осуществляется с
    помощью операторов COMMON, DIM, REDIM, SHARED или STATIC. В их
    теле должна присутствовать одна из конструкций вида :

                      V([ind1,...)  AS  book
                      V[()] AS book

         После такого об'явления к содержимому соответствующих ком-
    понент записи можно обращаться по именам V.avtor, V.naimenovanie,
    V.izdatelstvo, V.god, V.cena .
         Основным назначением переменных типа "запись" является их
    использование в операторах обмена с файлами прямого доступа :

                    GET #5, K, V
                    PUT #3, 20,V

                 1.2.6.Преобразование типов данных

         С преобразованием данных из одного формата представления в
    другой мы сталкиваемся как явно, используя соответствующие стан-
    дартные функции, так и неявно, когда тип переменной не совпадает
    с типом присваиваемого ей значения. По результату своего действия
    явный и неявный способы преобразования ничем не отличаются друг
    от друга. Например, два следующие оператора приводят к абсолютно
    идентичным результатам :

                A# = 1%
                A# = CDBL(1%)


         Стандартные функции преобразования числовых и символьных
    данных можно сгруппировать по следующим пяти разделам.
         Первую группу составляют четыре функции, преобразующие чис-
    ловой аргумент любого типа к заданному числовому формату. Значе-
    ниями этих функций являются соответственно короткие (CINT) или
    длинные (CLNG) целые числа, вещественные числа с одинарной (CSNG)
    или удвоенной (CDBL) точностью. Замене аргумента вешественного
    типа коротким или длинным целочисленным значением предшествует
    округление аргумента до ближайшего целого числа. Аналогичное ок-
    ругление производится при переходе от вещественного аргумента с
    удвоенной точностью к короткому вещественному числу. Если аргу-
    мент функций CINT, CLNG или CSNG выходит за пределы допустимых
    диапазонов для данных соответствующего типа, то во время выпол-
    нения программы фиксируется ошибка типа "переполнение".
         Описанные выше преобразования числовых аргументов могут быть
    использованы для передачи параметров нужного типа подпрограммам
    или функциям без дополнительного переприсваивания.
         Вторая группа преобразований, представленная двумя функция-
    ми, связана с прямыми (ASC) или обратными (CHR$) переходами от
    представления любого символа таблицы ASCII к его числовому коду,
    принадлежащему диапазону [0, 255]. Аргументом функции ASC может
    быть любое символьное выражение ненулевой длины, однако преобра-
    зованию подвергается только его первый знак. Например :

                         ASC("ASC") = 65

    Попытка применить функцию ASC к пустому аргументу фиксируется
    как ошибка периода выполнения. Функция CHR$ выполняет преобразо-
    вание целочисленного аргумента в односимвольное значение :

                         CHR$(65) = "A"
    Функция CHR$ зачастую используется для включения в текстовые выра-
    жения любых неотображаемых символов. Например :

                 PRINT CHR$(7)
                 KEY   1,"LIST 1 - 9999" + CHR$(13)

    В первом случае оператор PRINT выдает односимвольную константу
    со служебным обозначением Bell в таблице ASCII, вывод которой
    сопровождается кратковременным звуковым сигналом. Во втором слу-
    чае за функциональной клавишей F1 закрепляется текст директивы
    вывода программы, завершающийся символом "возврат каретки" (де-
    сятичный код - 13, шестнадцатеричный - &H0D). Это позволяет выпол-
    нить директиву LIST путем нажатия единственной клавиши.
        Третья группа, в которую также входят две функции, исполь-
    зуется для преобразования числовых величин из их машинного пред-
    ставления в символьную строку (STR$) или для обратного перевода
    (VAL).  Аргументом функции STR$ может быть числовое выражение
    любого типа. Результат преобразования - строка символов, абсо-
    лютно идентичная той, которую мы бы увидели на экране дисплея
    при выводе значения аргумента по оператору PRINT. Обратное пре-
    образование числа из его символьного представления в машиный фор-
    мат, соответствующий типу аргумента, осуществляется функцией VAL.
    Это преобразование начинается с наиболее левого значащего симво-
    ла и продолжается до тех пор, пока не будет исчерпана строка,
    либо пока не встретится первый нечисловой символ (пробелы при
    этом игнорируются).
        В четвертую группу входят три функции - BIN$(e),HEX$(e) и
    OCT$(e), которые осуществляют перевод числового аргумента любого
    типа в строку с двоичной, восьмеричной или шестнадцатеричной фор-
    мой эквивлентного значения. Вещественные аргументы при этом окру-
    гляются до целых. Если округленное значение принадлежит одному из
    интервалов [-32768, 32767] или [0, 65535], то результат преобра-
    зования по длине совпадает с записью коротких констант соответ-
    ствующего типа, у которых отброшены лидирующие нули :

                 BIN$(65) = "1000001"
                 HEX$(65) = "41"
                 OCT$(65) = "101"

         Если округленное значение аргумента выходит за пределы ука-
    занных интервалов, но может быть размещено в целочисленном четы-
    рехбайтовом формате, то указанные функции выдают результат типа
    LONG.
         Отрицательные аргументы преобразуются в соответствии с их
    представлением в дополнительном коде. Например :

                   BIN$(-1) = "1111111111111111"
                   HEX$(-1) = "FFFF"
                   OCT$(-2) = "177776"

         Наиболее многочисленная группа представлена 16-ю функциями,
    используемыми для замены числовых данных их символьными "эквива-
    лентами" при работе с файлами прямого доступа или для перехода
    от формата MBF к стандарту IEEE. Функции MKI$, MKL$, MKS$ и MKD$
    позволяют преобразовать n-байтовое числовое значение аргумента
    (n = 2,4,4,8) в n-байтовый "эквивалент" символьного типа. Факти-
    чески, при этом переходе никакого преобразования не происходит.
    К двоичному представлению целого или вещественного числа добав-
    ляются 3 или 4 байта, сопровождающие хранение текстовой величины,
    а само число без какого-либо изменения копируется в область, пред-
    назначенную для хранения символьных данных. Полученный таким об-
    разом символьный "эквивалент" числа можно переносить с левым или
    правым прижимом на поля буфера, отведенного для обмена с файлом
    прямого доступа :

      FIELD  #5, 6 AS p1$, 10 AS p2$, 5 AS p3$, 12 AS p4$
      .....................
      LSET  p1$ = MKI$ (V1%)
      LSET  p2$ = MKL$ (V2&)
      RSET  p3$ = MKS$ (V3)
      RSET  p4$ = MKD$ (V4#)
      ......................
      PUT  #5,K

         Обратный переход от символьных "эквивалентов" числовых данных,
    считанных в буфер из файла прямого доступа, производится с помощью
    функций CVI, CVL, CVS и CVD. Их аргументами должны быть символьные
    строки, содержащие соответственно по 2,4,4 и 8 байтов и полученные
    в результате применения функций MKI$, MKL$, MKS$ и MKD$ :

                       GET #5, N
                       V1% = CVI (MKI$ ( LEFT$ (p1$,2)))
                       V2& = CVL (MKL$ ( LEFT$ (p2$,4)))
                       V3  = CVS (MKS$ ( RIGHT$ (p3$,4)))
                       V4# = CVD (MKD$ ( RIGHT$ (p4$,8)))

         Входной язык Turbo BASIC предоставляет в распоряжение поль-
    зователя функции MKMS$ и MKMD$, являющиеся аналогами функций MKS$
    и MKD$, с помощью которых производится перевод вещественных зна-
    чений из числового формата IEEE в символьный "эквивалент" формата
    MBF. В этих процедурах числовой аргумент уже подвергается содер-
    жательному преобразованию, так как стандарты MBF и IEEE отличают-
    ся по внутреннему представлению. Обратный переход в стандарт IEEE
    из символьного "эквивалента" вещественных чисел формата MBF про-
    изводится с помощью функций CVMS или CVMD.
         В Quick BASIC'е тоже имеется возможность перехода от число-
    вого стандарта IEEE к формату MBF. Функции MKSMBF$ и MKDMBF$
    преобразуют в символьный формат MBF соответственно короткие или
    длинные вещественные числа, представленные в стандарте IEEE. Об-
    ратный переход от символьного "эквивалента" формата MBF в число-
    вой стандарт IEEE производится с помощью функций CVSMBF или
    CVDMBF.
         Последние восемь функций позволяют через внешний носитель
    обмениваться результатами вычислений между программами, разрабо-
    танными в разных системах. GW BASIC не может использовать число-
    вые данные формата IEEE, полученные в "чужой" системе.



                 1.3.Стандартные и нестандартные функции

         Кроме констант, переменных и более сложных об'ектов типа за-
    писей к числу операндов, над которыми можно выполнять те или иные
    операции, относятся стандартные и нестандартные функции. По анало-
    гии с математическим определением функцию можно представлять себе
    как некоторую вычислительную процедуру, на вход которой подается
    набор допустимых аргументов, а на выходе получается единственный
    результат - значение числового или символьного типа. Любая функ-
    ция реализуется с помощью программы, которая либо является посто-
    янной компонентой системы программирования, либо должна быть скон-
    струирована в той или иной форме пользователем. В соответствии с
    этим все функции подразделяются на системные (стандартные) и поль-
    зовательские (нестандартные).
         Подобно переменным каждая функция снабжается уникальным име-
    нем и строится оно по тем же правилам, что и любой идентификатор
    Бейсика. За стандартными функциями закреплены фиксированные име-
    на, которые нельзя употреблять в качестве идентификаторов других
    об'ектов. Полный их перечень приведен в табл.5. Имена нестан-
    дартных функций пользователь конструирует сам. В одних случаях
    (см. опeратор DEF FN) имя нестандартной  функции должно начинать-
    ся с символов FN, после чего может следовать до 38 других алфа-
    витно-цифровых символов, включая и последний символ, явно опре-
    деляющий тип функции. В системе Quick BASIC наряду со внутренни-
    ми функциями (DEF FN) могут использоваться и внешние функции,
    оформляемые в виде отдельных модулей (см. оператор FUNCTION). Их
    имена могут начинаться с любых символов.
         Количество аргументов в нестандартных функциях обычно ограни-
    чивается достаточно большим числом (в Turbo BASIC'е, например, до
    16 переменных). В качестве формальных параметров внутренних функций
    пользователя выступают только простые переменные числового или сим-
    вольного типа.  Для внешних функций набор формальных параметров су-
    щественно шире. Он может включать имена массивов, структуры типа
    записей, номера файлов и адреса переменных.


                                                     Таблица 5
    ┌─────────┬────────────────────╖─────────┬────────────────────┐
    │  Имя    │ Наличие в системе  ║   Имя   │  Наличие в системе │
    │ функции ├────────────────────╢ функции ├────────────────────┤
    │         │ GW   Qick   Turbo  ║         │ GW   Qick   Turbo  │
    ├─────────┼────────────────────╫─────────┼────────────────────┤
    │ ABS     │  +     +      +    ║ LTRIM$  │  -     +      -    │
    │ ASC     │  +     +      +    ║ MID$    │  +     +      +    │
    │ ATN     │ s/d   s,d     d    ║ MKD$    │  +     +      +    │
    │ BIN$    │  -     -      +    ║ MKDMBF$ │  -     +      -    │
    │ CDBL    │  +     +      +    ║ MKI$    │  +     +      +    │
    │ CEIL    │  -     -      +    ║ MKL$    │  -     +      +    │
    │ CHR$    │  +     +      +    ║ MKMD$   │  -     -      +    │
    │ CINT    │  +     +      +    ║ MKMS$   │  -     -      +    │
    │ CLNG    │  -     +      +    ║ MKS$    │  +     +      +    │
    │ COS     │ s/d   s,d     d    ║ MKSMBF$ │  -     +      -    │
    │ CSNG    │  +     +      +    ║ OCT$    │  +     +      +    │
    │ CVD     │  *     *      +    ║ PEEK    │  +     +      +    │
    │ CVDMBF  │  -     +      -    ║ PEN     │  +     +      +    │
    │ CVI     │  +     +      +    ║ PLAY    │  +     +      +    │
    │ CVL     │  -     +      +    ║ PMAP    │  +     +      +    │
    │ CVMD    │  -     -      +    ║ POINT   │  +     +      +    │
    │ CVMS    │  -     -      +    ║ POS     │  +     +      +    │
    │ CVS     │  *     *      +    ║ REG     │  -     -      +    │
    │ CVSMBF  │  -     +      -    ║ RIGHT$  │  +     +      +    │
    │ ENVIRON$│  +     +      +    ║ RND     │  +     +      +    │
    │ EOF     │  *     +      +    ║ RTRIM$  │  -     +      -    │
    │ EXP     │ s/d   s,d     d    ║ SADD    │  -     +      -    │
    │ EXP10   │  -     -      d    ║ SCREEN  │  +     +      +    │
    │ EXP2    │  -     -      d    ║ SEEK    │  -     +      -    │
    │ FILEATTR│  -     +      -    ║ SETMEM  │  -     +      -    │
    │ FIX     │  +     +      +    ║ SGN     │  +     +      +    │
    │ FRE     │  *     +      +    ║ SIN     │ s/d   s,d     d    │
    │ HEX$    │  +     +      +    ║ SPACE$  │  +     +      +    │
    │ INP     │  +     +      +    ║ SPC     │  +     +      +    │
    │ INPUT$  │  +     +      +    ║ SQR     │ s/d   s,d     d    │
    │ INSTR   │  +     +      +    ║ STICK   │  +     +      +    │
    │ INT     │  +     +      +    ║ STR$    │  +     +      +    │
    │ IOCTL$  │  -     +      +    ║ STRIG   │  +     +      +    │
    │ LBOUND  │  -     +      +    ║ STRING$ │  +     +      +    │
    │ LCASE$  │  -     +      +    ║ TAB     │  +     +      +    │
    │ LEFT$   │  +     +      +    ║ TAN     │ s/d   s,d     d    │
    │ LEN     │  *     +      *    ║ UBOUND  │  -     +      +    │
    │ LOC     │  +     +      +    ║ UCASE$  │  -     +      +    │
    │ LOF     │  +     +      +    ║ USRn    │  +     -      -    │
    │ LOG     │ s/d   s,d     d    ║ VAL     │  +     +      +    │
    │ LOG10   │  -     -      d    ║ VARPTR  │  *     +      +    │
    │ LOG2    │  -     -      d    ║ VARPTR$ │  +     +      +    │
    │ LPOS    │  *     +      +    ║ VARSEG  │  -     +      +    │
    └─────────┴────────────────────╨─────────┴────────────────────┘
      Примечания :
         s/d - вычисляется с одинарной или удвоенной точностью
               в зависимости от настройки системы при ее запуске ;
         d   - вычисляется только с удвоенной точностью ;
         s,d - точность вычислений зависит от типа аргумента ;
         *   - имеются отклонения в синтаксисе.



            1.4. Арифметические и логические выражения

         Арифметические выражения состоят из операндов числового ти-
    па (константы,переменные, функции), об'единенных знаками арифме-
    тических операций, перечень которых приведен в табл.6. Круглые
    скобки в арифметических выражениях используются для управления
    последовательностью выполнения действий.

                                             Таблица 6
            ┌───────────┬───────────────────────────────┐
            │   Знак    │   Выполняемое действие        │
            │ операции  │                               │
            ├───────────┼───────────────────────────────┤
            │    +      │  Сложение                     │
            │    -      │  Вычитание                    │
            │    *      │  Умножение                    │
            │    /      │  Деление                      │
            │    \      │  Целочисленное деление        │
            │   MOD     │  Нахождение остатка от деления│
            │    ^      │  Возведение в степень         │
            └───────────┴───────────────────────────────┘


         Результат операции деления (/) всегда является вещественным
    числом с одинарной или удвоенной точностью. Перед выполнением
    операций целочисленного деления (\) и нахождения остатка от деле-
    ния (MOD) оба операнда округляются до ближайшего целого. Резуль-
    тат этих двух операций всегда целочисленный.
         За исключением  высказанных выше соображений тип арифмети-
    ческого выражения определяется по типу наиболее "сложного" среди
    входящих в него операндов. Порядок возрастания "сложности" типов
    задается довольно естественной цепочкой : целочисленный короткий
    --> целочисленный длинный --> вещественный с одинарной точностью
    --> вещественный с удвоенной точностью. Возведение в целочислен-
    ную степень выполняется путем последовательных умножений (x^n =
    x * x * ... * x). Если показатель степени вещественного типа, то
    значение x^y находится по формуле EXP(y * LOG(x)). Поэтому вели-
    чина x должна быть положительной.
         Логические выражения, на базе которых формируются условия в
    операторах цикла (WHILE, DO - LOOP) и конструкциях типа IF,
    ELSEIF, образуются из логических операндов, принимающих одно из
    двух значений - ложь или истина. Элементарные логические операнды
    представляют собой результат сравнения двух числовых величин :

           A > B,  A >= B,  A < B,  A <= B,  A = B,  A <> B

    Сочетание <> обозначает сравнение на неравенство. Значение эле-
    ментарного логического операнда, равное "истине", в памяти ЭВМ
    ассоциируется с двухбайтовым целым числом, отличным от нуля.
    Значение "ложь" воспринимается как короткое целое число, равное
    нулю. Элементарные логические операнды могут об'единяться в выра-
    жения с помощью логических операций, перечень которых приведен
    в табл.7.

                                                   Таблица 7
         ┌─────────────┬────────────────────────────────────────┐
         │ Обозначение │      Результат выполнения операции     │
         │  операции   ├──────────┬─────────┬─────────┬─────────┤
         │             │  x=0 y=0 │ x=0 y=1 │ x=1 y=0 │ x=1 y=1 │
         ├─────────────┼──────────┼─────────┼─────────┼─────────┤
         │     NOT  x  │     1    │    1    │    0    │    0    │
         │  x  AND  y  │     0    │    0    │    0    │    1    │
         │  x   OR  y  │     0    │    1    │    1    │    1    │
         │  x  XOR  y  │     0    │    1    │    1    │    0    │
         │  x  EQV  y  │     1    │    0    │    0    │    1    │
         │  x  IMP  y  │     1    │    1    │    0    │    1    │
         └─────────────┴──────────┴─────────┴─────────┴─────────┘

         Вообще говоря, логические операции выполняются над каждой па-
    рой одноименных двоичных разрядов своих операндов. Поэтому их
    можно использовать для работы с двухбайтовыми логическими шкала-
    ми:

      N%  AND  8 =    1, если третий разряд в двоичном представлении
                         значения переменной N% равен 1;

      N%  AND  8 =     0, если указанный бит равен 0.

         Операндами логических операций могут быть и об'екты вещест-
    венного типа, но перед выполнением соответствующего действия зна-
    чения операндов округляются до ближайшего целого числа.



               1.5.Операторы и программные строки

          1.5.1.Декларативные и исполняемые операторы

         Операторы представляют собой синтаксические конструкции, из
    которых составляется программа. Как правило, такие конструкции
    начинаются с одного или двух служебных слов, определяющих харак-
    тер действия, предписываемого оператором. Действие это может но-
    сить как декларативный, так и исполнительный характер.
         В первом случае оно адресовано компилятору (интерпретатору)
    и должно быть обработано до начала выполнения программы. К декла-
    ративным действиям относятся операторы об'явления типов и струк-
    тур данных (CONST, DEFDBL, DEFINT, DEFLNG, DEFSNG, DEFSTR, DIM,
    OPTION BASE, TYPE), задания способов распределения данных в памя-
    ти ЭВМ (COMMON, LOCAL, MEMSET, SHARED, STATIC), формирования вну-
    треннего блока данных (DATA), описания нестандартных функций и
    подпрограмм (DECLARE, DEF FN, DEF SEG, FUNCTION, SUB), указания
    точек входа в подпрограммы обработки особых ситуаций (ON COM, ON
    ERROR, ON KEY, ON PLAY, ON STRIG, ON TIMER, ON PEN), включения
    комментариев (REM или апостроф).
         За исключением Quick-системы, где оператор REM может быть
    использован для набора псевдооператоров $STATIC, $DYNAMIC или
    $INCLUDE, текст комментария компилятором (интерпретатором) игно-
    рируется.
         На декларативные операторы распространяется довольно естест-
    венное правило по поводу их расположения в программе или в проце-
    дуре : сначала опиши (об'яви), а потом - используй. Поэтому они
    обычно должны находиться в начале программы (модуля). Указанное
    правило не относится к комментариям, которые могут встретиться
    в любом месте программы.
         Некоторое отклонение от этого правила связано и с оператором
    DIM при об'явлении динамических массивов. В этом случае оператор
    DIM превращается в исполняемый оператор, и описанные выше ограни-
    чения на него уже не распространяются.
         Исполняемые операторы предписывают действия, результат кото-
    рых проявится только во время выполнения программы. В этот период
    декларативные операторы уже не обрабатываются - они просто обхо-
    дятся.
         Служебное слово, определяющее характер действия операторов,
    среди программистов принято называть "именем оператора". Термин
    этот не очень точно передает смысл, так как соответствует понятию
    "идентификатор", которое по отношению к шифру действия вряд ли
    следовало применять. Идентификатором оператора скорее следовало
    называть его метку или номер соответствующей программной строки.
         Вслед за именем оператора располагается информация, исполь-
    зуемая при его обработке. Обычно ее называют "телом оператора",
    и завершается оно двоеточием, комментарием или неотображаемым сим-
    волом "возврат каретки". Обычно комментарий отделяется от текста
    оператора только апострофом, и после него может следовать лишь
    "возврат каретки".


           1.5.2.Непосредственные и отложенные действия

         Системы GW и Quick BASIC позволяют "превратить" ПЭВМ в ариф-
    мометр, который выполняет оператор сразу же после его набора. В
    GW-системе для этой цели программная строка набирается без номера
    и после нажатия клавиши Enter на экране появляется результат. В
    Quick-системе операторы выполняются немедленно, если они набира-
    ются в окне непосредственных вычислений (Immediate Window). Такой
    режим обработки операторов может быть использован как для организа-
    ции несложных одноразовых расчетов, для которых нецелесообразно
    составлять программу, так и для отладки текущей программы, выполне-
    ние которой тем или иным способом прервано. С помощью непосред-
    ственно выполняемых операторов можно отобразить на экране или из-
    менить значения любых переменных, изменить режим работы дисплея
    и т.п.
         Текст операторов, непосредственно выполняемых GW-системой, в
    памяти ЭВМ не сохраняется. Поэтому при повторении какого-либо ранее
    проведенного вычисления текст программной строки придется набирать
    заново.
         Непосредственный режим не распространяется на декларативные
    операторы. Да и не любой исполняемый оператор может быть выполнен
    таким образом. К числу таких исключений относятся операторы цикла
    WHILE - WEND и любые другие блочные конструкции типа SELECT - END
    SELECT, IF - END IF, для реализации которых пришлось бы набрать не-
    сколько программных строк.
         Операторы, которые набираются в GW BASIC'e с номерами строк
    или вводятся в Quick- и Turbo-системах в окне редактирования,
    участвуют в формировании текста исходной программы. Выполнение
    последней может быть отложено на неопределенно долгий срок, ко-
    нечно, при условии, что текст набранной программы будет сохранен.
    Отложенные таким образом действия можно выполнить в любой момент,
    запустив тем или иным способом вызванный программный файл. Их мож-
    но многократно исполнить без повторного перенабора текста программы.

                1.5.3.Идентификация программных строк

         Строки с отложенным выполнением мы будем называть програм-
    мными. Каждая такая строка может содержать один или несколько опе-
    раторов, разделяемых двоеточием. Последний оператор в программной
    строке завершается символом "возврат каретки", включаемым в состав
    оператора в момент нажатия клавиши Enter. Особо внимательно надо
    набирать составные программные строки, содержащие несколько опера-
    торов и включающие комментарии. Правее комментария нельзя распола-
    гать какие-либо другие операторы. Следует воздерживаться от об'е-
    динения в одной строке декларативных и исполняемых операторов.
         В GW-системе любая программная строка начинается с целочис-
    ленного номера, принадлежащего диапазону [0, 65529]. Нулевой но-
    мер строки используется для специальных целей (например, для бло-
    кировки перхода на подпрограмму обработки особых ситуаций) и поэ-
    тому для нумерации программных строк обычно не используется.
         Системы Quick BASIC и Turbo BASIC не требуют обязательной
    нумерации программных строк, хотя "старые" Бейсик-программы об-
    рабатываются в этих системах без каких-либо изменений. Кроме тра-
    диционных номеров строк в новых системах допускается применение
    меток, характерных для развитых алгоритмических языков.
         В качестве меток могут выступать любые идентификаторы, содер-
    жащие до 40 символов, и целые числа. В строке, которая начинается
    с метки, может находиться только комментарий. Таким образом, метка
    идентифицирует программную строку, расположенную следом :

       MaxA.B :
                LET Y = B : REM возможно, максимум = В
       055:
                IF A > B THEN  Y = A
       Print.MaxA.B :
                PRINT "A="; A, "B="; B, "Max(A,B)="; Y

         Метка отделяется от оператора двоеточием и, в этом смысле,
    целочисленная метка мало чем отличается от традиционного номера
    строки. Нужно только представить себе, что программная строка на-
    чинается с пустого оператора и имеет продолжение. Двоеточие может
    следовать как сразу после метки, так и спустя несколько пробелов.
         Программная строка может иметь несколько абсолютно равноправ-
    ных меток, но каждая из них должна располагаться в отдельной стро-
    ке :

             M1 :
             M2 :
                 PRINT USING "Максимум = ###.##" ; Y

         В связи с появлением меток все операторы передачи управления
    в системах Quick и Turbo BASIC в качестве точек перехода наряду
    с прежними номерами строк допускают использование меток. Мнемо-
    ника символьных меток выгодно отличается от лишенных какого-либо
    содержания номеров строк. Конечно, при этом не следует злоупотреб-
    лять метками типа M1, M2, ...,M999.
         Максимальная длина программной строки достаточно велика (GW -
    255, Turbo - 249, Quick - 255). Однако при наборе строк, длина ко-
    торых превышает 80 символов, пользователь испытывает неудобства
    из-за того, что не видит всю строку целиком. Кроме того, длинные
    строки могут быть обрезаны при выводе на принтер. В Turbo BASIC'е
    имеется возможность осуществить "перенос" программной строки на
    следующую строку экрана дисплея за счет использования символа "под-
    черк".