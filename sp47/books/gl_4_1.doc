                  4.ОБРАБОТКА ТЕКСТОВОЙ ИНФОРМАЦИИ

            4.1.Символьные константы, переменные и массивы

         Основные сведения о символьных об'ектах и их идентификации
    уже приводились в разделе 1.2, однако они были разбросаны там по
    нескольким параграфам. Поэтому напомним вкратце необходимую инфор-
    мацию.
         Символьные константы, используемые в качестве литеральных
    констант в тексте исходной программы, представляют собой последо-
    вательность произвольных знаков алфавита, окаймляемую двойными
    кавычками. В списке операторов DATA текстовая константа может не
    заключаться в кавычки, если она не содержит запятых или концевых
    пробелов.
         Версия Quick BASIC допускает употребление именованных конс-
    тант символьного типа :

                 CONST  DATE1$ = "17 июля 1935 года"

    Аналогичного эффекта можно добиться, используя внутренние нестан-
    дартные функции без аргументов :

                        DEF   FNMaxX% = 639

         Идентификаторы текстовых переменных распознаются либо по по-
    следнему символу имени (DATE1$), либо по первой букве (DATE2,EVA,
    QUICK), если эта буква была указана в списке оператора DEFSTR :

                        DEFSTR   D-F, Q

         Quick BASIC позволяет вводить об'екты символьного типа с по-
    мощью описателя AS STRING, который может встретиться в одном из
    декларативных операторов COMMON, DECLARE, DEF, DIM, FUNCTION, SHA-
    RED, STATIC, SUB, TYPE, REDIM. Например :

         DIM  ALPHA(20) AS STRING, BETA AS STRING  *40

         TYPE  NOTEBOOK
               name    AS STRING *20
               phone   AS STRING *10
               address AS STRING *50
         END TYPE

         Интересной особенностью оператора DIM (REDIM) является воз-
    можность об'явления не только символьных массивов, но и скалярных
    переменных. Указание о длине символьного об'екта после описателя
    AS STRING причисляет его к разряду статических.


         4.2.Формирование и изменение значений переменных
                         символьного типа

         Перед запуском задачи на счет всем переменным символьного
    типа присваивается значение "пусто". Для формирования заранее из-
    вестных значений в символьных переменных используются те же самые
    приемы, что и для числовых переменных - извлечение соответствующих
    величин из буфера клавиатуры или из файла данных (операторы INPUT,
    LINE INPUT), считывание предварительно заготовленных текстовых кон-
    стант (операторы DATA, READ, RESTORE).
         Текстовые значения, формируемые в процессе выполнения прграм-
    мы, можно занести в символьную переменную с помощью обычного (LET)
    или специального (LSET, RSET) оператора присваивания. Оператором
    MID$ можно воспользоваться для обновления части символов прежнего
    значения переменной.

                4.2.1.Использование внутреннего блока данных

         Внутренний блок данных, формируемый с помощью операторов DATA
    и представляющий собой потоковый набор значений с последовательным
    доступом, может содержать среди своих элементов как числовые, так
    и текстовые константы. На порядок их чередования в блоке данных
    никакого ограничения не накладывается. Забота о соответствии типов
    переменной и извлекаемого значения возлагается на программиста.
    При этом надо учитывать тот факт, что текстовые константы в спис-
    ке операторов DATA могут не заключаться в кавычки. Поэтому число-
    вые константы можно рассматривать как последовательность символов
    и их значения допустимо извлекать в переменные символьного типа :

                   DATA    123, 456
                   .................
                   READ     A$, B$
             или
                   DATA    "123","456"
                   ....................
                   READ     A$, B$

         Каких-либо других особенностей, связанных с употреблением
    символьных констант в операторах DATA, по сравнению с обычными
    числовыми блоками данных нет.


            4.2.2.Ввод символьных значений по запросу программы

         Ввод символьных данных с клавиатуры может быть реализован по
    оператору INPUT (см. раздел 3.1.2), если в его списке заданы имена
    текстовых переменных :

              INPUT  [;] ["text" {;|,}]  V1$, V2$, ...

         Технология ввода при этом ничем не отличается от процесса на-
    бора числовых значений, описанного в разделе 3.1.2. Текстовые кон-
    станты, вводимые по оператору INPUT, можно набирать так же, как и
    в списке оператора DATA - с кавычками или без кавычек. В последнем
    случае символьные значения не могут содержать пробелов и запятых,
    рассматриваемых при вводе как разделители.
         Вторым оператором, с помощью которого программа может выдать
    запрос на ввод символьного значения с клавиатуры или из последова-
    тельного файла данных, является LINE INPUT :

                   LINE INPUT  [;] ["text";] V$
                   LINE INPUT  #n, V$

    Он отличается от оператора INPUT тем, что содержит в своем теле
    имя единственной переменной V$, в которую вводятся все набираемые
    символы до появления управляющего кода "возврат каретки". Среди
    них могут быть и пробелы, и запятые.
         Оператор LINE INPUT не выдает приглашение ко вводу в виде во-
    просительного знака, но все остальные атрибуты (точка с запятой в
    начале, текстовая подсказка) имеют тот же смысл, что и в операторе
    INPUT.
         Ввод данных с клавиатуры по операторам INPUT и LINE INPUT со-
    провождается отображением поступающих значений на экране дисплея.
    Имеется возможность осуществить ввод символьных данных и без пере-
    носа набираемых кодов в видеопамять, то-есть без появления соот-
    ветствующих знаков на экране. Потребность в таком скрытом вводе
    может возникнуть при наборе секретной информации (пароли доступа)
    или в игровых программах, где экран занят изображением какой-то
    сцены.
         Если вводимый текст должен содержать фиксированное (k) число
    символов, то ввод без их отображения осуществляется с помощью фун-
    кции INPUT$ :

                     A$ = INPUT$ (k [,[#] nf])

    Второй необязательный аргумент этой функции задается в том случае,
    когда запрашиваемые k символов извлекаются из файла с номером nf.
         Для ввода символьного значения, соответствующего коду одной
    нажатой клавиши, без отображения знака на экране можно воспользо-
    ваться служебной переменной INKEY$ :

               10   A$ = INKEY$  :  IF A$ = ""  THEN  10

    В приведенном примере цикл ввода продолжается до тех пор, пока
    пользователь не нажмет какую-либо клавишу.
         С помощью переменной INKEY$ можно опознать не только одно-
    байтовый код любого воспроизводимого символа алфавита, но и двух-
    байтовые коды, появляющиеся в результате нажатия большинства уп-
    равляющих клавиш или их сочетаний. Исключение составляют клавиша
    Print Screen и комбинации Ctrl+Break, Ctrl+NumLock, Ctrl+Alt+Del,
    Ctrl+Print Screen, коды которых программе недоступны.
         При работе с функцией INPUT$ и служебной переменной INKEY$
    следует помнить, что ввод может завершиться и без ожидания ответа
    пользователя. Дело в том, что клавиатура снабжена буфером и, если
    до момента выполнения оператора ввода там находились невостребован-
    ные символы, то они будут считаны. Поэтому не следует просто так
    нажимать клавиши во время выполнения программы, ибо поступающая от
    них информация запоминается в буфере и может неправильно интерпре-
    тироваться последующими операторами ввода.
         О состоянии буфера ввода в процессе выполнения программы мож-
    но узнать по служебной переменной INSTAT, значение которой равно
    0 ("ложь") при пустом буфере или -1 ("истина") при наличии в нем
    хотя бы одного символа. Если буфер клавиатуры не пуст, то находя-
    щиеся в нем коды символов извлекаются в порядке их поступления
    (первым вошел - первым вышел).


           4.2.3.Символьные выражения и стандартные процедуры
                     обработки текстовой информации

         Изменение значения символьной переменной с помощью операторов
    LET, READ или INPUT  изменяет и ее длину. Под длиной символьного
    об'екта понимают количество символов, содержащихся в его значении.
         Опрос длины производится с помощью функции LEN :

                 10  PRINT  A$,  LEN (A$)
                 20  A$ = "BASIC"  :   PRINT  A$,  LEN (A$)
                 30  A$ = "Turbo BASIC"  :  PRINT  A$,  LEN (A$)
                 RUN
                               0
                 BASIC         5
                 Turbo BASIC   11

         Максимальная длина текстовой переменной не может превышать
    255 символов в системе GW BASIC и 32767 символов в Turbo- и Quick-
    системах.
         Аргументом функции LEN может быть произвольное выражение сим-
    вольного типа, которое составляется из текстовых операндов, об'е-
    диняемых знаком операции конкатенации (сцепления) :

                          "Turbo" + A$

    Операция конкатенации сводится к приписыванию значения очередного
    "слагаемого" в хвост к предыдущей строке.
         В качестве операндов символьного выражения наряду с текстовы-
    ми константами и переменными могут выступать стандартные или не-
    стандартные функции символьного типа. Довольно большую группу фун-
    кций такого типа составляют процедуры преобразования числовых дан-
    ных в символьный формат, описанные в разделе 1.2.6.
         Вторую группу процедур, создающих символьные значения, пред-
    ставляют стандартные функции, приведенные в табл.10.

                                                      Таблица 10
     ┌────────────────────┬──────────────────────────────────────────
     │ Наименование       │              Значение
     │   функции          │               функции
     ├────────────────────┼───────────────────────────────────────────
     │ ENVIRON$ (n)       │ Строка, представляющая значение n-го
     │                    │ параметра из таблицы окружения опера-
     │                    │ ционной системы MS DOS, установленного
     │                    │ по директиве SET или оператору ENVIRON
     │                    │
     │ ENVIRON$ ("ss...s")│ Аналогичная строка, выдаваемая по иден-
     │                    │ тификатору системного параметра
     │                    │
     │ INPUT$ (k[,[#]nf]) │ Строка, содержащая k символов, считанных
     │                    │ из буфера клавиатуры или из файла с номе-
     │                    │ ром nf
     │                    │
     │ IOCTL$ ([#]nu)     │ Строка с управляющими данными, поступив-
     │                    │ шая от драйвера устройства с номером nu
     │                    │
     │ LCASE$ (e$)        │ Строка, полученная в результате замены
     │                    │ больших букв значения аргумента на малые
     │                    │
     │ LEFT$ (e$,n)       │ Строка, полученная в результате выделения
     │                    │ первых n символов из значения аргумента
     │                    │ e$ (левая подстрока)
     │                    │
     │ LTRIM$ (e$)        │ Строка, полученная из значения аргумента
     │                    │ путем удаления лидирующих пробелов (отсе-
     │                    │ чение слева)
     │                    │
     │ MID$ (e$,i[,n])    │ Строка, полученная из значения аргумента
     │                    │ e$ путем выделения n символов, начиная с
     │                    │ i-того (центральная подстрока). Если ар-
     │                    │ гумент n не задан, то выделяются все сим-
     │                    │ волы, начиная с i-того
     │                    │
     │ RIGHT$ (e$,n)      │ Строка, полученная в результате выделения
     │                    │ последних n символов из значения аргумента
     │                    │ e$ (правая подстрока)
     │                    │
     │ RTRIM$ (e$)        │ Строка, полученная из значения аргумента
     │                    │ путем удаления конечных пробелов (отсече-
     │                    │ ние справа)
     │                    │
     │ SPACE$ (n)         │ Строка, состоящая из n пробелов
     │                    │
     │ STRING$ (n,cod)    │ Строка, состоящая из n одинаковых символов
     │                    │ с кодом cod (0 <= cod <= 255)
     │                    │
     │ STRING$ (n,e$)     │ Аналогичная строка, в которой n раз повто-
     │                    │ ряется первый символ значения e$
     │                    │
     │ UCASE$ (e$)        │ Строка, полученная в результате замены
     │                    │ малых букв значения аргумента на большие
     │                    │
     │ VARPTR$ (V$)       │ Строка, представляющая адрес переменной
     │                    │ V$ в символьном формате, используемом в
     │                    │ операторах DRAW и PLAY
     └────────────────────┴───────────────────────────────────────────

         Функция MID$, используемая для выделения внутренней подстроки,
    может применяться и как оператор для замены внутренней подстроки
    новым значением. В этом случае в качестве первого аргумента может
    выступать только идентификатор символьной переменной :

                 A$ = "Turbo BASIC"
                 MID$ (A$,1,5) = "Quick"

    Длина заменяемой подстроки при таком присвоении не меняется. Если
    заменяющее значение имеет меньшую длину, то недостающие символы
    справа дополняются пробелами. В противном случае используются пер-
    вые n символов замещающего выражения.
         Кроме стандартных функций, перечисленных в табл.5 и 10,
    в качестве операндов символьных выражений могут выступать служеб-
    ные переменные текстового типа (см. табл.11). Некоторые из них
    доступны только для чтения (COMMAND$, ERDEV$, INKEY$), значения
    других (DATE$, TIME$) можно изменить.

                                                   Таблица 11
     ┌───────────────┬───────────────────────────────────────────────
     │ Наименование  │              Значение
     │   переменной  │             переменной
     ├───────────────┼───────────────────────────────────────────────
     │ COMMAND$      │ Текст командной строки, использованной для
     │               │ запуска программы под управлением MS DOS
     │               │
     │ DATE$         │ Текущая дата в одном из допустимых форматов
     │               │ ("01/31/90", "01/31/1990", "01-31-90" или
     │               │ "01-31-1990")
     │               │
     │ ERDEV$        │ Идентификатор ошибочно сработавшего устройства
     │               │
     │ INKEY$        │ Одно- или двухбайтовое значение, соответствую-
     │               │ щее коду нажатой клавиши
     │               │
     │ TIME$         │ Текущее время в формате "чч:мм:cc"
     └───────────────┴─────────────────────────────────────────────────

         Идентификаторы переменных символьного типа могут использовать-
    ся в левой части обычного (LET) или специальных операторов присва-
    ивания :

                     LSET   V1$ = e1$
                     RSET   V2$ = e2$

    Переменные V1$ и V2$ в этом случае представляют символьные поля
    фиксированной длины, расположенные в буфере обмена с файлом прямо-
    го доступа. Специфика присвоения значений таким переменным заклю-
    чается в том, что оно не изменяет длину переменной и осуществляет
    перенос нового значения на указанное поле с прижимом к его левой
    (LSET) или правой (RSET) границе. Если присваиваемое значение име-
    ет меньшую длину, то незадействованные позиции символьного поля
    заполняются пробелами.
         Имена символьных переменных могут встретиться и в теле опера-
    тора SWAP, осуществляющего обмен значениями между двумя перемен-
    ными :

                      SWAP  A$, B$

         Подобно числовым выражениям символьные значения можно сравни-
    вать между собой :

                      IF  A$ = "YES"  THEN  200

    Операции отношения над текстовыми операндами базируются на посим-
    вольном сравнении их числовых кодов. Поэтому для правильной интер-
    претации результатов сравнения программист должен знать последова-
    тельность расположения сравниваемых символов в таблице ASCII. На-
    пример,числовые коды латинских букв возрастают в соответствии с их
    размещением по алфавиту ( ASC("A")=65, ASC("B")=66, ...). Поэтому
    буква B "больше" буквы A, и этот факт может быть использован для
    сортировки текстовых значений в лексикографическом порядке. К со-
    жалению, расположение русских букв в таблицах ASCII не всегда соот-
    ветствует их порядку в нашем алфавите, и для сортировки русских
    слов иногда приходится прибегать к специальным приемам.
         Для анализа текстовой информации очень полезна функция INSTR :

                    N = INSTR ([i,] e1$,e2$)

    Она обеспечивает поиск вхождения значения e2$ в значение e1$. Этот
    поиск начинается либо с первой, либо с i-той позиции значения e1$.
    Если процедура поиска завершена успешно и в тексте e1$ найден фра-
    гмент e2$, то значением функции INSTR является номер позиции, на-
    чиная с которой обнаружено первое вхождение. Для поиска следующего
    вхождения можно продвинуть указатель начала поиска и повторно об-
    ратиться к функции INSTR. Если анализ вхождения приводит к отрица-
    тельному результату, то значение функции INSTR равно нулю.
         В качестве примера эффективного использования функции INSTR
    приведем анализ на допустимость односимвольного ответа пользовате-
    ля :

          100 INPUT "Будете продолжать - Y/Д/Н/N"; OTBET$
          110 IF INSTR ("YyДдНнNn", OTBET$) = 0  THEN 100



                      4.3.Вывод текстовой информации

         Символьные об'екты (константы, переменные, выражения) могут
    выступать в качестве элементов выводного списка оператора PRINT.
    При этом в составе их значений могут встретиться не только знаки
    алфавита, но и управляющие символы, а также коды псевдографики.
    Как правило, для их подключения к символьному значению использует-
    ся стандартная функция CHR$ :

                  PRINT   "Привет !" + CHR$ (7)

    Вывод приветствия в данном случае будет сопровождаться кратковре-
    менным звуковым сигналом.
         Запятая после символьного об'екта в теле оператора PRINT вы-
    зывает перемещение указателя выводной строки в начало следующей
    зоны. Точка с запятой, используемая в качестве разделителя после
    символьного об'екта, дополнительного сдвига указателя не вызывает.
    Очередной элемент выводного списка при этом отображается вплотную
    к предшествующему значению.
         Для вывода символьных данных с использованием оператора PRINT
    USING формат выводной строки должен включать односимвольные описа-
    тели "!" , "&" или n-символьные шаблоны текстовых полей вида
    "\     \" :

          A$ = "Quick BASIC"
          PRINT USING "! & \   \"; A$, A$, A$
          ...................................
          Q Quck BASIC Quick


