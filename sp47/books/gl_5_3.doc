            5.5.Взаимодействие с активными внешними устройствами

         Работа с активными внешними устройствами базируется на аппа-
    рате событий и использует механизм прерываний. Идея заключается в
    том, что в момент возникновения события, который программе заранее
    не известен, генерируется сигнал прерывания. Работающая программа
    располагает тремя возможными вариантами поведения. Она может проиг-
    норировать возникшее событие, если заранее позаботилась об установ-
    ке режима блокировки соответствующего сигнала. Во-вторых, программа
    может запомнить факт появления события, но отложить (заморозить)
    его обработку в связи с тем, что занята выполнением более срочных
    дел. Наконец, работа программы может быть немедленно прервана с
    целью передачи управления пользовательской или системной подпро-
    грамме обработки неотложного события.
         Любая из этих линий поведения программируется с помощью од-
    ной из модификаций оператора выбора способа реакции на событие :

       тип события ON   - разрешение немедленного прерывания в момент
                          возникновения события или перехода на под-
                          программу ранее замороженного прерывания;

       тип события OFF  - блокировка реакции на прерывание;

       тип события STOP - замораживание реакции на прерывание.

         Назначение точки входа (метки или номера строки N) в пользо-
    вательскую подпрограмму обработки прерывания и установление связи
    между этой процедурой и типом события выполняется одной из разно-
    видностей оператора ON :

                       ON  тип события  GOSUB  N

    Естественно, что такое назначение должно состояться заблаговремен-
    но, и обычно такие операторы помещаются в начало программы. Вклю-
    чение режима слежения за определенным событием означает, что после
    выполнения каждого оператора программы будет выполняться проверка
    соответствующего системного признака. Таким образом, возникновение
    физического сигнала прерывания не прервет текущий оператор и даст
    ему доработать до конца.
         Во время работы подпрограммы может появиться необходимость в
    отмене или переназначении ранее об'явленной процедуры обработки
    прерывания. Выполняется это повторным назначением с указанием ну-
    левой строки в качестве точки входа. Например :

                        ON  KEY  GOSUB  0

         Еще одна деталь общего характера связана с завершением рабо-
    ты подпрограммы обработки прерывания. Выход из нее осуществляется
    либо по безадресному оператору RETURN, либо по оператору RETURN с
    указанием конкретной точки возврата. В первом случае работа прер-
    ванной программы продолжается с той точки, где ее застигло возник-
    шее событие. Во втором случае выход из подпрограммы обработки пре-
    рывания происходит в заранее обусловленную точку.
         Ниже обсуждаются операторы, функции и системные переменные,
    связанные с обработкой различных событий.

                            5.5.1.Клавиатура

         Операции ввода обычных данных с клавиатуры, выполняемые по
    запросу программы и сопровождающиеся как отображением набираемой
    пользователем информации, так и блокировкой эхо-сигнала при набо-
    ре специальных сообщений, ранее обсуждались в разделах 3.1.2 и
    4.1.2. Однако клавиатура современного компьютера, содержащая 101
    или 102 клавиши, наряду с отображаемыми и управляющими кодами по-
    зволяет работать со специальными - функциональными или программи-
    руемыми клавишами.
         Специфика функциональных клавиш с обозначениями F1, F2,...
    заключается в том, что нажатие любой из них сопровождается выда-
    чей в ЭВМ особого сигнала прерывания. Это событие перехватывается
    системной программой и может быть использовано для реализации не-
    которых типовых процедур. Например, в GW BASIC'е за каждой из пер-
    вых десяти функциональных клавиш закреплена определенная строка,
    воспринимаемая как директива или ее начальный фрагмент. При нажа-
    тии такой клавиши закрепленный за ней текст появляется в текущей
    строке дисплея и, если он завершается управляющим кодом &H0D
    ("возврат каретки"), соответствующая директива начинает немедлен-
    но выполняться.
         Запуск GW-системы сопровождается демонстрацией в служебной
    строке экрана тех текстов, которые по умолчанию закреплены за кла-
    вишами F1 - F10. Можно увидеть эти тексты и в более удобном (пол-
    ном) формате, если выполнить оператор (директиву) KEY LIST.
         Служебная строка дисплея может быть освобождена системой и
    передана задаче для использования полного экрана после выполнения
    оператора KEY OFF. Восстановление статуса служебной строки осуще-
    ствляется оператором KEY ON.
         Рассматриваемые BASIC-системы предоставляют пользователю воз-
    можность закрепить за указанной функциональной клавишей новый текст,
    содержащий не более 15 символов :

                   KEY  n, "новый текст"

    Здесь  n - номер функциональной клавиши, который может принадле-
    жать диапазону 1-20 (GW BASIC), 1-10 или 1-12 (Turbo BASIC),
    [1-10,30,31] (Quick BASIC). Под номерами 30 и 31 в Quick-системе
    выступают клавиши F11 и F12.
         Закрепление за функциональными клавишами часто повторяющихся
    фрагментов может ускорить процедуру набора данных.
         Описанное выше свойство функциональных клавиш следует отнести
    скорее к разряду пассивных, так как оно не связано с вмешательст-
    вом человека в процесс работы программы. Однако, если функциональ-
    ная клавиша нажимается во время выполнения программы, то закреплен-
    ный за ней текст игнорируется. Вместо этого система имитирует ак-
    тивное событие, характеризуемое номером n нажатой клавиши. Событие
    это может быть заблаговременно предусмотрено в программе :

                  KEY (n)  { ON | OFF | STOP }
                  .............................
                  ON  KEY (n)   GOSUB   N

    Номер n в этих операторах должен принадлежать диапазону 1-20 (GW),
    [1-25,28,29] (Turbo) или [1-25,30,31] (Quick). В связи с тем, что
    физическое количество функциональных клавиш обычно не превышает
    10 - 12, их набор искусственно расширяют путем подключения клавиш
    управления курсором (n=11 - сдвиг вверх, n=12 - сдвиг влево, n=13
    - сдвиг вправо, n=14 - сдвиг вниз) и комбинацией двух одновременно
    нажатых клавиш. Настоящие клавиши F11 и F12 выступают под номерами
    28,29 (Turbo) или 30,31 (Quick). Двухсимвольные функциональные
    "клавиши" с номерами 15-20 (GW) или 15-25 (Quick, Turbo) относят-
    ся к разряду определяемых пользователем. Одним из таких символов
    должен быть управляющий код из числа клавиш CapsLock (код - &H40),
    NumLock (код - &H20), Alt (код - &H08), Ctrl (код - &H04), левый
    Shift (код - &H01), правый Shift (код - &H02). В качестве второго
    символа в паре с первой управляющей клавишей может выступать прак-
    тически любая другая клавиша по усмотрению пользователя. Об'явле-
    ние функциональной пары с номером n (n > 14) выполняется с помощью
    следующего оператора :

              KEY  n, CHR$(HexCode) + CHR$(ScanCode)

    Здесь  HexCode - шестнадцатеричный код одной из выше перечисленных
    управляющих клавиш, а ScanCode - внутренний код второй клавиши. Не-
    которое неудобство состоит в том, что скан-коды символов не совпа-
    дают с их кодировкой в таблице ASCII, и приходится иметь дело с еще
    одной кодировочной таблицей, содержимое которой зависит от типа ис-
    пользуемой клавиатуры. Для большинства современных 101/102-клавиа-
    тур внутренняя нумерация клавиш ведется слева направо по рядам
    (Esc - 1, !/1 - 2, @/2 - 3,... возврат - 14, Tab - 15, Q - 16,
    W - 17, E - 18, R - 19, ...).

                          5.5.2.Световое перо

         К числу дополнительных устройств, которыми изредка комплекту-
    ются персональные ЭВМ, относится световое перо (СП). Оно использу-
    ется для идентификации знакоместа или пикселя экрана, к которому
    пользователь подвел кончик пера. На кончике пера находится миниа-
    тюрная линза и светочувствительный элемент, фиксирующий момент вре-
    мени, в который под пером оказался луч развертки. По разнице между
    временем фиксации луча и моментом начала развертки контроллер дисп-
    лея вычисляет координаты местоположения светового пера.
         Рядом с кончиком пера находится микровыключатель, состояние
    которого можно опросить через аппаратуру контроллера. Нажатие вы-
    ключателя приводит к активизации пера. Для фиксации точки на экра-
    не к ней подводят перо практически вплотную к дисплею и нажимают
    переключатель.
         Опрос состояния светового пера можно выполнить по прерыванию
    INT 10h (функция AH=4), к которому можно обратиться как в момент
    активизации пера (инициатива принадлежит пользователю), так и в
    любой другой момент времени по инициативе программы. Последняя
    возможность реализуется функцией PEN(n), перечень значений которой
    зависит от аргумента и приведен в табл.24.

                                                   Таблица 24
     ┌───┬────────┬──────────────────────────────────────────────────┐
     │ n │ PEN(n) │                Пояснение                         │
     ├───┼────────┼──────────────────────────────────────────────────┤
     │ 0 │    0   │ Микровыключатель нажимался хотя бы раз с момента │
     │   │        │ последнего опроса состояния СП                   │
     │   │   -1   │ Микровыключатель больше не нажимался             │
     │   │        │                                                  │
     │ 1 │  Xold  │ Старая координата x (в пикселях) положения СП в  │
     │   │        │ момент его опроса при предшествующей активизации │
     │ 2 │  Yold  │ Старая координата y                              │
     │   │        │                                                  │
     │ 3 │    0   │ В данный момент микровыключатель не нажат        │
     │   │   -1   │ В данный момент микровыключатель нажат           │
     │   │        │                                                  │
     │ 4 │  Xnew  │ Новая координата x (в пикселях) текущего         │
     │   │        │ положения СП                                     │
     │ 5 │  Ynew  │ Новая координата y                               │
     │   │        │                                                  │
     │ 6 │  Rold  │ Старый номер строки (от 1 до 24) положения СП в  │
     │   │        │ момент его опроса при предшествующей активизации │
     │ 7 │  Cold  │ Старый номер столбца (от 1 до 40 или 80)         │
     │   │        │                                                  │
     │ 8 │  Rnew  │ Номер строки текущего положения СП               │
     │ 9 │  Cnew  │ Номер столбца текущего положения СП              │
     └───┴────────┴──────────────────────────────────────────────────┘

         Для анализа состояния пера в момент его активизации программа
    должна разрешить реакцию на такое событие (PEN ON) и предусмотреть
    программу его обработки :

                      ON  PEN  GOSUB  1500

         Разрешение прерывания со стороны СП замедляет процесс выполне-
    ния программы, так как система должна периодически проводить опрос
    сотояния пера. На тех участках работы программы, где статус СП
    можно проигнорировать, контроль за состоянием пера отключают (PEN
    OFF) или замораживают (PEN STOP).
         В качестве примера работы с СП приведем фрагмент программы,
    в котором производится отслеживание положения пера в момент его
    активизации и фиксация этого места на экране точками красного
    цвета :

             10  ON  PEN  GOSUB  1000
             20  PEN  ON
           .................................
           1000  X = PEN (4)  :  Y = PEN (5)
           1010  PSET (X,Y), 4
           1020  RETURN

         После вывода очередной "активной" точки программа продолжает
    свою работу с прерванного места.

                      5.5.3.Игровые пульты (джойстики)

         Игровой порт с адресом 201h может обслуживать одновременно
    два двухкоординатных рычажковых пульта ("джойстики") или четыре
    однокоординатных игровых устройства (рычажковые или осевые приводы
    потенциометров, снабженных аналого-цифровыми преобразователями).
         Остановимся несколько подробнее на джойстиках в связи с ориен-
    тацией на них в рассматриваемых версиях Бейсика. Конструктивно
    джойстик представляет собой рычаг на подставке, обладающий двумя
    степенями свободы и приводящий в действие два связанных с ним дат-
    чика координат x и y. На подставке и в верхней части рукоятки джой-
    стика находятся кнопки (клавиши), количество которых зависит от мо-
    дели. Обычно все кнопки разделяются на две группы, так что нажатие
    любой кнопки из группы вызывает абсолютно одинаковый эффект. Чело-
    век нажимает ту кнопку, которая для него удобнее расположена.
         Для того, чтобы различать джойстики и их кнопки используем
    следующую мнемонику - сами рычаги будем обозначать буквами A или B,
    а связанные с ними кнопки через A1 и A2 (первая и вторая кнопки джой-
    стика A), B1 и B2 (кнопки джойстика B).
         Игровой порт обеспечивает опрос координат X и Y, пропорциональ-
    ных отклонению рычага от нейтрального положения, и состояния кнопок
    любого джойстика. Средствами операционной системы эти процедуры
    осуществляются путем прерывания INT 15h с входной информацией AH=
    84h и DX=0 (опрос состояния клавиш) или DX=1 (опрос координат). В
    Бейсике для управления джойстиками используются функции STICK(n),
    STRIG(n), а также операторы  STRIG ON | OFF | STOP   и  ON STRIG(n)
    GOSUB  N.
         Функция STICK(n) в зависимости от аргумента выдает координату
    x джойстиков A (при n=0) и B (при n=2) или y джойстиков A (при n=1)
    и B (при n=3). Так как конструкции джойстиков достаточно разнообраз-
    ны и входящие в их состав преобразователи аналог-код имеют различное
    разрешение, то игровой пульт целесообразно протестировать на диапа-
    зоны (Xmin, Xmax) и (Ymin, Ymax).
         Выполнить это поможет программа, заимствованная из книги Р.
    Журдена "Справочник программиста IBM PC", перевод которой готовится
    в издательстве "Мир". Единственная хитрость, подмеченная автором
    этой программы, заключается в том, что получению любой координаты
    STICK(n) для n=1,2 или 3 обязательно должно предшествовать холостое
    обращение с нулевым аргументом. Оно обеспечивает сброс прежних пока-
    заний координат и выдачу их истинных текущих значений.

      110  STRIG  ON  : 'Разрешили прерывания от нажатия клавиш
      120  V = STRIG(0) : 'Очистка старых показаний
      130  PRINT "Нажми кнопку 1 в крайнем левом положении"
      140  Xmin = STICK(0)
      150  IF STRIG(0) = 0  THEN 140 : ' Повтор до нажатия
      155  'Организуем временную задержку
      160  STRIG OFF : FOR N=1 TO 1000 : NEXT : STRIG ON
      170  PRINT "Нажми кнопку 1 в крайнем правом положении"
      180  Xmax = STICK(0)
      190  IF STRIG(0) = 0  THEN 180 : ' Повтор до нажатия
      200  STRIG OFF : FOR N=1 TO 1000 : NEXT : STRIG ON
      210  PRINT "Нажми кнопку 1 в крайнем верхнем положении"
      220  V = STICK(0) : Ymin = STICK(1)
      230  IF STRIG(0) = 0  THEN 220 : ' Повтор до нажатия
      240  STRIG OFF : FOR N=1 TO 1000 : NEXT : STRIG ON
      250  PRINT "Нажми кнопку 1 в крайнем нижнем положении"
      260  V = STICK(0) : Ymax = STICK(1)
      270  IF STRIG(0) = 0  THEN 260 : ' Повтор до нажатия
      280  STRIG OFF : 'Запретили отвлекаться
      290  'Вычисляем масштабные коэффициенты Kx и Ky
      300  Kx = 320 / (Xmax - Xmin)
      310  Ky = 200 / (Ymax - Ymin)
      320  'Отслеживаем точку и рисуем траекторию перемещения
      330  X = STICK(0) : Y = STICK(1)
      340  X = (X - Xmin) * Kx :  Y = (Y - Ymin) * Ky
      350  PSET (X,Y)  :  GOTO 330

              5.5.4.Таймер и временные прерывания

         ПЭВМ типа IBM PC располагают двумя (XT) или тремя (AT) источ-
    никами , связанными с временными измерениями.
         Первый из них - это тактовый генератор системных часов, импуль-
    сы которого проходя через специальную схему делителя частоты преоб-
    разуются в сигналы отсчета времени. Интервал между двумя такими от-
    счетами равен 1/18.2 сек (в секунде - 18.2 импульса, в минуте - 1092,
    в часу - 65520). Появление каждой временной отметки вызывает прерыва-
    ние, обрабатываемое операционной системой. Обработка заключается в
    суммировании временных импульсов и записи результата в четырехбай-
    товый счетчик с адресами &H46C - &H46F. Обнуление этого счетчика
    производится в полночь.
         Второй источник временых отсчетов представлен программируемой
    микросхемой - интервальным таймером типа 8253 (XT) или 8254 (AT).
    Таймер состоит из трех независимых компонент, которые мы условно
    будем называть "будильниками". На входе каждого будильника имеется
    16-разрядный регистр с "защелкой". Защелку можно "открыть" или "за-
    крыть" по сигналам, поступающим в порт управления соответствующего
    будильника (адреса портов - &H40,&H41 и &H42). Если защелка открыта,
    то путем вывода в соответствующий порт содержимое входного регистра
    можно обновить. Как только во входной регистр поступило новое зна-
    чение, оно переписывается во внутренний регистр, и будильник начи-
    нает свою работу. Из содержимого внутреннего регистра с каждым от-
    счетом времени вычитается по единице. В тот момент, когда содержи-
    мое этого регистра становится равным нулю, будильник начинает "зво-
    нить" - на его выходной линии меняется потенциал. Затем содержимое
    регистра-защелки вновь переписывается во внутренний регистр бу-
    дильника и процесс повторяется.
         Будильник с номером 0 управляет работой системных часов, сле-
    дующий будильник принимает участие в процедурах регенерации памяти
    и, наконец, будильник с номером 2 может использоваться в интересах
    программы для управления  временными процессами и организации зву-
    ковых эффектов.
         Последним источником времени в IBM PC/AT являются обычные
    электронные часы - специальная микросхема MC146818, работающая на
    собственной батарейке и предоставляющая процессору возможность ус-
    тановить или опросить текущие показания времени и даты.
         Для организации временных измерений в распоряжении пользовате-
    ля имеются системные переменные символьного типа DATE$, TIME$ и
    арифметическая переменная TIMER. Первые две из них можно изменять,
    необходимость в чем возникает при корректировке показаний даты и
    времени :

                      DATE$ = "01/31/91"
                      DATE$ = "01/31/1991"
                      TIME$ = "07:45:00"

         Формат задания текущей даты допускает употребление символа
    "-" в качестве разделителя между месяцем, днем и годом. При уста-
    новке нового показания времени младшие компоненты (секунды, мину-
    ты и секунды) можно не набирать. По умолчанию вместо них будут ус-
    тановлены нулевые значения.
         Из показаний системных переменных очень несложно выделить
    символьные или числовые значения отдельных компонент :

      T$ = TIME$
      H$ = LEFT$ (T$,2) : H = VAL (H$) : IF  H > 12 THEN  H = H - 12
      M$ = MID$ (T$,4,2) : M = VAL (M$)
      S$ = RIGHT$ (T$,2) : S = VAL (S$)

         В системной переменной TIMER хранится количество секунд, про-
    шедших после полуночи. Содержимое этой переменной можно только про-
    читать. С ее помощью можно определить время работы той или иной
    программной процедуры :

          10 T = TUMER : 'Засекаем время запуска процедуры
          20 'Начало хронометрируемой процедуры
          ......................................
         200 'Конец процедуры
         210 T = TIMER - T
         220 H = FIX (T / 3600)  : 'Подсчитали часы
         230 T = T - H * 3600
         240 M = FIX (T / 60)    : 'Подсчитали минуты
         250 S = T - M * 60      : 'Подсчитали секунды
         260 PRINT  H; "часов", М; "минут", S; "секунд"

         Если процедура хронометрирования требует более высокой точно-
    сти измерения чем одна секунда, то вместо переменной TIMER можно
    воспользоваться подпрограммой опроса содержимого системных часов :

         1000  DEF  SEG = 0
         1010  B0 = PEEK (&H46C) :  'младший байт
         1020  B1 = PEEK (&H46D) :  'следующий байт
         1030  B2 = PEEK (&H46E) :  'старший байт
         1040  T = B2 * 65536 + B1 * 256 + B0
         1050  RETURN

         Однако в этом случае надо помнить, что цена единицы времени
    ("тика") равна 1/18.2 сек :

         10  GOSUB 1000
         20  T1 = T
         ...............
         205  GOSUB 1000
         210  T = T - T1
         220  H = FIX (T / 65520) : ' Подсчитали часы
         230  T = T - H * 65520
         240  M = FIX (T / 1092)  : ' Подсчитали минуты
         250  T = T - M * 1092    : ' Получили остаток в "тиках"
         ..........................

         Значение переменной TIMER можно использовать для перенастрой-
    ки датчика случайных чисел :

                             RANDOMIZE  TIMER

         Пользователи Turbo-системы имеют двусторонний доступ к еще
    одной системной переменной MTIMER. Она представляет собой обычный
    счетчик тактовых сигналов, накапливающий сумму с шагом в одну мил-
    лисекунду. Установив в нем нулевое значение (MTIMER = 0), спустя
    некоторое время можно определить длительность прошедшего интерва-
    ла (DT = MTIMER).
         Для организации временной паузы (задержки), например, между
    динамически сменяющимися кадрами на экране, в Turbo BASIC'е исполь-
    зуется оператор DELAY. Его единственным аргументом является вели-
    чина задержки в секундах :

                           DELAY  5

    Интересно, что точно такую же задержку можно организовать и с по-
    мощью оператора SOUND :

                           SOUND  32767, 91

    На частоте 32767 Гц динамик компьютера никакого звука не воспроиз-
    водит - полоса пропускания не та, да и человеческое ухо не услышит.
    А время "звучания" (91 = 5*18.2)  составит ровно 5 сек.
         Подпрограммы, срабатывающие по принципу будильника, об'являют-
    ся с помощью следующих операторов :

             10  TIMER  ON
             20  ON  TIMER (n)  GOSUB  300

         Первый оператор разрешает пользовательскую обработку прерыва-
    ний от интервального таймера, а второй - устанавливает точку входа
    в подпрограмму и осуществляет запись в регистр-защелку соответству-
    ющего значения будильника. Через каждые n сек. после выполнения
    оператора 20 управление будет передаваться подпрограмме обработки
    сигнала будильника. Отменить такое прерывание можно либо по опера-
    тору TIMER OFF, либо путем переназначения точки входа на нулевую
    строку.

                   5.5.5.Организация звуковых эффектов

         В отличие от бытовых или специализированных компьютеров, снаб-
    жаемых программируемыми многоканальными звуковыми генераторами,
    ПЭВМ типа IBM PC/XT и AT комплектуются довольно примитивными сред-
    ствами формирования звуковых сигналов. К встроенному динамику под-
    ведены две линии, одна из которых управляется выходом второго кана-
    ла программируемого таймера 8253/8254, а вторая - первым битом пор-
    та 61h ( на PC/XT этот порт обслуживает микросхему 8255 управления
    периферийными устройствами). На каждой из этих линий программным
    образом можно сгенерировать электрические сигналы с прямоугольными
    импульсами заданной частоты и длительности. Изменение переднего и
    заднего фронтов импульса, а также сглаживание угловых точек позво-
    ляет уподобить генерируемые сигналы синусоидальным. Однако регули-
    ровка по амплитуде, т.е. по уровню громкости сигнала здесь отсут-
    ствует.
         Самым простым средством, которое обычно применяется для при-
    влечения внимания пользователя, является генерация кратковременно-
    го звукового сигнала с помощью оператора BEEP :

         150 PRINT "Вы ошиблись. Повторите"  : BEEP : GOTO  60

    При его выполнении раздается звук с частотой 400 герц и длительно-
    стью порядка 1/4 секунды, т.е. примерно такой же эффект, как и при
    выводе символа с кодом 07.
         Оператор SOUND обеспечивает выдачу монотонного звукового сиг-
    нала с заданной частотой F от 37 до 32767 герц и длительностью зву-
    чания T от 0 до 65535 "тиков" (1 тик = 1/18.2 сек) :

                            SOUND  F, T

    При T=0 оператор SOUND блокирует выполнение каких-либо других музы-
    кальных фрагментов, запущенных ранее и не успевших завершиться.
         Сигнал, сформированный с помощью оператора SOUND, звучит в
    так называемом режиме музыки переднего плана. Это означает, что
    ЭВМ не перейдет к выполнению следующего оператора до тех пор, пока
    звуковой сигнал не будет отработан.
         В отличие от этого Бейсик позволяет формировать и исполнять
    музыкальную программу на фоне действия других операторов. Для этой
    цели используется программно организованный музыкальный буфер, раз-
    меры которого можно изменить при запуске или перенастройке парамет-
    ров системы. По умолчанию емкость этого буфера - 256 байтов, что
    позволяет разместить закодированную музыкальную программу, содержа-
    щую до 32 нот со всеми необходимыми характеристиками (частота, дли-
    тельность, темп исполнения).
         Музыкальная программа генерируется оператором PLAY по значению
    символьной строки, представленной в виде текстовой константы или
    текстового выражения. При этом каждая нота кодируется одной из
    букв C("до"),D("ре"),E("ми"),F("фа"),G("соль"),A("ля") и B("си").
    Знаки "+" или "#", употребленные вслед за обозначением ноты, соот-
    ветствуют музыкальному термину "диез" (нота, звучащая на полтона
    выше). Для включения термина "бемоль" (нота,звучащая на полтона ни-
    же) используется символ "-". Таким образом, указатели C# или C+ и D-,
    D# или D+ и E-, F# или F+ и G-, G# или G+ и A-, A# или A+ и B-  со-
    ответствуют одноименным черным клавишам октавы.
         Выбор октавы в музыкальной программе осуществляется по указанию
    On, где числовой индекс n, принадлежащий диапазону от 0 до 6, задает
    номер октавы. Переход к соседней октаве, можно указывать символами
    ">" (увеличение номера октавы на 1) или "<" (уменьшение номера окта-
    вы на 1). По умолчанию установлена октава O3, соответствующая пер-
    вой октаве музыкального инструмента, частоты нот которой имеют сле-
    дующие значения в герцах :

             до (C)  -  523.25            соль (G)  -  783.99
             ре (D)  -  587.33            ля   (A)  -  880.00
             ми (E)  -  659.26            си   (B)  -  987.77
             фа (F)  -  698.46

    Частоты нот каждой соседней октавы увеличиваются (>) или уменьша-
    ются (<) вдвое.
         Существует и другой способ идентификации клавиш музыкального
    инструмента в виде Nn, где n - число из диапазона от 0 до 84, за-
    дающее (при n > 0) порядковый номер клавиши в семи возможных окта-
    вах. Указатель N0 соответствует паузе между нотами.
         Относительная длительность нот устанавливается командой Ln,
    где числовой параметр n из диапазона 1-64 задает количество нот,
    содержащихся в полной (L1) ноте. По умолчанию установлен режим
    L4. Число, записанное вслед за указателем ноты, определяет ее
    индивидуальную длительность.
         Командами MN (нормальная музыка), ML (музыка legato) и MS
    (музыка staccato) устанавливаются режимы, в которых фактическая
    длительность звучания ноты равна соответственно 7/8, 1 и 3/4 от
    относительной длительности, установленной предшествующей коман-
    дой Ln.
         Относительные паузы между нотами регулируются командой Pn,
    где числовая величина n имеет тот же смысл, что и в команде Ln.
         Темп исполнения музыкальной программы, определяющий количе-
    ство четвертных нот в минуте, устанавливается командой Tn (n от
    32 до 255). По умолчанию действует режим T120.
         Индивидуальная длительность ноты может быть изменена с помо-
    щью одной или нескольких точек, записываемых вслед за обозначением
    ноты. Каждая точка прибавляет к длительности звучания, заданной
    командами L и T, половину временного интервала. Таким образом ноты
    "A." и "A.." звучат соответственно 3/2 и 9/4 от временного интерва-
    ла, принятого для ноты "A".
         Запись музыкальной программы в буфер осуществляется оператором
    PLAY :

                    W$ = "T180 O2 P2 P8 L8 G G G  L2 E-"
                    PLAY W$ + "P24 P8 L8 F F F L2 D"

         Если музыкальной программе предшествует команда MF, то содер-
    жимое буфера исполняется в режиме музыки переднего плана. Это озна-
    чает, что программа приостанавливается до тех пор, пока музыкальный
    буфер не будет опустошен. По умолчанию оператор PLAY исполняет свой
    фрагмент именно в таком режиме.
         В случае, когда содержимое буфера формируется с установочной
    командой MB, то соответствующий фрагмент исполняется в режиме фоно-
    вой музыки. Именно этот режим позволяет программе проконтролировать,
    сколько нот еще находится в музыкальном буфере. Для этой цели пред-
    назначена функция PLAY(n) с фиктивным аргументом. Ее значением яв-
    ляется количество нот буфера, еще не обработанных системной програм-
    мой воспроизведения звуков. С помощью оператора SOUND F,0 можно про-
    извести досрочную очистку содержимого буфера.
         Выполняясь параллельно с фоновой музыкой, программа может пре-
    рвать свою работу в тот момент, когда в буфере останется заданное
    количество нот. Для этого необходимо разрешить прерывание, наступа-
    ющее при переходе звуковоспроизводящего процесса с обработки k-той
    ноты на (k-1)-ую :

                       PLAY  ON
                       ON  PLAY (k)   GOSUB  1200

         В качестве числового аргумента музыкальных команд L,O,P и T
    могут выступать целочисленные переменные :

        10  W$ = "BA#AG#GF#FED#DC#CC#DD#EFF#GG#AA#B"
        20  FOR  I% = 1  TO  10
            30  FOR  J% =1  TO  6
                40  PLAY "MB L16 T120 O=J%;" + W$
            50  NEXT  J%
        60  NEXT  I%

         Одним из мощных средств оператора PLAY является возможность
    включения в состав музыкальной программы фрагментов, являющихся
    значениями символьных переменных и выполняющих роль музыкальных
    подпрограмм. Кроме средств конкатенации, продемонстрированных в
    ранее приведенных примерах, подключение музыкальной подпрограммы
    можно реализовать с помощью команды X :

        40  PLAY  "MB L16 T120 O=J%; XW$;"
        40  PLAY  "MB L16 T120 O=J%; X" + VARPTR$ (W$)

    Первый вариант использования музыкальной команды X характерен для
    интерпретаторов, второй - для компиляторов.
         Использование музыкальных подпрограмм интересно еще и тем,
    что запрограммированный фрагмент может быть исполнен с различными
    вариациями управляемых звуковых параметров - в другой октаве, со
    сменой темпа и т.п.


            5.5.6.Доступ к портам и ячейкам оперативной памяти

         Термин "порт" уже не раз фигурировал в разделах данной главы,
    однако попытка расшифровать это понятие еще не предпринималась.
    Большинство руководств по Бейсик-системам довольно скупо освещают
    технологию работы с портами, так как эта проблема выходит за рамки
    обычного программирования прикладных задач.
         Порты являются основным средством связи центрального процес-
    сора (CPU) с многочисленными микросхемами и контроллерами, которы-
    ми напичкана плата компьютера. Обслуживание штатных внешних уст-
    ройств выполняется средствами операционной системы или системы про-
    граммирования. Поэтому к непосредственной работе с портами рядовые
    пользователи обычно не прибегают.
         Внешне порты напоминают ячейки оперативной памяти. Так же,
    как и байты ОП, порты имеют адреса от 0 до 65535, хотя задействова-
    ны из них далеко не все. Однако порт с адресом A не имеет никакого
    отношения к байту оперативной памяти с тем же адресом. Это - два
    совершенно разных об'екта, и запись в один из них никоим образом
    не влияет на содержимое другого. Доступ к порту осуществляется с
    помощью машинных команд IN (чтение из порта) и OUT (вывод в порт),
    тогда как для обращения к байтам памяти используются различные мо-
    дификации команды MOV.
         С каждым внешним устройством обычно связано несколько портов,
    выполняющих определенные функции на различных стадиях обмена. В од-
    ни порты заносятся управляющие признаки и адреса (номера) внутрен-
    них регистров обслуживаемой микросхемы. Другие порты используются
    для обмена данными между CPU и выбранными внутренними регистрами.
    По содержимому третьих портов операционная система получает инфор-
    мацию о состоянии внешнего устройства, анализирует  признаки завер-
    шения очередной процедуры обмена, контролирует правильность функци-
    онирования оборудования.
         Программирование обмена с периферийным устройством на уровне
    портов иногда называют программированием на физическом уровне. Оно
    требует профессионального знания большого количества технических
    деталей, соблюдения жестких временных ограничений и, как правило,
    ведется на языке ассемблера. Программы, обслуживающие обмен с внеш-
    ним устройством и оформленные в соответствии с требованиями опера-
    ционной системы, называются драйверами.
         Драйверы на Бейсике, практически, никто не пишет, однако во
    всех трех версиях имеется возможность обратиться напрямую к тому
    или иному порту. Для этой цели предназначены операторы OUT, WAIT
    и функция INP. Они позволяют выполнить любые операции по управле-
    нию внешними устройствами, которые не предусмотрены в стандартных
    средствах ввода/вывода. Это может оказаться полезным при работе с
    новыми внешними устройствами, не обслуживаемыми Бейсик-системой.
         С помощью функции INP(A) осуществляется считывание однобайто-
    вого значения из порта с адресом A. Обычно адрес порта задается в
    виде шестнадцатеричной константы &Hxxxx . Перечень адресов некото-
    рых портов приведен в табл.25.

                                                     Таблица 25
    ┌───────────────┬─────────────────────────────────────────────┐
    │ Адреса портов │         Обслуживаемое устройство            │
    ├───────────────┼─────────────────────────────────────────────┤
    │  00 -  1F     │ контроллер прямого доступа к памяти DMA,    │
    │               │ 8237 (для AT - первый контроллер DMA)       │
    │  20 -  2F     │ контроллер прерываний, 8259 (XT)            │
    │  20 -  3F     │ контроллер прерываний 1 (AT)                │
    │  40 -  5F     │ программируемый таймер, 8253/8254           │
    │  60 -  6F     │ адаптер интерфейса с периферией, 8255       │
    │  70 -  7F     │ автономные часы реального времени (AT)      │
    │  80 -  9F     │ регистры страниц DMA                        │
    │  A0 -  BF     │ контроллер прерываний 2 (AT)                │
    │  C0 -  DF     │ второй контроллер DMA (AT)                  │
    │ 1F0 - 1F8     │ контроллер винчестера (AT)                  │
    │ 200 - 20F     │ адаптер игровых пультов                     │
    │ 278 - 27F     │ второй адаптер параллельного принтера       │
    │ 2F8 - 2FF     │ адаптер канала связи COM2                   │
    │ 320 - 32F     │ контроллер винчестера (XT)                  │
    │ 378 - 37F     │ первый адаптер параллельного принтера       │
    │ 3B0 - 3BF     │ адаптер параллельного принтера и ч/б дисплея│
    │ 3D0 - 3DF     │ адаптер цветного графического монитора      │
    │ 3F0 - 3F7     │ контроллер флоппи-дисков                    │
    │ 3F8 - 3FF     │ адаптер канала связи COM1                   │
    └───────────────┴─────────────────────────────────────────────┘

         Процедура вывода однобайтового значения n из диапазона от 0
    до 255 в порт с адресом A осуществляется оператором  OUT  A,n.
         Оператор WAIT предназначен для приостановки процесса выполне-
    ния программы до тех пор, пока в порту с адресом A не появится ко-
    довая комбинация X, удовлетворяющая заданному условию :

                          WAIT  A, n1 [,n2]

    Два последние операнда n1 и n2, принадлежащие интервалу от 0 до
    255, задают условие прекращения задержки :

            IF  ((X XOR n2) AND n1) = 0 THEN ожидание

    Если операнд n2 не задан, то он по умолчанию считается равным нулю
    и проверка упрощается :

                  IF  (X AND n1) = 0 THEN ожидание

         Конечно, такую задержку можно было бы организовать и без опе-
    ратора WAIT :

                  150  X = INP (A)
                  160  IF  ((X XOR n2) AND n1) = 0  THEN  150

         Программирование на физическом уровне, как правило, связано с
    доступом к тем или иным ячейкам памяти ОЗУ / ПЗУ, в которых опера-
    ционная система хранит информацию, участвующую в обслуживании соот-
    ветствующего устройства. Для обеспечения такого рода процедур пред-
    назначены операторы DEF SEG, POKE и функция PEEK.
         Мы уже упоминали, что доступ к ячейкам оперативной памяти в
    IBM PC базируется на использовании 20-разрядных адресов, обеспечи-
    вающих идентификацию байтов ОЗУ в диапазоне от 0 до 1Мб. Составля-
    ется такой адрес из двух 16-разрядных компонент B и D, условно за-
    писываемых в виде B:D.
         Компонента B называется базой сегмента и, в зависимости от
    адресуемого типа данных, хранится в одном из регистров CS (сегмент
    команд), DS (сегмент данных), SS (сегмент стека) или ES (дополни-
    тельный сегмент). Сдвиг базового адреса на 4 разряда влево позволя-
    ет получить 20-разрядный начальный адрес сегмента.
         Вторая компонента D задает смещение адресуемого байта относи-
    тельно начала сегмента, так что полный физический адрес об'екта
    равен 16 * B + D. Максимально допустимая длина сегмента - 64 Кб.
         Функция POKE(D) позволяет извлечь содержимое байта, расположен-
    ного по относительному адресу D, а оператор "PEEK D,n" осуществляет
    запись целочисленного значения n (от 0 до 255) по относительному ад-
    ресу D.
         Для правильного формирования полного физического адреса проце-
    дурам POKE и PEEK должно обязательно предшествовать задание началь-
    ного базового адреса :

      100 'Фрагмент программы очистки буфера клавиатуры
      110  DEF SEG = &H40     : 'Установили базу сегмента
      120  'Извлекаем указатель головного символа в буфере
      130  PBEG = PEEK (&H1A) : 'Полный адрес равен 0040:001A
      140  'Сбрасываем указатель конечного символа в буфере
      150  POKE  &H1C, PBEG   : 'Очистка буфера завершена

         Оператор DEF SEG, употребленный без параметров, восстанавлива-
    ет системное значение базы данных.
         Компоненты физического адреса любой переменной или массива мо-
    гут быть опрошены с помощью функций VARSEG, VARPTR или VARPTR$ :

      100  DEF SEG : 'Восстановили базу системного сегмента данных
      110  B = VARSEG (A5)     : 'База переменной A5
      120  D = VARPTR (A5)     : 'Смещение переменной A5
      130  B1 = VARSEG (C(0))  : 'База массива C
      140  ADR$ = VARPTR$ (A5) : 'Адрес A5 в специальном формате

    В операторе 140 результат формируется в виде трехбайтовой строки.
    В первом байте находится признак типа аргумента (2 - целочислен-
    ный, 3 - строка, 4 - вещественный, 8 - вещественный с удвоенной
    точностью). Второй и третий байты содержат соответственно младшие
    и старшие разряды относительного адреса аргумента. Этот формат
    соответствует правилам задания адреса операнда команды "X" в опе-
    раторах DRAW и PLAY.
         Полученные таким путем адреса могут быть переданы в качестве
    входных или выходных параметров процедурам, обслуживающим програм-
    мные прерывания, или подпрограммам, составленным на других алго-
    ритмических языках.

                       5.5.7.Работа с каналами связи

         Телекоммуникационные возможности IBM PC обеспечиваются одной
    или двумя микросхемами UART 8250 (Universal Asynchronous Receiver
    Transmitter), которые носят название последовательных каналов свя-
    зи COM1: и COM2: . Каждая их этих микросхем содержит по 10 одно-
    байтовых программируемых регистров, с помощью которых осуществляет-
    ся управление обменом информацией между PC и другим устройством -
    абонентом.
         В качестве абонента может выступать принтер с последовательным
    интерфейсом типа RS 232C, другая ПЭВМ, находящаяся в непосредствен-
    ной близости или специальное устройство дальней связи - модем. Пос-
    ледний осуществляет прямое (модуляция) или обратное (демодуляция)
    преобразование цифрового сигнала, передаваемого по телефонному ка-
    налу связи, может накапливать передаваемую порцию данных, контроли-
    ровать правильность передачи, управлять различными телефонными ат-
    рибутами (звонок, номеронабиратель) и т.п. Существует довольно мно-
    го различных конструкций модемов и схем их взаимодействия с ЭВМ,
    которые принято называть протоколами связи.
         В простейшем случае ЭВМ и пассивный абонент связываются всего
    тремя линиями, по одной из которых передаются битовые последователь-
    ности данных, а по другой - управляющие потенциалы. Третья шина вы-
    полняет роль общей "земли". По управляющему проводу высоким или низ-
    ким потенциалом приемник сообщает о своей готовности принять очеред-
    ную порцию данных.
         Информация, передаваемая по шине данных, представляет собой
    последовательность кодовых посылок (цифры, символы), окаймляемых
    специальными сигналами :

             <-----  направление передачи данных

                       0   1   2  ...   7
             ──┐     ┌───┬───┬───┬────┬───┐╔═╗┌──┬─┐
               │     │   |   |   |... |   │║ ║│  | │
               └──┬──└───┴───┴─┬─┴────┴───┘╚╤╝└──┴┬┘──────┬──
                  │            │            │     │       │
              стартовый  информационные     │  стоповый   │
                "бит"         биты          │    бит   следующий
                                       контрольный     стартовый
                                           бит            бит

         В зависимости от типа передаваемых данных и способа их коди-
    ровки количество информационных битов может варьироваться от четы-
    рех до восьми.
         Контрольный бит дополняет количество единиц в информационных
    битах до четного (контроль по "чету") или до нечетного (контроль
    по "нечету") числа. Допускаются варианты обмена, когда контрольный
    разряд может заполняться нулем или единицей, независимо от числа
    единиц в информационных битах, и даже вообще отсутствовать.
         Взаимодействующие абоненты обязательно договариваются между
    собой о количестве информационных битов, способе заполнения кон-
    трольного бита, количестве стоповых битов и скорости передачи дан-
    ных. Последнее обстоятельство очень важно, так как выделить каждый
    информационный бит можно только по его длительности, ибо между дву-
    мя одинаковыми смежными разрядами никаких разделительных сигналов
    нет. Скорость передачи данных измеряется в бодах - числе двоичных
    разрядов, передаваемых в секунду. Для микросхем UART 8250 допусти-
    мыми скоростями являются 75, 110, 150, 300, 600, 1200, 1800, 2400,
    4800 и 9600 бод.
         Количество стоповых битов, завершающих посылку информационной
    единицы данных, может быть равно 1, 1.5 или 2. Не надо удивляться
    значению в "полтора" двоичных разряда, так как здесь имеется ввиду
    временная длительность сигнала. А ее-то можно и поделить.
         В случае подключения к ЭВМ модема между ними может использо-
    ваться одна или две шины данных, а также шесть следующих управляю-
    щих линий :

     ┌─────┐ передаваемые данные  ┌───────┐             ┌───────┐
     │     ├─────────────────────>│       │             │       │
     │     │ принимаемые данные   │       │             │       │
     │     │<─────────────────────┤       │             │       │
     │     │  DTR                 │       │             │       │
     │     ├─────────────────────>│       │             │       │
     │     │  RTS                 │       │             │       │
     │ IBM ├─────────────────────>│       │ Телефонная  │       │
     │ P C │                 DSR  │ Модем ├─ ─ ─ ─ ─ ─ ─│ Модем │
     │     │<─────────────────────┤       │ линия связи │       │
     │     │                 CTS  │       │             │       │
     │     │<─────────────────────┤       │             │       │
     │     │                 DCD  │       │             │       │
     │     │<─────────────────────┤       │             │       │
     │     │                  RI  │       │             │       │
     │     │<─────────────────────┤       │             │       │
     └─────┘                      └───────┘             └───────┘

         Сигнал DTR (Data Terminal Ready) сообщает модему о готовности
     компьютера к сеансу связи.
         Сигнал RTS (Request To Send) информирует модем о том, что ком-
    пьютер ожидает поступления данных.
         Сигнал DSR (Data Set Ready) сообщает компьютеру о готовности
    модема к обмену данными.
         Сигнал CTS (Clear To Send) сообщает компьютеру о том, что мо-
    дем готов начать передачу данных.
         Сигнал DCD (Data Carrier Detect) сообщает компьютеру, что мо-
    дем связан с другим модемом.
         Сигнал RI (Ring Indicator) информирует ЭВМ о том, что телефон-
    ная линия, к которой подсоединен модем, имеет звонок.

         Взаимодействие компьютера и модема при передаче данных удален-
    ному абоненту развивается по следующей схеме :

       - ЭВМ выдает сигнал DTR;
       - установив, что модем включен, компьютер предлагает ему связать-
         ся с удаленным абонентом;
       - после установления связи модем выставляет сигнал DSR;
       - компьютер выдает сигнал RTS;
       - после того, как модем отвечает сигналом CTS, начинается пере-
         дача данных абоненту.

         В процессе диалога возможны различные ситуации, две из которых
    мы рассмотрим несколько подробнее. Первая из них связана с ошибкой
    таймаута, свидетельствующей о том, что за установленный интервал
    времени не поступил ожидаемый сигнал. Второй момент связан с терми-
    ном "протокол XON/XOFF". Управляющий сигнал XOFF, имеющий в табли-
    це ASCII код 19, свидетельствует о том, что в приемном пункте обра-
    ботка данных ведется медленнее и не соответствует скорости их пос-
    тупления. В такой ситуации передающий пункт должен приостановить
    поток данных. Второй сигнал XON с кодом 17 сообщает абоненту, что
    можно продолжить передачу. Таким образом, обмениваясь сигналами
    XON/XOFF, абоненты в условиях асинхронной связи могут согласовать
    свои возможности.
         Еще некоторые технические детали следует упомянуть в связи с
    телекоммуникационными каналами. Для совмещения процессов обработки
    поступающей информации и диалога с модемом в оперативной памяти ЭВМ
    за каждым каналом закрепляются приемные и/или передающие буфера.
    Если процедура обработки затягивается, то помимо выше упомянутых
    сигналов XON/XOFF можно пойти на увеличение емкости буферов.
         Доступ к управляющим регистрам UART 8250 осуществляется через
    порты с адресами 2F8h - 2FEh (COM2:) и 3F8h - 3FEh (COM1:). Прог-
    раммирование на этом уровне требует не только детального знания
    функций каждого разряда управляющих регистров, системы команд моде-
    ма, но и понимания логико-временной последовательности событий в
    процессе взаимодействия абонентов.
         Рассматриваемые версии Бейсика обеспечивают более простой ре-
    жим общения программы с телекоммуникационными каналами связи, кото-
    рое проистекает по следующей схеме.
         Канал связи, для определенности COM1:, инициируют так же, как
    открывают обычные файлы :

     OPEN "COM1: optlist1 optlist2" [ FOR mode ] AS [#]n [ LEN = rl ]

    Здесь optlist1 - список параметров, определяющих скорость передачи
                     данных и конфигурацию передаваемой порции ([speed]
                     [,[parity][,[data][,stop]]]);
          optlist2 - список параметров, определяющих другие характерис-
                     тики процесса обмена (см. табл.26);
              mode - режим доступа к записям файла, принимающий одно
                     из значений INPUT, OUTPUT или RANDOM;
                 n - программный номер, под которым канал связи будет
                     выступать в операторах и функциях обмена;
                rl - длина записи (по умолчанию - 128 б);
             speed - скорость передачи в бодах;
            parity - символ, определяющий способ формирования бита кон-
                     троля (N - нет контроля, E - контроль по четности,
                     O - контроль по нечетности, S - контрольный бит
                     всегда равен нулю, M - контрольный бит всегда ра-
                     вен единице);
              data - количество информационных битов (от 4 до 8);
              stop - количество стоповых битов (1 или 2). Для data =
                     4 или 5 значение stop = 2 соответствует полутора
                     стоповым сигналам.
         Параметры списка optlist2 разделяются запятыми и их формат
    приведен в табл.26. По умолчанию коммуникационный файл открыва-
    ется как двоичный файл (BIN) со следующими атрибутами :

             speed = 300;   parity = E;   data  = 7;
              stop = 2  для скоростей 75 и 100 бод;
              stop = 1  для всех остальных скоростей;
                         timeout = 1000

                                                    Таблица 26
      ┌───────────┬──────────────────────────────────────────────────┐
      │  Формат   │                   Пояснение                      │
      │ параметра │                                                  │
      ├───────────┼──────────────────────────────────────────────────┤
      │ ASC       │ Файл открывается в режиме ASCII. Символы Tab     │
      │           │ заменяются пробелами. Каждая строка завершается  │
      │           │ кодом CR. Сочетание Ctrl+Z воспринимается как    │
      │           │ признак конца файла (Eof). Используется протокол │
      │           │ XON/XOFF.                                        │
      │           │                                                  │
      │ BIN       │ Открывается двоичный файл                        │
      │           │                                                  │
      │ CD[m]     │ Устанавливается максимально допустимая задержка  │
      │           │ сигнала DCD в m млсек.                           │
      │           │                                                  │
      │ CS[m]     │ Аналогичная задержка для сигнала CTS             │
      │           │                                                  │
      │ DS[m]     │ Аналогичная задержка для сигнала DSR             │
      │           │                                                  │
      │ LF        │ Используется при передаче текстового файла на    │
      │           │ принтер с последовательным интерфейсом. Вызывает │
      │           │ принудительную вставку управляющего символа LF   │
      │           │ (Line Feed) после каждого признака конца строки  │
      │           │ CR (Carriage Return).                            │
      │           │                                                  │
      │ OP[m]     │ Устанавливается максимально допустимая задержка  │
      │           │ процедуры открытия телекоммуникационного файла   │
      │           │                                                  │
      │ RB[n]     │ Задается длина (n) приемного буфера в байтах     │
      │           │ (в GW и Turbo BASIC'е по умолчанию - 256 б, в    │
      │           │  Quick BASIC'е - 512 б).                         │
      │           │                                                  │
      │ RS        │ Блокируется анализ сигнала RTS                   │
      │           │                                                  │
      │ TB[N]     │ Задается длина передающего буфера                │
      └───────────┴──────────────────────────────────────────────────┘

         Выполнение процедуры OPEN COM развивается по следующей схеме :

      - выделяются буфера и разрешаются сигналы прерывания от UART;
      - устанавливается высокий потенциал ("1") на линии DTR;
      - по истечению времени, установленного параметрами OP[m] или
        DS[m], проверяется ситуация "ошибка таймаута";
      - если не был задан параметр RS, то устанавливается высокий
        потенциал на шине RTS;
      - по истечению времени, установленного параметрами OP[m] или
        CD[m], проверяется ситуация "ошибка таймаута";
      - если в указанных проверках ошибка таймаута не была обнаружена,
        то канал связи считается открытым. В противном случае буфера
        возвращаются системе, прерывания от UART блокируются, сбрасы-
        ваются потенциалы на управляющих линиях и производится аварий-
        ное завершение программы.

         В связи с тем, что моменты поступления данных от абонента про-
    грамме заранее не известны, на помощь приходит аппарат событий и
    механизм обработки прерываний. Операторы COM(n) ON, COM(n) OFF и
    COM(n) STOP соответственно разрешают, блокируют или замораживают
    прерывания, генерируемые указанным каналом связи в тот момент, ког-
    да в приемный буфер поступает очередная порция данных. С помощью
    оператора ON COM(n) GOSUB ...  назначается точка входа в подпрог-
    рамму обработки сигналов прерывания.
         Для вывода данных через открытый канал используют операторы
    PRINT #n, PRINT #n USING или WRITE #n, употребление которых ничем
    не отличается от общения с обычными файлами.
         Прием данных, поступающих по каналу связи, можно организовать
    либо по оператору INPUT #n, либо по функции INPUT$(m,#n). Послед-
    няя предоставляет больше удобств, так как мы можем прочитать не
    всю запись целиком, а только требуемое количество байтов. Размер
    приемного буфера в 256 байтов представляется разумным, так как он
    позволяет поместить считанное значение в одну текстовую переменную
    (это ускоряет процедуру ввода).
         При обработке вводимых данных из текстового файла могут ока-
    заться полезными функции LOC(n) и LOF(n). Первая из них сообщит,
    сколько байтов сейчас находится в буфере, и эту информацию можно
    учесть при вводе :

                      A$ = INPUT$ ( LOC(1), #1)

    Вторая функция сообщает, сколько байтов в буфере свбодны. Знание
    этой величины позволит не переполнить буфер при выводе.
         Оценить ситуацию появления в приемном буфере сигнала XOFF
    нам поможет функция INSTR :

             IF  INSTR (1, A$, CHR$ (19)) > 0  THEN ...

         Для прекращения сеанса связи телекоммуникационный канал за-
    крывают самым обычным образом :

                           CLOSE  #n

         В качестве примера познакомьтесь с небольшим фрагментом прог-
    раммы, которая занимается отображением на экране символов, набира-
    емых на клавиатуре. Однако путь символа к экрану лежит через буфер
    телекоммуникационного канала. ЭВМ посылает в канал связи информацию,
    поступающую с клавиатуры,  и тут же сама ее принимает:

        10  OPEN "COM1: 9600,0,7" AS #1 : 'Открыли канал
        20  ON  COM(1) GOSUB  100       : 'Назначили точку входа
        30  COM(1)  ON                  : 'Разрешили прерывания
        40  'Прием символа, набираемого на клавиатуре
        50  A$ = INKEY$ : IF  A$ = ""  THEN  50
        60  PRINT #1, A$;               : 'Вывод символа в канал
        70  GOTO 50
       .................................
       100  'Прием символов из канала и их отображение на экране
       110  L  = LOC(1) :  IF  L < 1 THEN  RETURN
       120  B$ = INPUT$ (L,#1) : PRINT  B$; :  RETURN


          5.5.8.Управление внешними устройствами на физическом
                                  уровне

         Дополнительные возможности по управлению устройствами ввода/
    вывода предоставляют оператор IOCTL  и функция IOCTL$ :

                     IOCTL [#]n, "SS...S"
                     A$ = IOCTL$ ([#]n)

         Оператор IOCTL обеспечивает передачу цепочки символов "SS...S",
    воспринимаемых как последовательность команд, управляющих работой
    внешнего устройства. Каждая такая команда состоит из кода операции,
    обозначаемого двух- или трехсимвольным идентификатором, и располо-
    женным вслед за ним необходимым набором данных. Разделителем команд
    в строке служит точка с запятой. Например, установка количества
    строк в странице при выводе на принтер может быть реализована сле-
    дующим образом :

        OPEN  "LPT1:"  FOR OUTPUT  AS #1
        ................................
        IOCTL  #1, "PL64"  'размер страницы = 64 строки

         С помощью функции IOCTL$ производится опрос управляющих дан-
    ных, которыми устройство подтверждает правильность обработки посту-
    пившей команды, сообщает о причинах аварийной ситуации, выдает зна-
    чения опрашиваемых параметров. Например, опрос текущей ширины стро-
    ки на принтере можно произвести следующим образом :

         IOCTL  #1, "GW"             'команда опроса ширины строки
         WIDLINE = VAL (IOCTL$(#1))  'ответ драйвера принтера

         Естественно, что применение таких средств требует детального
    знакомства с набором команд драйверов соответствующих устройств.
    Описанные процедуры могут оказаться полезными при подключении к
    компьютеру новых внешних устройств, не обслуживаемых Бейсик-систе-
    мой.


