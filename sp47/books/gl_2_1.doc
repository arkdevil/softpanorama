                   2.ОРГАНИЗАЦИЯ ПРОГРАММЫ

                    2.1.Головная программа

         По аналогии с другими алгоритмическими языками под головной
    программой понимают модуль, с которого начинается счет. В ранних
    версиях Бейсика, в том числе и в GW-системе, программа для реше-
    ния той или иной задачи представляет собой единственный модуль,
    физическим концом которого является оператор END, расположенный
    в строке с наибольшим номером.
          В системах программирования Turbo и Quick BASIC наряду с
    головной программой (Main Program) могут существовать и другие
    программные модули, оформленные в виде внешних функций и подпро-
    грамм. Такие модули могут компилироваться как совместно с головной
    программой, так и отдельно от нее. В последнем случае получаются
    так называемые об'ектные модули. Их имена в файловой системе MS
    DOS снабжаются расширением .OBJ . Об'ектные модули можно подклю-
    чать к головной программе на стадии ее выполнения и компоновать
    в библиотеки, которые по своему назначению мало чем отличаются
    от системных библиотек.
         Внешние процедуры имеют свои собственные (локальные) пере-
    менные, допускают свою автономную нумерацию строк, и эти обстоя-
    тельства развязывают программисту руки. Он вовсе не должен знать,
    какие имена переменных задействованы в используемых им процеду-
    рах, в отличие от ранних версий Бейсика, где это обстоятельство
    приходилось учитывать. Он не должен заботиться о согласовании
    номеров (меток) строк в головной программе и во внешней процеду-
    ре. А раньше приходилось выполнять значительный об'ем работы по
    перенастройке используемых им готовых подпрограмм, заимствованных
    из других задач. Наличие отдельно транслируемых внешних модулей
    существенно облегчает работу по созданию крупных программных си-
    стем.


               2.2.Элементы структурного программирования

         Мы уже упоминали, что минимальной синтаксической конструк-
    цией, участвующей в построении программы, является оператор. Сле-
    дующим по сложности элементом конструкции программ является прог-
    раммная строка с необязательным номером (меткой) М, содержащая
    несколько операторов Oi :

                    [ M : ]   O1 : O2 :  ...  : On

         Xарактерной особенностью программной строки является то, что
    начать ее выполнение можно только с самого первого оператора O1,
    т.е. нельзя извне передать управление  внутреннему оператору.
         По аналогии с принципами построения программной строки в
    структурном программировании выделяют типовые блочные конструкции,
    которые, как правило, состоят из нескольких программных строк,
    имеют один вход, один выход и реализуют наиболее часто встречаю-
    щиеся логические структуры - циклы, выбор альтернативных вариан-
    тов и т.п.
         Как и в случае программной строки, войти в блочную конструк-
    цию извне разрешается только через ее единственный вход. Для со-
    временных версий Бейсика (Quick, Turbo) характерно и то обстояте-
    льство, что блок обязательно должен доработать до своего логиче-
    ского конца. Это означает, что в нем могут быть и не выполнены
    все запрограммированные действия, но возврат из блочной конструк-
    ции должен состояться только через ее единственный выход. Вну-
    тренние переходы в блоках не запрещены.


                         2.2.1.Циклы

         Цикл представляет собой фрагмент программы, который повторя-
    ется либо заданное количество раз, либо до тех пор, пока не будет
    удовлетворено некоторое условие. Чтобы выделить такой фрагмент,
    необходимо тем или иным способом задать его начало (заголовок ци-
    кла) и указать его конец. Программные строки, расположенные между
    этими двумя точками, принято называть телом цикла.
         Условие повторения цикла может находиться как в заголовке
    цикла, так и в его конечном операторе. Досрочный выход из тела
    цикла на строку, следующую за конечным  оператором цикла, осуще-
    ствляется с помощью оператора EXIT. В ранних версиях Бейсика тако-
    го оператора не было и для досрочного завершения цикла использова-
    лись обычные переходы - условные или безусловные. Они могли пере-
    дать управление не только на оператор, следующий за концом цикла,
    но и в любую точку программы. Такие возвраты не проходят бесслед-
    но, т.к. организация повтора цикла обычно связана со стеком, где
    хранятся параметры цикла - указатель на начало тела цикла, имя уп-
    равляющей переменной, ее конечное значение и величина приращения
    при очередном повторе. Если цикл не завершается нормальным обра-
    зом, то такого рода информация из стека не удаляется. Это может
    привести как к исчерпанию выделенного под стек участка памяти,
    так и к неправильному выполнению последующих циклов. Поэтому мы
    рекомендуем любой досрочный выход из цикла производить только с
    помощью оператора EXIT (EXIT FOR, EXIT DO, EXIT LOOP).
         К наиболее простым вариантам организации цикла относится по-
    втор тела, при котором по правилу арифметической прогрессии осу-
    ществляется изменение значения управляющей переменной (счетчика
    цикла) V :

             V = Vн,   V = Vн + dV,   V = Vн + 2*dV, ...

    Имя управляющей переменной (V), ее начальное (Vн) и конечное(Vк)
    значения, а также величина приращения (dV) задаются в заголовке
    цикла с помощью оператора FOR :

               FOR   V = Vн    TO  Vк    STEP  dV

         В качестве управляющей переменной может выступать простая
    переменная любого из числовых типов. Элемент массива в роли счет-
    чика циклов не допустим. Параметры цикла (Vн,Vк,dV) могут зада-
    ваться любыми арифметическими выражениями. Если шаг приращения
    управляющей переменной равен единице, то конструкцию "STEP 1"
    в заголовке цикла можно опустить.
         В современных версиях компиляторов и интерпретаторов приня-
    то проверять условие завершения цикла перед входом в его тело
    (цикл с предусловием) :

                     V  >  Vк       при    dV > 0
                     V  <  Vк       при    dV < 0

    Поэтому надо быть готовым к ситуации, что тело цикла никогда не
    выполнится при задании несовместимых параметров цикла. В этом
    случае программа продолжит свою работу с оператора, расположен-
    ного вслед за оператором конца цикла NEXT :

                               NEXT   V

         Имя управляющей переменной, повторяемое в операторе конца
    цикла, обязательно должно совпадать с идентификатором, указанным
    в заголовке. Все три версии допускают употребление оператора
    NEXT без указания имени управляющей переменной.
         Короткие циклы могут быть организованы даже в пределах од-
    ной программной строки :

          S = 0 :   FOR K=1 TO 20 :    S = S + A(K) :    NEXT

         С помощью операторов WHILE - WEND организуется цикл с пред-
    условием :

                    WHILE  условие
                   ┌────────────────┐
                   │   тело цикла   │
                   └────────────────┘

                    WEND

    Работа такого цикла начинается с проверки условия, записанного в
    заголовке WHILE. Если условие истинно, то начинается выполнение
    тела цикла, после чего оператор WEND вновь возвращает нас на за-
    головок цикла WHILE. Если в теле цикла происходят какие-то изме-
    нения, влияющие на результат проверки условия, то может наступить
    момент, когда это условие становится ложным, и управление из
    WHILE будет передано на оператор, следующий за WEND. В противном
    случае цикл будет повторяться до тех пор, пока в его теле не сра-
    ботает один из операторов перехода (GOTO, IF, ON) или досрочного
    выхода из цикла (EXIT).
         Одну из наиболее современных конструкций цикла позволяют со-
    здать операторы DO - LOOP :

            DO  [ WHILE условие  |  UNTIL условие ]
            ┌──────────────────────────────────────┐
            │                                      │
            │               тело цикла             │
            │                                      │
            └──────────────────────────────────────┘

            LOOP  [ WHILE условие  |  UNTIL условие ]

    В таких циклах программист сам может выбрать вариант проверки ус-
    ловия повторения - в начале цикла (предусловие) или в конце (пост-
    условие). А можно воспользоваться и двумя условиями сразу или ор-
    ганизовать бесконечно повторяющийся цикл, который можно прервать
    либо с помощью оператора EXIT LOOP, либо при наступлении какого-
    либо события (прерывание от активного внешнего устройства, исте-
    чение заданного временного интервала и т.п.).
         Конструкция "WHILE условие" заставляет повторять тело цикла
    до тех пор, пока условие остается истинным. Сочетание "UNTIL ус-
    ловие" приводит к повтору цикла при ложности условия.
         Тело цикла может включать другие циклы, которые принято на-
    зывать внутренними или вложенными по отношению к внешнему циклу.
    Это могут быть как однотипные циклы, организуемые парами FOR -
    NEXT, WHILE - WEND, DO - LOOP, так и смешанные конструкции с лю-
    бым сочетанием типов циклов и количеством их вложений. Если вло-
    женные циклы имеют одинаковую структуру FOR - NEXT, то допуска-
    ется завершать два или более циклов одним оператором NEXT :

                      FOR  K = 1  TO  10
                      FOR  J = 1  TO  20
                      S(K,J) = A(K,J) + B(K,J)
                      NEXT J,K

         Последовательность управляющих переменных при этом задается
    в порядке вложения циклов.


                    2.2.2.Блоки выбора по условию

         Блочная конструкция IF - END IF обобщила первоначальный за-
    мысел оператора условного перехода IF ... THEN . Сначала этот
    оператор предусматривал проверку элементарного логического усло-
    вия и при его истинности передавал управление в указаную точку
    программы :

                     50  IF  A>B  THEN    100

    Если проверяемое условие оказывалось ложным, то выполнение про-
    граммы продолжалось с оператора, следующего за IF.
         На следующем этапе развития языка появилась возможность за-
    давать в операторе IF и альтернативную точку перехода :

                50  IF  A>B  THEN   100   ELSE  200

         Затем последовало радикальное сближение оператора IF ...THEN
    ...ELSE с логическим оператором IF из Фортрана, который в случае
    истинности проверяемого условия допускал использование не только
    операторов перехода (IF (A.GT.B) GOTO 100), но и многих других
    операторов. В результате в Бейсике возникла очередная конструк-
    ция оператора IF :

            IF  условие  THEN  оператор1  ELSE  оператор2

         Несколько расширились возможности условного оператора IF за
    счет применения более сложных логических выражений (см. раздел
    1.4). Однако кульминация этого подхода состояла в том, чтобы раз-
    решить в альтернативных ветвях после служебных слов THEN и ELSE
    выполнять не только по одному оператору. Оставалось только приду-
    мать способ указания начала и конца групп альтернативных действий,
    т.е. ввести эквивалент операторных скобок, существующих в других
    алгоритмических языках (фигурные скобки в "Си", begin и end в ал-
    голоподобных языках и т.п.). Поскольку служебные слова THEN и
    ELSE сами являются разделителями, то для указания конца второй
    группы операторов и был введен признак END IF (допускается и
    слитное написание ENDIF).
         В результате появилась блочная конструкция IF - END IF,
    которая в простейшем случае выглядит следующим образом :

               IF  условие  THEN
                ┌─────────────────────────────┐
                │  Действия, выполняемые при  │
                │      соблюдении условия     │
                │         (Группа 1)          │
                └─────────────────────────────┘

               ELSE
                 ┌─────────────────────────────┐
                 │  Действия, выполняемые при  │
                 │    несоблюдении условия     │
                 │        (Группа 2)           │
                 └─────────────────────────────┘

               END IF

         Выполнение первой группы программных строк, следующих за слу-
    жебным словом THEN, автоматически завершается переходом на END IF,
    т.е. выходом из блока. Поэтому пользователю не требуется завершать
    группу 1 оператором передачи управления на END IF.
         Вторая альтернативная ветвь (группа 2) может отсутствовать.
    При этом признак ее начала - служебное слово ELSE, - также опуска-
    ется. И тогда группа 1 завершается оператором END IF.
         Для построения сложных блоков указанного вида, в которых ко-
    личество разветвлений может быть более двух, используется оператор
    ELSEIF, обеспечивающий проверку дополнительных условий и выполне-
    ние соответствующих действий. Продемонстрируем это на примере ква-
    дратного уравнения, без программы решения которого не обходится
    ни одна книга по Бейсику :

       PRINT "Решение квадратного уравнения A * X^2 + B*X + C = 0"
    Wwod :
       INPUT "Введите коэффициенты A,B,C"; A,B,C
       IF  A = 0 THEN
           PRINT "Степень этого уравнения меньше двух. Повторим :"
           GOTO Wwod
       END IF
       D = B*B - 4*A*C  :  E = 2*A  :  D1 = SQR(ABS(D))
       IF  D = 0 THEN
           PRINT "Имеется два кратных корня :"
           PRINT "X1 = X2 ="; -B/E
       ELSEIF  D > 0  THEN
           PRINT "Имеется два вещественных различных корня :"
           PRINT "X1 ="; (-B + D1)/E
           PRINT "X2 ="; (-B - D1)/E
       ELSE
           PRINT "Имеется два комплексных сопряженных корня :"
           PRINT "Вещественная часть корня ="; -B/E
           PRINT "Мнимая часть корня ="; D1/E
       END IF

         В пределах одного блока IF - END IF может быть использовано
    любое количество конструкций с дополнительными проверками (ELSEIF).
         Выполнение любой из альтернативных групп действий автомати-
    чески завершается выходом из блока.
         На все выше описанные конструкции типа IF - END IF распро-
    страняется общее для блочных структур правило : никаких передач
    извне на внутренние программные строки.
         Включенные в данный раздел сведения о различных модификациях
    оператора IF и путях его эволюции носят не только харарактер ис-
    торической справки. Все эти форматы могут использоваться в любой
    из описываемых версий. Однако блочная конструкция IF - END IF в
    состав входного языка GW BASIC, к сожалению, не попала.


                    2.2.3.Блоки выбора по ключу

         Одним из частных случаев выбора альтернативных решений яв-
    ляется вариант проверки на принадлежность значения арифметичес-
    кого или символьного выражения заданному набору значений. Конеч-
    но, такую проверку можно было бы реализовать с помощью ранее
    описанного блока IF - END IF :

                  IF  e = c1   THEN
                       ┌─────────────────────────────┐
                       │         Группа 1            │
                       │    программных строк        │
                       └─────────────────────────────┘

                   ELSEIF  e = c2  THEN
                        ┌─────────────────────────────┐
                        │        Группа 2             │
                        │   программных строк         │
                        └─────────────────────────────┘

                    ELSEIF  e = c3  THEN
                        ┌─────────────────────────────┐
                        │        Группа 3             │
                        │   программных строк         │
                        └─────────────────────────────┘
                     ...............................
                     END IF

         Однако в структурном программировании предпочитают исполь-
    зовать более изящную конструкцию :

                     SELECT CASE  e
                        CASE  c1
                        ┌─────────────────────────────┐
                        │        Группа 1             │
                        │    программных строк        │
                        └─────────────────────────────┘

                        CASE  c2
                        ┌─────────────────────────────┐
                        │         Группа 2            │
                        │     программных строк       │
                        └─────────────────────────────┘
                       .............................
                        CASE  ELSE
                        ┌─────────────────────────────┐
                        │        Группа n             │
                        │    программных строк        │
                        └─────────────────────────────┘

                     END SELECT


         Блоки такого вида принято называть переключателями, а тес-
    тируемое выражение e, которое может быть числовым или символьным,
    - переключающим выражением.
         Условия проверки, формируемые с помощью операторов CASE,
    могут содержать не только одно ключевое значение. В теле операто-
    ра CASE может быть задано несколько таких значений, разделенных
    запятыми. И в качестве ключей могут выступать любые выражения
    того же типа, что и переключающее выражение :

                   CASE  5+N, 12, -(K+1)

         Второй разновидностью проверяемого условия является проверка
    на принадлежность значения переключающего выражения некоторому
    интервалу. Например, проверка на принадлежность значения x интер-
    валу [a,b] может быть реализована с помощью условия :

                   SELECT CASE  x
                   ..............
                          CASE  a  TO  b
                          ...............

         Наконец, третья модификация проверки значения переключающего
    выражения состоит в использовании самой обычной операции отноше-
    ния. Например, для выполнения действий, когда тестируемое выраже-
    ние превышает заданный порог a, условие выбора может выглядеть
    так :
                           CASE IS  >= a

    Связка IS заменяет в данном случае тестируемое выражение.
         Оператор CASE ELSE позволяет выполнить группу действий в
    случае, когда значение переключающего выражения не "совпало" ни
    с одним из выше указанных ключей.
         Необходимо иметь ввиду, что условия проверок в  блоке
    SELECT - END SELECT  не обязательно должны быть взаимоисключающи-
    ми. Поэтому, если значение переключающего выражения "совпало" с
    одним из ключей и соответствующие этой ситуации действия были
    выполнены, то последующие проверки в теле блока не игнорируются.
    Для того, чтобы прервать все последующие проверки и выйти на ко-
    нец блока, соответствующая группа действий должна заканчиваться
    оператором EXIT SELECT.


                  2.3.Описание нестандартных функций

                       2.3.1.Внутренние функции

         Нестандартные функции принято называть внутренними или ло-
    кальными, если описание соответствующей вычислительной процедуры
    включено в состав того программного модуля, где эта функция ис-
    пользуется.
         Различают одностроковые (точнее, однооператорные) и много-
    строковые внутренние функции. В первом случае формула для вычис-
    ления значения функции должна быть представлена выражением ариф-
    метического или символьного типа, которое записывается в правой
    части оператора DEF FN :

                 DEF  FNnn...nt (x1,x2,...) = e

         Идентификатор функции FNnn...nt должен начинаться с симво-
    лов FN (от FuNction). Этот "пережиток" сохранился от ранних вер-
    сий Бейсика, но зато он позволяет пользоваться функциями без ар-
    гументов, чего нет в других алгоритмических языках. Общее коли-
    чество символов в обозначении функции, включая FN и концевой
    признак типа t (t = { %, !, #, $ }), не должно превышать 40.
         В круглых скобках после имени функции расположен список
    формальных параметров - аргументов функции. В Turbo BASIC'е их
    количество не должно превышать 16. В качестве формальных парамет-
    ров можно указывать только идентификаторы простых переменных. К
    имени аргумента может добавляться символ - указатель типа. В Quick
    BASIC'e наряду с таким способом задания типа формального параметра
    применяется и другой :

        DEF  FNsumma% ( X1 AS REAL, X2 AS REAL) = X1 + X2

         Выражение е, используемое для вычисления значения функции,
    наряду с именами аргументов может включать имена обычных перемен-
    ных программного модуля, указатели стандартных и нестандартных
    функций. Явная (DEF FNfactorial(n) = n * FNfactorial(n-1) ) или
    скрытая (FNA --> FNB --> FNC --> ... --> FNA) рекурсия в описа-
    нии функций запрещена.
         Очень важно подчеркнуть, что идентификаторы, используемые
    для обозначения формальных переменных, не имеют никакого отноше-
    ния к программным переменным с теми же именами. В этом легко убе-
    диться, выполнив следующую программу :

              10 DEF FNA(X,Y) = X + Y
              20 X = 1
              30 Y = 2
              40 Z = FNA(3,4)
              50 PRINT "X=" ; X, "Y=" ; Y, "Z=" ; Z

         Никаких троек или четверок в программных переменных X и Y
    мы не обнаружим, хотя в формальные параметры с аналогичными име-
    нами такие значения подставлялись.
         Если процедура вычисления функции включает проверку различ-
    ных условий, то в некоторых ситуациях можно попытаться построить
    одностроковое определение. Пусть, например :

                y(x) = -x   ,  если  x < 0;
                y(x) = x^2  ,  если  x > 0.

    Не так уж и сложно подобрать некоторый множитель g(x), который
    принимает нулевое значение для отрицательных аргументов и еди-
    ничное - для положительных. Очевидно, что для конструирования
    такой единичной "ступеньки" следует воспользоваться функцией SGN,
    которая тоже имеет форму ступеньки, но немного смещена вниз и
    имеет вдвое большую амплитуду :

                 g(x) = (SGN(x) + 1)/2

         Тогда нашу функцию y(x) можно представить в виде двух сла-
    гаемых :

             y(x) = -x * (1 - g(x)) + g(x) * x^2

    И соответствующее одностроковое определение  функции уже никакого
    труда не составляет.
         Но процедура вычисления функции может оказаться и намного
    более сложной. И в этой ситуации на помощь приходит возможность
    создать многостроковое описание, которая предоставляется пользо-
    вателям Quick- и Turbo-систем. По сути дела, это - блочная кон-
    струкция, обращение к которой производится неявно - в тот момент,
    когда потребовалось значение функции. При прямой передаче управ-
    ления такой блок обходится как и любой декларативный оператор.
         Многостроковая нестандартная функция начинается с заголовка :

                      DEF  FNnn...nt (x1,x2,...)

    Вслед за ним размещается программа вычисления значения функции,
    состоящая из обычных операторов Бейсика. Единственная особенность
    заключается в технике возврата найденного результата. Его надо
    присвоить простой переменной с таким же именем, как и идентифика-
    тор функции. Завершается многостроковое описание нестандартной
    функции оператором END DEF.
         И еще одна особенность - для досрочного выхода из тела фун-
    кции используется оператор EXIT DEF. Продемонстрируем эти сред-
    ства на приводившемся выше примере функции y(x) :

                DEF FNy(x)
                IF  x < 0  THEN  FNy = -x :   EXIT DEF
                FNy = x^2
                END DEF

         Конечно, в данном примере можно было построить и другое
    описание :

                DEF FNy(x)
                IF  x < 0  THEN  FNy = -x   ELSE  FNy = x^2
                END DEF


                        2.3.2.Внешние функции

         Возможность описать нестандартную функцию в виде внешней
    процедуры со своими локальными переменными и со своей внутренней
    идентификацией программных строк имеется только в Quick BASIC'e.
         В отличие от внутренних функций внешнюю процедуру можно ав-
    тономно откомпилировать и использовать полученный об'ектный модуль
    либо как самостоятельную программную единицу, либо в составе биб-
    лиотеки. К услугам внешней процедуры-функции может обратиться лю-
    бая Бейсик-программа, тогда как внутренняя функция доступна лишь
    тому модулю, где она определена.
         Описание внешней функции начинается с заголовка :

         FUNCTION name [(V1[()] [AS type1]
                      [,(V2[()] [AS type2] ... ] [STATIC]

    В отличие от внутренних функций идентификатор внешней функции мо-
    жет начинаться с любых символов. Он может содержать до 40 симво-
    лов, включая концевик, определяющий тип функции.
         Заголовок внешней функции может включать описание типов ар-
    гументов, среди которых в отличие от внутренних функций могут
    присутствовать и имена массивов, сопровождаемые пустыми круглы-
    ми скобками.
         Указатель STATIC, завершающий заголовок, употребляется в
    тех случаях, когда необходимо сохранить значения локальных пере-
    менных между двумя последовательными обращениями к функции. Пе-
    ред первым обращением к внешней функции все ее локальные перемен-
    ные сброшены в начальное состояние (нулевые значения для числовых
    переменных и пустые значения - для символьных).
         Во всем остальном тело внешней функции мало чем отличается
    от многостроковой внутренней функции. Здесь тоже должен присут-
    ствовать оператор присваивания, возвращающий результат вычислений.
    Для досрочного выхода из процедуры используется оператор EXIT
    FUNCTION. А завершается тело внешней функции оператором END FUN-
    CTION.
         Для внешних функций система Quick BASIC допускает рекурсивные
    обращения :

                       FUNCTION  Fact# (N%)
                          IF  N% > 1 THEN
                              Fact# = N% * Fact#(N% - 1)
                          ELSE
                              Fact# = 1
                          END IF
                       END FUNCTION


         Отметим еще две важные детали, связанные с использованием
    внешних функций. Во-первых, в программе, использующей внешнюю
    функцию с именем f, должен присутствовать декларативный оператор :

     DECLARE FUNCTION  f [ CDECL ] [ ALIAS "name1" ]
             [ ( [ BYVAL | SEG ] V1 [()] [ AS type1 | ANY ]
             [,( [ BYVAL | SEG ] V21[()] [ AS type2 | ANY ] ...])]

         Такое об'явление позволяет выделить идентификатор f и не пу-
    тать его с именами других об'ектов в случае отсутствия у функции
    аргументов. В связи с тем, что вызываемая функция может быть на-
    писана не только на Бейсике, но и на других алгоритмических язы-
    ках, в операторе присутствуют два межязыковых указателя - CDECL
    и ALIAS. Первый из них означает, что вызываемая функция придер-
    живается способа передачи аргументов, принятого в системе прог-
    раммирования "Си". Второй указатель сопровождается заданием до-
    полнительного имени name1, которое может оказаться необходимым
    для поиска вызываемого модуля среди отдельных файлов с расшире-
    нием .OBJ или в библиотечном файле.
         Дело в том, что в разных системах программирования исполь-
    зуются различные правила идентификации программных единиц. В од-
    них случаях имя модуля может иметь до 40 символов (Бейсик), в
    других случаях длина идентификатора регулируется ("Си"), Фортран
    использует шестисимвольные обозначения, а в файловой системе MS
    DOS имя модуля не может содержать более 8 знаков. Возможность
    указать дополнительное эквивалентное имя модуля позволяет в ка-
    кой-то степени согласовать такие разночтения.
         Повторение описания типов аргументов, в точности совпадающее
    с соответствующим фрагментом заголовка внешней функции, обеспечи-
    вает возможность проконтролировать правильность обращений по типу
    и количеству параметров. Контроль за соответствием типов может
    быть отключен, если вместо описания типа (AS type) стоит указание
    ANY (любой).
         Кроме того, перед каждым параметром может быть задан один из
    двух указателей BYVAL или SEG. Первый из них указывает на способ
    передачи соответствующего аргумента по значению (by value). В
    этом случае значение фактического аргумента при необходимости вы-
    числяется и переносится в ту область памяти внешней процедуры,
    которая отведена для хранения соответствующего формального пара-
    метра. Сочетание указателей ANY и BYVAL недопустимо. Во втором
    случае (SEG) вместо значения аргумента передается его адрес в
    виде двухбайтового смещения от начала сегмента данных. Имена мас-
    сивов передаются только по адресу.
         Вторая особенность связана с тем, что обмен данными между
    внешней функцией и вызывающей программой не ограничивается только
    механизмом передачи параметров. Функция может иметь доступ к гло-
    бальным переменным вызывающего модуля, если они между собой "до-
    говорились" о совместном использовании общих переменных. С этой
    целью в теле функции может находиться оператор SHARED :

       SHARED  V1 [ AS type1 ][, V2 [ AS type2 ] ...]

    Здесь имена V1,V2,... - идентификаторы переменных вызывающего мо-
    дуля, которыми пользуется внешняя функция без их передачи в каче-
    стве параметров. Среди совместных переменных, об'являемых по опе-
    ратору SHARED, могут находиться и массивы. Тогда их идентификато-
    ры в списке сопровождаются пустыми круглыми скобками :

           SHARED  Alpha() AS INTEGER, Beta() AS STRING

         Другой вариант совместного доступа к общему участку памяти
    реализуется с помощью оператора COMMON. Однако в этом случае опе-
    ратор COMMON должен появиться не только в теле внешней функции,
    но и в составе вызывающего модуля. В Quick BASIC'e этот оператор
    имеет следующий формат :

           COMMON [ SHARED ] [ /name_block/ ]
                             V1 [(ind11,...)] [ AS type1]
                          [, V2 [(ind21,...)] [ AS type2], ... ]

    Указатель SHARED в данной ситуации означает, что переменные (мас-
    сивы) с именами V1,V2,... доступны для всех процедур модуля.
         Идентификатор name_block, заключаемый в косые скобки, ис-
    пользуется для обозначения блока общей памяти, в который об'яв-
    ляющий модуль помещает свои переменные (массивы). Отсутствие это-
    го параметра допустимо только в том случае,когда для размещения
    общих переменных используется непоименованный блок общей памяти.
         Порядок переменных (массивов) в списке оператора COMMON ва-
    жен, т.к. именно в этой последовательности об'екты размещаются в
    указанном блоке.
         Если два модуля, например, вызывающий модуль и внешняя функ-
    ция используют один и тот же блок общей памяти, то каждый из них
    должен содержать по оператору COMMON с указанием имени этого бло-
    ка. Можно совместно использовать и безымяный блок, но и в этом
    случае форматы операторов COMMON должны быть согласованы.
         Что же касается обозначения общих переменных (массивов), то
    каждому модулю предоставляется право именовать их по своему. Это
    упрощает работу программиста, т.к. не надо согласовывать имена
    об'ектов, используемых при написании программ. Но порядок разме-
    щения совместно используемых величин в блоке общей памяти эти
    программы должны обязательно соблюдать, и соответствие типов
    данных должно быть обеспечено. В этом и заключается основное раз-
    личие между операторами COMMON и SHARED.



