                  3. ОРГАНИЗАЦИЯ МАТЕМАТИЧЕСКИХ ВЫЧИСЛЕНИЙ

             3.1. Способы формирования и изменения значений числовых
                                  переменных

         Исходные данные, промежуточные и окончательные результаты вы-
    числений составляют тот набор значений, которые приходится разме-
    щать и в течение некоторого времени хранить в соответствующих пе -
    ременных.
         Для формирования заранее известных значений в числовых пере -
    менных обычно прибегают к процедуре ввода нужной информации,кото -
    рая может быть прочитана из буфера клавиатуры, из файла данных,
    расположенного на гибком или жестком магнитном диске, из блока
    данных, предварительно сформированного в оперативной памяти.
         Если значение переменной должно быть получено в результате
    вычисления по арифметической формуле, то его запись в область опе-
    ративной памяти, выделенную для хранения переменной, производится
    с помощью оператора присвоения.


             3.1.1. Использование внутренних блоков данных


         Блок числовых данных можно представить себе как одномерный
    массив, расположенный в оперативной памяти. Последнее обстоятель-
    ство является основанием назвать этот блок внутренним. Запоминание
    указанного массива ведется в процессе предварительной обработки
    текста исходной программы до ее запуска на счет. Как только в про-
    грамме встречается оператор DATA, то все константы, перечисленные
    в его теле, переносятся в специально отведенную область памяти.
    Порядок их размещения в блоке данных в точности повторяет порядок
    их следования в списке оператора DATA :

               DATA   c1, c2,....

    Первая константа c1 становится первым элементом блока данных, вто-
    рая константа с2 - вторым элементом и т.д.
         В программе может встретится не один оператор DATA, и тогда
    очередная числовая порция заносится в блок данных вслед за предше-
    ствующей. Порядок переноса таких порций соответствует последова-
    тельности расположения операторов DATA в тексте программы. Сформи-
    рованный таким образом блок данных может быть использован в каче -
    стве поставщика числовых значений переменных арифметического типа
    во время выполнения программы. Сами же операторы DATA относятся к
    декларативным и во время работы программы их обходят. Характерной
    особенностью блока данных является последовательный доступ к его
    элементам. В момент запуска программы на счет в состоянии готовно-
    сти приводится числовое значение, которое попало в блок данных пер-
    вым. Иными словами это - первая константа самого первого оператора
    DATA.После выборки этого значения доступной становится следующая
    константа и т.д.
         Для извлечения числовых значений из блока данных предназначен
    оператор  READ :

                READ  V1, V2,...

    Он последовательно удовлетворяет переменные своего списка, извлекая
    очередное доступное значение из блока данных и перемещая его в об -
    ласть памяти, отведенную для хранения переменой. Выполнение этой
    процедуры, при необходимости, может сопровождаться преобразованием
    машинного формата числовой константы к тому виду, который соответ-
    ствует типу переменной.
         Попытка извлечь из блока данных хотя бы еще одно значение пос-
    ле того, как уже была прочитана последняя константа, расценивается
    как ошибка периода выполнения и приводит к аварийному завершению
    программы.
         Третьим оператором, который участвует в обслуживании блока
    данных, является оператор RESTORE :

                     RESTORE  [N]

    Без операнда N этот оператор приводит блок данных в первоначаль-
    ное состояние, при котором очередным доступным значением становит-
    ся самая первая константа. Если операнд задан, то в GW BASIC'e им
    может быть номер программной строки, в которой находится оператор
    DATA, а в двух других версиях вместо числового номера может быть
    задана метка аналогичной строки. После выполнения такого оператора
    RESTORE  очередным доступным значением становится первая константа
    числовой порции указанного оператора  DATA.
         Оператор RESTORE может быть применен на любой стадии "опусто-
    шения" блока данных. Даже, если  мы из блока данных еще ни одного
    значения и не извлекали.


                3.1.2. Ввод данных по запросу программны


         Требование на ввод данных с клавиатуры или из файла последова-
    тельного доступа реализуется путем включения в программу оператора
    INPUT :

             INPUT [;] ["text"{;|,}] V1,V2,...
             INPUT #n, V1,V2,...

    Здесь text - произвольный текcт, который в случае ввода с клавиа-
                 туры выдается на терминал и играет роль подсказки для
                 пользователя;
          V1,V2... - список переменных, которым присваиваются вводимые
                     значения;
          n - номер файла с последовательным доступом, из которого дол-
              жна быть считана очередная порция данных.

         В связи с тем, что процедуры обмена с файлами более подробно
    описываются в главе 5, мы остановимся здесь только на деталях вво-
    да данных с клавиатуры.
         Выполнение оператора INPUT начинается с приостанова работы
    программы . В этот момент на экране дисплея появляется сообщение,
    заданное параметром text, вслед за которым в этой же строке или
    в начале следующей возникает вопросительный знак. Позиция, в кото-
    рой появляется символ "?", зависит от наличия или отсутствия сим-
    вола ";" сразу после наименования оператора. Если тело оператора
    начинается с точки с запятой, то вопрос появляется в той же стро-
    ке, что и подсказка text. Если в качестве разделителя, стоящего
    вслед за параметром text, используется запятая, то выдача вопро-
    сительного знака отменяется.
         После появления на экране указанного приглашения пользователь
    должен набрать необходимое количество числовых значений, разделяя
    их запятыми. Набор последнего числа завершается нажатием клавиши
    Enter. В системе Turbo BSAIC в качестве разделителя можно исполь-
    зовать и пробел. Если количество данных не соответствует длине
    списка перемнных, то GW- и Quick-системы реагируют одинаково. Они
    выдают повторное приглашение :

                         ?Reado from start

    И теперь ввод данных придется начать заново. Эта же ситуация воз-
    никнет и в том случае, если произведен набор недопустимой числовой
    константы (число содержит нечисловые символы, выходит за пределы
    допустимого диапазона и т.д.).
         В Turbo-системе количество вводимых данных может не совпадать
    с длиной списка переменных. Лишние данные будут проигнорированы,
    а в случае нехватки числовых данных оставшимся переменным присво-
    ятся нулевые значения.


              3.1.3.Изменение значений переменных по результатам
                                  вычислений

         Засылка значения арифметического выражения в область, выде-
    ленную для хранения числовой переменной, носит название процедуры
    присваивания и реализуется с помощью оператора присваивания :

                       [ LET ]  V = e

    Слева от знака равенства указывается идентификатор скалярной пере-
    менной или элемента массива, а справа - любое арифметическое выра-
    жение. Наименование оператора (LET) можно не писать, и это - един-
    ственный оператор в Бейсике, который может начинаться не со слу-
    жебного слова.
         Допускается, чтобы типы числовой переменной V и арифметичес-
    кого выражения e не совпадали. В этом случае система осуществляет
    автоматическое преобразование числового значения из одного форма-
    та представления  в другой. Никаких округлений при этом не проис-
    ходит. Для того, чтобы округлить результат вычислений по общепри-
    нятым в математике правилам, можно воспользоваться соответствующей
    функцией преобразования типов данных - CINT, CLNG, CSNG, CDBL (см.
    раздел 1.2.6).
         Кроме оператора присваивания в Бейсике существует оператор
    SWAP, позволяющий двум переменным одного типа обменяться своими
    значениями :

                          SWAP       V1, V2

    По сути дела, один оператор SWAP заменяет три оператора LET, ис-
    пользующих для этой же цели еще и вспомогательную переменную V3 :

                           LET   V3 = V1
                           LET   V1 = V2
                           LET   V2 = V3

         Turbo BASIC предлагает еще два оператора, с помощью которых
    можно увеличить (INCR) или уменьшить (DECR) значение переменной V
    на заданную величину dV. По умолчанию величина приращения считает-
    ся равной 1 :

              INCR  V        эквивалентно      LET V = V + 1
              INCR  V,dV     эквивалентно      LET V = V + dV
              DECR  V        эквивалентно      LET V = V - 1
              DECR  V,dV     эквивалентно      LET V = V - dV


                 3.1.4.Стандартные математические функции

         Перечень математических функций, которые можно использовать
    в качестве операндов арифметических выражений, приведен в табл.9.
    В большинстве случаев наименование функции совпадает с ее обще-
    принятым математическим обозначением. Однако некоторые детали
    нуждаются в комментариях.

                                                   Таблица 9
     ┌────────────┬───────────────────────────────────────────────────
     │ Функция    │                      Назначение
     ├────────────┼───────────────────────────────────────────────────
     │ ABS (X)    │   Вычисление модуля  │ Х │
     │ ATN (X)    │   Вычисление арктангенса arctg(X)
     │ CEIL (X)   │   Нахождение ближайшего целого, превосходящего X
     │ COS (X)    │   Вычисление косинуса cos(X)
     │ EXP (X)    │   Вычисление экспоненты  e^X
     │ EXP10 (X)  │   Вычисление экспоненты 10^X
     │ EXP2 (X)   │   Вычисление экспоненты  2^X
     │ FIX (X)    │   Выделение целой части X
     │ INT (X)    │   Нахождение ближайшего целого, не превосходящего X
     │ LOG (X)    │   Вычисление натурального логарифма ln(X)
     │ LOG10 (X)  │   Вычисление десятичного логарифма log(X)
     │ LOG2 (X)   │   Вычисление двоичного логарифма от X
     │ RND [(X)]  │   Генерация очередного случайного числа
     │ SGN (X)    │   Определение знака X :
     │            │               SGN(X) = -1, если X < 0
     │            │               SGN(0) =  0, если X = 0
     │            │               SGN(X) = +1, если X > 0
     │ SIN (X)    │   Вычисление синуса sin(X)
     │ SQR (X)    │   Извлечение квадратного корня из X
     │ TAN (X)    │   Вычисление тангенса tg(X)
     └────────────┴───────────────────────────────────────────────────

         Первое обстоятельство связано с точностью вычисления значе-
    ния функции. В GW BASIC'е точность устанавливается в момент запус-
    ка системы (см. главу 7). Поэтому все стандартные функции выдают
    свои значения либо с одинарной точностью, либо с удвоенной. В Tur-
    bo-системе вычисления значений всех функций ведутся с удвоенной
    точностью, а лишние значащие цифры могут быть отброшены в момент
    присваивания или вывода. Система Quick BASIC подстраивает точность
    вычисления функции под тип аргумента. Если последний имеет удвоен-
    ную точность, то с таким же количеством значащих цифр выдается и
    значение функции.
         Аргументом математических функций может быть арифметическое
    выражение любого числового типа. Для тригонометрических функций
    типа SIN, COS и TAN аргумент задается в радианах. Результат вы-
    числения обратной тригонометрической функции ATN также выдается
    в радианах.
         Аргумент функций LOG, LOG10 и LOG2 должен быть положительным.
    Это же относится и к функции SQR, однако квадратный корень из ну-
    ля извлечь можно.
         Функции CEIL, FIX и INT используются для манипуляций над ве-
    щественными аргументами, в результате которых можно выделить це-
    лую или дробную части числа, произвести его округление в нужном
    разряде. Продемонстрируем эти возможности на конкретных примерах :

                 INT (1.1) = 1             CEIL (1.1) = 2
                 INT (1.9) = 1             CEIL (1.9) = 2
                 INT (-1.1) = -2           CEIL (-1.1) = -1
                 INT (-1.9) = -2           CEIL (-1.9) = -1

                 INT (1.1 + 0.5) = 1       INT (-1.1 + 0.5) = -1
                 INT (1.9 + 0.5) = 2       INT (-1.9 + 0.5) = -2

                 INT(1.481 * 100 + 0.5) / 100 = 1.480
                 INT(-1.481 * 100 + 0.5) / 100 = -1.480
                 INT(1.486 * 100 + 0.5) / 100 = 1.490
                 INT(-1.486 * 100 + 0.5) / 100 = -1.490

         Функция RND вызывает служебную подпрограмму, генерирующую
    очередное случайное число из интервала (0,1). Ее алгоритм преду-
    сматривает выдачу чисел с равномерным законом распределения и в
    зависимости от знака аргумента X позволяет :
      - выдать очередное случайное число (при X > 0);
      - повторить выдачу предыдущего "случайного" числа (при X = 0);
      - начать цикл генерации "случайных" чисел заново (при X < 0).
    Эта функция является уникальной в том смысле,что ее можно употре-
    бить и без аргумента :

                  Y = INT (RND * (K + 1))

    В этом случае она действует точно так же, как и с положительным
    аргументом. Кстати, приведенный пример демонстрирует возможность
    получать целые случайные числа из диапазона [0, K].
         Любой запрограммированный алгоритм генерации случайных чисел
    имеет вполне определенный цикл, после прохождения которого полу-
    ченный ряд "случайных" чисел повторяется. Обычно в таких програм-
    мах в качестве стартовых исходных данных используют одну или две
    константы, и, если в алгоритм не вносить никаких изменений, то
    очередной запуск датчика случайных чисел будет повторять те же са-
    мые значения, которые получались и раньше. Таким образом, распеча-
    тав один раз эту цепочку или ее начало, в следующий раз мы сможем
    точно предсказать очередное случайное число.
         При отладке программы, использующей датчик случайных чисел,
    возможность повторить прохождение программы на одном и том же на-
    боре данных полезна. Однако во время эксплуатации такой программы
    возможность предсказать очередное "случайное" событие вряд ли кого
    обрадует. Поэтому входной язык предоставляет пользователю средство
    "возмутить" стартовые константы таким образом, чтобы и само возму-
    щение тоже носило достаточно случайный характер. Достигается это
    путем включения в программу оператора RANDOMIZE :

                         RANDOMIZE
                         RANDOMIZE   e%
                         RANDOMIZE   TIMER

         В случае отсутствия аргумента система обратится к пользовате-
    лю с просьбой ввести целое число из диапазона [-32768, 32767]. Это
    число, или заданное значение арифметического выражения e% , или по-
    казатель таймера используются для перенастройки текущих параметров
    датчика случайных чисел. После выполнения оператора RANDOMIZE фун-
    кция RND начинает выдавать числа, которые с гораздо большим основа-
    нием можно называть случайными.
         Очень интересный пример перенастройки генератора случайных чи-
    сел для игровых программ приведен в руководстве по Turbo BASIC'у :

            MTIMER
            PRINT "Для начала игры нажмите любую клавишу"
            WHILE NOT INSTAT : WEND
            RANDOMIZE  MTIMER

    Первая строка сбрасывает микротаймер Turbo-системы, после чего он
    начинает отсчет времени до момента нажатия любой клавиши. Индика-
    тором последнего события служит появление отличного от нуля значе-
    ния в системной переменной INSTAT. Таким образом, стартовая величи-
    на, влияющая на выработку первого случайного значения, зависит от
    реакции пользователя.


                     3.2.Вывод результатов вычислений

         Результаты вычислений, предназначенные для визуального кон-
    троля за ходом решения задачи, выдаются на экран дисплея с помощью
    одного из операторов PRINT или PRINT USING. Если итоговые резуль-
    таты предназначены для включения в состав отчетной документации,
    то для их оформления используются операторы LPRINT или LPRINT
    USING, осуществляющие вывод данных на принтер.
         Выводимая числовая информация может сопровождаться различны-
    ми пояснительными текстами, которые либо заготавливаются заранее,
    либо формируются в процессе выполнения программы.
         Отображению числовых данных на дисплее могут предшествовать
    стирание прежнего содержимого экрана и позиционирование курсора.
    Первая процедура выполняется с помощью оператора CLS. Для перево-
    да курсора в позицию экрана, с которой начнет отображаться выводи-
    мая информация, используется оператор LOCATE :

            LOCATE  [ nr ][,[ nc ][,i ][,[ start ][,stop ]]]

    Здесь  nr - номер строки (от 1 до 25);
           nc - номер столбца (от 1 до 80);
            i - признак видимости (i=1) или невидимости (i=0) курсора;
        start - номер начальной строки в минирастре знакоместа;
         stop - номер конечной строки в минирастре знакоместа.
    Два последние параметра управляют габаритами курсора и его распо-
    ложением в знакоместе - прямоугольной области экрана, отводимой
    для размещения одного символа. В зависимости от типа дисплея и ус-
    тановленного режима его работы знакоместо представлено матрицей
    точек размером 8х8, 8х14 или 8х16.
         В GW и Quick BASIC'е имеется возможность разделить экран на
    две или три горизонтальные полосы, в одной из  которых выводится
    текстовая информация, а в оставшейся части экрана - графическая.
    Указание границ текстового экрана осуществляется с помощью опера-
    тора VIEW PRINT :

                         VIEW PRINT  r1 TO r2

    При этом вывод числовых и символьных данных будет происходить в
    окне, начиная со строки r1 и кончая строкой r2.

           3.2.1.Вывод числовых данных по стандартному формату

         Стандартный формат вывода предполагает, что текущая строка
    на дисплее или принтере, предназначенная для отображения числовой
    информации разделена на зоны длиной по 14 позиций. Всего таких
    зон шесть, но на последнюю зону остается всего 10 позиций.
         Вывод по стандартному формату организуется с помощью опера-
    торов PRINT или LPRINT :

                    PRINT   [ a1{;|,| } a2{;|,| }...]
                    LPRINT  [ a1{;|,| } a2{;|,| }...]

    В качестве элементов выводного списка a1,a2,... могут выступать
    арифметические выражения любого типа, текстовые константы или ре-
    дактирующие указатели. Каждый элемент выводного списка завершает-
    ся символом-разделителем, в качестве которого можно использовать
    запятую, точку с запятой, пробел или один из двух признаков конца
    оператора - двоеточие или управляющий символ "возврат каретки".
         Во время выполнения оператора PRINT (LPRINT) значения число-
    вых выражений или текстовых констант переносятся в выводную строку.
    Важным элементом этого процесса является специальный системный ука-
    затель, который "смотрит" на очередную свободную позицию выводной
    строки и по мере ее заполнения перемещается вправо. Его поведение
    напоминает перемещения курсора на экране дисплея во время набора
    строки или пишущего узла принтера во время вывода.
         В момент запуска программы выводная строка заполнена пробела-
    ми, а указатель смотрит на первую позицию, т.е. на самую левую по-
    зицию первой зоны. Если вывод начинается с числового элемента, то
    начальная позиция рассматривается как знаковая и заполняется про-
    белом для положительного значения. После переноса отображаемого
    числа указатель перемещается на ближайшую справа свободную позицию
    выводной строки. На дальнейшее перемещение указателя влияет сим-
    вол-разделитель, расположенный вслед за обработанным числовым зна-
    чением.
         Если им оказалась запятая, то указатель переводится в первую
    позицию следующей зоны выводной строки. Именно отсюда и будет рас-
    положено значение очередного элемента выводного списка. Если пра-
    вее текущего положения указателя не осталось ни одной зоны, то за-
    полненная выводная строка отображается на дисплее или принтере.
    После этого строка чистится, а указатель возвращается в ее началь-
    ную позицию.
         Если в качестве разделителя была использована точка с запя-
    той или пробел, то после переноса числового значения указатель вы-
    водной строки перемещается вправо дополнительно на одну позицию.
    Таким образом между двумя смежными значениями на выводе образуется
    только один пробел. Точка с запятой после текстовой константы к до-
    полнительному сдвигу указателя не приводит.
         В случае, когда значение очередного элемента списка оператора
    PRINT (LPRINT) не помещается в оставшейся части строки, теущее со-
    держимое выводной строки отображается на экране дисплея (принтере),
    и вывод продолжается с начальной позиции следующей строки.
         Если очередной элемент списка завершается признаком конца
    оператора, то выводная строка отображается независимо от степени
    ее заполнения и приводится в свое первоначальное состояние.
         Указатель  можно переместить в произвольную позицию выводной
    строки с номером n (0 < n < 81), расположенную справа от текущего
    положения указателя. Осуществляется это путем включения редактиру-
    ющей функции TAB(n) в качестве элемента выводного списка :

            PRINT  TAB(5), "X="; X, TAB(30); "SIN(X)="; SIN(X)

    Знак препинания после функции TAB(n) не вызывает никакого дополни-
    тельного перемещения указателя и может вообще отсутствовать.
         Если элементом выводного списка оказывается другая редактиру-
    ющая функция SPC(n), то n позиций выводной строки, начиная с теку-
    щего положения указателя, заполняются пробелами. В каком-то смысле
    функции TAB(n) и SPC(n) приводят к одинаковому результату, только
    в первом случае отсчет позиций выводной строки осуществляется в
    абсолютных единицах, а во втором - в относительных.
         Если последний элемент выводного списка завершается запятой,
    точкой с запятой, функциями SPC или TAB, то следующий оператор
    PRINT (LPRINT) продолжит вывод в той же строке с позиции, в кото-
    рой находится указатель.
         Физически реализация вывода на дисплей или принтер носит не-
    сколько иной характер, нежели описанная выше технология переноса
    данных в выводную строку. Оба эти устройства располагают буферной
    памятью с принципиально разными схемами управления. Запись инфор-
    мации в буферную память дисплея (видеопамять) сопровождается мгно-
    венным появлением выводимых данных на экране дисплея. В отличие от
    этого принтер - устройство гораздо более медленное, и выводимая
    информация сначала накапливается в его буфере, а уж потом из ЭВМ
    поступит команда на отображение содержимого буфера. Исключая мел-
    кие технические детали, буфер принтера можно рассматривать как фи-
    зический эквивалент выводной строки. У него действительно есть
    аналог указателя, позицию которого можно опросить с помощью функ-
    ции LPOS(n). В GW BASIC'е аргумент функции носит фиктивный харак-
    тер, тогда как в двух других системах он задает номер опрашиваемо-
    го принтера (n=1,2,3).
         Бейсик-системы оперируют с выводной строкой, длина которой по
    умолчанию равна 80 позициям. С помощью оператора WIDTH длину стро-
    ки можно изменить.
         Для дисплея эта процедура выполняется следующим образом :

                        WIDTH  [ nc ][,nr ]

    Здесь  nc - количество столбцов, которое может принимать значение
                40 или 80;
           nr - количество строк, которое в зависимости от типа дисп-
                лея может быть равно 25,30,43,50 или 60 (по умолчанию
                nr = 25).
    Уменьшение количества столбцов до 40 сопровождается увеличением
    ширины символов примерно вдвое, так как физические размеры экрана
    при этом не меняются.
         Для принтера длина выводной строки изменяется одним из сле-
    дующих операторов :

                        WIDTH  LPRINT, nc
                        WIDTH "LPT1:", nc
                        WIDTH "LPT2:", nc
                        WIDTH "LPT3:", nc

    Количество позиций в строке выбирается в зависимости от техничес-
    ких ограничений принтера - ширина бумаги, тип установленного или
    загруженного шрифта.
         Стандартный формат печати числовых данных автоматически учи-
    тывает тип и величину значения элемента списка. Во всех трех сис-
    темах целочисленные значения, принадлежащие соответствующему диа-
    пазону, выдаются в формате целых чисел. Для вещественных значений
    с одинарной и удвоенной точностью формат вывода в каждой из систем
    имеет свои особенности.
         В GW-системе для числовых значений с одинарной точностью дей-
    ствует следующее правило. Если количество значащих цифр, включая
    лидирующие нули в дробном числе, не превышает семи, то использует-
    ся формат вывода с фиксированной точкой. В противном случае веще-
    ственное число выводится в формате с плавающей точкой :

                           -b.bbb...E+pp

    И в том, и в другом случае количество выводимых значащих цифр не
    превышает семи (незначащие нули в хвосте числа подавляются).
    Для вещественных значений с удвоенной точностью, выводимых с фик-
    сированной точкой, количество значащих цифр может достигать 16. В
    формате с плавающей точкой указатель порядка "E" заменяется симво-
    лом "D".
         Очень похожие правила вывода числовых значений приняты и в
    Quick BASIC'е. Некоторые расхождения в точности выводимых значений
    об'ясняются разными способами хранения числовых данных в GW- и
    Quick-системах.
         В Turbo-системе вещественные значения с одинарной точностью,
    принадлежащие диапазону [0.1 , 1E15], выводятся в формате с фикси-
    рованной точкой и могут содержать до 16 значащих цифр, из которых
    верными являются только семь. В остальных случаях вещественные чи-
    сла выводятся в формате с плавающей точкой и содержат 16 значащих
    цифр, из которых доверять можно только первым семи :

                    -b.bbbbbbbbbbbbbbbE+ppp

    Для вещественных чисел удвоенной точности в Turbo BASIC'е исполь-
    зуются аналогичные форматы, но доверять уже можно 16-17 значащим
    цифрам.
         Следует обратить внимание на один важный нюанс, связанный с
    выводом текстовой информации, содержащей русские буквы. Так назы-
    ваемая "русификация" дисплея и принтера выполняется разными прог-
    раммно-техническими средствами. Их необходимо задействовать, преж-
    де чем начать сеанс работы с Бейсиком. Особенно важно проследить
    за принтером, так как его "русификация" иногда выполняется путем
    программной загрузки шрифта в буферную память, которая стирается
    при отключении питания.


                      3.2.2.Потоковый вывод данных

         В отличие от описанного выше зонного расположения данных в
    выводной строке имеется возможность сгруппировать отображаемую ин-
    формацию в виде потока или списка значений. Два смежных значения в
    таком списке разделяются запятой, а текстовые величины в дополне-
    ние к тому окаймляются кавычками. Завершается выводная строка уп-
    равляющими символами CR ("возврат каретки") и LF ("новая строка").
         Поток данных, состоящий из строк описанной структуры, форми-
    руется операторами WRITE :

                         WRITE  a1, a2, ...

    Элементами выводного списка здесь могут быть любые выражения ариф-
    метического или символьного типов.
         К выводу потока на экран дисплея прибегают крайне редко. Го-
    раздо чаще операторами WRITE пользуются для вывода данных на внеш-
    ние запоминающие устройства, откуда их можно извлекать подобно то-
    му, как считываются значения из списка оператора DATA.


              3.2.3.Использование нестандартного формата при
                        выводе результатов вычислений

         Зонный формат вывода числовой информации не позволяет полу-
    чать качественные документы в форме привычных таблиц из-за того,
    что отображаемые значения прижимаются к левой границе зоны. При
    этом одноименные разряды данных, расположенных в одной колонке,
    оказываются смещенными, разброс значений нарушает однообразие в
    формате представления чисел, отображение слишком большого количе-
    ства цифр приводит к захвату смежной зоны и искривлению колонок
    таблицы.
         Нестандартный формат вывода, задаваемый пользователем, дает
    ему возможность самому решать, в каком месте выводной строки раз-
    местить то или иное числовое значение, сколько цифр должно быть
    отведено в целой и дробной частях, следует ли сопровождать отобра-
    жаемое число знаком плюс и где его расположить, подавлять или не
    подавлять в выводимом значении лидирующие нули и т.п. С этой целью
    нестандартная структура выводной строки описывается при помощи
    шаблона, задаваемого в теле оператора PRINT (LPRINT) USING :

              PRINT USING   { c$ | e$ }; a1, a2, ...
              LPRINT USING  { c$ | e$ }; a1, a2, ...

         Выводная строка при этом представляется как последовательность
    полей, предназначенных для размещения информации трех типов :
      - значений числовых выражений, являющихся элементами выводного
        списка (числовые поля);
      - значений символьных выражений, являющихся элементами выводного
        списка (символьные поля);
      - произвольных текстовых констант, включенных в состав шаблона
        между описаниями числовых и символьных полей (литеральные
        поля).
    Как правило, каждый символ шаблона, заданного значением символьной
    константы c$ или символьного выражения  e$, соответствует одной
    позиции выводной строки.
         Для описания структуры числовых полей в шаблоне применяется
    следующий набор символов :

                    #   .   ^   +   -   *   $  ,  _

         Знак номера (#) обозначает цифровую позицию, которая в случае
    необходимости может быть заполнена пробелом, знаком числа, знаком
    денежной единицы ($) или звездочкой (*).
         Точка в описании числового поля задает позицию десятичной точ-
    ки, отделяющей целую часть числа от дробной. Например, шаблон вида
    "#####" задает описание поля, отводимого под целочисленное значе-
    ние, тогда как шаблон "##.###" предусматривает вывод числа с тремя
    цифрами в дробной части.
         Четыре подряд идущих знака возведения в степень (^^^^) опре-
    деляют местоположение порядка числа (E+pp или D-pp) в случае выбо-
    ра формата с плавающей точкой. Например :

         PRINT USING "###.###^^^^";-12345    -->  -12.345E+03

         Знак плюс заставляет систему выводить символ "+" у положи-
    тельного числа вместо заполнения соответствующей позиции пробелом.
    Знаки плюс или минус могут находиться как в начале описания число-
    вого поля, так и в конце. В первом случае знак числа выводится пе-
    ред старшей значащей цифрой числа или перед десятичной точкой, ес-
    ли число чисто дробное. Во втором случае - в самой правой позиции
    поля.
         Две звездочки, расположенные в начале описания числового поля,
    приводят к заполнению символом "*" лидирующих нулей. Обычно же та-
    кие нули подавляются пробелами.
         Комбинация $$ в начале шаблона числового поля вызывает появ-
    ление знака денежной единицы перед старшей значащей цифрой числа.
    Сочетание **$ в первых трех позициях шаблона указывают на необхо-
    димость заполнения звездочками лидирующих нулей и вывода знака
    доллара перед старшей значащей цифрой.
         Запятая в описании числового поля используется для придания
    большей наглядности отображаемому значению :

           PRINT USING "#,###,###"; 1E6    -->   1,000,000

         Значение арифметического выражения округляется, преобразуется
    к формату, заданному описанием числового поля, и размещается на
    соответствующих позициях выводной строки с прижимом к правой гра-
    нице поля. Это обеспечивает необходимую стройность при выводе таб-
    личных документов.
         Может оказаться, что количество знаков в выводимом значении
    превышает число позиций, содержащихся в описании соответствующего
    числового поля. Тогда в выводной строке резервируется необходимое
    количество дополнительных позиций и перед отображаемым значением
    помещается знак процента :

              PRINT USING ".##"; 0.999    -->      %1.00

         В качестве описателя текстовых полей в шаблоне вывода могут
    использоваться либо цепочка из n пробелов, окаймленная символами
    "\", либо односимвольные указатели "!" или "&".
         Описатель вида \  n пробелов \  осуществляет перенос в вывод-
    ную строку (n+2)-х начальных символов из текстового значения оче-
    редного элемента списка. Если длина отображаемого значения меньше
    длины символьного поля, то недостающие позиции справа заполняются
    пробелами.
         Восклицательный знак заставит систему перенести в выводную
    строку только первый символ отображаемого значения.
         Амперсанд (&) является указанием о выводе текстового значения
    элемента выводного списка целиком. Это единственный описатель вы-
    водного поля, длина которого не определена. В сочетании с возмож-
    ностью переполнения числового поля такая ситуация приводит к несо-
    ответствию между длинами шаблона и выводной строки.
         Все остальные символы алфавита в шаблоне выполняют роль раз-
    делителей между описаниями числовых и текстовых полей. Они без
    всякого изменения переносятся в соответствующие позиции выводной
    строки. Если в их состав необходимо включить те символы, которые
    задействованы в описании числовых и текстовых полей, то перед каж-
    дым "управляющим" символом в шаблоне помещают подчерк (_) :

              PRINT USING "####_!"; 1990     -->     1990!

    Сам подчерк в выводной строке может появиться, если в шаблоне ему
    соответствуют два подряд идущих подчерка.
         Если тип очередного элемента выводного списка не соответству-
    ет описанию поля, то все три системы реагируют на такую ситуацию
    как на ошибочную.
         Количество описаний числовых и символьных полей в шаблоне вы-
    вода может не соответствовать количеству элементов выводного спис-
    ка. Если количество отображаемых данных превышает число описателей,
    то шаблон вывода повторяется с самого начала. В отличие от Фортра-
    на здесь вывод продолжается в той же самой строке. Поэтому следую-
    щие операторы осуществляют вывод данных абсолютно идентично :

                  PRINT USING  "### "; 1, 2, 3
                  PRINT USING  "### ### ### "; 1, 2, 3

         Если длина списка в операторе PRINT USING короче, чем шаблон
    вывода, то вслед за значением последнего элемента в выводную стро-
    ку из шаблона переносится очередное литеральное поле. Описатели
    полей, оставшиеся неиспользованными, при этом игнорируются. Напри-
    мер :

      PRINT USING "### руб ## коп"; 100     -->    100 руб

         Turbo BASIC воспринимает пробел между элементами выводного
    списка как разделитель, тогда как GW-система пробелы между число-
    выми данными игнорирует, а Quick-система при наборе таких операто-
    ров автоматически заменяет пробел на точку с запятой.
         Отметим еще одно расхождение, связанное с реакцией на нуле-
    вую длину шаблона вывода. Turbo-система в такой ситуации все рав-
    но выдает значения элементов выводного списка, снабжая их пред-
    шествующим символом "%". GW и Quick BASIC расценивают это событие
    как ошибочное.


              3.3.Управление логикой вычислительного процесса

         В однопроцессорных ЭВМ с последовательной обработкой команд
    машинной программы естественным считается выполнение команд в по-
    рядке возрастания их адресов. Такой же естественной назовем после-
    довательность выполнения операторов друг за другом в порядке их
    написания : в пределах программной строки операторы обрабатывают-
    ся слева направо, а программные строки - сверху вниз ( в терминах
    GW BASIC - в порядке возрастания номеров строк).
         Однако вычислительные процессы и соответcтвующие им програм-
    мы, как правило, не укладываются в такую линейную схему - отдель-
    ные фрагменты алгоритма приходится циклически повторять, в опре-
    деленных точках в зависимости от выполнения заданных условий не-
    обходимо выбирать ту или иную ветвь вычислений и т.п. В таких си-
    туациях мы должны нарушить естественную последовательность выпол-
    нения операторов и заставить ЭВМ перейти в нужную точку програм-
    мы.
         Операторы, с помощью которых осуществляются такого рода мани-
    пуляции, принято называть операторами управления. В их состав вхо-
    дят рассматривавшиеся ранее операторы организации циклов (см. раз-
    дел 2.2.1), структурные блоки выбора по условию(см. раздел 2.2.2)
    или по ключу (см. раздел 2.2.3), операторы обращения к внутренним
    (см. раздел 2.4.1) или внешним подпрограммам (см. раздел 2.4.2),
    многочисленные модификации оператора EXIT, обеспечивающие досроч-
    ный выход из различного рода программных конструкций. В разделе
    2.2.2 описывался оператор условного перехода IF - THEN (IF - THEN -
    ELSE), который также относится к группе операторов управления.
         Кроме упомянутых выше операторов к группе управления относят-
    ся оператор останова (STOP), безусловного перехода (GOTO) и пере-
    ключатели (ON).
         Оператор останова прерывает выполнение Бейсик-программы. Ес-
    ли такое прерывание происходит в режиме интерпретации (GW BASIC)
    или под управлением интегрированной среды (Turbo или Quick BASIC),
    то на экране дисплея появляется сообщение о причине останова и
    указание о номере программной строки, в которой это событие насту-
    пило (при отсутствии номера выдается 0). В этот момент открытые
    файлы задачи и значения всех ее переменных сохраняют свое состоя-
    ние, что обеспечивает возможность провести некоторые отладочные
    мероприятия и продолжить выполнение программы. Если оператор STOP
    встречается в самостоятельно откомпилированном модуле с расшире-
    нием .EXE, то все файлы задачи закрываются и управление передает-
    ся операционной системе.
         Тело оператора безусловного перехода состоит из единственного
    указателя точки программы, в которую передается управление. Им мо-
    жет быть либо номер программной строки (GW BASIC), либо ее метка :

                              GOTO  100
                              GOTO  SumVec

         Конструкция под названием "переключатель" представляет собой
    специальный вид оператора условного перехода или условного обраще-
    ния к внутренней подпрограмме :

                    ON  e  GOTO   T1,T2,...,Tk
                    ON  e  GOSUB  T1,T2,...,Tk

         Список точек перехода T1,T2,... состоит из k указателей про-
    граммных строк. Выбор одной из них осуществляется по значению ариф-
    метического выражения e, которое иногда называют переключающим вы-
    ражением. Как правило, оно является целочисленным и возможные его
    значения должны принадлежать диапазону [1,k]. При е=1 из списка то-
    чек перехода выбирается T1 и по этому адресу передается управление
    (ON...GOTO) или производится вызов внутренней подпрограммы (ON...
    GOSUB), при е=2 в качестве точки перехода используется метка (но-
    мер) T2 и т.д. После выполнения внутренней подпрограммы возврат
    осуществляется на оператор, следующий за ON...GOSUB .
         Если переключающее выражение имеет вещественный тип, то его
    значение превращается в целое число путем естественного округления
    дробной части (1.2 --> 1, 1.5 --> 2, 1.9 --> 2).
         Если значение переключающего выражения выходит за пределы
    интервала [1,k], то оператор ON не изменяет естественную последо-
    вательность выполнения программных строк. Он просто игнорируется.












