             2.4.Описание и использование подпрограмм

         Подпрограмма представляет собой встроенную в модуль или ав-
    тономно оформленную процедуру, к которой можно обратиться из лю-
    бой точки, приостановив таким образом выполнение основной програм-
    мы, и после завершения работы процедуры вернуться в точку прерыва-
    ния для продолжения основной программы.
         Для организации работы подпрограмм характерны следующие об-
    стоятельства. Во-первых, при каждом очередном обращении подпро-
    грамме должны быть тем или иным способом переданы новые исходные
    данные. Без этого многократное выполнение подпрограммы потеряло
    бы свой смысл. Естественно, что результаты работы процедуры тоже
    каким-то образом должны быть возвращены адресату.
         Во-вторых, любое обращение к подпрограмме отличается от
    обычного перехода (GOTO, IF) тем, что координаты точки, из кото-
    рой производится вызов, необходимо запомнить для организации воз-
    врата после завершения работы вызванной процедуры. Это напоминает
    ситуацию с циклами, когда при обработке заголовка приходится за-
    поминать параметры и адрес точки входа в тело цикла. Они понадо-
    бятся в тот момент, когда будет обрабатываться последний оператор
    цикла. И при реализации вложенных циклов, и в случае последова-
    тельных обращений из одной подпрограммы в другую для запоминания
    очередной точки возврата используется стековый механизм. В момент
    обращения к подпрограмме адрес возврата заносится в стек и хранит-
    ся там до тех пор, пока не будет выполнен специальный оператор
    возврата. При этом сделавший свое дело адрес возврата из стека
    удаляется.

                2.4.1.Внутренние подпрограммы

         Внутренние или встроенные подпрограммы - одна из наиболее
    ранних синтаксических конструкций Бейсика, построенная по анало-
    гии с примитивно оформленными машинным подпрограммами. У них от-
    сутствуют четко выраженные границы, характерные для блочных кон-
    струкций. Для индикации входных точек во внутренней подпрограмме
    приходится пользоваться только комментариями. Физический конец
    внутренней подпрограммы тоже ничем не выделяется. Единственный
    оператор, по которому можно опознать подпрограмму, это - опера-
    тор возврата RETURN. Но и он может располагаться не только в по-
    следней программной строке подпрограммы. Например :

         1000 REM Масштабирование I-той строки матрицы
         1010 J = 0
         1020 IF A(I,I) = 0  THEN  RETURN    ELSE  J = -1
         1030 FOR K = I + 1  TO  N
         1040 A(I,K) = A(I,K)/A(I,I)
         1050 NEXT K
         1060 RETURN

         В приведенной процедуре реализуется один из шагов вычисления
    определителя по схеме Гаусса - деление элементов строк на диаго-
    нальный элемент. Если деление невозможно, то в переменную J зано-
    сится нуль, отождествляемый с логическим значением "ложь".
         Для обращения к внутренним подпрограммам используется опе-
    ратор GOSUB, в теле которого задается номер начальной программной
    строки или метка первого оператора подпрограммы. В частности, к
    приведенной выше процедуре можно обратиться с помощью оператора
    GOSUB 1010.
         Самым большим недостатком внутренних подпрограмм является
    отсутствие механизма параметров, который применяется даже в част-
    ном виде подпрограмм - в нестандартных функциях. Поэтому обмен
    данными с подпрограммой основан на совместном использовании пере-
    менных, область действия которых распространяется на весь модуль.
    Это накладывет на программиста дополнительные заботы по согласо-
    ванию имен переменных и номеров строк, задействованных во вну-
    тренних подпрограммах. Кроме того, перед обращением к подпрограм-
    ме пользователь должен позаботиться о присвоении нужных значений
    входным переменным, а после возврата из подпрограммы - и о спасе-
    нии результатов работы процедуры. Иначе предыдущие результаты
    будут "забиты" при повторном обращении к подпрограмме.
         В отличие от функций в результате работы подпрограммы вовсе
    не обязательно что-то сосчитать и возвратить одно или несколько
    значений. Подпрограмма может, например, осуществить построение
    на экране некоторого графического об'екта с заданными характери-
    стиками, выполнить проверку сходимости итерационного процесса,
    произвести ввод значений определенных переменных, которые должны
    удовлетворять условиям задачи и т.п.
         Возврат из подпрограммы тоже может быть предусмотрен не
    только на оператор, следующий за GOSUB. Эта возможность обеспечи-
    вается за счет указания в теле оператора RETURN номера или метки
    программной строки. Например :

       Analiz:
          dx = x1 - x2
          dy = y1 - y2
          dz = z1 - z2
          d = sqr(dx*dx + dy*dy + dz*dz)
          IF d > 1e-4  AND  Niter < 100
               x1 = x2 :  y1 = y2 :  z1 = z2
               Niter = Niter + 1  :  RETURN
          ELSEIF  Niter > 100  THEN
               PRINT "Количество итераций превысило допустимое"
               PRINT "Смените начальную точку"
               RETURN NewPoint
          ELSE
               PRINT "Решение найдено за"; Niter;"итераций"
               RETURN NewAlgorithm
          END IF

         Таким фрагментом проверки сходимости можно воспользоваться
    при решении некоторой оптимизационной задачи, в которой запрог-
    раммировано несколько разных алгоритмов.
         Возможность указать точку возврата в операторе RETURN не
    следует воспринимать как аналог оператора обычного перехода в за-
    данную точку программы. Дело в том, что выполнение оператора RE-
    TURN связано еще и с дополнительной нагрузкой - очисткой строки
    в стеке возвратов, которая была сформирована оператором GOSUB.
    Именно это обстоятельство позволяет зафиксировать ошибку, вызван-
    ную переходом на подпрограмму с помощью обычных операторов GOTO,
    IF. В этом случае стек возвратов пуст и выполнение оператора RE-
    TURN заканчивается выдачей сообщения об ошибке.
         Стековый механизм позволяет легко организовать вложенные об-
    ращения из одной подпрограммы в другую, а в системе Quick BASIC
    допускаются и рекурсивные обращения :

                    Factorial :
                       Nfact = 1  :  N% = n
                       GOSUB Factor
                       RETURN
                    Factor :
                       IF N% > 1 THEN
                          Nfact = N% * Nfact
                          N% = N% - 1
                          GOSUB Factor
                        ELSE
                          RETURN

         Приведенный пример подпрограммы, вычисляющей значение n! ,
    носит только иллюстративный характер. Конечно, вычисление факто-
    риала можно реализовать и более эффективным способом.


                  2.4.2.Внешние подпрограммы

         Отсутствие четких правил в оформлении структуры внутренних
    подпрограмм и механизма передачи параметров, необходимость согла-
    совывать совместно используемые ресурсы (переменные, номера
    строк), обязательное включение текста внутренней подпрограммы в
    состав основной программы существенно затрудняют использование
    таких процедур.
         В системах Quick и Turbo BASIC эти препятствия удалось устра-
    нить за счет подключения внешних подпрограмм, которые могут быть
    составлены как на Бейсике, так и на других алгоритмических языках.
    Заголовок внешней подпрограммы на Бейсике оформляется с помощью
    оператора SUB, который в обеих системах имеет несколько отличаю-
    щиеся форматы :

      Turbo :   SUB name [ ( V1 [()], V2 [()],...]
      Quick :   SUB name [ ( V1 [()] [AS type1],
                             V2 [()] [AS type2],....  ] [STATIC]

         Каждая внешняя подпрограмма подобно функциям уже имеет инди-
    видуальное имя (name) и список формальных параметров, среди кото-
    рых наряду с простыми переменными могут фигурировать имена масси-
    вов любой размерности. Для их выделения в списке формальных пара-
    метров вслед за идентификатором массива ставятся круглые скобки.
         В теле подпрограммы наряду с формальными параметрами могут
    использоваться свои собственные (локальные) об'екты с динамичес-
    ким или статическим способами размещения в оперативной памяти, а
    также переменные, совместно используемые (SHARED) вызывающей про-
    граммой и подпрограммой или расположенные в одноименных блоках
    общей памяти (COMMON). В общих чертах механизм обмена данными
    с внешними подпрограммами практически ничем не отличается от ана-
    логичного общения с внешними функциями.
         Применение ряда операторов в теле подпрограммы запрещается
    (DEF FN, FUNCTION, SUB). Однако обращаться к другим внешним функ-
    циям и подпрограммам можно без каких-либо ограничений.
         Завершает тело подпрограммы оператор END SUB, выход на кото-
    рый автоматически приводит к возврату в вызывающую программу.
    Оператор RETURN во внешних подпрограммах не используется. Для до-
    срочного выхода из подпрограммы применяют оператор EXIT SUB.
         Обращение к внешней подпрограмме осуществляется с помощью
    оператора CALL :

                CALL  name [ ( W1 [()], W2 [()],...) ]

    Здесь W1,W2,...- фактические аргументы, последовательность и тип
    которых должны находиться в соответствии с формальными параметра-
    ми V1,V2,... .
         Система Turbo BASIC допускает применение параметров, спосо-
    бом передачи которых можно управлять. По умолчанию вместо значе-
    ний скалярных (одиночных) аргументов в подпрограмму передаются
    их относительные адреса в сегменте данных. Такой способ принято
    называть передачей данных по указателю (по ссылке, по адресу).
    Массивы всегда передаются только по указателю. Для физического
    переноса значения фактического параметра в соответствующую об-
    ласть подпрограммы аргумент заключают в круглые скобки :

                      CALL  ABC ( a, (b), (c(5)) )

         Если в роли фактического аргумента выступает переменная и
    в подпрограмму передается ее значение, то такой параметр может
    быть только входным, ибо любое его изменение в теле подпрограммы
    никак не скажется на самой переменой в вызывающей программе. Ад-
    рес-то ее мы ведь в подпрограмму не сообщили.
         В связи с тем, что в теле внешних подпрограмм (функций) не
    принято описывать массивы, указанные в числе формальных парамет-
    ров, входные языки Quic- и Turbo-систем предоставляют внешним
    процедурам возможность узнать настоящие размеры соответствующего
    фактического аргумента. Для этого используются функции LBOUND(V,k)
    и UBOUND(V,k), выдающие соответственно значения нижней и верхней
    границы индекса по заданному измерению k в массиве с именем V.
    Способ их применения демонстрирует внешняя подпрограмма, суммиру-
    ющая элементы двумерного массива :

                SUB SumArray (A() AS REAL,S AS REAL)
                     N1 = LBOUND(A,1) : M1 = UBOUND(A,1)
                     N2 = LBOUND(A,2) : M2 = UBOUND(A,2)
                     S = 0
                     FOR I = N1  TO  M1
                         FOR J = N2  TO  M2
                             S = S + A(I,J)
                         NEXT J
                     NEXT I
                 END SUB

         Возврат из внешней подпрограммы всегда происходит на опера-
    тор, следующий за оператором CALL.
         Quick BASIC допускает возможность обращения к подпрограммам
    и без оператора CALL. Однако в этом случае имя подпрограммы не
    может совпадать с именами служебных слов, а в вызывающей програм-
    ме должен присутствовать декларативный оператор :

       DECLARE  SUB name [(V1[()][AS type1],V2[()][AS type2],...)]

    При вызове внешней подпрограммы без служебного слова CALL факти-
    ческие аргументы в круглые скобки не заключаются.


          2.4.3.Общение с другими системами программирования

         Иногда бывает полезно воспользоваться подпрограммами или
    функциями, составленными на других алгоритмических языках. Одна-
    ко существует довольно много причин, осложняющих взаимодействие
    об'ектных модулей, изготовленных различными системами программи-
    рования.
         Во-первых, могут оказаться несовместимыми внутренние форма-
    ты представления внешне однотипных об'ектов (вспомните форматы
    IEEE и MBF для вещественных чисел, трех- и четырехбайтовые де-
    скрипторы, связанные с хранением символьных значений, возможность
    расположить двумерный массив в памяти по строкам или столбцам и
    т.п.).
         Во-вторых, разные системы программирования используют раз-
    личные механизмы передачи параметров и способы совместного ис-
    пользования общих пепременных. В одних случаях формируются таб-
    лицы, содержащие адреса значений фактических параметров, и вызы-
    ваемым модулям передаются ссылки на эти таблицы и их длины. В
    других случаях вся информация передается через стек. Да и сами
    параметры могут передаваться разными способами - по значению, по
    ссылке (вместо значения передается его адрес).
         В-третьих, могут оказаться различными и соглашения о правилах
    использования регистров, о порядке их запоминания и восстановле-
    ния, о месте расположения и размерах областей сохранения.
         Преодолению такого рода барьеров способствует расширение
    состава стандартных функций, обеспечивающих преобразование данных
    из одного формата представления в другой (см.раздел 1.2.6) и ус-
    тановление соответствия между идентификаторами об'ектов и их адре-
    сами (VARPTR,VARPTR$,SADD), средства управления памятью (DEF SEG,
    MEMSET), процедуры обмена с ячейками оперативной памяти по физи-
    ческим адресам (POKE,PEEK) и т.д.
         Ниже рассматриваются основные средства, обеспечивающие вза-
    имосвязь между Бейсик-программами и внешними процедурами, реали-
    зованными на других алгоритмических языках.
         Ранние Бейсик-системы (в т.ч. и GW BASIC) отводили в опера-
    тивной памяти под задачу пользователя всего 64 Кб. Об'яснялось
    это принятым тогда способом прямой адресации об'ектов, который
    на ЭВМ с 16-разрядными словами не позволял задать адрес более
    65535. Однако на IBM PC/XT имеется возможность работать с адрес-
    ным пространством до 640 Кб, а на моделях AT-286 и AT-386 об'ем
    оперативной памяти может достигать 16 Мб.
         Чтобы рационально использовать память большого об'ема, ее
    делят на сегменты, размер каждого из которых не может превышать
    64 Кб. Для адресации об'ектов (команд, операндов), расположенных
    в любом сегменте, используются две компоненты - база сегмента b,
    эквивалентная (но не равная !) его начальному адресу, и смещение
    d об'екта относительно начала сегмента.
         Значение базы b формируется в одном из 16-разрядных управля-
    ющих регистров :

            CS - регистр сегмента команд;
            DS - регистр сегмента данных;
            SS - регистр сегмента стековых операндов;
            ES - регистр внешнего сегмента;

    Величина смещения d может быть указана непосредственно в машинной
    команде или формироваться за счет прибавления к машинному адресу
    соответствующего индексного регистра.
         Полный 20-разрядный адрес, позволяющий идентифицировать лю-
    бые данные в пределах до 1 Мб, формируются следующим образом :

                  Address = 16 * b + d

    Первое слагаемое, представляющее собой настоящий начальный адрес
    сегмента, равно содержимому регистра соответствующего сегмента,
    сдвинутому влево на 4 двоичных разряда.
         Это небольшое отступление было предпринято для того, чтобы
    лучше понять смысл некоторых стандартных функций и операторов,
    используемых в процессе взаимодействия с внешними функциями и
    подпрограммами.
         Оператор DEF SEG позволет сформировать в одной из служебных
    ячеек Бейсик-системы начальный адрес сегмента, значение которого
    влияет на выполнение операторов BLOAD, BSAVE, CALL ABSOLUTE, DEF
    USR, POKE и функции PEEK. Он имеет следующий формат :

                   DEF SEG  [= Address]

    База сегмента должна принадлежать диапазону [0, 65535]. Если опе-
    ранд не задан, то в соответствующую служебную ячейку заносится
    значение, предусмотренное системой по умолчанию.
         С помощью функции VARSEG(V) можно узнать базовый адрес сег-
    мента, в котором хранится переменная с именем V. Смещение этой же
    переменной относительно начала сегмента определяется по значению
    функции VARPTR(V). Аргументами обеих функций могут быть идентифи-
    каторы как символьных, так и числовых переменных или массивов.
    Результат выдается в виде двухбайтового целого числа, и он может
    быть передан в качестве параметра в любую внешнюю функцию или
    подпрограмму.
         В Quick BASIC'е для определения смещения переменной (массива)
    символьного типа применяется функция SADD(V$).
         В GW BASIC'е функции VARPTR(V) и VARPTR$(V) имеют несколько
    иной смысл. Первая функция наряду с идентификатором переменной
    допускает в качестве аргумента и номер файла (VARPTR(#5)). В этом
    случае значением функции является адрес (смещение) блока управле-
    ния (FCB - File Control Block), выделяемого задаче в момент ини-
    циализации файла с указанным номером. Функция VARPTR$(V) выдает
    в символьном формате трехбайтовый дескриптор переменной V :

                   1            2            3
             ┌────────────┬────────────┬────────────┐
             │    Тип     │ мл.разряды │ ст.разряды │
             │ переменной │   адреса   │   адреса   │
             └────────────┴────────────┴────────────┘

    Тип переменной обозначается числовым признаком, принимающим зна-
    чения 2 (целый), 3 (строка), 4 (вещественный с одинарной точно-
    стью) и 8 (вещественный с удвоенной точностью).
         Дополнительные средства управления распределением памяти пре-
    доставляются функциями FRE (GW, Quick, Turbo), SETMEM (Quick) и
    оператором MEMSET (Turbo).
         Функция FRE, предназначенная для опроса об'ема свободной
    памяти, в GW-системе работает несколько не так, как в двух других.
    Если ее аргументом является идентификатор любой числовой перемен-
    ной, то она выдает количество свободных байтов, оставшихся в сег-
    менте задачи (полный об'ем этого сегмента - 64 Кб). При аргументе
    символьного типа функция FRE выдает об'ем свободного участка па-
    мяти в области, выделенной для хранения текстовых значений (в так
    называемой "куче"). Одновременно запускается и процедура "уборки
    мусора" в куче. Периодическая реорганизация кучи с целью сборки
    свободных участков в сплошной массив памяти производится системой
    каждый раз, когда в куче не находится свободное место под очеред-
    ной результат символьного типа. Процедура эта довольно длительная.
    На IBM PC/XT она занимает от одной до полутора минут.
         В Quick- и Turbo-системах аргумент функции FRE может прини-
    мать одно из четырех следующих значений :

         FRE (-2) - сообщает об'ем свободной памяти в стеке;
         FRE (-1) - сообщает об'ем свободной памяти,который может
                    быть использован для размещения числового массива;
         FRE (e)  - сообщает размер следующего свободного блока в
                    куче (е - произвольное числовое выражение, зна-
                    чение которого отлично от -1 и -2);
         FRE (e$) - сообщает размер всех свободных блоков в куче
                    (e$ - произвольное выражение символьного типа).

         Система Quick BASIC предоставляет возможность управлять раз-
    мером памяти (кучи), отводимой для хранения символьных значений :

                           K = SETMEM(n)

    Если значение аргумента функции SETMEM отлично от нуля, то на та-
    кое количество байтов увеличивается (n > 0) или уменьшается (n <
    0) об'ем памяти в дальней куче. Значение функции при этом совпада-
    ет с новым об'емом кучи. Если n=0, то функция SETMEM выдает теку-
    щий об'ем кучи.
         В Turbo BASIC'е с помощью оператора "MEMSET EndAddr" можно
    установить максимальный адрес, ограничивающий ресурсы Turbo-сис-
    темы. Ячейки памяти с адресами превышающими значение EndAddr, мо-
    гут быть выделены внешним подпрограммам, изготовленным в других
    системах программирования. Аналогичными средствами располагают
    GW-интерпретатор и Quick-компилятор. Только задаются такие грани-
    цы как значения соответствующих параметров в командной строке.


                      2.4.3.1.Связь с ассемблером

         Исторически сложилось так, что в Бейсик-системах раньше все-
    го была отработана схема общения с подпрограммами на языке ассем-
    блера. Имеются такие средства и в GW BASIC'е, однако они не носят
    достаточно универсальный характер и потому в дальнейшем не полу-
    чили распространения. К их числу относятся оператор DEF USRn и
    функция USRn(x).
         Программа на Бейсике может включать до 10-ти пользователь-
    ских подпрограмм (n = 0,1,2,...,9), написанных в машинных кодах.
    Оператор DEF USR устанавливает связь между подпрограммой с номе-
    ром n и ее начальным адресом :

                        150 DEF USR3 = &H4000

    О размещении (загрузке) соответствующей подпрограммы по указанно-
    му адресу пользователь должен позаботиться сам. Сделать это можно
    различными способами. Например, об'явить массив необходимого раз-
    мера и определить его адрес с помощью функции VARPTR :

                        20 DIM  A(2000)
                        ...............
                       100 Address = VARPTR(A)

    Затем на это место можно загрузить абсолютную программу из диско-
    вого файла по оператору BLOAD :

                        140 BLOAD "Sub3", Address

         Абсолютная программа может быть задана и в блоке данных
    (DATA) как последовательность числовых значений байтов программы.
    Оттуда их можно извлечь и с помощью оператора PEEK записать на
    выделенное место в памяти :

                        120 FOR K = Address  TO  Address + N
                        130 READ A%   :    POKE  K,A%
                        140 NEXT K

         Переход на подпрограмму осуществляется с помощью функции
    USRn(x) :

                        160 Y = USR3(X)

    При этом подпрограмме передается единственный числовой или сим-
    вольный аргумент.Числовой аргумент помещается на специальное вось-
    мибайтовое поле FAC (от Floating point ACcumulator), расположен-
    ное в сегменте данных GW-системы. Адрес FAC сообщается вызванной
    подпрограмме через регистр BX ( <BX> = FAC + 4).
         Тип аргумента заносится в виде числового признака в регистр
    AL (2 - целочисленный тип, 3 - строка, 4 - вещественный тип с
    одинарной точностью, 8 - вещественный тип с удвоенной точностью).
    Если аргумент представлен числовым об'ектом, то его значение рас-
    положено в FAC следующим образом:

     FAC  FAC+1  FAC+2  FAC+3  FAC+4  FAC+5  FAC+6  FAC+7
    ┌─────────────────────────┬─────────────┬──────────────┐
    │                         │  мл.    ст. │              │
    │                         │ разр.  разр.│              │ integer
    ├─────────────────────────┼──────┼──────┼──────┬───────┤
    │                         │  мл.           ст. │ p-128 │
    │                         │ разр.         разр.│       │ single
    ├─────┬─────┬──────┬──────┼──────┼──────┬──────┼───────┤
    │  мл.                                     ст. │ p-128 │
    │ разр.                                   разр.│       │ double
    └─────┴─────┴──────┴──────┴──────┴──────┴──────┴───────┘

         Вычисляемое подпрограммой арифметическое значение обычно
    имеет такой же тип, что и аргумент, и оно должно быть занесено в
    FAC.
         Если аргумент X символьного типа, то при входе в подпрограмму
    регистр DX содержит адрес трехбайтового дескриптора строки (1 байт
    - длина, 2 байта - адрес строки).
         Гораздо больший прогресс в GW BASIC'е был достигнут за счет
    введения почти современной конструкции оператора CALL :

                      CALL   V [(a1,a2,...)]

    Здесь V - идентификатор целочисленной переменной, значение которой
    равно адресу входа в подпрограмму (точнее - смещению относительно
    начального адреса сегмента команд, установленного ранее с помощью
    оператора DEF SEG). В качестве фактических параметров вызываемой
    подпрограмме могут быть переданы значения переменных любого типа
    или константы. На самом деле, подпрограмма получает не сами значе-
    ния аргументов, а их адреса, расположенные в стеке в обратном по-
    рядке. Подпрограмма должна сама извлечь необходимые ей входные
    данные, организовать отсылку вычисляемых значений выходных пара-
    метров и привести стек в состояние, предшествовавшее моменту об-
    ращения. Проверка на соответствие и количество фактических и фор-
    мальных параметров здесь не производится, хотя это обстоятельство
    может оказаться причиной трудно уловимых ошибок.
         В системе Turbo BASIC появился довольно оригинальный способ
    включения ассемблеровской программы в состав исходной программы :

                  SUB  name_sub  INLINE
                       $INLINE  b11,b12,...
                       $INLINE  b21,b22,...
                       ....................
                   END SUB
            или
                   SUB  name_sub  INLINE
                       $INLINE  "name_file"
                   END SUB

    В первом варианте вслед за метаоператором $INLINE расположены бай-
    ты машинной программы, во втором - задается имя файла с расширени-
    ем .COM, который должен существовать на диске. Количество COM-фай-
    лов, участвующих в формировании тела одной подпрограммы типа INLI-
    NE, может достигать 16. Допускается и смешанное использование обо-
    их вариантов.
         Обращаются к подключенной таким образом подпрограмме с помо-
    щью стандартного оператора CALL :

                    CALL name_sub [(a1,a2,...)]

         Turbo BASIC предоставляет еще одну возможность обращения к
    ассемблеровским подпрограммам :

                  CALL ABSOLUTE address [(i1,i2,...)]

    Здесь вместо имени подпрограммы указывается адрес ее точки входа
    (address), а в качестве фактических аргументов могут использовать-
    ся только целочисленные переменные или константы. Через стек пере-
    даются однако не сами значения аргументов, а их адреса.
         Qick BASIC предлагает два оператора для вызова  ассемблеров-
    ских подпрограмм :

                   CALL ABSOLUTE (a1,a2,...,i)
                   CALLS name_sub (a1,a2,...)

    В первом операторе адрес точки входа в вызываемую подпрограмму
    задается с помощью смещения i, которое должно быть прибавлено к
    базовому адресу сегмента команд, установленного по оператору DEF
    SEG. Добавка символа S к оператору CALL означает, что обмен дан-
    ными между вызывающей и вызываемой программами осуществляется
    через стек.


               2.4.3.2.Использование прерываний BIOS

         Система прерываний BIOS (Basic Input/Output System) и тесно
    связанные с ней встроенные программы, обслуживающие процедуры об-
    мена с различными устройствами, является компонентой операционной
    системы MS DOS и позволяет максимально эффективно использовать ап-
    паратные возможности ЭВМ.
         Доступ к системе прерываний на языке ассемблера реализуется
    по машинной команде INT :

                             INT  n

    Номер прерывания n, обычно задаваемый в виде шестнадцатеричной
    константы, соответствует адресу слова в так называемом векторе
    прерываний (ячейки оперативной памяти с адресами 0H - 1FH). А на-
    ходится в этом слове адрес точки входа в программу ПЗУ, отвечаю-
    щую за обработку прерывания с номером n. Так что команда INT вы-
    полняет функцию оператора вызова соответствующей процедуры BIOS.
    Естественно, что при этом запоминается и адрес возврата на коман-
    ду, следующую за INT.
         Для обмена информацией между вызывающей программой и проце-
    дурами BIOS используются двухбайтовые регистры микропроцессора
    AX, BX,... или их однобайтовые компоненты (AH - старший байт ре-
    гистра AX, AL - младший байт регистра AX, BH, BL,...).
         Как правило, каждая процедура BIOS, обслуживающая прерывание
    с заданным номером, выполняет несколько операций. Иногда их назы-
    вают функциями и внутри каждого прерывания различают по номерам -
    0,1,2,... . Перед выполнением команды INT номер функции заносится
    в регистр AH. Каждая функция имеет свой набор входных и выходных
    параметров, размещаемых на фиксированных регистрах. С этой инфор-
    мацией в первом приближении можно познакомиться, например, в 6-й
    главе книги Л.Скэнлона "Персональные ЭВМ IBM PC и XT : Программи-
    рование на языке ассемблера" (изд."Радио и связь", М., 1989). Не-
    которые из функций, связанные с обработкой прерывания 10H (управ-
    ление дисплеем в текстовом и графическом режимах) рассматриваются
    в разделе 5.4.5.
         Для обращения к функциям BIOS в системе Turbo BASIC предла-
    гаются операторы CALL INTERRUPT, REG и функция REG.
         Оператор REG позволяет сформировать входные параметры в слу-
    жебном массиве, содержимое которого перед обращением к выбранной
    процедуре переносится в регистры микропроцессора. При работе на ас-
    семблере такого рода участки памяти принято называть областями со-
    хранения. Переход из одной подпрограммы в другую сопровождается за-
    поминанием в области сохранения состояния машинных регистров. Пос-
    ле завершения работы вызванной подпрограммы содержимое области со-
    хранения используется для восстановления регистров. Служебный мас-
    сив, формируемый с помощью оператора REG, работает как бы в проти-
    вофазе - его элементы загружаются в соответствующие машинные реги-
    стры в момент перехода на процедуру BIOS. А по завершению процеду-
    ры в них запоминается состояние регистров. Общепринятого идентифи-
    катора у служебного массива нет. Обращение к его элементам произво-
    дится по их индексам - 0,1,2,...,9. В этой последовательности им
    соответствуют регистры FLAGS, AX, BX, CX, DX, SI, DI, BP, DS и ES.
         Для того, чтобы сформировать в регистрах AH, AL и BX соответ-
    ственно значения 16, 3 и 5, необходимо выполнить операторы :

                      REG  1, 16*256 + 3
                      REG  2, 5

    Первый операнд задает номер элемента служебного массива, выделен-
    ного в качестве образа соответствующего регистра. Второй операнд
    представляет значение элемента массива, которое впоследствии бу-
    дет занесено в выбранный регистр. Иногда заносимое в регистр зна-
    чение бывает удобно задавать в виде шестнадцатеричной константы.
    Предыдущий пример мог бы выглядеть и так :

                       REG  1, &H1003
                       REG  2, &H5

         Состояние тех регистров, эквивалентные области сохранения ко-
    торых не подвергаются воздействию операторов REG, будет таким же,
    каким оно было в момент завершения предшествующего обращения к
    BIOS. Перед выполнением программы всем элементам служебного мас-
    сива присваиваются нулевые значения.
         Физическая пересылка содержимого области сохранения в реги-
    стры микропроцессора осуществляется в момент исполнения оператора
    CALL INTERRUPT. Единственным его аргументом является номер n функ-
    ции BIOS :

                        CALL INTERRUPT  n

          После обработки прерывания с номером n содержимое выходных
    регистров можно опросить с помощью функции REG :

                        AX = REG(1)
                        AL = REG(1) AND &H00FF
                        AH = REG(1) \ 256

         К операциям умножения или целочисленного деления на 256 при-
    ходится прибегать в тех случаях, когда нас интересует содержимое
    старших разрядов соответствующего регистра. Для опроса младшего
    байта (AL, BL, CL, DL) разумнее всего использовать логическое ум-
    ножение.
         Quick BASIC тоже предоставляет возможность доступа к преры-
    ваниям и соответствующим процедурам BIOS с помощью следующих слу-
    жебных подпрограмм :

                  CALL INT86OLD   (n, IN_R, OUT_R)
                  CALL INT86XOLD  (n, IN_R, OUT_R)
                  CALL INTERRUPT  (n, IN_REC,OUT_REC)
                  CALL INTERRUPTX (n, IN_REC,OUT_REC)

    Здесь   n - номер прерывания ;
         IN_R - массив, содержащий 8 или 10 (в модификации с добавле-
                нием символа X - от eXtended) элементов и представляю-
                щий область с входной регистровой информацией;
        OUT_R - массив с аналогичной структурой, предназначенный для
                запоминания выходного состояния регистров;
       IN_REC - имя переменной типа "запись", содержащей 8 или 10 це-
                лочисленных компонент с входной регистровой информа-
                цией;
      OUT_REC - запись с аналогичной структурой, предназначенная для
                запоминания состояния регистров на выходе из процедуры
                обработки прерывания.

    Имена входного и выходного массивов (записей) могут, в частности,
    и совпадать.
         Индексы элементов в массивах IN_R и OUT_R отсчитываются от
    единицы и их номера соответствуют следующей последовательности
    регистров :

        ┌────────────────────────────────────────────────────┐
        │ Индекс   1   2   3   4   5   6   7     8    9   10 │
        ├────────────────────────────────────────────────────┤
        │ Регистр  AX  BX  CX  DX  BP  SI  DI  Flags  DS  AS │
        └────────────────────────────────────────────────────┘

         Шаблон записи, тип которой приписывается параметрам IN_REC
    и OUT_REC, может быть описан следующим образом :

                         TYPE REGS
                              AX  AS INTEGER
                              BX  AS INTEGER
                              CX  AS INTEGER
                              DX  AS INTEGER
                              BP  AS INTEGER
                              SI  AS INTEGER
                              DI  AS INTEGER
                           Flags  AS INTEGER
                              DS  AS INTEGER
                              AS  AS INTEGER
                         END TYPE

                         DIM  IN_REC AS REGS, OUT_REC AS REGS

         Рассматривавшийся ранее пример в Quick BASIC'е выглядел бы
    так :

                      IN_REC.AX = 16*256 + 3
                      IN_REC.BX = 5
                      CALL INTERRUPT (&H10,IN_REC,OUT_REC)
                      AX = OUT_REC.AX
                      AL = OUT_REC.AX AND &H00FF
                      AH = OUT_REC.AX \ 256


         Таким образом, единственное отличие в процедурах обращения
    между Turbo- и Quick-системами заключается в способах формирования
    и опроса содержимого регистров. Вариант, предлагаемый в Quick BA-
    SIC'е, очень близок к принятому в системах программирования на
    базе языка "Си" и кажется нам более рациональным.


             2.4.3.3.Связь с другими языками программирования

         Средства общения с другими системами программирования более
    всего развиты в Quick BASIC'е. Он позволяет, например, обратиться
    из Бейсик-программ к подпрограммам и функциям, написанным на "Си",
    Фортране или Паскале.
         Именно поэтому в операторах об'явления внешних функций и под-
    программ здесь появились указатели CDECL и ALIAS :

       DECLARE FUNCTION name [CDECL][ALIAS "name1"][(аргументы)]
       DECLARE   SUB    name [CDECL][ALIAS "name1"][(аргументы)]

    Смысл этих указателей уже обсуждался в разделе 2.3.2. Кроме того,
    в операторе об'явления перед каждым формальным параметром может
    быть задан и способ его передачи вызываемой процедуре - по значе-
    нию (BYVAL) или по относительному адресу (SEG).
         Приведем несколько примеров, заимствованных из руководства
    фирмы "Microsoft" по межязыковому общению. В первом примере Бей-
    сик-программа обращается к подпрограмме на "Cи", не содержащей
    параметров и не возвращающей значение.

           BASIC :                                  C  :

     DECLARE SUB Prn CDECL()                    void Prn()
     .......................                    {.........}
     CALL Prn

     Во втором примере Бейсик-программа обращается к внешней функции,
     вычисляющей факториал и написанной на Фортране.

           BASIC  :                            FORTRAN  :

     DECLARE FUNCTION Fact%              INTEGER*2 FUNCTION FACT(N)
                (BYVAL N AS INTEGER)     INTEGER*2 N [VALUE]
     X% = 3 :  Y% = 4                    INTEGER*2 J
     PRINT Fact%(X%), Fact%(Y%)          FACT = 1
     END                                 DO 2 J=1,N
                                            FACT = FACT * J
                                      2  CONTINUE
                                         RETURN
                                         END

    Третий пример демонстрирует вызов подпрограммы, написанной на
    Фортране. Адресация параметров, передаваемых подпрограмме, в этом
    примере использует двухбайтовые (короткие, близкие - NEAR) указа-
    тели.

           BASIC  :                            FORTRAN  :

    DECLARE SUB Maxparam                  SUBROUTINE MAXPAR(I,J)
            ALIAS "MAXPAR"                INTEGER*2 I [NEAR]
            (A AS INTEGER,                INTEGER*2 J [NEAR]
             B AS INTEGER)                IF I > J THEN
    X% = 3  :   Y% = 4                             J = I
    CALL Maxparam(X%,Y%)                  ELSE
    PRINT X%,Y%                                    I = J
    END                                   END IF
                                          END




                    2.5.Программные файлы

         Изначальный ввод текста программ в память ЭВМ связан с боль-
    шими затратами времени из-за длительности ручного набора на кла-
    виатуре. Набранная программа обычно содержит ошибки как синтакси-
    ческого, так и алгоритмического характера. Придется еще изрядно
    потрудиться, чтобы довести ее до кондиции. Поэтому мало вероятно,
    что за один сеанс работы с ПЭВМ можно получить качественную прог-
    рамму, и хотелось бы максимально упростить процесс ее появления в
    памяти ЭВМ при повторных сеансах. Это - первое обстоятельство, вы-
    нуждающее нас прибегать к средствам хранения текстов программ на
    внешних запоминающих устройствах.
         Во-вторых, ранее создававшиеся программы или их фрагменты
    могут быть повторно использованы при конструировании новых про-
    грамм.
         Наконец, для того, чтобы обмениваться программами, мы так или
    иначе вынуждены прибегать к услугам системных средств, обеспечива-
    ющих хранение и поддержку программных файлов.


              2.5.1.Запоминание программных файлов на диске

         Для того, чтобы сохранить текст исходной программы на Бейси-
    ке, необходимо с терминала обратиться к соответствующей компоненте
    той или иной системы программирования. Эти возможности подробно
    обсуждаются в главах 7 - 9.
         Текст программы, сформированной в машинных командах, запоми-
    нается на диске с помощью оператора BSAVE :

                  BSAVE  "file_spec",Address,l

    Здесь file_spec - полная или сокращенная спецификация дискового
    файла, записанная в соответствии с правилами MS DOS. Начальный
    адрес запоминаемой программы задается  в виде смещения Address
    относительно начала сегмента, установленного предшествующим опе-
    ратором DEF SEG. Длина сохраняемой программы l задается в байтах
    (0 <= l <= 65535).

                    2.5.2.Загрузка дисковых файлов

         Кроме средств первоначальной загрузки исходной программы,
    которыми располагает каждая Бейсик-система (они подробно обсужда-
    ются в главах 7 - 9), для считывания программного файла с диска
    в оперативную память можно прибегнуть к операторам LOAD, BLOAD и
    RUN.
         Первый из них можно использовать только в рамках GW-системы :

                    LOAD  "file_spec" [,R]

    Он дает возможность загрузить указанный программный файл и даже
    передать ему управление для запуска на счет, если задан второй
    операнд - символ "R". В последнем случае сохраняются значения всех
    переменных текущей программы и состояние всех открытых ею файлов.
    Это обстоятельство обеспечивает передачу информации от вызывающей
    программы вновь загружаемому файлу.
         В Quick- и Turbo-системах загрузка программного файла выпол-
    няется оператором RUN :

                     RUN  "file_spec"

    В отличие от оператора LOAD текущая программа и значения ее пере-
    менных при этом не сохраняются.
         Для загрузки программ, написанных в машинных командах, пред-
    назначен оператор BLOAD :

                     BLOAD "file_spec" [,Address]

    Начальный адрес оперативной памяти, начиная с которого располага-
    ется считываемая программа, формируется из смещения Address с уче-
    том базового адреса сегмента, установленного предшествующим опера-
    тором DEF SEG.

             2.5.3.Подключение файлов к текущей программе

         В отличие от процедуры загрузки подключение программного
    файла происходит без уничтожения текста текущей программы. Таким
    образом осуществляется об'единение нескольких программных модулей
    или заблаговременно подготовленных заготовок.
         В GW BASIC'е слияние текущей программы  с дисковым файлом
    осуществляется по оператору MERGE :

                       MERGE  "file_spec"

    При этом следует учитывать, что номера программных строк вызывае-
    мого файла могут совпадать с номерами строк текущей программы. В
    таком случае вновь вызываемые строки будут затирать своих пред-
    шественников.
         Quick BASIC и Turbo BASIC для подключения дисковых файлов
    используют сходные метаоператоры $INCLUDE :

       Quick :     REM  $INCLUDE  "file_spec"
       Turbo :     $INCLUDE  "file_spec"

    Обычно такие метаоператоры располагаются в самом начале программы.
    В Turbo-системе подключаемые дисковые файлы иногда снабжают рас-
    ширением .INC, однако по умолчанию система добавит к неполной спе-
    цификации файла стандартное расширение .BAS .

              2.5.4.Выполнение цепочки программных файлов

         В большинстве систем программирования, базирующихся на алго-
    ритмических языках высокого уровня, существует возможность исполь-
    зовать внешние процедуры, вызывая их при каждом обращении из соот-
    ветствующего участка дисковой памяти и занимая место в оперативной
    памяти под процедуру только на время ее выполнения. Поскольку в
    одном и том же участке оперативной памяти могут последовательно
    располагаться разные подпрограммы, то принято говорить о наложении
    одного программного модуля на другой или о программах с так назы-
    ваемой оверлейной структурой.
         Некоторую аналогию с этой организацией программ можно усмо-
    треть в возможности увязать в цепочку последовательность Бейсик-
    программ, выполняющихся друг за другом и передающих совместно ис-
    пользуемые данные своему соседу по цепочке. Такой подход позволяет
    построить крупный программный комплекс, целиком не помещающийся в
    оперативной памяти.
         Вызов следующей по цепочке программы осуществляется с помо-
    щью оператора CHAIN :

    GW :  CHAIN [ MERGE ] "file_spec" [,[ N ]
                                [ ALL ][ ,DELETE N1-N2 ]]]
    Quick, Turbo :  CHAIN  "file_spec"

    Служебное слово MERGE означает, что вызываемый файл об'единяется
    (сливается) с текущей программой. При этом имеется возможность
    предварительно удалить фрагмент текущей программы, начиная со
    строки с номером N1 и до строки с номером N2 включительно. Пара-
    метр ALL означает, что должны быть сохранены значения всех пере-
    менных текущей программы, а не только те переменные, которые со-
    седи по цепочке "договорились" разместить в общей памяти (COMMON).
    Задание номера строки N после спецификации вызываемого файла по-
    зволяет передать управление в указанную точку сформированной про-
    граммы. Если номер N не задан, то в качестве продолжения выбира-
    ется оператор, следующий за CHAIN.

           2.5.5.Взаимодействие с файловой системой MS DOS

         Работа с программными файлами, в конечном итоге, реализуется
    с помощью соответствующих компонент операционной системы MS DOS.
    Поэтому кроме перечисленных выше операторов в состав входного язы-
    ка Quick- и Turbo-систем дополнительно включен ряд операторов, по-
    зволяющих в процессе выполнения Бейсик-программ изменять текущий
    каталог, выводить оглавления существующих директорий, создавать
    новые оглавления, переименовывать или уничтожать файлы. Формат
    этих операторов максимально приближен к структуре одноименных ди-
    ректив операционной системы. Их перечень приведен в табл.8.
         В GW BASIC'е аналогичные процедуры можно выполнить с помощью
    одноименных директив Бейсик-системы.

                                                        Таблица 8
     ┌──────────────────────────┬─────────────────────────────────────┐
     │ Формат оператора         │       Выполняемая функция           │
     ├──────────────────────────┼─────────────────────────────────────┤
     │ CHDIR path_spec          │ Изменение текущей директории        │
     │                          │                                     │
     │ FILES [ file_mask ]      │ Вывод имен файлов текущей директо-  │
     │                          │ рии, спецификация которых удовле-   │
     │                          │ творяет заданной маске              │
     │                          │                                     │
     │ KILL file_spec           │ Удаление указанного файла из теку-  │
     │                          │ щей  директории                     │
     │                          │                                     │
     │ KILL file_mask           │ Удаление всех файлов текущей дирек- │
     │                          │ тории, спецификации которых удовле- │
     │                          │ творяют заданной маске              │
     │                          │                                     │
     │ MKDIR path_spec          │ Создание нового оглавления          │
     │                          │                                     │
     │ NAME old_name AS new_name│ Переименование файла                │
     │                          │                                     │
     │ RMDIR path_spec          │ Удаление указанного оглавления      │
     └──────────────────────────┴─────────────────────────────────────┘


          2.6.Взаимосвязь по данным между программными модулями

         Способы управления памятью, влияющие на распределение пере-
    менных (массивов) и возможность доступа к ним из разных програм-
    мных модулей, в той или иной мере уже описывались в соответствую-
    щих разделах глав 1 и 2. Цель настоящего параграфа собрать воеди-
    но разрозненную информацию и обсудить ее с общих позиций.

              2.6.1.Локальные и глобальные переменные

         Для ранних Бейсик-систем (в т.ч. и для GW BASIC'а) было ха-
    рактерным использование только глобальных переменных, действие
    которых распространялось на всю программу, представленную един-
    ственным модулем.
         С появлением внешних программных единиц разделились и зоны
    действия переменных. Те переменные, область влияния которых огра-
    ничивается только тем модулем, где они были об'явлены, называются
    локальными. В отличие от них в программах могут использоваться и
    другие переменные, предназначенные для межмодульного общения.
         В различных языках программирования приняты два подхода к
    введению переменных совместного пользования. В одних системах мо-
    дуль об'являет некоторые свои переменные (массивы) доступными для
    других программных единиц. На языке ассемблера, например, для этой
    цели используется оператор ENTRY, в теле которого перечисляются
    входные идентификаторы. Другие модули, в которых эти об'екты ис-
    пользуются с целью обмена информацией, об'являют такие идентифи-
    каторы внешними (EXTERN). Характерной особенностью этого подхода
    является то, что совместно используемые переменные (массивы) име-
    ют одинаковые имена как в модуле-владельце, так и в вызываемых
    процедурах. Это не всегда удобно, так как при подключении к своей
    программе чужого модуля приходится согласовывать идентификаторы
    совместно используемых данных.
         Второй подход, развивавшийся в рамках Фортрана, базируется
    на выделении одной или нескольких областей (блоков) общей памяти,
    расположенных за пределами программной единицы. Два модуля, ис-
    пользующие совместные данные, "договариваются" между собой об
    идентификаторе общего блока памяти и каждый из них "просит" си-
    стему поместить в эту область общие переменные (массивы). Каждый
    из них может называть такие об'екты по-своему, но порядок располо-
    жения общих данных и их типы между партнерами должны быть согласо-
    ваны.
         В Quick- и Turbo-системах нашли отражение оба подхода. Пере-
    менные головной программы, используемые одновременно и во внешней
    процедуре без их передачи в качестве фактических параметров, носят
    название разделяемых об'ектов. Об'являются они только в теле внеш-
    ней подпрограммы или функции с помощью оператора SHARED :

        Turbo : SHARED  V1 [()], V2 [()],...
        Quick : SHARED  V1 [()] AS type1, V2 [()] AS type2,...

         Для вынесения переменных в общую память используется оператор
    COMMON, форматы которого в наших системах несколько отличаются :

    GW    : COMMON  V1[()], V2[()],...
    Turbo : COMMON  V1[(n1)], V2[(n2)],...
    Quick : COMMON [SHARED][/name_block/]
                               V1[(ind11,...)][AS type1],
                               V2[(ind21,...)][AS type2],...

         Общие переменные в GW-системе используются для передачи дан-
    ных следующей по цепочке программе (см. оператор CHAIN).
         В Turbo BASIC'е оператором COMMON могут дополнительно пользо-
    ваться и внешние подпрограмы. Целое число n, указываемое в круглых
    скобках после имени массива, задает количество индексов. Верхнюю и
    нижнюю границы каждого из них подпрограмма может опросить с помо-
    щью функций LBOUND и UBOUND.
         Ближе всего к Фортрану находится формат оператора COMMON, ре-
    ализованный в Quick BASIC'е. Если в двух предыдущих системах вза-
    имодействующие программные единицы используют одну единственную
    область внешней памяти (так называемый непоименованный блок), то
    входной язык Quick BASIC предоставляет возможность иметь любое ко-
    личество общих блоков. Идентификатор общего блока (name_block) мо-
    жет содержать до 40 символов. Дополнительное служебное слово SHA-
    RED означает, что общие переменные, указанные в списке оператора
    COMMON, доступны для всех процедур модуля. Непоименованный блок
    общей памяти в Quick-системе используется, как и в двух других
    для общения программ, вызываемых по цепочке.
         Локальные переменные и массивы, доступные только в текущей
    процедуре или в пределах многостроковой внутренней функции, об'-
    являются в Turbo BASIC'е с помощью оператора LOCAL :

                           LOCAL  V1,V2,...

    Память под локальные переменные выделяется только на время выпол-
    нения процедуры. Поэтому об'екты, перечисленные в теле оператора
    LOCAL не могут встречаться в операторах SHARED и STATIC.


          2.6.2.Статическое и динамическое распределение памяти

         В системах Quick и Turbo BASIC предусмотрены две возможности
    для распределения оперативной памяти под локальные переменные и
    массивы.
         В первом случае память выделяется на стадии компиляции и за-
    крепляется за переменными (массивами) на весь период выполнения
    программы. Такие об'екты принято называть статическими. Если ста-
    тическая переменная принадлежит внешней процедуре, то ее значение
    сохраняется между двумя последовательными обращениями к процедуре.
    Этим обстоятельством можно пользоваться для запоминания некоторых
    промежуточных данных без опасения, что какой-то другой модуль мо-
    жет что-то испортить.
         Второй вариант распределения памяти под переменные и массивы
    заключается в том, что необходимые ресурсы выделяются во время вы-
    полнения соответствующего модуля и сразу же освобождаются перед
    возвратом в вызывающую программу. Такой способ носит название ди-
    намического. Он позволяет более экономно расходовать оперативную
    память, особенно в тех случаях, когда речь идет о массивах боль-
    шого размера. Однако динамическое выделение и освобождение ресур-
    сов памяти связано с дополнительными затратами машинного времени.
         В системе Turbo BASIC приняты следующие соглашения :

      - под одиночные (скалярные) переменные память выделяется дина-
        мически только в тех случаях, когда они описаны с помощью
        оператора LOCAL;
      - массивы с переменными границами, массивы, отнесенные к общей
        памяти (COMMON), и локальные (LOCAL) массивы процедур распре-
        деляются только динамически;
      - по умолчанию под массивы с фиксированными границами память
        выделяется статически.

         Последнее правило умолчания для массивов может быть изменено,
    если перед соответствующей процедурой поместить метаоператор $DY-
    NAMIC. Отменить его действие для других процедур можно с помощью
    метаоператора $STATIC.
         Конкретный массив, об'являемый с помощью оператора DIM, мож-
    но явно описать как статический или динамический, включив в состав
    оператора один из указателей STATIC или DYNAMIC :

                          DIM  STATIC  A(50)
                          DIM  DYNAMIC B(30)

         В Quick-системе по умолчанию все локальные переменные внешней
    процедуры распределяются динамически. Чтобы перейти к статическому
    выделению памяти, в заголовке процедуры добавляется указатель STA-
    TIC (см. операторы SUB и FUNCTION). Пользователю Quick-системы до-
    ступен и метаоператор $STATIC, имеющий тот же смысл, что и в Tur-
    bo-системе.
         Обе системы допускают явное описание статических переменных
    в теле подпрограмм и функций :

         Turbo :    STATIC  V1[()], V2[()],...
         Quick :    STATIC  V1[()] [AS type1], V2[()] [AS type2],...