
 ╔═══════════════════════════════════════════════════════════════════╗
 ║                                                                   ║
 ║	   Челябинский Государственный Технический Университет	     ║
 ║                                                                   ║
 ║             Лаборатория локальных вычислительных сетей            ║
 ║                                                                   ║
 ║                                                                   ║
 ║        Диспетчер мультипроцессного режима в среде MS-DOS 3.30     ║
 ║                                                                   ║
 ║                   Руководство системного программиста             ║
 ║                                                                   ║
 ║                            Редакция  4.0                          ║
 ║                                                                   ║
 ║                             от 11.02.91                           ║
 ║                                                                   ║
 ╚═══════════════════════════════════════════════════════════════════╝

                               Введение

        При разработке сетевого программного обеспечения CNET возникли
сложности, связанные с необходимостью обработки множества асинхронных
событий (тайм-ауты, прием-передача пакетов).  Кроме того, необходимо
было обеспечить взаимодействие сетевой программы, реализующей уровни с
канального по сессионный включительно, и программ прикладного уровня,
обеспечивающих доступ к ресурсам сети: файлам, базам данных,
электронной почте и т.п. Для решения этих проблем и был предложен
диспетчер процессов.

        Диспетчер процессов - это резидентная программа, которая
управляет выполнением процессов на нескольких уровнях приоритетов,
поддерживает тайм-ауты и обеспечивает "невложенность" обращений к
операционной системе от асинхронных процессов.  Процессом здесь
называется последовательность команд, инициируемая диспетчером и
завершающаяся передачей управления диспетчеру.  Процессы могут
запускать друг друга, завершаться, ждать истечения тайм-аута, установки
флага, семафора, прерывания, удалять и устанавливать процессы в
диспетчере.  Диспетчер занимает небольшой об'ем памяти (около 3 Кбайт).
Среднее время переключения между процессами - примерно 100 команд.

        Документ имеет следующую структуру.  В первом разделе
приводится описание диспетчера процессов.  Во втором разделе
рассматривается решение проблемы вложенных вызовов MS-DOS и способы
обращения к MS-DOS из асинхронных процессов. Описание макробиблиотеки
для работы с диспетчером помещено в третьем разделе.


                1. Диспетчер мультипроцессной среды

                 1.1. Основные функции диспетчера

        Описываемый диспетчер управляет взаимодействием асинхронных
процессов, их последовательным выполнением на восьми уровнях
приоритетов, и регистрацией событий, происходящих в системе. Диспетчер
поддерживает запуск процессов по директивам запуска прцессов, по
тайм-ауту, по флагам, по семафорам и по прерываниям.

        Процесс - последовательность команд, выполнение которой
инициируется диспетчером.  Выполнение любого процесса завершается или
приостанавливается выдачей одной из директив диспетчера: Terminate,
Kill, Wait time, Wait flag, P или Run.

        Существует один особый процесс, для которого эти правила не
выполняются - это оперативная задача. Оперативная задача
приостанавливается при возникновении любого события диспетчера и вновь
получает управление после завершения всех процессов.

        Событием для диспетчера является истечение тайм-аута,
прерывание по вектору, захваченному диспетчером, завершение
DOS-операции, выполнение любой директивы диспетчера, кроме директивы
создания процесса и директивы установки тайм-аута.


                        1.2. Типы процессов

        Оперативная  задача - прерывается   по  любому  событию   и
восстанавливается  после   завершения всех  процессов,   порождаемых
этим событием.  Может запускать процессы.

        Простой процесс  - запускается по директивам запуска, по
тайм-ауту и по флагу.

	ДОС-процессор - процесс, использующий функции  MS DOS. Может быть
запущен только после завершения текущей функции MS DOS. ДОС-процессом
может быть любой процесс диспетчера.

       Процесс-драйвер - захватывает через диспетчер вектор
прерывания и вызывается диспетчером после этого прерывания.
Драйвер может быть запущен по директиве, флагу или тайм-ауту.



                     1.3. Приоритеты процессов

        При обработке сетевых событий, используются различные по
длительности процессы.  Длительность выполнения этих процессов может
различаться на несколько порядков.  Для того, чтобы длительные процессы
не блокировали короткие, введены восемь уровней приоритетов
процессов(нулевой - самый высокий).  Оперативная задача имеет самый
низкий приоритет (дополнительный - восьмой).  Процесс с более высоким
приоритетом может прерывать процесс с более низким приоритетом.
Порядок выполнения процессов, имеющие одинаковый приоритет,
определяется порядком их активизации в диспетчере.

                     1.4. Состояния процессов

         Процесс может находится в одном из девяти состояний:

- Run             ( активное состояние );
- Ready_Cont      ( готовый к продолжению или прерванный более
		   приоритетным процессом );
- Ready_Run       ( готовый к запуску );
- Passive         ( пассивное );
- Wait_time_Run   ( ожидающий тайм-аута для запуска );
- Wait_time_Cont  ( ожидающий тайм-аута для продолжения );
- Wait_flag_Run   ( ожидающий флага для запуска );
- Wait_flag_Cont  ( ожидающий флага для продолжения ).
- Wait_Semaphore  ( ожидающий освобождения семафора для продолжения ).

Состояние Run

         Процесс выполняется.

Состояние Ready_Cont

         Процесс переходит в это состояние, если произошло событие,
породившее более приоритетные процессы, и восстанавливается после их
завешения.

Состояние Ready_Run

         Процесс  готов  к  запуску  и  ожидает  своей  очереди   на
выполнение.

Состояние Passive

         Процесс не готов к запуску и не ждет флага или тайм-аута
( драйвер всегда ожидает прерывания, но считается пассивным ).

Состояние Wait_time_Run

         Процесс  ожидает  истечения  некоторого промежутка времени,
после  чего  он  становится  готовым к запуску (Ready_Run). Длительность
тайм-аута можно менять.

Состояние Wait_time_Cont

         Процесс  ожидает  истечения  некоторого промежутка времени,
после  чего  он  становится  готовым к продолжению (Ready_Cont). Длительность
тайм-аута можно менять.

Состояние Wait_flag_Run

         Процесс ожидает установки одного из нескольких флагов
диспетчера.  После директивы Set flag все процессы в очереди к флагу
переходит в состояние Ready_Run.

Состояние Wait_flag_Cont

         Процесс ожидает установки одного из нескольких флагов
диспетчера.  После директивы Set flag все процессы в очереди к флагу
переходит в состояние Ready_Cont.

Состояние Wait_Semaphore

         Процесс ожидает установки одного из нескольких флагов
диспетчера.  После директивы Set flag все процессы в очереди к флагу
переходит в состояние Ready_Cont.


                 1.5. Элементарные операции диспетчера

        Диспетчер может осуществлять над процессами следующие операции:
инсталяция, запуск процесса, прерывание процесса, восстановление процесса,
завершение процесса, уничтожение процесса.

			    Инсталяция процесса

	Перед выполнением любых операций процесс должен быть инсталирован.
При инсталяции адрес блока управления процессом заносится в таблицы
лиспетчера.

			    Передиспетчеризация

	По событию ( вызов диспетчера,истечение тайм-аута, прерывание )
диспетчер начинает передиспетчеризацию для выбора следующего процесса с
наивысшим приоритетом. Если активный процесс иммеет более низкий
приоритет, то он прерывается ( Ready_Cont ) и запускается процесс с
наивысшим приоритетом.

                            Запуск процесса

        Если по какому либо событию необходимо запустить процесс, но
приоритет выполняющегося процесса выше, то процесс становится в очередь
на запуск (очередь готовых процессов). После выполнения всех процессов
с высшим приоритетом и процессов с равным приоритетом, но вставших в
очередь раньше, процесс запускается. При запуске процесса из состояния
Ready_Run диспетчер устанавливает его регистры DS,ES,SS и SP.

                          Прерывание процесса

        При возникновении какого либо события может возникнуть
необходимость приостановки процесса для запуска нового.  Диспетчер
сравнивает приоритет процесса, который надо запустить, и выполняющегося
процесса.  Если приоритет нового процесса выше, то регистры
прерываемого процесса запоминаются в его стеке.  Адрес стека
прерываемого процесса сохраняется в его блоке управления процеесом PCB
и процесс переходит в состояние Cont.  После этого запускается новый
процесс c разрешенными прерываниями. Процесс-драйвер запускается
с запрещенными прерываниями.

                          Завершение процесса

        Любой процесс (кроме оперативной задачи) должен заканчиваться
директивой завершения или запуска. По директиве завершения процесс
переходит в состояние Passive. Диспетчер запускает новый процесс с
наивысшим приоритетом.

                        Восстановление процесса

        Если приоритет прерванного процесса выше, чем приоритет
готового, то из блока управления процесса восстанавливается адрес стека
процесса. Из стека восстанавливаются регистры и по команде IRET процесс
продолжает работу.

			Уничтожение процесса

        При уничтожении процесса его блок управления PCB убирается из
таблицы про ессов и уничтожаются все ссылки на. Новые операции над
процессом в зможны только после его инсталяции.



                                 ╔═════════╗
                     Install     ║         ║
                 ───────────────>╢ Passive ╟<─────────────────────────┐
            ┌────────────────────║         ║─────────────────┐        │
            │                    ╚════╤════╝                 │        │
            │ Run_on_flag             │ Suspend              │Run_on_ │
            │                         │ Run                  │time    │
            │                         │ Прерывание           │        │
           \│/                       \│/                    \│/       │
        ╔═══╧═════╗              ╔════╧════╗             ╔═══╧═════╗  │
        ║ Wait    ║ Set_flag     ║         ║  Тайм-аут   ║ Wait    ║  │
        ║ flag    ╟─────────────>╢  Ready  ╟<─────────── ║ time    ║  │
        ║ Run     ║              ║  Run    ║             ║ Run     ║  │
        ╚════╤════╝              ╚════╤════╝             ╚════╤════╝  │
            /│\                       │                      /│\      │
             │                        │ Процесс с наивысшим   │       │
             │                        │ приоритетом           │       │
             │     Run_on_flag        │        Run_on_time    │       │
             └────────────────────┐   │   ┌───────────────────┘       │
                                  │  \│/  │                           │
        ╔═════════╗  P(0)        ╔╧═══╧════╗ Run, Terminate           │             │
   ┌────╢  Wait   ║<─────────────╢         ╟──────────────────────────┘
   │    ║  sema-  ║    ┌─────────╢  Run    ║───────────────────┐       
   │    ║  phore  ║    │         ║         ║                   │       
   │    ╚═════════╝    │         ╚═╤════╤══╝                   │           
   │         ┌─────────┘ Прерванный│   /│\  Процесс с наивысшим│Sleep      
   │         │ Wait_on   процесс   │    │   приоритетом        │                   
   │        \│/ flag              \│/   │                     \│/
   │   ╔═════╧════╗             ╔══════════╗             ╔══════════╗
   │   ║   Wait   ║ Set_flag    ║  Ready   ║ Тайм-аут    ║  Wait    ║
   │   ║   flag   ╟────────────>╢  Cont    ║<────────────╢  time    ║
   │   ║   Cont   ║             ║          ║             ║  Cont    ║
   │   ╚══════════╝             ╚════╤═════╝             ╚══════════╝
   │                 V (0)          /│\
   └─────────────────────────────────┘



Приmечание:
        1. Из любого состояния процесс может быть переведен в состояние
Passive директивой Terminate.
        2. Из любого состояния процесс может быть уничтожен директивой Kill.

Рис  1.1. Состояния процессов и переходы между ними


                  1.6. Служба времени диспетчера

        Одной из причин, порождающих асинхронные процессы, является
прерывание таймера, используемое для отслеживания тайм-аутов. Диспетчер
захватывает вектор прерывания системного таймера. По прерыванию от
таймера диспетчер проверяет очередь процессов, ожидающих истечения
тайм-аута и переводит в состояние Ready все, чье время запуска совпадает
с текущим временем диспетчера.  Если после этого появились готовые
процессы с приоритетом более высоким, чем приоритет прерванного таймером
процесса, то старый процесс прерывается и запускается новый.  Время
диспетчера измеряется в "тиках" (ticks).  Период "тика" около 55
милисекунд (18.16 Гц).  Такой же интервал поддерживает BIOS.


                      1.7. Обработка прерываний в диспетчере

        Асинхронные процессы могут порождаться по прерываниями от
аппаратуры или от программ низкого уровня.  Диспетчер позволяет
обрабатывать такие прерывания специальным процессам-драйверам.  При
инсталлировании драйвера диспетчер захватывает "на себя" вектор
прерывания и по прерыванию переводит драйвер в состояние Ready_Run. При
запуске драйверов действует обычный механизм приоритетов, причем
драйверы запускаются с запрещенными прерываниями.  Если во время работы
драйвера происходит новое прерывание с тем-же номером, то диспетчер
выдает в центре экрана ( только для  EGA, CGA ) букву Е и "зависает" с
разрешенными прерываниями, позволяя программисту определить с помощью
ОТЛАДЧИКА причину повторной входимости в драйвер.  Если необходимо
передать управление по старому вектору, то процесс должен это делать
сам. Старый вектор сохраняется в блоке управления процессом.
Количество прерываний, которые могут быть захвачены драйверами
ограничено (до 8 векторов).

        Процессы-драйверы могут использоваться для обработки как
аппаратных, так и программных прерываний. Во втором случае драйвер
может получать параметры вызова через стек процесса, выдавшего
прерывание.  Адрес стека процесса, который вызвал прервание помещается
блок состояния процесса-драйвера перед его запуском в поле P_ISS и
P_ISP. Формат стека приведен на рис. 1.4.

                         1.8. Флаги диспетчера

        Для запуска процесса по событию, порождаемому другим процессом
можно использовать флаги диспетчера. В блоке состояния диспетчера
зарезервирована область флагов (16 бит).  При загрузке флаги находятся
в сброшенном состоянии.  По директиве Set Flag, которую может выдать
любой процесс, диспетчер устанавливает флаги, заданные в маске флагов.
Затем диспетчер проверяет очередь к флагам и переводит все процессы,
ожидающие хотя бы один из установленных флагов, в состояние Ready.
Затем по приоритету восстанавливается прерванный процесс или
запускается новый.  Таким образом процессы запускаются по дизьюнкции
флагов.  По директиве Wait Flag процесс переходит в состояние ожидания
флага или в состояние Ready, если флаг установлен. Флаги после запуска
процессов не сбрасываются. Сбрасывать флаги может любой процесс
директивой Reset_Flag.

		 1.10 Семафоры

	Для работы с семафорами используются примитивы P и V. Семафор
должен быть описан как двухбайтовая беззнаковая глобальная переменная.
Процесс, выдавший директиву P, переходит в состояние ожидания, если
семафор равен нулю, или семафор уменьшается на единицу. По директиве V
первый из очереди ожидающих процессов переходит в состояние Ready и
семафор увеличивается на единицу.

		 1.11. Структуры данных диспетчера

        Для обращения  к диспетчеру  используется прерывание INT  32H.
Параметры передаются через регистры, а дополнительные сведения о
процессе диспетчер получает из Process Control Block (PCB) формат
которого приводится ниже. В свою очередь,  любой  процесс  может
получить  информацию  о  состоянии диспетчера через Dispatcher Stauts
Block, адрес которого указывается в INT 61H.




Рис.    1.2.       Формат Process Control Block

╓────────┬────────────────────────┬────────────────────────────╖
║Смещение│      Старший байт      │      Младший байт          ║
╠════════╪════════════════════════╪════════════════════════════╣
║   0    │#  P_pri                │#       P_id                ║
╟────────┼────────────────────────┼────────────────────────────╢
║   2    │#  P_status             │#       P_type              ║
╟────────┼────────────────────────┼────────────────────────────╢
║   4    │*                 P_flags                            ║
╟────────┼────────────────────────┼────────────────────────────╢
║   4    │&                 P_vector                           ║
╟────────┼────────────────────────┼────────────────────────────╢
║   4    │*                 P_sema                             ║
╟────────┼────────────────────────┼────────────────────────────╢
║   6    │*                 P_time                             ║
╟────────┼────────────────────────┼────────────────────────────╢
║   8    │#                 P_ep                               ║
╟────────┼────────────────────────┬────────────────────────────╢
║   12   │#                 P_SS                               ║
╟────────┼────────────────────────┬────────────────────────────╢
║   14   │#                 P_SP                               ║
╟────────┼────────────────────────┬────────────────────────────╢
║   16   │#                 P_DS                               ║
╟────────┼────────────────────────┬────────────────────────────╢
║   18   │#                 P_ES                               ║
╟────────┼────────────────────────┬────────────────────────────╢
║   20   │#&                P_Ovo                              ║
╟────────┼────────────────────────┬────────────────────────────╢
║   22   │#&                P_Ovs                              ║
╟────────┼────────────────────────┬────────────────────────────╢
║   24   │&                 P_ISS                              ║
╟────────┼────────────────────────┬────────────────────────────╢
║   26   │&                 P_ISP                              ║
╙────────┴─────────────────────────────────────────────────────╜

         *    -  поле не используется для процессов-драйверов.
         #    -  поля, устанавливается процессом перед инсталлированием.
         $    -  поле инициализируется диспетчером после инсталлирования
                 процесса.
         &    -  поле используется только для процесса-драйвера.

        P_id          - идентификатор процесса (должен быть больше 0 и
                        меньше 17).  Каждый процесс должен иметь
                        уникальный идентификатор.

         P_pri        - приоритет процесса:
                        0 - 7 - для драйверов и простых процессов;
                        8 - оперативная задача.

         P_type       - тип процесса:
                        - Tp_DOS  ( DOS-процесс );
			- Tp_Driver ( процесс-драйвер );
			- Tp_Simple ( простой процесс ).

         P_status     - состояние процесса:
                        - Run             ( активное состояние );
                        - Ready_Cont      ( готовый к продолжению );
                        - Ready_Run       ( готовый к запуску );
                        - Passive         ( пассивное );
                        - Wait_time_Run   ( ожидающий тайм-аута );
			- Wait_time_Cont  ( ожидающий тайм-аута  );
			- Wait_flag_Run   ( ожидающий флага );
			- Wait_flag_Cont  ( ожидающий флага );
			- Wait_Semaphore  ( ожидающий семафора ).

         P_flags        - маска флагов, ожидаемых процессом.
         P_vector       - номер вектора, захватываемого
                          процессом-драйвером.
	 P_Sema		- far адрес семафора, ожидаемого процессом.
         P_time         - время запуска процесса.
         P_ep           - точка входа для запуска процесса.
         Process context- содержимое регистров перед запуском процесса.
         P_Ovo, P_Ovs   - старый вектор.
         P_ISS, P_ISS   - адрес стека процесса,
                          прерванного перед переходом драйвера в
                          состояние Ready.



Рис.    1.3. Важнейшие поля Dispatcher Status Block

╓───────────╥────────────────────────────┬────────────────────────────╖
║ Смещение  ║      Старший байт          │      Младший байт          ║
╠═══════════╬════════════════════════════╧════════════════════════════╣
║   30      ║                       .DSB_f                            ║
╟───────────╫────────────────────────────┬────────────────────────────╢
║   32      ║                       .DSB_ct                           ║
╟───────────╫────────────────────────────┼────────────────────────────╢
║   34      ║      .DSB_cppri            │    .DSB_cpid               ║
╟───────────╫────────────────────────────┼────────────────────────────╢
║   36      ║                      .DSB_SP_ips                        ║
╟───────────╫────────────────────────────┼────────────────────────────╢
║   38      ║                      .DSB_SS_ips                        ║
╙───────────╨────────────────────────────┴────────────────────────────╜


Область флагов ( .DSB_f)
        Содержит значения флагов (1/0 - установлен/сброшен)

Текущее время ( .DSB_ct )
        Текущее время диспетчера ( в тиках ).

Параметры выполняемого процесса (.DSB_cppri/.DSB_id)
        Приоритет и идентификатор процесса, находяшегося в состоянии Run.

Стек прерванной оперативной задачи (.DSB_SP_ips/.DSB_SS_ips)

        При прерывании процесса  регистры сохраняются в  его  стеке.
Кадр стека прерванного процесса см. на рис. 1.4. Поле P_ISS и P_ISP
драйвера указывает на стек процесса вызвавшего прерывание.


Рис 1.4. Кадр стека процесса при прерывании


         ╓────────┬───────╖ <---P_SS:P_SP
         ║      P_SP      ║
         ╟────────────────╢
         ║      P_SS      ║
         ╟────────────────╢<---P_ISS:P_ISP (драйвер)
         ║      ES        ║
         ╟────────────────╢
         ║      DS        ║
         ╟────────────────╢
         ║      BP        ║
         ╟────────────────╢
         ║      SI        ║
         ╟────────────────╢
         ║      DI        ║
         ╟────────────────╢
         ║      DX        ║
         ╟────────────────╢
         ║      CX        ║
         ╟────────────────╢
         ║      BX        ║
         ╟────────────────╢
         ║      AX        ║
         ╟────────────────╢
         ║      CS        ║
         ╟────────────────╢
         ║      IP        ║
         ╟────────────────╢
         ║     FLAGS      ║
         ╙────────────────╜

                        2. Директивы диспетчера

        Директивы диспетчера инициируются с помощью прерывания INT
32H.  Параметры передаются через регистры AX, CX, DX и ES.  При
обработке запросов диспетчер использует Process Control Block ( Блок
Управления Процессом ), структуру которого см.  на рис. 1.3. Если после
завершения операции управление возвращается процессу, инициировавшему
операцию, то в регистре AL передается код ошибки ( ErrorCode ) Если в
результате операции процесс завершается, то код ошибки не возвращается.

			2.1 Директивы ассемблера

	Макрокоманды ассемблера и определения констант и структур
диспетчера содержатся в файле rtdef.inc. Для правильной трансляции
ассемблерной программы используйте директиву ассемблера
	INCLUDE rtdef.inc



Директива	.Create_PCB	Name,Id,Pri,Ptype,Vector

	Вход	Name	- метка блока PCB;
		Id	- идентификатор процесса: 
				0     - первый свободный,
				1-16  -	специально указанный.		
		Pri	- приоритет процесса (от 0 до 7);
		Ptype	- тип процесса;
		Vector	- номер вектора, захватываемого драйвером
			  ( используется только для драйверов ).
	Выход	нет.

	Действие	создаёт блок PCB в памяти программы.

	Ошибки	нет.

	Побочные  эффекты	нет.


Директива	.Install  Name,Name_seg,P_off,P_seg,_SS,_SP,_DS,_ES

	Вход	Name	   - смещение блока PCB;
		Name_seg   - сегмент блока PCB;
		P_off	   - смещение точки входа в процесс;
		P_seg	   - сегмент точки входа в процесс;
		_SS	   - сегмент стека процесса;
		_SP	   - смещение стека процесса;
		_DS	   - сегмент данных процесса;
		_ES	   - сегмент расширенных данных процесса.

	Выход	al  	   - код ошибки.

	Действие	инсталлирует  PCB в диспетчере. Если Id 
			в макрокоманде .Create_PCB равен 0 то
			диспечер назначает процессу первый свободный
			идентификатор, в противном случае пытается 
			выделить указанный.

	Ошибки	1	- недопустимый приоритет;
		2	- недопустимый идентификатор процесса;
		3	- идентификатор процесса занят.

	Побочные  эффекты	модифицирует регистр ax.


Директива	.Kill	Id

	Вход	Id	- идентификатор процесса (необязателен).

	Выход	al  	   - код ошибки.

	Действие	уничтожает процесс. Если Id в макрокоманде равен 0 
			или не указан,то диспечер уничтожает  текущий
			процесс, выдавший директиву. В противном случае
			уничтожается процесс с указанным идентификатором.

	Ошибки	2	- недопустимый идентификатор процесса;
		6	- не найден вектор в таблице векторов прерывания
			для процесса-драйвера.

	Побочные  эффекты	модифицирует регистр ax.


Директива	.Suspend   Id

	Вход	Id	- идентификатор процесса .

	Выход	al  	   - код ошибки.

	Действие	перводит процесс  Id в состояние Ready_Run.

	Ошибки	2	- недопустимый идентификатор процесса.

	Побочные  эффекты	модифицирует регистр ax.


Директива	.Run	Id

	Вход	Id	- идентификатор процесса.

	Выход	al  	   - код ошибки.

	Действие	перводит процесс  Id в состояние Ready_Run.
			Процесс, выдавший директиву переходит в состоя-
			ние Passive.

	Ошибки	2	- недопустимый идентификатор процесса;

	Побочные  эффекты	модифицирует регистр ax.


Директива	.Terminate	Id

	Вход	Id	- идентификатор процесса (необязателен).

	Выход	al  	   - код ошибки.

	Действие	переводит процесс в состояние Passive. Если 
			Id в макрокоманде равен 0 или не указан,то 
			диспечер пассивизирует текущий	процесс, 
			выдавший директиву. В противном случае 
			пассивизируется процесс с указанным 
			идентификатором.

	Ошибки	2	- недопустимый идентификатор процесса;

	Побочные  эффекты	модифицирует регистр ax.


Директива	.RunOnTime	Id,Delay

	Вход	Id	- идентификатор процесса;
		Delay	- длительность интервала в тиках перед
			запуском процесса.

	Выход	al  	   - код ошибки.

	Действие	перводит процесс  Id в состояние Wait_time_Run.
			Если это текущий процесс, то он прерывается.

	Ошибки	2	- недопустимый идентификатор процесса;
		3	- недопустимое состояние процесса.

	Побочные  эффекты	модифицирует регистр ax.


Директива	.RunOnFlag	Id,Flag

	Вход	Id	- идентификатор процесса;
		Flag 	- флаг, определяющий условие запуска процесса.

	Выход	al  	   - код ошибки.

	Действие	перводит процесс  Id в состояние Wait_flag_Run.
			Если это текущий процесс, то он прерывается.
			Если флаг устаовлен, то процесс переходит
			в состояние Ready_Run.

	Ошибки	2	- недопустимый идентификатор процесса;
		3	- недопустимое состояние процесса.

	Побочные  эффекты	модифицирует регистр ax.


Директивы	.SetFlag	Flag
		.Set_Flag	Flag

	Вход	Flag 	- флаг, определяющий условие запуска процесса.

	Выход	нет.

	Действие	устанавливает флаги диспетчера по дизьюнкции.
			Если есть ожидающие процессы,то они переводятся
			в состояние Ready.

	Ошибки	нет.

	Побочные  эффекты	модифицирует регистр ax.


Директива	.Create_Process	Name,Name_seg,P_off,P_seg,_SS,_SP

	Вход	Name	   - смещение блока PCB;
		Name_seg   - сегмент блока PCB;
		P_off	   - смещение точки входа в процесс;
		P_seg	   - сегмент точки входа в процесс;
		_SS	   - сегмент стека процесса;
		_SP	   - смещение стека процесса;

	Выход	al  	   - код ошибки.

	Действие	инсталлирует  PCB в диспетчере. Если Id 
			в макрокоманде .Create_PCB равен 0, то
			диспечер назначает процессу первый свободный
			идентификатор, в противном случае пытается 
			выделить указанный. После инстоляции процесс
			переводится в состояние Ready_Run.

	Ошибки	1	- недопустимый приоритет;
		2	- недопустимый идентификатор процесса;
		3	- идентификатор процесса занят.

	Побочные  эффекты	модифицирует регистр ax.


Директива	.Exit

	Вход	нет.

	Выход	al  	   - код ошибки.

	Действие	уничтожает текущий процесс.

	Ошибки	6	- не найден вектор в таблице векторов прерывания
			для процесса-драйвера.

	Побочные  эффекты	модифицирует регистр ax.


Директива	.Sleep	Delay

	Вход	Delay	- длительность интервала в тиках прерывания
		процесса.

	Выход	al  	   - код ошибки.

	Действие	переводит текущий процесс в состояние 
			Wait_time_Cont на заданный интервал в тиках.

	Ошибки	2	- недопустимый идентификатор процесса.

	Побочные  эффекты	модифицирует регистр ax.



Директива	.Wait_Flag	Flag

	Вход	Flag 	- флаг, определяющий условие прерывания 
			процесса.

	Выход	al  	   - код ошибки.

	Действие	переводит текущий процесс в состояние 
			Wait_flag_Cont. Если флаг устаовлен, 
			то процесс переходит в состояние Ready_Cont.

	Ошибки	2	- недопустимый идентификатор процесса.

	Побочные  эффекты	модифицирует регистр ax.


Директива	.Test_Flag

	Вход	нет.

	Выход	ax	- значение флагов диспетчера.

	Действие	считывает флаги диспетчера.

	Ошибки	нет.

	Побочные  эффекты	нет.



Директива	.Reset_Flag	Flag

	Вход	Flag	- слово, единичные разряды которого определяют
			сбрасываемые флаги диспетчера.

	Выход	нет.

	Действие	сбрасывает флаги диспетчера операцией 
			исключающее ИЛИ.

	Ошибки	нет.

	Побочные  эффекты	нет.


Директива	.P	Sema_off,Sema_seg

	Вход	Sema_off   - смещение far адреса семафора.
		Sema_seg   - сегмент far адреса семафора.

	Выход	al  	   - код ошибки.

	Действие	переводит текущий процесс в состояние 
			Wait_Semaphore, если семафор равен 0.
			В противном случае уменьшает семафор на 1.

	Ошибки	2	- недопустимый идентификатор процесса.

	Побочные  эффекты	модифицирует регистр ax.


Директива	.V	Sema_off,Sema_seg

	Вход	Sema_off   - смещение far адреса семафора.
		Sema_seg   - сегмент far адреса семафора.

	Выход	нет.

	Действие	увеличивает значение семафора на 1. 
			Если есть ожидающие семафор процессы,
			то первый из очереди переводится 
			в состояние Ready_Cont.

	Ошибки	нет.

	Побочные  эффекты	модифицирует регистр ax.






			2.2 Директивы Си

	Директивы языка Си и определения констант диспетчера содержатся
в файле макроопределений rtdef.h. Для правильной трансляции конструкций
языка используйте оператор Си

#define "rtdef.h"

	Для эффективной организации обращений к диспетчеру в макрокомандах
используется служебная подпрограмма calldisp, поэтому при компановке
программ на языке Си необходимо подключать файл calldisp.prj.
	Совместимость диспетчера с языковой средой Си для пакетов
Turbo C и Мicrosoft C проверена практически, однако для избежания лишних 
проблем программистам рекомендуется учесть следующие рекомендации:
	
	- сегментные регистры DS и ES должны быть инициализированы
значением текущего сегментного регистра ES при инсталяции процесса;

	- в макрокомандах использованы системные макрокоманды  
FP_OFF и FP_SEG имеющие зависимость от модели памяти и приводящие
к ошибкам в HUGE модели (дальнейшая доработка планируется);

	- отладка макрокоманд в Turbo C затруднена, поэтому
рекомендуется определять параметры макрокоманд максимально аккуратно в
соответствии с описанием;

	- программы Си, использующие функции printf и аналогичные
должны быть описаны как DOS-процссы;

	- константы, используемые макрокомандами совпадают, по
синтаксису с ассемблерными и являются зарезервированными именами.



Структура блока управления процессом PCB

 struct PCB	{ unsigned char	P_id,
				P_pri,
				P_type,
				P_status;
		  unsigned int	P_flag,
				P_time;
		 		P_ip,
				P_cs,
		 		P_ss,
				P_sp,
				P_ds,
				P_es,
				P_buf[4],
				P_DSB[2];
		 };



Директива	Create_PCB(PCB,PRI,TYP,VECTOR,ENTRY,STACK,DS,ES)

	Вход	PCB	- имя блока PCB(struct PCB);
		PRI	- приоритет процесса (от 0 до 7);
		PTYPE	- тип процесса;
		VECTOR	- номер вектора, захватываемого драйвером
			  ( для процессов не драйверов 0 );
		ENTRY	- точка входа в процесс  ( void ENTRY(); );
		STACK   - стек процесса ( unsigned STACK[256]; ).
			Стек изменяется от старших к младшим адресам 
			памяти, поэтому необходимо указывать адрес 
			последнего слова типа &STACK[255];
		DS	- сегмент данных процесса ( unsigned DS; );
		ES	- сегмент расширенных данных процесса( unsigned DS; ).

	Выход	нет.

	Действие	заполняет блок PCB в памяти программы.

	Ошибки	нет.


Директива	Install(PCB,RES)

	Вход	PCB	- имя блока PCB( struct PCB; );

	Выход	RES  	   - код ошибки ( int RES; ).

	Действие	инсталлирует  PCB в диспетчере. Если Id 
			в структуре PCB равен 0, то диспечер 
			назначает процессу первый свободный
			идентификатор, в противном случае пытается 
			выделить указанный.

	Ошибки	1	- недопустимый приоритет;
		2	- недопустимый идентификатор процесса;
		3	- идентификатор процесса занят.



Директива	Kill(Id,RES)

	Вход	Id	- идентификатор процесса ( int Id; ).

	Выход	RES  	   - код ошибки ( int RES; ).

	Действие	уничтожает процесс. Если Id в макрокоманде 
			равен 0,то диспечер уничтожает  текущий
			процесс, выдавший директиву. В противном случае
			уничтожается процесс с указанным идентификатором.

	Ошибки	2	- недопустимый идентификатор процесса;
		6	- не найден вектор в таблице векторов прерывания
			для процесса-драйвера.


Директива	Suspend(Id,RES)

	Вход	Id	- идентификатор процесса ( int Id; ).

	Выход	RES  	   - код ошибки ( int RES; ).

	Действие	перводит процесс  Id в состояние Ready_Run.

	Ошибки	2	- недопустимый идентификатор процесса.


Директива	Run(Id,RES)

	Вход	Id	- идентификатор процесса ( int Id; ).

	Выход	RES  	   - код ошибки ( int RES; ).

	Действие	перводит процесс  Id в состояние Ready_Run.
			Процесс, выдавший директиву переходит в состоя-
			ние Passive.

	Ошибки	2	- недопустимый идентификатор процесса;


Директива	Terminate(Id,RES)

	Вход	Id	- идентификатор процесса ( int Id; ).

	Выход	RES  	   - код ошибки ( int RES; ).

	Действие	переводит процесс в состояние Passive. Если 
			Id в макрокоманде равен 0,то диспечер 
			пассивизирует текущий	процесс, 
			выдавший директиву. В противном случае 
			пассивизируется процесс с указанным 
			идентификатором.

	Ошибки	2	- недопустимый идентификатор процесса;


Директива	RunOnTime(Id,Delay,RES)

	Вход	Id	- идентификатор процесса ( int Id; );
		Delay	- длительность интервала в тиках перед
			запуском процесса ( int Delay; ).

	Выход	RES  	   - код ошибки ( int RES; ).

	Действие	перводит процесс  Id в состояние Wait_time_Run.
			Если это текущий процесс, то он прерывается.

	Ошибки	2	- недопустимый идентификатор процесса;
		3	- недопустимое состояние процесса.


Директива	RunOnFlag(Id,Flag,RES)

	Вход	Id	- идентификатор процесса  ( int Id; );
		Flag 	- флаг, определяющий условие запуска 
		процесса ( int Flag; ).

	Выход	RES  	   - код ошибки ( int RES; ).

	Действие	перводит процесс  Id в состояние Wait_flag_Run.
			Если это текущий процесс, то он прерывается.
			Если флаг устаовлен, то процесс переходит
			в состояние Ready_Run.

	Ошибки	2	- недопустимый идентификатор процесса;
		3	- недопустимое состояние процесса.


Директивы	SetFlag(Flag,RES)

	Вход	Flag 	- флаг, определяющий условие запуска 
		процесса ( int Flag; ).

	Выход	RES  	   - код ошибки ( int RES; ).

	Действие	устанавливает флаги диспетчера по дизьюнкции.
			Если есть ожидающие процессы,то они переводятся
			в состояние Ready.

	Ошибки	нет.


Директива	Create_Process(PCB,PRI,TYP,ENTRY,STACK,DS,ES,RES)

	Вход	PCB	- имя блока PCB(struct PCB);
		PRI	- приоритет процесса (от 0 до 7);
		TYP	- тип процесса;
		ENTRY	- точка входа в процесс  ( void ENTRY(); );
		STACK   - стек процесса ( unsigned STACK[256]; ).
			Стек изменяется от старших к младшим адресам 
			памяти, поэтому необходимо указывать адрес 
			последнего слова, например &STACK[255];
		DS	- сегмент данных процесса ( unsigned DS; );
		ES	- сегмент расширенных данных процесса( unsigned DS; ).

	Выход	RES  	   - код ошибки ( int RES; ).

	Действие	инсталлирует  PCB в диспетчере. Если Id 
			в структуре PCB равен 0, то диспечер 
			назначает процессу первый свободный
			идентификатор, в противном случае пытается 
			выделить указанный. После инстоляции процесс
			переводится в состояние Ready_Run.

	Ошибки	1	- недопустимый приоритет;
		2	- недопустимый идентификатор процесса;
		3	- идентификатор процесса занят.


Директива	Exit(RES)

	Вход	нет.

	Выход	RES  	   - код ошибки ( int RES; ).

	Действие	уничтожает текущий процесс.

	Ошибки	6	- не найден вектор в таблице векторов прерывания
			для процесса-драйвера.


Директива	Sleep(Delay,RES)

	Вход	Delay	- длительность интервала в тиках прерывания
		процесса ( int Delay; ).

	Выход	RES  	   - код ошибки ( int RES; ).

	Действие	переводит текущий процесс в состояние 
			Wait_time_Cont на заданный интервал в тиках.

	Ошибки	2	- недопустимый идентификатор процесса.


Директива	Wait_Flag(Flag,RES)

	Вход	Flag 	- флаг, определяющий условие прерывания 
			процесса ( int Flag; ).

	Выход	RES  	   - код ошибки ( int RES; ).

	Действие	переводит текущий процесс в состояние 
			Wait_flag_Cont. Если флаг устаовлен, 
			то процесс переходит в состояние Ready_Cont.

	Ошибки	2	- недопустимый идентификатор процесса.


Директива	Test_Flag(RES)

	Вход	нет.

	Выход	RES  	   - код ошибки ( int RES; ).

	Действие	считывает флаги диспетчера.

	Ошибки	нет.



Директива	Reset_Flag(Flag)

	Вход	Flag	- слово, единичные разряды которого определяют
			сбрасываемые флаги диспетчера ( int Flag; ).

	Выход	нет.

	Действие	сбрасывает флаги диспетчера операцией 
			исключающее ИЛИ.

	Ошибки	нет.



Директива	P(Sema,RES)

	Вход	Sema	- имя семафора (int Sema; ).

	Выход	RES  	   - код ошибки ( int RES; ).

	Действие	переводит текущий процесс в состояние 
			Wait_Semaphore, если семафор равен 0.
			В противном случае уменьшает семафор на 1.

	Ошибки	2	- недопустимый идентификатор процесса.


Директива	V(Sema,RES)

	Вход	Sema	- имя семафора (int Sema; ).

	Выход	RES  	   - код ошибки ( int RES; ).

	Действие	увеличивает значение семафора на 1. 
			Если есть ожидающие семафор процессы,
			то первый из очереди переводится 
			в состояние Ready_Cont.

	Ошибки	нет.

 Директива	Residentc

	Вход	нет.

	Выход	нет.

	Действие	с помощью прерывания DOS 31h оставляет
			резидентной Си программу. Размер резидентной
			программы определяется текущей памятью,
			занимаемой программой.

	Ошибки	нет.




			3. Файлы диспетчера и его запуск

	Диспетчер состоит из следующих файлов:

rtdisp.com	программа диспетчер, резидентная в памяти;

rtdef.inc	файл макроопределений для ассемблерных программ;

rtdef.h		файл макроопределений для Си программ;

calldisp.obj	вспомательная подпрограмма для Си программ;

rtdisp.doc	данная документация;

dostest.c	пример программы на Си;

testrt.asm	пример программы на ассемблере.

	Для запуска программ, использующих диспетчер, необходимо
выдать команду:
	rtdisp

	Диспетчер выдаст сообщение и установится резидентным в памяти.
