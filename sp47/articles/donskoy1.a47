Тезисы доклада на конференцию

"Недостатки объектно-ориентированного программирования"

М.В. Донской

СП ПараГраф

Прежде всего: ООП - это хорошо, и все дальнейшее - не призыв от него
отказываться, а призыв его развивать.

Прежде, чем говорить конкретно об ООП, надо договориться, кому и зачеи
нужна технология программирования. Технология программирования нужна
руководителю большой программной разработки (в частном случае одному
программисту, делающему большую программу) для того, чтобы держать
проект в голове целиком, при необходимости уточняя детали.

Должен огорчить программистов, сказав, что такая проблема стоит перед
человечеством не впервые, и более или менее успешно решается им на всем
пути развития. Один из примеров - организация управления большими
человеческими коллективами. (Забегая вперед - структурное
программирование является аналогом иерархической организации таких
коллективов, а ООП - аналогом делегирования управленческих функций на
низшие уровни управления. Как известно, все это само по себе еще не
делает управление эффективным).

Как всякая технология, технология программирования направлена не на
поднятие уровня лучших программистов на недосягаемую высоту, а,
наоборот, на то, чтобы основная масса программистов могла производить
хорошие программы. И развитие каждого элемента этой технологии (такого
как структурное программирование или ООП) проходит три стадии -
творческую, идеологическую и инструментальную.

На творческой стадии некоторые хорошие программисты придумывают правила
программирования для собственного пользования и с успехом их применяют.
Так было со структурным программированием в 60-х годах.

Затем уже другие люди, чаще даже не программисты оформляют эти правила
как идеологию (Иногда не очень понимая про что речь. Например, первые
работы Дийкстра по структурному программированию носили не адекватный
характер.) Здесь уместна аналогия с Книгой Чисел в Библии, где правила,
имеющие глубокий практический смысл, представляются как данные Богом,
без объяснения реальных причин.

И, наконец, для удобного применения этой идеологии создается набор
инструментальных средств, и новообращенные люди не всегда знают и
понимают идеологию. Для них вся технология состоит в этих
инструментальных средствах.

Таким способом программисты среднего уровня и даже начинающие могут
производить технологичные программы. (А программисты высокого уровня
либо становятся еритиками, критикуя эти средства, а иногда и саму
идеологию, либо разрабатывают следующую).

После этого долгого введения вернемся к ООП. Оно было задумано как
естественное дополнение к структурному программированию и прекрасно с
ним сосуществовало. Но в последнее время этот милый альянс существенно
нарушился появлением нового (или хорошо забытого старого) типа
программных систем - систем, организованных потоком событий. Примером
(далеко не единственным) такой системы является программа для
MS-WINDOWS.

В системах, организованных потоком событий, программа строится как набор
реакций на события, поступающие из потока. Порождаться в потоке эти
события могут разными способами, но основным источником событий является
активность пользователя - его работа с мышью, клавиатурой и так далее.

Такая организация программ, несомненно, является прогрессом, так как
активной стороной в диалоге пользователя и программы становится
пользователь. Только такая организация может обеспечить пользователя
иллюзией того, что он может делать с программой все, что ему нужно или
хочется. К сожалению, с точки зрения программиста структура программы
становится весьма непривычной, и уж совсем не укладывающейся в привычные
схемы структурного программирования. С другой стороны, ООП было как бы
специально создано для такой организации программ и все системы,
управляемые событиями по структуре (но не всегда по инструментарию) с
необходимостью становятся объектно-ориентированными.

Классическое структурное программирование 70-х годов в этих системах,
мягко говоря, не уместно. Вся книга Петцольда по программированию в
среде WINDOWS кишит антиструктурными примерами. Становится понятно,
почему так медленно идет разработка больших программ для WINDOWS -
там-то от структурности так просто не откажешься, а то работать не
будет.

А ООП без структурного программирования правильнее называть локальным
программированием. Все локальные решения хорошо понятны, но общее
поведение программы наблюдению не поддается. Нет такого фрагмента
программы (а раньше он был), глядя на который можно сказать, что она в
общих чертах делает. Перестает существовать контекст программы по
управлению - если программа пришла в эту точку, то заведомо открыты
нужные файлы, аллоцирована нужная память и так далее. Все это приводит к
отказу от старых добрых принципов структурного программирования,
большинство переменных становится глобальными (с вытекающими отсюда
прелестями отладки). И, главное, плохо становится тому, ради кого была
придумана организация программы потоком событий - пользователю.

Любимый программистами способ организации возникающего хаоса - система
запретов на различные действия пользователя (говоря точнее, их
игнорирование). Классическим примером этого садизма являются модальные
DIALOG BOX в WINDOWS.

Для решения этой проблемы требуется создание новой технологии
программирования. Но не вместо старых, а в дополнение к ним. Автор
находится в творческой стадии создания такой технологии. Назовем ее
условно "интерфейсно-ориентированное программирование". Сразу же
оговорюсь, что это не единственно возможный способ преодоления описанных
проблем.

Возвращаясь к аналогии с организацией человеческих коллективов,
предлагается путь организации промежуточных уровней программы, почти
полностью независимых друг от друга (подобно институту
вице-президенства, но не стран, а фирм). Эти уровни называются
состояниями программы и являются хранилищами различных ресурсов - окон,
файлов, кусков динамической памяти, переменных состояния и так далее.

Работа программы строится как интерпретация конечного магазинного
автомата по принципу классических схем синтаксического анализа (когда
потоком входных событий является анализируемый текст). Соответственно,
имеется таблица, описывающая переходы из состояния в состояние. Именно
эта таблица и является тем фрагментом, где видна схема работы программы.
При переходе из состояния в состояние все ресурсы старого состояния либо
освобождаются либо передаются новому активному состоянию.

Такая схема реализована в СП ПараГраф и успешно функционирует в
различных программах как в среде DOS так и среде WINDOWS. Результатом с
точки зрения пользователя является возможность в любой момент времени
использовать любую клавишу по ее назначению, не тратя сил на понимание
должна она работать в текущий момент или нет. В прекрасном интефейсе
интегрированных сред Борланда это не так. Например, вызвав список
использовавшихся текстов клавишей ALT-0 и (естественно) не обнаружив в
нем нужного текста, я не могу сразу же обратиться к загрузке файла
клавишей F3, а должен сначала нажать ESC. Эта история происходит со мной
в среднем раз в час.

В предлагаемой схеме работы система автоматически приводит программу в
состояние (если оно содержится в стеке), способное отработать нужное
событие (в нашем примере нажатие клавиши F3). Кроме того, реализован ряд
стандартных состояний для часто встречающихся фрагментов диалога - ввода
строки, поиска имени файла и так далее.

Реализация схемы интерфейсно-ориентированного программирования держится
на принципе RUN-TIME поддержки. Увеличение быстродействия современных
машин и не слишком жесткие временные требования при работе интерфейсных
частей программы позволяют все большую часть инструментальных средств
оформлять как работающие во время исполнения программы. Как известно, во
время исполнения программы имеется больше информации о реальной ситуации
и, соответственно, можно аккуратнее делать необходимые действия.

В схеме задумано, но пока не реализовано, автоматическое освобождение
ресурсов, чью судьбу программист не определил, за счет RUN-TIME
поддержки.

Мне кажется, что эта или подобная схема программирования для систем,
управляемых потоком событий, ждет своих идеологов и инструментальщиков,
а может быть, и позволит найти кардинально другие способы структуризации
программ.
