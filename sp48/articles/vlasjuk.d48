▓▓▓▓▓▓▓▓▓▓▓▓▓  Методы защиты FOX-приложений ▓▓▓▓▓▓▓▓▓▓▓▓▓

М.И.Власюк

    В данной заметке сделана попытка осветить некоторые вопросы защиты
программ и данных в приложениях,  написанных на языке программирования
СУБД FoxBase.  Большинство описанных приемов будут полезны и для  тех,
кто программирует на Clipper и dBASE-IV.

    В качестве объектов защиты рассмотрены:

    исполняющая оболочка;
    программы;
    файлы базы данных.

    Предложены к рассмотрению следующие методы защиты:

    1. Защита COM и EXE файлов, входящих в состав приложения:

    1.1) защита исполняющей оболочки;
    1.2) защита с помощью внешнего вызова модуля-манекена.

    2. Персонализация приложения:

    2.1) вход по паролю;
    2.2) привязка приложения к серийному номеру исполняющей оболочки;
    2.3) персонализация выходных форм.

    3. Кодирование текстов программ.
    4. Кодирование данных в полях DBF-файлов.

    Список не претендует на полноту, однако комплексное применение пе-
речисленных приемов защиты достаточно надежно защитит Вашу интеллекту-
альную собственность (чего нельзя сказать о наших законах).

    В текстах примеров программ приняты ряд соглашений:

    - ключевые слова пишутся заглавными буквами;
    - наименования встроенных функций пишутся прописными буквами;
    - переменные памяти начинаются с заглавной буквы;
    - переменные (поля) базы данных пишутся заглавными буквами.


▓▓▓▓▓▓▓ 1.Защита COM- и EXE-файлов

    Этот вид защиты предусматривает применение большого числа программ
ориентированных на этот тип файлов (например,  обратитесь по этому по-
воду в ПТЦ "Техинформ", тел.290-40-73, Ассонов Алексей).

    При выборе  средств  защиты этого типа следует различать защиту от
копирования дистрибутива и защиту FOX-приложения периода исполнения.

    В защите дистрибутива Вы должны уделить  главное  внимание  защите
инсталятора  Вашего приложения,  а после инсталяции защита должна пре-
дохранять от несанкционированного копирования само приложение.

    При выборе системы защиты COM- EXE-файлов следует обратить  внима-
ние на степень автоматизации переноса дистрибутива на рабочий носитель
в рамках действующей защиты,  так как некоторые  виды  защиты  периода
исполнения  могут  быть установлены на винчестере заказчика только при
непосредственном участии лица, устанавливающего FOX-приложение.

    Отмечу, что для приложений  откомпилированных  с  помощью  Clipper
этот вид защиты наиболее предпочтителен, так как не требует раздельно-
го рассмотрения сомнительной защиты исполняющей оболочки FoxBase и вы-
чурных приемов защиты через внешние вызовы модулей-манекенов.

    Я предпочитаю  использовать  для  защиты программ систему ключевой
защиты RePro (REsident PROtector,  автор А.Степанюк,  НПО "Горсистемо-
техника"),  которая  надежно  предохраняет от несанкционированного за-
пуска и копирования одновременно до 16-ти COM- и EXE-файлов путем  ак-
тивизации  ключевых последовательностей,  ранее упрятанных на ключевой
дискете.

    Защищаемые файлы   (например,   mfoxprun.exe   и    модуль-манекен
dummy.com)  обрабатываются  программой  построения  ключей на ключевой
дискете. Вызываемые обработанные модули будут неработоспособными, если
их  ключевые  последовательности не будут "подняты" в ОЗУ другой рези-
дентной программой, выполняющей контроль отработки защищенных модулей.


    1.1. Защита исполняющей оболочки
    ================================

    Защищать исполняющие   оболочки   (karat.exe   -    СУБД    КАРАТ,
mfoxplus.exe,  mfoxprun.exe  - СУБД FoxBase 2.00+,  foxplus.exe - СУБД
FoxBase 2.10+, foxproln.exe, foxprort.exe - СУБД FoxPro/Lan) Вы сможе-
те с помощью любой из выбранных Вами защит EXE-файлов.

    Необходимо однако  помнить,  что  на  каждом  втором   компьютере,
вследствии пиратского копирования (воровство - удел нищих) имеется та-
кая же незащищенная оболочка.  Поэтому этот вид защиты более похож  на
одесский трактор-танк времен Великой Отечественной с броским названием
"На испуг!".


    1.2. Защита с помощью внешнего вызова модуля-манекена
    =====================================================

    1.2.1 Исполняемый модуль-манекен в формате COM- либо EXE-файла

    Этот вид защиты строится на использовании специально  подготовлен-
ного (ранее обработанного программой защиты) COM- или EXE-модуля,  вы-
зов которого Вы встраиваете в свою программу.  По  сути  данный  прием
опосредовано переносит защиту COM- и EXE-файлов на программы, написан-
ные на языке СУБД FoxBase.

    Фрагмент такой программы, вызывающей модуль DUMMY.COM приведен ни-
же:

* ПРИМЕР 1

* начало
* Есть DUMMY.COM в текущем каталоге?
IF FILE("DUMMY.COM")
   * да
   !DUMMY.COM  && внешний вызов модуля-манекена
ELSE
   * нет
   QUIT
ENDIF
RETURN
* конец

    Внимательно посмотрите этот фрагмент,  так как только в таком виде
программа надежно сработает в случае удаления модуля DUMMY.COM. Вместо
команды выхода "QUIT" можно вызвать модуль выдачи сообщения о  наруше-
нии защиты и затем выйти.

    Сам модуль  DUMMY.COM должен быть "молчаливым" и содержать неболь-
шое число машинных команд (применяемый мною модуль  содержит  в  своем
теле всего два байта). Защищенный, некорректно копированный модуль-ма-
некен должен остановить выполнение программы (например, "вешать" маши-
ну).

    Можно предложить  и более тонкий механизм защиты с анализом струк-
туры модуля-манекена при попытке подмены манекена другой программой  с
таким же именем. Например, для анализа тела модуля в версиях до FoxPro
можно загрузить модуль как запись  в  файл  базы  данных  и  выполнить
посимвольный  разбор  либо  сравнение с эталонной строкой.  В FoxPro с
этой задачей Вы легко справитесь, используя функции низкоуровневой ра-
боты с файлами - FOPEN(),FREAD() и привычные операторы сравнения.


    1.2.2 Исполняемый модуль-манекен в формате BIN-файла

    Принцип защиты такого типа заключается в запуске специально подго-
товленного  (на  ассемблере)  модуля привязки к винчестеру с проверкой
значения параметра, контролирующего правильную установку приложения.

* ПРИМЕР 2

* начало
* Есть DUMMY.BIN в текущем каталоге?
IF FILE("DUMMY.BIN")
   * да
   LOAD DUMMY.BIN  && внешний вызов BIN-модуля
ELSE
   * нет
   QUIT
ENDIF

* инициализация DUMMY
Param="AAAA"
CALL DUMMY WITH Param

* проверка кода возврата
IF .not.Param=="AAAA" && Не корректный код?
   * да
   QUIT
ENDIF

RETURN
* конец


▓▓▓▓▓▓▓  2.Персонализация приложения


    2.1. Вход по паролю
    ===================

    Данный вид защиты реализует санкционированный вход в Ваше приложе-
ние.  Опуская вопросы целесообразности применения этого  вида  защиты,
остановлюсь  на разборе конкретного фрагмента программы входа по паро-
лю, взятым из разработанного мною АРМ по учету средств измерений.

    Для ведения  файла  паролей  и  пользователей  используется   файл
USER.DBF со следующей структурой:

Поле   Имя Поля    Тип        Ширина

    1  FIO         СИМВОЛ        16  фамилия пользователя
    2  DAT_END     ДАТА           8  дата сеанса
    3  DAT_WRK     ДАТА           8  парольная дата
    4  BEG_TIM     ЧИСЛО          8  время начала сеанса
    5  END_TIM     ЧИСЛО          8  время окончания сеанса
    6  ALL_TIM     ЧИСЛО         10  суммарное время работы
    7  KOL_SNS     ЧИСЛО          4  суммарное количество сеансов

    Для входа в приложение используется пара  значений  "фамилия-код",
однозначно определяющих оператора текущего сеанса. Для упрятывания ко-
да (число из четырех знаков,  переменная  Pass)  используется  простое
соотношение: DAT_WRK=Pass+DAT_RAB.

    Здесь же по каждой фамилии ведется статистика по продолжительности
последнего  сеанса  (поля BEG_TIM,  END_TIM),  накапливается суммарное
время (в сек.) работы с системой (поле  ALL_TIM)  и  общее  количество
сеансов работы (поле KOL_SNS).

    Фрагмент программы  (пример 3) включает заглавный блок (собственно
вход по паролю),  тело программы (это может быть  главное  меню,  либо
другие  функциональные  модули),  завершающий блок (расчет статистики,
корректировка парольной даты):

* ПРИМЕР 3
* начало
* 1) заглавный блок

* вывод
SET COLOR TO n/g, w/n, n
@ 8,11 SAY "Введите ключ доступа, свою фамилию в указанные поля. "

Cnt=0                && сброс счетчика количества обращений
USE USER             && открыть файл пользователя
DO WHILE Cnt<=3      && цикл по количеству обращений

   * нач. установки
   Tekdat=DATE()
   Pass=0
   Fiopol=space(16)

   * ввод данных
   SET COLOR TO r/g,n/n        && затемнение поля кода
   @ 2,52 GET Pass PICT "9999"
   SET COLOR TO r/g,r/g
   @ 3,52 GET Fiopol
   @ 4,52 GET Tekdat
   READ

   LOCA ALL FOR Pass+DAT_RAB=DAT_WRK.and.Fiopol=FIO && поиск кода и
                                                    && фамилии
   Pass=0
   * найден пароль?
   IF .not.EOF()
      * да
      REPLA BEG_TIM WITH val(substr(TIME(),1,2))*3600+;
      val(substr(TIME(),4,2))*60
      EXIT
   ELSE
      * нет
      @ 8,11 SAY str(Cnt,1)+" Hеправильный код либо фамилия, повторите ввод."
      * последний вход?
      IF Cnt=2
         * да
         @ 8,11 SAY "Hеправильный доступ, Выходим из АРМ."
         SET COLOR TO
         QUIT
      ENDIF
      Cnt=Cnt+1
   ENDIF
ENDDO

* вход нормальный
SET COLOR TO r/g, w/n, n
@ 8,11 SAY "Приглашаем начать работу, нажмите любую клавишу..."

* 2) тело программы
  ...

* 3) завершающий блок

CLOSE DATABASE                 && закрыть все файлы базы данных
USE USER                       && открыть файл пользователя
LOCA ALL FOR FIO=Fiopol        && установить на активную фамилию
Pass=DAT_WRK-DAT_RAB           && восстановить код пароля

REPLACE;
 * переписать дату последнего сеанса
 DAT_RAB with Tekdat,;
 * записать время окончания сеанса (в сек.)
 END_TIM with val(substr(TIME(),1,2))*3600+val(substr(TIME(),4,2))*60,;
 * прибавить продолжительность последнего сеанса
 ALL_TIM with ALL_TIM+(END_TIM-BEG_TIM),;
 * рассчитать новую парольную дату
 DAT_WRK with DAT_RAB+Pass,;
 * изменить количество сеансов работы
 KOL_SNS with KOL_SNS+1

* завершающее сообщение
SET COLOR TO w+/g
@ 09, 8 SAY "╔═══════════════════════════════════════════════════════════╗"
@ 10, 8 SAY "║ Продолжительность сеанса       мин. Всего сеансов:        ║"
@ 11, 8 SAY "║ Пользователь                   Выход - любая клавиша.     ║"
@ 12, 8 SAY "║                                                           ║"
@ 13, 8 SAY "╚═══════════════════════════════════════════════════════════╝"
@ 10,36 SAY (END_TIM-BEG_TIM)/60  PICT "999"
@ 10,62 SAY KOL_SNS  PICT "9999"
@ 11,25 SAY FIO

* ожидание нажатия клавиши
DO WHILE inkey()=0
ENDDO

RETURN
* конец


    2.2 Привязка приложения к серийному номеру исполняющей оболочки
    ===============================================================

    Этот вид защиты делает невозможным выполнение программ под оболоч-
кой с неопознанным серийным номером.  В основе этого фрагмента (пример
4) лежит применение функции SYS(9):

* ПРИМЕР 4

SNumb=sys(9)               && чтение серийного номера оболочки

IF .not.SNumb="FPV028751"  && это не серийный номер FPV028751?
   * да

   * вывод сообщения
   SET COLOR TO W+/R
@  6,8 SAY "╔═══════════════════════════════════════════════════════════╗"
@  7,8 SAY "║ Hарушена целостность программного продукта. Дальнейшая ра-║"
@  8,8 SAY "║ бота не возможна. Hажмите любую клавишу...                ║"
@  9,8 SAY "╚═══════════════════════════════════════════════════════════╝"

   * ожидание нажатия клавиши
   SET CONS OFF
   WAIT
   SET CONS ON

   * полный выход
   QUIT

ENDIF

    Применение этого  вида  защиты  вместе  с  защитой самой оболочки,
описанной в п.1.1.,  существенно снижает возможность замены защищенной
оболочки на незащищенную.


    2.3 Персонализация выходных форм
    ================================

    Этот тип персонализации предусматривает нанесение на выходные фор-
мы реквизитов организации-заказчика.  Сами реквизиты должны быть защи-
щены от модификации пользователем.

    Можно предложить такие варианты защиты этих реквизитов:

    - внесение наименования организации-заказчика во все выходные фор-
мы в самих текстах программ.  Этот вариант хорош тем,  что не  требует
дополнительных  мер на защиту текста наименования,  так как шифрование
всего текста программ выполняется на этапе компиляции.  Однако при пе-
редаче программ другому заказчику Вы вынуждены будете выполнить замену
наименования во всех модулях печати выходных форм;

    - хранение наименования организации-заказчика во внешнем файле пе-
ременных (например,  с именем CONFIG.MEM) вместе с контрольной суммой.
Этот способ предполагает  разработку  модуля  конфигурирования  АРМ  и
средств контроля наименования организации-заказчика после чтения пере-
менных из файла CONFIG.MEM.

    Я отдаю предпочтение второму способу,  так как тиражируемые  АРМ-ы
так или иначе требуют включения в их состав средств конфигурирования.

    В примере 5 приведен фрагмент программы конфигурирования, реализу-
ющий  ввод  наименования организации-заказчика и построение простейшей
контрольной суммы.  Каждая буква кодируется числом, связанным с место-
положением этой буквы в кодирующей строке (переменная KodTable). Сумма
этих чисел дает контрольное число.

    Алгоритм можно очень просто модифицировать  на  бесконечное  число
вариантов путем перестановки литер алфавита в переменной KodTable.


* ПРИМЕР 5

* начало
IF FILE("СONFIG.MEM")

   * восстановить переменные конфигурации
   REST FROM CONFIG.MEM

ELSE

   * наименование по умолчанию
   Pred1='Очень малое предприятие "Инфо-Подол-Интернэйшнл"'
   Pred2=''

ENDIF

* дополнение наименования пробелами до длины в 50 символов
Pred1=Pred1+space(50-len(Pred1))
Pred2=Pred2+space(50-len(Pred2))

* вывод/ввод наименования
SET COLOR TO n/g,n/w
@  6,8 SAY "┌──Hаименование─предприятия, организации─потребителя──────────┐"
@  7,8 SAY "│                                                             │"
@  8,8 SAY "│                                                             │"
@  9,8 SAY "└─────────────────────────────────────────────────────────────┘"

@  7,10 GET Pred1
@  8,10 GET Pred2
READ

* построение контрольной суммы в переменной PS по первым 15-ти буквам Pred1
KodTable="зйбьчюгфхщцшэъеоаинтсрлвпкмдуыяЗЙБЬЧЮГФХЩЦШЭЪЕОАИНТСРЛВПКМДУЫЯ- "
WorkLine=rtrim(Pred1)

I=1
Ps=0 && контрольная сумма
DO WHILE I<=len(WorkLine) .and. I<15
   Ps=Ps+at(substr(WorkLine,I,1),KodTable)
   I=I+1
ENDDO

* сохранить новые значения
SET SAFETY OFF
SAVE TO CONFIG.MEM ALL LIKE P*

RETURN
* конец


    Пример 6  показывает  как  можно  реализовать контроль целостности
строки,  используя ранее сохраненные данные в переменных Pred1 (наиме-
нование предприятия-заказчика) и Ps (контрольная сумма по строке).


* ПРИМЕР 6

* начало
IF FILE("СONFIG.MEM")

   * восстановить переменные конфигурации
   REST FROM CONFIG.MEM

ELSE

   RETURN

ENDIF

* контроль по строке
@ 8,11 SAY "Контроль целостности программного продукта. Ждите...  "
KodTable="зйбьчюгфхщцшэъеоаинтсрлвпкмдуыяЗЙБЬЧЮГФХЩЦШЭЪЕОАИНТСРЛВПКМДУЫЯ- "
WorkLine=rtrim(Pred1)

I=1
CtrlSum=0
DO WHILE I<=len(WorkLine).and.I<21
   CtrlSum=CtrlSum+at(substr(WorkLine,I,1),KodTable)
   I=I+1
ENDDO

IF PS#CtrlSum && сравнение старого результата PS с вновь
              && определенной контрольной суммой в CtrlSum

   SET COLOR TO W+/R
@ 6,8 say "╔═══════════════════════════════════════════════════════════╗"
@ 7,8 say "║ Hарушена целостность наименования предприятия-заказчика.  ║"
@ 8,8 say "║ Работа не возможна. Hажмите любую клавишу...              ║"
@ 9,8 say "╚═══════════════════════════════════════════════════════════╝"

   DO WHILE inkey()=0
   ENDDO

   QUIT

ENDIF
* конец

    Можно усилить  этот  вид персонализации путем включения в выходные
формы фамилий лиц,  подписывающих те или иные документы.  Эти  фамилии
могут  быть  вынесены  в отдельный файл,  с которым работает программа
конфигурирования.  Однако  модификация  списка  фамилий  должна   быть
доступна пользователю при изменениях штатного расписания,  что по сути
отдает этот вид защиты на откуп пользователю.


▓▓▓▓▓▓▓  3. Кодирование текстов программ.

    Кодирование текста программы путем его обработки  FOX-компилятором
-  наиболее  эффективный способ шифрования текста и повышения скорости
выполнения программ.

    При компиляции,  результатом которой является модуль с расширением
FOX  либо  FXP (для FoxPro),  следует использовать ключ шифрования -E,
например:

    FOXPCOMP -E main.prg

    Интересно отметить,  что компилированные с ключом -E модули совер-
шенно не сжимаются архиваторами. Это следует иметь ввиду при подготов-
ке дистрибутивных дискет Ваших приложений.

    Не забудьте в начало головного модуля вашей программы  включить  две
SET-команды, исключающие возможность его отработки в отладочном режиме:

    SET STEP OFF
    SET DEBUG OFF

    Правилом хорошего тона является написание приложения виде одного,
двух процедурных файлов. При этом:

    - скрывается логическая структура программ;
    - повышается быстродействие;
    - наилучшим образом используются возможности планировщика
      процесса выполнения программ в FoxBase (FoxPro).

    Смею утверждать, что компилированный процедурный файл - это и есть
тот продукт,  относительно которого Fox Software, Inc. дает максималь-
ные гарантии его быстроходности (даже по сравнению с Сlipper).


▓▓▓▓▓  4. Кодирование данных в полях DBF-файлов.

    Кодирование значений текстовых полей направлено на исключение воз-
можности визуального чтения информации в  этих  полях,  при  просмотре
DBF-файлов.

    Основное требование  к  кодирующему модулю - преобразующая функция
(формула) должна иметь точную обратную функцию.

    Удобной для шифрования текстов в FoxPro является функция  преобра-
зования CHRTRAN(исх_строка,код_1,код_2),  где исх_строка - преобразуе-
мая строка,  код_1 и код_2 таблицы перевода.  Каждый символ исх_строки
ищется в код_1 и замещается на символ стоящий на том же месте в код_2.
На этой функции можно построить огромное количество кодировщиков,  из-
меняя  таблицы  код_1 и код_2.  Пример 7 иллюстрирует эту возможность.
Таблицы кодирования KodTable1,  KodTable2  используют  значение
переменной KodTable из примеров 5 и 6.


* ПРИМЕР 7

* начало
SET TALK OFF

* определение кодирующих таблиц
KodTbl1="зйбьчюгфхщцшэъеоаинтсрлвпкмдуыяЗЙБЬЧЮГФХЩЦШЭЪЕОАИНТСРЛВПКМДУЫЯ- "
KodTbl2="ЗЙБЬЧЮГФХЩЦШЭЪЕОАИНТСРЛВПКМДУЫЯзйбьчюгфхщцшэъеоаинтсрлвпкмдуыя- "

* определение преобразуемого значения
InTxt="Дай бог нам не сойти с ума..."
?InTxt && вывод на экран

* прямое преобразование
OutTxt=chrtran(InTxt,KodTbl1,KodTbl2)
?OutTxt  && вывод на экран

* обратное преобразование
InTxt=chrtran(OutTxt,KodTbl2,KodTbl1)
?InTxt && вывод на экран

RETURN
* конец

    Замечу, что в данном примере  не  будет  правильно  обрабатываться
большая русская буква "Н" (если она имеется в InTxt). Для этого следу-
ет применять FoxPro "подрезанный" народными умельцами для снятия огра-
ничения на ввод и обработку буквы "Н".

     Программа  примера  7  выдаст  последовательно на экран
следующие сообщения:

Дай бог нам не сойти с ума...
дАЙ БОГ ТАД ТЕ РОЙСИ Р ЫДА...
Дай бог нам не сойти с ума...

    В примере  8  представлен  текст  программы,  реализующей  функцию
CHRTRAN() в FoxBase 2.00+.  Вызов функции  в  точности
повторяет вызовы из примера 7.


* ПРИМЕР 8

* начало
PROCEDURE chrtran
PARAM LineText,Tbl1,Tbl2
LenTxt=len(trim(LineText))
* кодирование
I=1
OutText=""
DO WHILE I<=LenTxt
   CntTbl1=at(substr(LineText,I,1),Tbl1)
   OutText=OutText+substr(Tbl2,CntTbl1,1)
   I=I+1
ENDDO
RETURN OutText
* конец

    Применение шифрования замедляет работу программ  при  обращении  к
базам данных,  поэтому нет смысла шифровать все текстовые поля. Доста-
точно выбрать несколько, наиболее важных для Вас полей.


▓▓▓▓▓  5. Заключение

    Рассмотренные методы  защиты FOX-приложений лишь верхушка айсберга
в проблеме защиты программ и данных,  так как остались за чертой  воп-
росы  защиты  сетевых  FOX-приложений,  защиты  дистрибутивов,  защиты
текстов memo-полей и т.п.

    Сама по  себе разработка программных средств защиты Ваших приложе-
ний дело хорошее.  Однако бессмысленная  гонка  конструкторов-одиночек
изощренных  сейфов и тех кто открывает их с помощью лома и газовой го-
релки должна быть остановлена правовым регулированием вопросов  интел-
лектуальной  собственности  в  нашем таком независимом обществе.

    А пока, защищайтесь, сударь!

