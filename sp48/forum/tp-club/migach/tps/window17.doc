             ╔════════════════════════════════════════════╗
             ║                                            ║
             ║  ПАКЕТ ДЛЯ РАБОТЫ С ТЕКСТОВЫМИ ОКНАМИ      ║
             ║                                            ║
             ║       W I N D O W S    V 1.7               ║
             ║          ( turbo windows )                 ║
             ║                                            ║
             ║     (c) 1990, 1991 Мигач Ярослав           ║
             ║                                            ║
             ╚════════════════════════════════════════════╝


                 ║ РУКОВОДСТВО ПО ЭКСПЛУАТАЦИИ
                 ╙────────────────────────────

           Window17 представляет из себя набор подпрограмм,при
     помощи которых Вы сможете быстро и удобно организовать
     эффективный и нагляный интерфейс с пользователем.

     	Window17 позволяет создавать  на экране до 32-х
     независимых окон, каждое из которых теоретически может иметь
     любое количество вложенных окон ( Фактически 32 оконных
     стека ). Количество вложений ограничивается только размером
     памяти Вашего персонального компьютера. При наложении окон
     информация, бывшая на экране под окном, запоминается и после
     снятия верхнего окна опять может быть возобновлена на экране
     терминала. Кроме этого, пакет позволяет создавать стек
     экранов. Вы можете сохранить содержимое текущего экрана в
     этом стеке, а затем, при необходимости, восстановить его
     опять на терминале.  Есть также и подпрограмма для ввода и
     редактирования строк по указанным координатам на экране
     терминала.Имеется интерфейс с печатающим устройством.  У
     Window17 имеется еще много других возможностей, с которыми
     Вы познакомитесь в процессе чтения данного руководства.

  	Window17  написан при помощи Turbo Pascal V 6.0 и требует
     для своей работы такие стандартные модули, как Dos и Crt,
     которые находятся в файле Turbo.tpl, а также модуль WIN.OBJ
     полученный из программы WIN.ASM низкоуровневой обработки
     оконного интерфейса для Turbo Pascal 6.0 .  Кроме этого
     требуются модули TestH, Def, Fkey11 входящие в состав
     поставки " TURBO PASCAL SUPPORT " .

	Для использования описываемого пакета в  своей программе
     дайте команду транслятору:

           USES Dos, Crt, Def, Fkey11, Window17;


      ╔════════════╗
      ║ КОНСТАНТЫ  ║
      ╚════════════╝

     wwmax = 32; -  Максимальное количество оконных стеков. Как
                  показывает практика использования передыдущих
                  версий количество используемых оконных стеков в
                  программах редко превышает 8 - 10, чаще всего
                  это 1 - 3 оконных стека даже для программ со
                  сложным многооконным интерфейсом.

      ╔═══════════════════╗
      ║ ОБЬЯВЛЕННЫЕ ТИПЫ  ║
      ╚═══════════════════╝

     ecran_memory -   Соответствует типу TextScreen обьявленного
		    в модуле Def.

     ss_string    -   Соответствует типу StandartString
                    обьявленного в модуле Def.

	Эти типы данных сохранились от старой версии пакета -
    Window15

        При работе со строками  необходимо пользоватся
     встроеным типом StandartString или SS_String, которые
     определены как  STRING [ 79 ].

      ╔═════════════════════════╗
      ║ ГЛОБАЛЬНЫЕ ПЕРЕМЕННЫЕ : ║
      ╚═════════════════════════╝

	Глобальные переменные отсутствуют.


      ╔════════════════════════╗
      ║ ПРОЦЕДУРЫ И ФУНКЦИИ :  ║
      ╚════════════════════════╝


	В отличии от всех имеющихся на сегодняшний день пакетов
    текстового оконного интерфейса окна в Window17 имеют три
    области памяти. Первая является непосредственно экранной
    областью, вторая содержит ту информацию, которая оказалась
    под окном и третья содержит образ окна который далеко не
    всегда совпадает с тем, что отображено в текущий момент
    времени на экране. За счет наличия этой третьей области и
    достигаются те многие экранные эффекты, которые физически
    невозможны при использовании только первых двух областей.
    Наиболее полно эти возможности реализует пакет Window17
    который построен на основе обьектно - ориентированного
    программирования и будет завершен  к середине 1991 года.
	В пакете предусмотрены процедуры и функции для работы со
    всеми тремя указанными областями.


       ┌─────────────────────────────┐
       │Создание и уничтожение окон :│
       └─────────────────────────────┘

        Прежде чем создавать новое окно, необходимо установить его
     номер ( здесь и далее подразумевается номер оконного
     стека ). Эта операция производится процедурой

                work_number ( number );

     где единственным параметром является целое число, указывающее
     номер окна или цепочки окон, с которыми Вы будете работать.
     Процедура w_init по умолчанию устанавливает номер рабочего окна
     равным 1. Работу work_number более подробно мы рассмотрим
     чуть позже, а сейчас приступим к созданию окна. Сдуелать это
     можно, обратившись к процедуре n_window следующим образом:

              n_window ( x1, y1, x2, y2, color_fon, color_symbol );

     где x1, y1, x2, y2 - абсолютные координаты создаваемого окна на
     экране терминала. Эти переменные должны иметь тип BYTE.
     color_fon и color_symbol - определяют основной цвет фона и цвет
     символа в окне, устанавливаемые по умолчанию. Это совсем не
     означает, что Вы не можете использовать в данном окне и другие
     цвета. Описываемая версия пакета позволяет использовать в
     каждом окне все разрешенные для Вашего терминала цвета.
     color_fon и color_symbol должны иметь тип BYTE.

       Напомним, что координаты x1, y1, x2, y2 задаются точно так же,
     как и в стандартной процедуре турбо паскаля - WINDOW.     x1, y1
     представляют собой координаты верхнего левого угла окна, а
     координаты x2, y2 - нижнего правого. Координата x отсчитывается
     слева - направо, координата y сверху - вниз. Полный экран имеет
     размеры по x от 1 до 80, по y от 1 до 25.

        Внимание ! В целях увеличения быстродействия подпрограмм
     пакета, контроль за выходом координат из разрешенных пределов
     полностью возлагается на пользователя. В случае грубых
     нарушений, если при трансляции для отладки использован ключ
     {$R+} , средствами Турбо Паскаля на экран будет выдано
     сообщение о нарушении границ допустимого диапазона, и
     выполнение Вашей программы будет прекращено.



	Во время  вызова n_window происходит сохранение той части
     экрана, которая расположена под создаваемым окном.
     Процедура n_window еще ничего не выдает на экран, она только
     резервирует необходимую под окно память в динамически
     распределямой области и заполняет образ окна пробелами (
     фактически - заданным фоном ). Предположим, что Вы уже
     сделали с созданным окном все, что захотели. Теперь при
     помощи этой же процедуры у Вас имеется возможность наложить
     на это окно следующее. Для этого достаточно еще раз
     воспользоваться процедурой n_window и поверх старого образа
     окна будет создан новый, причем, вся информация, находящаяся
     в образе предыдущего окна, будет сохранена. Нет
     необходимосрти следить за тем, чтобы последующее окно не
     выходило за геометрические границы предыдущего.

        Теперь рассмотрим, что же еще делает work_number. Если окно
     с устанавливаемым номером было созданно, то оно активизируется.
     При этом устанавливается цвет фона и цвет символов, заданные по
     умолчанию для этого окна ( большей частью такая установка
     вызвана необходимостью совместимости пакета с предыдущими
     версиями ). Курсор "исчезает" с экрана. При
     дальнейшей работе он будет появляться на экране только при
     использовании процедуры экранного редактирования, либо если Вы
     примените процедуру show_cursor.
         Практически work_number служит для активизации ранее
     созданных окон. Причем, если имеются вложенные окна, то
     активизируется самое последнее созданное по цепочке окно.
         Если вы хотите произвести активизацию текущего окна, то
     воспользуйтесь вызовом

               work_number ( 0 );

        Для перехода к нижнему по цепочке окну необходимо
     воспользоватся процедурой

                d_window;

        Параметры не требуются. Уничтожается образ текущего
     активизированного окна ( если такое имеется ) и осуществляется
     активизация образа окна, находящегося по цепочке под ним
     ( опять же, если такое имеется ).


        Приведем примеры создания окон. Активное окно показанно
     двойной линией.


     work_number ( 1 );
     n_window ( x1, y1, x2, y2, color_fon, color_symbol );

     ╔═════════════╗
     ║             ║
     ║    ( 1 )    ║
     ║             ║
     ╚═════════════╝

     work_number ( 2 );
     n_window ( x1, y1, x2, y2, color_fon, color_symbol );

     ┌─────────────┐        ╔═════════════╗
     │             │        ║             ║
     │    ( 1 )    │        ║   ( 2 )     ║
     │             │        ║             ║
     └─────────────┘        ╚═════════════╝


     n_window ( x1, y1, x2, y2, color_fon, color_symbol );

     ┌─────────────┐        ┌─────────────┐
     │             │        │             │
     │    ( 1 )    │        │    ( 2 )    │
     │             │        │             │
     └─────────────┘        └──────┬──────┘
                                   │
                            ╔══════╧══════╗
                            ║             ║
                            ║    ( 2 )    ║
                            ║             ║
                            ╚═════════════╝



      work_number ( 1 );

      ╔═════════════╗       ┌─────────────┐
      ║             ║       │             │
      ║    ( 1 )    ║       │    ( 2 )    │
      ║             ║       │             │
      ╚═════════════╝       └──────┬──────┘
                                   │
                                   │
                            ┌──────┴──────┐
                            │             │
                            │    ( 2 )    │
                            │             │
                            └─────────────┘

      n_window ( x1, y1, x2, y2, color_fon, color_symbol );



      ┌─────────────┐       ┌─────────────┐
      │             │       │             │
      │    ( 1 )    │       │    ( 2 )    │
      │             │       │             │
      └──────┬──────┘       └──────┬──────┘
             │                     │
             │                     │
      ╔══════╧══════╗       ┌──────┴──────┐
      ║             ║       │             │
      ║    ( 1 )    ║       │    ( 2 )    │
      ║             ║       │             │
      ╚═════════════╝       └─────────────┘


      work_number ( 2 );

      ┌─────────────┐       ┌─────────────┐
      │             │       │             │
      │    ( 1 )    │       │    ( 2 )    │
      │             │       │             │
      └──────┬──────┘       └──────┬──────┘
             │                     │
             │                     │
      ┌──────┴──────┐       ╔══════╧══════╗
      │             │       ║             ║
      │    ( 1 )    │       ║    ( 2 )    ║
      │             │       ║             ║
      └─────────────┘       ╚═════════════╝



      d_window;

      ┌─────────────┐       ╔═════════════╗
      │             │       ║             ║
      │    ( 1 )    │       ║    ( 2 )    ║
      │             │       ║             ║
      └──────┬──────┘       ╚═════════════╝
             │
             │
      ┌──────┴──────┐
      │             │
      │    ( 1 )    │
      │             │
      └─────────────┘

          И так далее.




                pd_window;

      - удаляет активизированное окно с мгновенным восстановлением
      информации на экране



       ┌───────────────────────────────────┐
       │Ввод / вывод при работе с окнами : │
       └───────────────────────────────────┘


        Все выше сказанное окажется совершенно бесполезным, если у
      Вас не будет никакой возможности что-либо поместить в образ
      активизированного окна. Начнем с описания простейших процедур:

                w_char ( x, y, ch );

      Выводит символ ch в образ активизированного окна, без
      отображения на экране, по относительным координатам x и y,
      которые отсчитываются от верхнего левого угла окна, а не
      экрана. Пожалуйста запомните это; везде, где речь будет идти
      об относительных координатах, отсчет ведется именно так.

        Процедура

                xy_char ( x, y, ch );

      делает все то же самое, однако она помещает символ прямо на
      терминал, не фиксируя его в образе окна. При наложении окон
      этот символ будет потерян.

        Процедура

                w_xy_char ( x, y, ch );

      помещает символ и в образ окна и на экран одновременно.
        Совершенно аналогичным образом работают процедуры:

                w_print ( x, y, stroka );

                xy_print ( x, y, stroka );

                w_xy_print ( x, y, stroka );

      отличие состоит в том, что они работают не с отдельно взятым
      символом, а со строкой символов. Если строка выходит за
      геометрическую правую границу окна, то она будет усечена.



        Следует отметить еще одно средство, которое может пригодится
      Вам в работе. Это процедура:

                ld_char ( x, y, ch, atr );

      которая позволяет получить символ ch и его атрибут типа BYTE
      из образа активизированного окна по заданным относительным
      координатам.
        Для сверхскоростного вывода символа на экран можно
      воспользоваться процедурами :

                w_display ( x, y, color_fon, color_symbol, ch );
         и
                t_display ( x, y, ch );

      Обе процедуры оперируют с абсолютными координатами. В первой
      цвет фона и цвет символа задаются явно. Вторая использует
      установленное текущее значение и поэтому работает быстрее
      первой. Параметры color_fon и color_symbol  имеют тип BYTE,
      x, y  тип BYTE, ch тип CHAR. Указанные процедуры работают
      непосредственно с экраном, игнорируя при этом все окна,
      проэтому будьте осторожны при их использовании.

        Процедура

                conout ( x, y, key, ch );

      выводит символ ch в окно по относительным координатам x, y,
      используя ключ направления key. Если key = 0, то символ
      выводится только на экран; если key = 1, то символ выводится в
      образ окна; если key = 2, то символ выводится и на экран и в
      образ окна. По сути эта процедура представляет собой
      комбинацию уже ранее описанных w_char, xy_char и w_xy_char.
      Далее, везде, где речь пойдет о ключе направления, будет
      подразумеватся выше приведенное определение key. Мы рассматриваем
      здесь эту процедуру только в качестве примера использования ключа
      направления key. Эта процедура не входит в интерфейсную секцю
      пакета Window версий старше 1.3 .

        Процедура

           tp_window;

      осуществляет мгновенное отображение образа активизированного окна
      на экран терминала.


        Процедура:

                tp_old_screen;

      осуществляет мгновенное отображение информации "спрятанной" под
      акртивизированным окном

        Когда Вам потребуется отпечатать образ окна на экран
      слеве направо - воспользуйтесь процедурой :

                p_window ( number );

      где number = число типа BYTE, равное  номеру
      печатаемого окна. Если Вы хотите отобразить текущее окно -
      задайте  number = 0. При использовании этой процедуры всегда
      на экран будет выдаваться последнее созданое по цепочке окно.

                r1_window ( x1, y1, x2, y2, key, ch );

      вычерчивает в активизированном окне рамку при помощи символов
      ch, по направлению, задаваемому ключом key ( см процедуру
      conout ) по относительным координатам x1, y1 ( верхний левый
      угол ) и x2, y2 ( нижний правый угол ). Отметим некоторые
      особенности значения ch:
        ch = CHR ( 196 ) - вычерчивание тонкой линией;
        ch = CHR ( 205 ) - вычерчивание двойной линией;
        ch = CHR ( 219 ) - вычерчивание толстой линией;
        ch = CHR ( 242 ) - вычерчивание тонкой линией со
             скругленными углами ( действует для знакогенераторов
             машин ЕС-1840, ЕС-1841, НЕЙРОН, последних моделей
             ИСКРА-1030 )
      Если вы зададите ch = CHR ( 0 ), то независимо от назначения
      key на экране будет отображена рамка символами из
      активизированого окна. Все рамки выводятся на экран терминала
      по часовой стрелке начиная с левого верхнего угла.
      Рассматриевеемая процедура не выполняет сопряжения линий, как
      это делают процедуры вычерчивания линий.
         Отобразить содержимое образа окна на терминале
      можно при помощи процедуры:

                rn_window ( ch );

      где ch - символ рамки. При вызове этой процедуры содержимрое
      окна будет постепенно появляться на экране в раздвигающейся
      рамке. После отображения рамка, обрамляющая окно, будет
      зафиксированна в его образе.



        Для удаления с экрана текущего активизированного окна и
      плавного появления информации,находившейся в предыдущем по
      цепочке окне, необходимо воспользоваться процедурой:

                rd_window ( ch );

      Окно будет удаляться с экрана посредством сжимающейся в точку
      рамки, рисуемой символом ch. Эта процедура осуществляет
      автоматическую активизацию окна-предшественника. Процедуру
      d_window использовать при этом нет необходимости.

        Удаление текущего окна и появление на экране информации из
      окна-предшественника можно также  организовать при помощи
      следующей последовательности операций:

                d_window;

                p_window ( 0 );



       ┌───────────────┐
       │Стек экранов : │
       └───────────────┘

        Рассмотрим группу процедур для работы с экранным стеком:

                save_ecran;

       помещает текущее изображение с экрана терминала в экранный
       стек, запоминая при этом и положение курсора.

                restore_ecran;

       "вытаскивает" из стека изображение и помещает его на экран
       терминала, восстанавливая при этом прежнее положение курсора.

                d_ecran;

       удаляет из стека последнее помещенное туда изображение.

                copy_ecran_to_window;

       копирует изображение, находящееся в верхушке экранного стека
       в активизированное окно.



       ┌───────────────────────────────────────────────┐
       │Дополнительные процедуры оконного интерфейса : │
       └───────────────────────────────────────────────┘

         Поговорим немного о цвете. Как уже было ранее сказано,
      данная версия пакета позволяет использовать в окне любые
      возможные цвета. Установить новый цвет фона или новый цвет
      символов в окне можно при помощи процедур:

                set_color_symbol ( color_symbol );
            и
                set_color_fon ( color_fon );

      Цвета, назначенные этими проедурами, будут действовать до
      следующего обращения к work_number. Использование этих
      процедур вызвано той необходимостью, что обычные
      TEXTBACKGROUND и TEXTCOLOR для рассматриваемого пакета не
      действуют ( конечно, при условии, что Вы не пользуетесь
      стандартными процедурами экранного интерфеса ).

        При помощи процедуры

                c_window;

      Вы можете удалиить всю информацию из образа активизированного
      окна, заполнив его тем самым пробелами ( фоном, заданным по
      умолчанию ).

        Процедура :

                cursor (x, y );

      Процедура установит курсор по относительным координатам в
      активизированном окне если в момент вызова процедуры разрешено
      отображение курсора на экране терминала.

         Обращение к процедуре :

                show_cursor;

      включает или выключает курсор на экране терминала в зависимости от
      предыдущего состояния. Если курсора не было, то он появится, и
      наоборот.

	  Вызов процедуры :

		HideCursor;

      в любом случае погасит изображение курсора.


        Процедура :

                show_t ( color_fon, color_sym );

     создает в образе активизированного окна тень. Тень будет занимать
     самую правую колонку окна и самую нижнюю строку. Т.е. при работе с
     тенью необходимо учиртывать то, что тень занимает месрто в
     акртивизированном окне. При вызове этой процедуры отображение тени
     на экране не происходит. Для вывода окна с тень на экран
     воспользуйтесь любой из процедур отображения образа окна.
     Цвет тени передается первым параметром, цвет символов под тенью
     вторым.

        Процедура :

                m_window ( x, y );

     переместит активизированное окно на экране, установив его таким
     образом, что x и y станут новыми координатами верхнего левого угла
     окна. Если координаты x и y указаны так, что окно выйдет за пределы
     экрана, то процедура не произведет ни каких действий.

        Теперь приведем описание еще нескольких полезных
      подпрограмм, которые расширят Ваши возможности при работе с
      данным пакетом.
                f_window ( file, rem_cod, stop_cod, error );

      загружает образ активного окна текстом из файла fl типа TEXT.
      Загрузка образа производится до тех пор, пока образ окна не
      заполнен, либо пока не найден конец файла, либо пока первым
      символом одной из строк файла не встречен символ stop_cod.
      Если первым символом в одной из строк файла встречен rem_cod,
      то эта строка опускается, т.е. не входит в образ окна. В
      случае ошибки дисковых операций загрузка окна также
      прекращается и флаг ошибки error устанавливается в TRUE. При
      нормальном завершении он принимает значение  FALSE.

        Процедура

                sirena;

      как правило вызывает , особенно при первом употреблении, легкий
      шок пользователя, а затем лишь неприятные ощущения. Звук сирены
      можно выключить нажатием на любую клавишу во время исполнения
      программы.


        Сирену с успехом использует процедура вывода сообщений:

                warning ( x, y, mess );

      где x и y координаты выводимого сообщения, mess - текст сообщения.
      При нажатии на любую клавишу текст выведенного сообщения убирается
      и сирена выключается.

        Перейдем к описанию более сложных процедур :

                line_y ( x, y1, y2, pointer, key, ch );

      line_y отображает в активном окне вертикальную линию. x, y1 и
      y2 указывают относительные координаты этой линии, а ch
      является символом, при помощи которого эта линия отображается.
      Действие ключа направления key подробно рассмотрено в описании
      процедуры conout. pointer определяет способ рисования линии.
      Если pointer = 0, то линия будет изображаться сверху - вниз;
      если pointer = 1, то снизу - вверх. При установленном key в 1 или
      2 процедуры вычерчивания линий будут выполнять сопряжение с ранее
      выведенными в образ окна линиями псевдографики.

        Аналогично работает:

                line_x ( y, x1, x2, pointer, key, ch );

      эта процедура вычерчивает горизонтальную линию. Если
      pointer = 0, то слева - направо, если 1, то справа - налево.

	Следует обратить внимание на такое полезное средство как
      процедура :

		DoneAllWindows;

      которая уничтожает образы всех окон размещенных пакетом в
      динамически распределяемой области памяти.

		SetBackGround16;

	Переключает на 16-цветную фоновую палитру, а

		SetBackGround8;

      на 8-ми цветную с мерцанием ( + BLINK )



       ┌─────────────────────────────────────┐
       │Ввод и редактирование строк в окнах :│
       └─────────────────────────────────────┘

        Процедура:

                xy_edit ( x, y, ch, ln, stroka );

      производит ввод или редактирование символьной строки stroka по
      относительным координатам в активизированном окне. ln -
      представляет собой максимальное разрешенное для ввода или
      редактирования количество символов в строке. ch - символ,
      который указывает на команду, повлекшую за собой выход из
      режима редактирования. Если имела место двухсимвольная
      последовательность ( ESC + SYM ), то ch принимает значение
      последнего символа последовательности. При вводе и
      редактировании символьной строки с помощью xy_edit Вы можете
      пользоваться всеми командами для редактирования редактора
      WORDSTAR и функциональной клавиатурой. Режим вставки при
      редактировании всегда включен. Выход из режима редактирования
      осуществляется при помощи  ENTER, ESC, а также командами
      функциональной клавиатуры. Опрос клавиатуры
      осуществляется при помощи функций опроса клавиатуры
      определенных в модуле Def. При помощи xy_edit Вы можете
      обрабатывать и числовые значения. Например :

                .....
                     rstr : REAL;
                     stroka : STRING;
                     ch : CHAR;
                     err : INTEGER;

                .....             { x, y, ln - могут быть const }

                STR ( rstr, stroka );
                REPEAT
                      xy_edit ( x, y, ch, ln, stroka );
                      VAL ( stroka, rstr, err )
                UNTIL ( err = 0 );
                ......

	Процедура :

		SetInsEdit;

      включает режим вставки для редактора.


	Использование процедуры :

		ReSetInsEdit;

      выключает режим вставки в редакторе.

	Процедура :

		SetClearEdit;

      управляет режимом автоматического стирания. Т.е. при
      нажатии первой клавиши не являющейся клавишей управления
      производится стирание старой информации, содержащейся в
      редактируемой строке. Эта установка автоматически снимается
      при первом же обращении к редактору xy_edit. Если это
      необходимо, вызов данной процедуры следует повторять перед
      каждым новым вызовом процедуры редактирования.

	Установить цвет фона и цвет символов редактируемой строки
      можно при помощи процедуры :

		SetColorEdit ( fon, sym : BYTE );

      где fon - цвет фона подсветки редактируемой строки, а sym -
      цвет символов редактируемой строки.

	Следующее средство позволяет установить цвет фона и
      символов редактируемой строки при ожидании нажатия первой
      клавиши, если перед этим производился вызов SetClearEdit;.
      После нажатия первой клавиши цвета изменятся на
      установленные процедурой SetColorEdit; :

		SetColorClearEdit ( fon, sym : BYTE );

      параметры здесь аналогичны SetColorEdit;.


	Процедура :

		ReSetColorEdit;

      сбросит предыдущую установку цветов. При этом редактор
      будет работать с текущими установленными цветами.

	Одним из главных инструментов для управления
      редактированием является :

		SetTypeEdit ( tp : BYTE );

     Эта процедура позволяет задать тип редактируемых символов.
     Параметр tp и является задаваемым типом, который может
     принимать следующие значения :
	0 - любые символы,
	1 - только числовые символы,
	2 - числовые символы и символы необходимые для ввода
          вещественного числа,
	3 - числовые символы и знаки "+" и "-",
	4 - только русские большие буквы. Здесь вызавается
          функция преобразования символов всех регистров
          клавиатуры в русские большие буквы используя
          альтернативную кодировку,
	5 - русские большие и маленькие буквы и числовые знаки.
	  Здесь производятся преобразования аналогичные ( 4 )
          только с учетом регистра больших и маленьких букв.

	Процедура :

		ReadData ( x, y : BYTE; VAR Stroka :
                           StandartString );

     аналогична по своему характеру процедуре xy_edit, тольк
     вводит специальные данные - день, месяц, год в экранном
     формате с соответствующей подсказкой ДДММГГ. Опрос
     клавиатуры осуществляется при помощи функций опроса
     клавиатуры определенных в модуле Def.



	Функция :

		RushLardg ( ch : CHAR ) : CHAR;

     возвращает только большие русские буквы, независимо от
     регистра нажатой клавиши.

	Функция :

		RushAll ( Ch : CHAR ) : CHAR;

     работает аналогично, только с учетом больших и маленьких
     букв.



       ┌──────────────────────────────────┐
       │Работа с печатающим устройством : │
       └──────────────────────────────────┘

        Процедура:

                epson ( ch, key );

     производит вывод символа на печатающее устройство. Причем печать
     будет производиться только в том случае, если key = FALSE.
     Если печатающее устройство не готово, либо призошол какой - то сбой
     то на экран будет выдано соответствующее сообщение, которое
     автоматически удаляется с экрана при снятии неисправности, либо при
     нажатрии любой из клавиш. Если была нажата клавиша ESC, то печать
     будет прекращена и ключ key установлен в TRUE.

	Для удобства использования введены следующие две
     процедуры :

		List ( Stroka : STRING; Key : BOOLEAN );
	    и
		ListLn ( Stroka : STRING; Key : BOOLEAN );

    которые работают аналогично процедуре epson только печатают
    строку без перехода на новую строку или с переходом.

	Следует отметить что процедуры работают с любым типом
    принтера, а не только с EPSON, поскольку используют вызовы
    BIOS.



       ┌──────────────────────────────────────────────┐
       │Краткий справочник по процедурам и функциям : │
       └──────────────────────────────────────────────┘

        Ниже, для справки, приведено сокращенное описание процедур
      пакета Window17. Текст программ пакета снабжен
      необходимыми комментариями, что поможет Вам, при
      необходимости, более подробно разобраться в его устройстве.

   _______________________________________________________________________

   Название процедуры     Использование             параметры
   _______________________________________________________________________

   set_color_symbol       установка текущего        sym : BYTE
                          цвета символов
   _______________________________________________________________________

   set_color_fon          установка текущего        fon : BYTE
                          цвета фона
   _______________________________________________________________________

   w_display              вывод символа на экран    x, y : BYTE;
                          терминала по абсолют-     fon, sym : BYTE;
                          ным координатам с за-     ch : CHAR
                          данным фоном и цветом
   _______________________________________________________________________

   t_display              вывод символа на экран    x,y : BYTE;
                          терминала по абсолют-     ch : CHAR
                          ным координатам с теку-
                          щим цветом фона и символа
   _______________________________________________________________________

   save_ecran             экран в стек                 нет
   _______________________________________________________________________

   restore_ecran          экран из стека                нет
   _______________________________________________________________________

   d_ecran                удалить экран из стека       нет
                          без отображения
   ______________________________________________________________________

   copy_ecran_to_window    копировать содержимое
                           экрана верхушки стека в      нет
                           активизарованное окно


    work_number            установить номер активи-    number : BYTE
                           рованного окна
   ______________________________________________________________________

    n_window               создать окно                 kx1, ky1, kx2,
                                                        ky2 : BYTE;
                                                        col_fon : BYTE;
                                                        col_sym : BYTE
   ______________________________________________________________________

   w_char                  вывести символ в             x,y : BYTE;
                           образ окна                   ch : CHAR
   ______________________________________________________________________

   xy_char                 вывести символ на            x,y : BYTE;
                           экран                        ch : CHAR
   ______________________________________________________________________

   w_xy_char               вывести символ в            x, y : BYTE;
                           образ окна и на             ch : CHAR
                           экран
   _____________________________________________________________________

   w_print                 вывести строку              x, y : BYTE;
                           в образ окна               stroka : ss_string
   _____________________________________________________________________

   xy_print                вывести строку              x, y : BYTE;
                           на экран                   stroka : ss_string
   _____________________________________________________________________

   w_xy_print              вывести строку в            x, y : BYTE;
                           образ окна и на            stroka : ss_string
                           экран
   _____________________________________________________________________

   ld_char                 получить символ             x, y : BYTE;
                           из образа окна             VAR ch : CHAR;
                                                       VAR at : BYTE
   _____________________________________________________________________

   xy_edit                 редактирование              x, y : BYTE;
                           строки                      VAR ch : CHAR;
                                                       ln : BYTE;
                                                       VAR stroka :
                                                            ss_string


   d_window                удалить окно                   нет
   _____________________________________________________________________

   p_window                печать окна с заданным       number : BYTE
                           номером
   _____________________________________________________________________

   c_window                заполнение образа              нет
                           окна фоном
   ____________________________________________________________________

    f_window               чтение окна из               VAR fl : TEXT;
                            файла                       rem_cod : CHAR;
                                                        stop_cod : CHAR;
                                                        VAR kkey :
                                                                BOOLEAN
   ____________________________________________________________________

   line_y                  вычерчивание             x, y1, y2 : BYTE;
                           вертикальной линии        pointer : BYTE;
                                                     key : BYTE;
                                                     ch : CHAR
   ____________________________________________________________________

   line_x                                           y, x1, x2 : BYTE;
                                                      pointer : BYTE;
                                                     key : BYTE;
                                                     ch : CHAR
   _____________________________________________________________________

   r1_window               вычерчивание              kx1, ky1, kx2, ky2
                           рамки                            : BYTE;
                                                     key : BYTE;
                                                      ch : CHAR
   _____________________________________________________________________

   rn_window               развертывание окна        ch : CHAR
   ______________________________________________________________________

   rd_window               свертывание окна          ch : CHAR;
   ______________________________________________________________________

   tp_window               печать окна                    нет
   ______________________________________________________________________

   show_cursor             вкл/выкл курсор                нет


   sirena                     сирена                      нет
   _____________________________________________________________________

   warning                 вывод сообщения            x, y : INTEGER;
                                                      mess : ss_string
   ______________________________________________________________________

   tp_old_screen           вывод изображения               нет
                           из под окна
   ______________________________________________________________________

   pd_window               удаление окна с                 нет
                           восстановлением экрана
   ______________________________________________________________________

   m_window                перемещение окна           x, y : BYTE
   ______________________________________________________________________

   show_t                  создать тень               color_fon,
                                                      color_sym : BYTE
   ______________________________________________________________________

   epson                   вывести символ на          ch : CHAR;
                           печать                     VAR key : BOOLEAN
   ______________________________________________________________________

   cursor                  установить курсор по
                              относительным           x, y : BYTE
                               координатам
   ______________________________________________________________________

   SetInsEdit              вкл режим вставки                нет
   ______________________________________________________________________

   ReSetInsEdit            выкл режим вставки               нет
   ______________________________________________________________________

   HideCursor              погасить курсор                  нет
   ______________________________________________________________________

   DoneAllWindows          удалить все окна                 нет
   ______________________________________________________________________

   SetClearEdit            установка на стирание            нет
   ______________________________________________________________________


   ______________________________________________________________________

   SetColorEdit            цвета редактирования          fon, sym :
   							    BYTE;
   ______________________________________________________________________

   SetColorClearEdit       цвета редактирования          fon, sym :
   						            BYTE;
   ______________________________________________________________________

   ReSetColorEdit          сброс цветов редактирования      нет
   ______________________________________________________________________

   List                   печать строки                Stroka : STRING;
						       Key : BOOLEAN
   ______________________________________________________________________

   ListLn                  печать строки               Stroka : STRING;
						       Key : BOOLEAN
   ______________________________________________________________________

   RushLardg               русские большие               Ch : CHAR
   ______________________________________________________________________

   RushAll                 все русские                   Ch : CHAR
   ______________________________________________________________________

   ReadData                ввод даты                     x, y : BYTE;
							 VAR Line :
							 SS_String
   ______________________________________________________________________
