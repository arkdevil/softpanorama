           Руководство по Data Encryption ToolKit
                         Версия 1.3


1. Введение.

     Data Encryption  ToolKit позволяет  шифровать данные  и
исполняемые     коды      программ,     предотвращая      их
несанкционированное использование. Шифрование производится в
соответствии с федеральным стандартом США (DES), описанным в
книге Lance J. Hoffman, Modern Methods for Computer Security
and Privacy,  Prentice-Hall,  Inc.,  Englewood  Cliffs,  New
Jersey, 1977.
     Data Encryption ToolKit состоит из двух взаимосвязянных
компонентов: библиотеки  функций для  языков C,  C++,  Turbo
Pascal и Ассемблера, обеспечивающих шифрование блоков данных
и участков выполняемого кода в оперативной памяти, и утилиты
шифрования файлов.


2. Алгоритм шифрования.

     Стандарт DES определяет алгоритм шифрования блока из 64
бит по  ключу длиной  56 бит, или, иначе говоря, 8-байтового
блока по  7-байтовому ключу.  Точнее, ключ тоже считается 8-
байтовым, но  старший бит каждого байта не используется. При
этом алгоритмы шифрования и расшифровывания почти идентичны.
     Алгоритм выполняется  в 2 этапа. На первом производится
преобразование ключа,  при котором  из 1 исходного создается
16  производных   ключей,  которые  на  втором  этапе  будут
использованы в  16 одинаковых  последовательных  шагах.  Все
отличие алгоритма  расшифровывания от  алгоритма  шифрования
заключается в  том, что  для  него  эти  16  подключей  надо
выстроить  в   противоположном  порядке.   На  втором  этапе
производится  преобразование   8-байтового   блока   данных,
состоящее из  пролога, 16  упомянутых выше шагов, и эпилога.
Отметим,  что  при  шифровании  больших  объемов  информации
первый этап должен быть выполнен только один раз, а второй -
для каждого 8-байтового блока.
     Поскольку  стандарт   определяет  только  алгоритм  для
шифрования одного  8-байтового блока,  строить на его основе
алгоритмы шифрования  больших объемов  информации можно  по-
разному. В  Data Encryption  ToolKit используются  следующие
методы:
A. Без  зацепления.   Каждый   8-байтовый   блок   шифруется
     независимо от других.
B. С зацеплением.  Перед шифрованием  каждый блок поразрядно
     складывается с  зашифрованным  предыдущим  блоком.  При
     расшифровывании каждый  расшифрованный блок  поразрядно
     складывается с нерасшифрованным предыдущим. Для первого
     блока    в    качестве    зашифрованного    предыдущего
     используется дополнительный блок.
C. С аутентификацией.  Так же,  как и  с зацеплением,  но  в
     качестве  первого   блока  добавляется  аутентификатор,
     который  ни  с  чем  не  складывается.  Первые  6  байт
     аутентификатора задаются пользователем, а в последние 2
     помещается контрольная  сумма шифруемых данных, включая
     первые 6  байт аутентификатора.  При расшифровывании по
     аутентификатору проверяется целостность данных.
     Допускается также  повышение надежности  шифрования  за
счет   последовательного   шифрования   каждого   блока   по
нескольким ключам  (шифрование по  составному ключу). Каждый
ключ  рассматривается   как  последовательность  четырех  2-
байтовых целых  чисел (подключей).  Таким образом  составной
ключ  может  рассматриваться  как  последовательность  4 * N
подключей,  где   N  -  число  ключей.  Понятно,  что  время
шифрования примерно  пропорционально N,  так что  не следует
злоупотреблять длинными  ключами. В упомянутой книге Hoffman
утверждается, что  шифрование уже  по трем  ключам абсолютно
надежно (хотя,  если не  страдать  шпиономанией,  то  вполне
хватит  и  одного).  Составной  ключ  может  быть  и  пустым
(N = 0), в  этом  случае  отрабатываются  только  зацепление
блоков и  аутентификация. Это  может быть  использовано  для
повышения надежности  хранения данных  без затрат времени на
шифрование (точнее,  для повышения  уверенности, что  данные
сохранились).
     Кроме описанных  выше цифровых  8-байтовых ключей можно
использовать  символьные.   Символьный   ключ   состоит   из
последовательности  графических   символов  ASCII   (включая
пробел)  произвольной   длины  (в   разумных  пределах).   В
принципе,   в нее  можно включать и любые другие символы, но
они будут  интерпретированы как  пробелы. Такой длинный ключ
разбивается на  участки по  9 символов  (самый левый участок
дополняется спереди  пробелами), которые затем преобразуются
в 8-байтовые цифровые ключи.


3. Шифрование данных.

     Шифрование данных  возможно как  с помощью библиотечных
функций, так  и с  помощью утилиты шифрования файлов, причем
данные из  файла, зашифрованного  утилитой, могут быть затем
расшифрованы в прикладной программе через вызовы функций.
     При шифровании  данных с  помощью функций из прикладной
программы  вначале   надо  подготовить   ключ  (первый  этап
шифрования). Для  этого используется  одна из трех функций -
init_encryption, encryption_key  или decryption_key.  Первая
оперирует  цифровыми   ключами  и   используется   как   при
шифровании, так  и при расшифровывании, последние работают с
символьными    ключами,    при    шифровании    используется
encrypyion_key, а при расшифровывании - decryption_key.
     После обработки  ключа находящиеся в оперативной памяти
данные могут шифроваться (расшифровываться) либо 8-байтовыми
блоками,   либо    сразу    большими    областями.    Первое
обеспечивается функцией  encrypt_block, а  второе - функцией
encrypt_area, для которой дополнительно можно задать один из
пяти режимов  шифрования: без  зацепления; с  зацеплением; с
отдельно расположенным аутентификатором; с аутентификатором,
расположенным в последних 8 байтах обрабатываемой области; с
аутентификатором,   расположенным    в   первых   8   байтах
обрабатываемой области.
     При  шифровании   файла  с   помощью  утилиты   с   ним
производится ряд  преобразований. Длина  файла увеличивается
на 1-8  байт таким  образом, чтобы  она стала  кратна  8.  В
последний  байт   записывается  число   байт,  принадлежащих
исходному файлу,  в последних 8 байтах полученного файла (0-
7), в  остальные дополнительные  байты записываются двоичные
нули. Затем  файл разбивается  на участки  длиной 504  байта
(последний участок  может быть  укороченным). Каждый участок
расширяется  сзади  на  8  байт  и  шифруется  с  помещением
аутентификатора   в    это   расширение.    Таким   образом,
зашифрованный  файл   состоит  из  независимо  зашифрованных
участков длиной  512 байт (т.е. 1 физический сектор), каждый
из  которых  защищен  аутентификатором.  (Последний  участок
может быть  укорочен,  но  все  остальное  справедливо  и  в
отношении его.)
     В первые  3 байта аутентификатора помещается расширение
имени исходного  файла, при  необходимости дополненное сзади
двоичными нулями.  Следующие  3  байта  занимает  порядковый
номер участка  (нумерация начинается  с  0),  обеспечивающий
дополнительный контроль целостности данных.
     При  расшифровывании   файла  с   помощью  утилиты,  он
восстанавливается  в   своем  первоначальном  виде,  включая
расширение имени  файла. При  этом производится  контроль на
все   нарушения,   которые   можно   обнаружить   средствами
аутентификации.  Для   восстановления  исходного  расширения
достаточно чтобы  оно сохранилось  в аутентификаторе хотя бы
одного сектора.


4. Шифрование исполняемого кода.

     При    шифровании    исполняемого    кода    необходимо
согласованное  применение  библиотечных  функций  и  утилиты
шифрования  файлов.  Отдельные  участки  файла,  содержащего
исполняемый   код,    шифруются   с   помощью   утилиты,   а
расшифровываются в процессе выполнения (т.е. уже загруженные
в оперативную  память)  через  вызовы  функций.  Зашифрованы
могут быть  как .COM,  так  и  .EXE  файлы,  а  также  файлы
оверлеев (функции  могут быть  использованы  только  в  .EXE
файлах, поэтому  для расшифровки  .COM файла они должны быть
помещены в  оверлей,  имеющий  структуру  .EXE  файла).  Для
шифруемых файлов  не  должны  применяться  никакие  средства
упаковки.
      Программа,  которая  будет  шифроваться,  должна  быть
оформлена специальным образом. Прежде всего, она должна быть
условно разбита  на  2  части  -  шифруемую  и  нешифруемую.
Шифруемая  часть   может  состоять  из  нескольких  участков
произвольной длины  не обязательно  кратной 8.  Их суммарная
длина также  не обязана  делиться на  8 -  недостающие байты
будут взяты из Области Управления Шифрованием.
     В нешифруемую  часть должна  входить Область Управления
Шифрованием, код  функций, выполняющих  расшифровку, а также
те участки  кода и  данных, которые  используются до  вызова
этих функций.  Если программа  состоит из нескольких файлов,
т.е. имеет  оверлеи, каждый  шифруемый файл должен содержать
свою   Область    Управления   Шифрованием.   Главный   файл
(вызываемый непосредственно  из  DOS)  в  нешифруемой  части
обязательно должен  содержать код, с которого начинается его
выполнение. Файл  оверлея, в  принципе, может  в нешифруемой
части содержать только Область Управления Шифрованием.
     Область Управления  Шифрованием - это структура данных,
создаваемая в  программах на  языках C и C++ по макрокоманде
ENCRYPTION_CONTROL_AREA, в  программах на языке Turbo Pascal
- при  включении  файлов  ENCRCA0.INC  -  ENCRCA9.INC,  а  в
программах   на   языке   Ассемблера   -   по   макрокоманде
EncryptionControlArea. Она  указывается в качестве параметра
при вызове функций шифрования и расшифровывания исполняемого
кода.    Заполняется    Область    Управления    Шифрованием
автоматически во  время шифрования  файла с помощью утилиты,
пользователь указывает  в макрокоманде  только  ее  номер  и
максимальное число  несмежных  участков  в  шифруемой  части
(шифруемых  фрагментов)   с  учетом   того,   что   заданные
пользователем фрагменты  при наличии внутри них перемещаемых
констант могут  быть разбиты на более мелкие. Если указанное
число окажется  в результате  слишком малым, утилита сообщит
об этом  и не зашифрует файл. Каждый файл может содержать до
десяти Областей Управления Шифрованием, пронумерованных от 0
до 9.  Они могут использоваться в произвольном порядке как с
одинаковыми ключами, так и с разными.
     Для расшифровки  зашифрованной части необходимо откуда-
нибудь получить  ключ (цифровой  или символьный).  Он  может
содержаться в  нешифруемой части  программы, в  этом  случае
шифрование,  по-видимому,   используется   для   затруднения
дизассемблирования  кода   и  изменения   его  всякого  рода
хакерами. Ключ  может также  запрашиваться у пользователя, в
такой ситуации  он будет, фактически, выполнять роль пароля,
без знания  которого даже  самый искуссный  хакер не  сможет
заставить    программу     работать    (поскольку    данные,
зашифрованные по  алгоритму DES  не могут  быть расшифрованы
без знания  ключа за разумное время). Можно представить себе
и другие источники получения ключа.
     После того  как ключ  тем или иным способом получен, он
должен быть,  как и  при расшифровывании  данных,  обработан
функцией   init_encryption    или   decryption_key.    Затем
зашифрованная  часть   может  быть   расшифрована   функцией
decrypt_program. При  необходимости  эта  часть  может  быть
вновь  зашифрована,  для  этого  следует  применять  функции
init_encryption, encryption_key  и encrypt_program. Ключ, по
которому будет  производиться повторное шифрование, может не
совпадать с  исходным. Через  какое-то время программа может
быть опять расшифрована и так до бесконечности.
     Если  пользователь  не  хочет  вызывать  все  указанные
функции, ему  предоставляется еще одна функция, делающая все
сама. Эта функция запрашивает ввод пароля и использует его в
качестве  символьного   ключа  при  расшифровке.  Ее  имя  -
password_decrypt_program. Внутри  себя она  содержит Область
Управления Шифрованием максимального размера.
     В связи  с возможностью  использования  шифрования  для
обеспечения парольной  защиты,  надо  заметить,  что  пароль
(ключ) нигде  и ни в каком виде в исходном программном файле
не содержится.  Он указывается только при шифровании файла и
может быть  разным для  разных копий  программы.  Тем  самым
обеспечивается уникальная  идентификация копий  и, в  случае
чего, простота определения зарегистрированного пользователя,
растиражировавшего свою копию.
     До тех  пор, пока  программный  файл  не  зашифрован  с
помощью  утилиты,  вызовы  функций  шифрования  не  вызывают
никаких действий. Это позволяет включить их в исходный текст
с самого  начала, но реально не связываться с шифрованием до
завершения отладки.  После того,  как файл будет зашифрован,
функции автоматически включатся в работу.


5. Константы, библиотечные функции и макрокоманды.

     Библиотечные функции  содержатся в файле ENCRYPT.LIB, а
их описания, а также описания используемых с ними констант и
макрокоманд - в файлах ENCRYPT.H (для программ на языках C и
C++) и  ENCRYPT.INC (для программ на языке Ассемблера). Файл
ENCRPAS.LIB  содержит  те  же  функции,  но  оформленные  по
правилам языка  Pascal (на  любителя), файла .H для них нет.
Файл  ENCRYPT.PAS,   написанный  на   языке  Turbo   Pascal,
описывает их  же, а  также используемые  с ними константы. С
этим  языком   используются  также   файлы   ENCRCON.INC   и
ENCRCA0.INC - ENCRCA9.INC.


5.1. Константы.

ENCRYPTION_KEY_SIZE                     C, C++
EncryptionKeySize                       Pascal, Assembler
= 8 - число байт в цифровом ключе.

ENCRYPTION_KEY_MAX_NUMBER               C, C++
EncryptionKeyMaxNumber                  Pascal, Assembler
= 255 -  максимальное  число  цифровых  ключей  в  составном
     ключе.

ENCRYPTION_KEY_LENGTH                   C, C++
EncryptionKeyLength                     Pascal, Assembler
= 9 - длина символьного ключа, преобразуемого в 1 цифровой.

ENCRYPTION_KEY_MAX_LENGTH               C, C++
EncryptionKeyMaxLength                  Pascal, Assembler
= 2295 - максимальная длина символьного ключа.

ENCRYPTED_BLOCK_SIZE                    C, C++
EncryptedBlockSize                      Pascal, Assembler
= 8 - число байт в 8-байтовом блоке.

ENCRYPTED_BLOCK_MAX_NUMBER              C, C++
EncryptedBlockMaxNumber                 Pascal, Assembler
= 4095 -  максимальное число  8-байтовых блоков  в шифруемой
     области.

ENCRYPTED_BLOCK_MAX_SIZE                C, C++
EncryptedBlockMaxSize                   Pascal, Assembler
= 32760 - максимальное число байт в шифруемой области.

ENCRYPTED_FRAGMENT_MAX_NUMBER           C, C++
EncryptedFragmentMaxNumber              Pascal, Assembler
= 84 - максимальное число шифруемых фрагментов кода.

ENCRYPTION_CONTROL_AREA_MAX_ID          C, C++
EncryptionControlAreaMaxId              Pascal, Assembler
= 9 - максимальный номер Области Управления Шифрованием.

ENCRYPTION_KEY_AREA_SIZE (NUMBER)       C, C++
EncryptionKeyAreaSize                   Pascal, Assembler
= NUMBER * 128 + 8 - число байт в Области Ключей Шифрования,
     формируемой на  первом этапе шифрования, NUMBER - число
     цифровых  ключей.  В  программах  на  языках  Pascal  и
     Ассемблера NUMBER  равно константе EncryptionKeyNumber,
     которая должна  быть предварительно  определена.  Кроме
     того, для  определения этой  константы в  программе  на
     языке Pascal необходимо включить файл ENCRCON.INC.
ENCRYPT_NOCHAIN                         C, C++
EncryptNochain                          Pascal, Assemdler
= 0 - код команды шифрования без зацепления.

DECRYPT_NOCHAIN                         C, C++
DecryptNochain                          Pascal, Assembler
= 0 - код команды расшифровывания без зацепления.

ENCRYPT_CHAIN                           C, C++
EncryptChain                            Pascal, Assembler
= 1 - код команды шифрования с зацеплением.

DECRYPT_CHAIN                           C, C++
DecryptChain                            Pascal, Assembler
= - 1 - код команды расшифровывания с зацеплением.

ENCRYPT_AUTH                            C, C++
EncryptAuth                             Pascal, Assembler
= 2  -   код  команды   шифрования  с  аутентификатором  вне
     шифруемой области.

DECRYPT_AUTH                            C, C++
DecryptAuth                             Pascal, Assembler
= - 2 -  код команды  расшифровывания с аутентификатором вне
     расшифровываемой области.

ENCRYPT_LAST_AUTH                       C, C++
EncryptLastAuth                         Pascal, Assembler
= 3 -  код команды  шифрования с  аутентификатором  в  конце
     шифруемой области.

DECRYPT_LAST_AUTH                       C, C++
DecryptLastAuth                         Pascal, Assembler
= - 3 -  код команды  расшифровывания с  аутентификатором  в
     конце расшифровываемой области.

ENCRYPT_FIRST_AUTH                      C, C++
EncryptFirstAuth                        Pascal, Assembler
= 4 -  код команды  шифрования с  аутентификатором в  начале
     шифруемой области.

DECRYPT_FIRST_AUTH                      C, C++
DecryptFirstAuth                        Pascal, Assembler
= - 4 - код команды расшифровывания с аутентификатором в
     начале расшифровываемой области.

NORMAL_ENCRYPTION                       C, C++
NormalEncryption                        Pascal, Assembler
= 0 - код возврата при нормальном завершении.

INVALID_ENCRYPT_PARAM                   C, C++
InvalidEncryptParam                     Pascal, Assembler
= 1 - код возврата при недопустимых значениях параметров.

INVALID_ENCRYPT_AUTH                    C, C++
InvalidEncryptAuth                      Pascal, Assembler
= 2 -  код  возврата  при  расшифровке  области  с  неверным
     аутентификатором.

self_encrypt_start                      C, C++
SelfEncryptStart                        Pascal
= _psp + 16  -   сегментный   адрес   начала   выполняющейся
     программы. В  программах на  языке ассемблера  _psp при
     старте программы содержится в регистрах DS и ES.


5.2. Макрокоманды.

ENCRYPTION_CONTROL_AREA (ID, NUMBER)    C, C++
ID - номер Области Управления Шифрованием (от 0 до 9).
NUMBER - максимальное число шифруемых фрагментов.
     По  этой   макрокоманде  создается  Область  Управления
Шифрованием и  переменная void * encryption_control_area_0 -
encryption_control_area_9, указывающая на нее.

EncryptionControlArea Id, Number        Assembler
Id - номер Области Управления Шифрованием (от 0 до 9).
Number - максимальное число шифруемых фрагментов.
     По  этой   макрокоманде  создается  Область  Управления
Шифрованием    с     именем     EncryptionControlArea0     -
EncryptionControlArea9.

     Для создания Области Управления Шифрованием в программе
на   языке    Pascal   необходимо    определить    константу
EncryptionFragmrntNumber0  -   EncryptionFragmrntNumber9   и
включить файл ENCRCA0.INC - ENCRCA9.INC.


5.3 Функции.

void far cdecl init_encryption (   
  void far * key_area,
  const void far * key,
  const int key_number);                C, C++, Assembler
procedure InitEncryption (
  var KeyArea;
  var Key;
  NumKey: Integer);                     Pascal, Assembler
key_area, KeyArea - указатель на Область Ключей Шифрования.
key, Key - указатель на цифровой ключ.
key_number,  KeyNumber   -  число   цифровых  ключей,   если
     требуется расшифровка, то со знаком минус.
     Эта функция  формирует  Область  Ключей  Шифрования  по
цифровым ключам  как для  операции  шифрования,  так  и  для
операции расшифровывания.

void far cdecl encryption_key (
  void far * key_area,
  const char far * key_string);         C, C++, Assembler
procedure EncryptionKey (
  var KeyArea;
  KeyString: String);                   Pascal, Assembler
key_area, KeyArea - указатель на Область Ключей Шифрования.
key_string,  KeyString   -  указатель  на  символьный  ключ,
     завершающийся нулевым  байтом (C, C++) или содержащий в
     первом байте свою длину (Pascal).
     Эта функция  формирует  Область  Ключей  Шифрования  по
символьному ключу для операции шифрования.

void far cdecl decryption_key (
  void far * key_area,
  const char far * key_string);         C, C++, Assembler
procedure DecryptionKey (
  var KeyArea;
  KeyString: String);                   Pascal, Assembler
key_area, KeyArea - указатель на Область Ключей Шифрования.
key_string,  KeyString   -  указатель  на  символьный  ключ,
     завершающийся нулевым  байтом (C, C++) или содержащий в
     первом байте свою длину (Pascal).
     Эта функция  формирует  Область  Ключей  Шифрования  по
символьному ключу для операции расшифровывания.
     

void far cdecl encrypt_block (
  const void far * key_area,
  void far * block);                    C, C++, Assembler
procedure EncryptBlock (
  var KeyArea;
  var Block);                           Pascal, Assembler
key_area, KeyArea - указатель на Область Ключей Шифрования.
block, Block - указатель на 8-байтовый блок.
     Эта функция шифрует или расшифровывает 8-байтовый блок.

int far cdecl encrypt_area (
  const void far * key_area,
  void far * main_block,
  const int block_number,
  void far * add_block,
  const int op_code);                   C, C++, Assembler
procedure EncryptArea (
  var KeyArea;
  var MainBlock;
  BlockNumber: Integer;
  var AddBlock;
  OpCode: Integer;
  var RetCode: Integer);                Pascal, Assembler
key_area, KeyArea - указатель на Область Ключей Шифрования.
main_block,   MainBlock    -    указатель    на    шифруемую
     (расшифровываемую) область.
block_number, BlockNumber  - число  8-байтовых блоков в этой
     области.
add_block, AddBlock - указатель на дополнительный 8-байтовый
     блок, используемый по-разному в разных режимах.
op_code, OpCode - один из перечисленных выше кодов команды.
Результат,  RetCode  -  один  из  перечисленных  выше  кодов
     возврата.
     Эта  функция   шифрует  или   расшифровывает   область,
состоящую из  нескольких 8-байтовых  блоков.  Дополнительный
блок  используется  только  в  режимах  с  зацеплением  и  с
аутентификатором вне  области. В первом случае он передает в
функцию блок для зацепления с предыдущей областью и получает
из нее  блок для зацепления со следующей областью. Во втором
- он содержит аутентификатор.

void far cdecl encrypt_program (
  const void far * key_area,
  const int segment_address,
  const void far * control_area);       C, C++, Assembler
procedure EncryptProgram (
  var KeyArea;
  SegmentAddress: Word;
  var ControlArea);                     Pascal, Assembler
key_area, KeyArea - указатель на Область Ключей Шифрования.
segment_address, SegmentAddress - сегментный адрес шифруемой
     программы.
control_area, ControlArea  - указатель на Область Управления
     Шифрованием.
     Эта функция шифрует исполняемый код.

void far cdecl decrypt_program (
  const void far * key_area,
  const int segment_address,
  const void far * control_area);       C, C++, Assembler
procedure DecryptProgram (
  var KeyArea;
  SegmentAddress: Word;
  var ControlArea);                     Pascal, Assembler
key_area, KeyArea - указатель на Область Ключей Шифрования.
segment_address, SegmentAddress - сегментный адрес шифруемой
     программы.
control_area, ControlArea  - указатель на Область Управления
     Шифрованием.
     Эта функция расшифровывает исполняемый код.

void far cdecl password_decrypt_program (
  );                                    C, C++, Assembler
procedure PasswordDecryptProgram;       Pascal, Assembler
     Эта функция запрашивает ввод пароля и расшифровывает по
нему, как по символьнуму ключу,  исполняемый код.


6. Утилита шифрования файлов.

     Для шифрования  файлов используется  утилита  ENCRFILE.
Формат ее вызова:

ENCRFILE [options] [filename [directory]]

Опции могут  набираться на  любом регистре и располагаться в
любом месте  командной строки.  Они  не  обязаны  отделяться
пробелом от  имени утилиты,  других  параметров  и  друг  от
друга. Имеются следующие опции:
/H - выдать справку о формате вызова;
/L - выдать информацию о лицензировании;
/E - зашифровать файлы данных;
/D - расшифровать файлы данных;
/V - проверить целостность зашифрованных файлов данных;
/C - зашифровать исполняемые файлы;
/S  -   выполнить  заданную  операцию  для  всего  поддерева
     каталогов, начиная с исходного;
/R  -   пометить  выходные   файлы   как   только   читаемые
     (используется вместе с /E);
/B  -   создавать  резервные   копии  для  шифруемых  файлов
     (используется вместе с /C);
/W - удалять исходные файлы с очисткой занимаемого ими места
     (вместе с  /E), удалять  исходные файлы  (вместе с /D),
     удалять резервные  копии  с  очисткой  занимаемого  ими
     места (вместе  с /C,  подразумевается наличие  /B), для
     каждого отдельного файла указанное действие выполняется
     только при успешном завершении основной операции.
     Параметр filename задает файлы, для которых выполняется
операция. В  нем допустимы  стандартные wildcards  DOS '*' и
'?'. Если  расширение имени  отсутствует, то для операции /E
принимается пустое  расширение, для /D и /V - .SEC, а для /C
- .EXE,  если имя  отсутствует полностью, то для операции /E
принимается *.*,  а  для  всех  остальных  -  *  (расширение
добавляется  как   было  указано).  За  один  раз  в  каждом
справочнике может быть обработано не более 1000 файлов (если
окажется, что их больше, оставшиеся не будут обработаны).
     Параметр directory  может быть указан для операций /E и
/D, для  которых он  указывает выходной  справочник, а также
для операции  /C с  опцией /B,  в этом  случае он  указывает
справочник  для  резервных  копий.  Этот  справочник  должен
существовать до  вызова утилиты,  однако его  подсправочники
(если указана  опция /S)  при  необходимости  будут  созданы
автоматически. Поэтому  не следует с этой опцией указывать в
качестве выходного  или резервного  справочник,  входящий  в
поддерево   исходного.   По   умолчанию   берется   исходный
справочник.
     Имена выходных  файлов для  операции /E  образуются  из
имен исходных  файлов заменой  расширения на  .SEC, а если в
операции участвуют  несколько файлов из одного справочника с
одинаковыми  именами,   но  разными   расширениями,   первый
выходной файл  получит расширение  .SEC, а  все остальные  -
.^xx, где  xx -  два допустимых  в именах символа, различных
для каждого файла.
     При выполнении  операции /D  расширения  имен  выходных
файлов восстанавливаются  из  содержимого  исходных  файлов,
если же  это по  какой-либо причине оказывается невозможным,
для них  устанавливаются расширения  .OUT или .`xx по тем же
правилам, что  при операции /E. Точнее говоря, всем выходным
файлам  назначаются  такие  расширения,  а  после  окончания
операции   файл,   если   расширение   было   восстановлено,
переименовывается.
     Назначение расширений  резервным копиям  при выполнении
операции /C  зависит от назначенного резервного справочника.
Если он  совпадает с исходным, назначаются расширения .BAK и
.~xx, а  если не совпадает - файлы резервируются с исходными
расширениями.
     Если  в   выходном  или   резервном   справочнике   уже
существует файл  с именем,  назначенным выходному  файлу или
резервной копии, он будет замещен. При совпадении входного и
выходного (резервного)  справочников некоторые входные файлы
могут быть  таким образом  замещены. Если замещенный входной
файл еще  не был  обработан, то  он уже  не будет  обработан
никогда. Но  в любом  случае заместивший  его файл  не будет
обработан повторно.
     Перед началом  обработки файлов  утилита запрашивает  у
пользователя ключ, который может быть введен как в цифровой,
так и в символьной форме. При вводе ключа в символьной форме
регистр букв, а также все ведущие и замыкающие пробелы в нем
являются  значащими.   Каждый  цифровой  ключ  вводится  как
последовательность      из       четырех      четырехзначных
шестнадцатеричных чисел  - подключей.  Для прекращения ввода
подключей на очередной запрос надо ответить простым нажатием
на клавишу  Enter. Если  последний ключ  был  введен  не  до
конца, все его оставшиеся подключи принимаются равными 0.
      После  завершения операции  для всех  указанных файлов
утилита спрашивает,  будет ли выполняться та же операция для
других файлов и, если да, с тем же ключем или с другим. Если
пользователь ответил  утвердительно у  него, если требуется,
будет  запрошен  новый  ключ,  а  затем  новая  спецификация
исходных файлов.  Последняя интерпретируется  точно так  же,
как параметр filename, за исключением того, что по умолчанию
принимается  предыдущая  спецификация.  Если  операция  того
требует, будет  запрошена также  спецификация выходного  или
резервного справочника, которая интерпретируется так же, как
параметр directory.
     При выполнении операции /C для каждого шифруемого файла
дополнительно   запрашивается   номер   Области   Управления
Шифрованием и  список шифруемых  фрагментов. Каждый фрагмент
задается парой  чисел -  смещением  от  начала  программы  и
длиной. Для  .COM (.BIN)  файлов смещение задается от начала
файла, для  .EXE файлов  - от  начала  загружаемой  области.
Таким образом вся необходимая информация может быть получена
из  листингов  линкера  и,  возможно,  трансляторов.  Как  и
подключи цифровых ключей, смещение и длина должны задаваться
в шестнадцатеричной форме. Завершается ввод также аналогично
- простым  нажатием на  клавишу Enter  в ответ  на вопрос об
очередном фрагменте.
     Введенные   данные    о   фрагментах   проверяются   на
корректность (фрагменты не должны пересекаться друг с другом
и с  Областью Управления  Шифрованием) и  при  необходимости
утилита предлагает повторить ввод. После завершения ввода на
дисплей  выдается   список  фрагментов  в  формате  листинга
линкера (.MAP  файла) и  требуется  подтверждение.  В  ответ
можно разрешитьь  шифрование этих  фрагментов или  повторить
ввод с самого начала.
     За  один   раз  может  быть  использовано  произвольное
количество Областей Управления Шифрованием. Завершается этот
простым процесс  нажатием на клавишу Enter в ответ на вопрос
о номере очередной Области Управления Шифрованием.


7. Состав пакета и лицензирование.

     Data Encryption ToolKit включает в себя следующие файлы
(в составе архивного файла ENCR0130.EXE):
ENCRFILE.EXE - утилита шифрования файлов;
ENCRYPT.LIB -  библиотека,  содержащая  все  описанные  выше
     функции;
ENCRPAS.LIB -  библиотека, содержащая  их же, но оформленных
     по соглашениям языка Pascal;
ENCRTPU1.OBJ -  ENCRTPU5.OBJ  -  объектные  модули  этих  же
     функций для языка Turbo Pascal;
ENCRYPT.PAS - исходный текст единицы, включающей их;
ENCRYPT.H - включаемый файл описаний для языков C и C++;
ENCRCON.INC, ENCRCA0.INC  - ENCRCA9.INC  - включаемые  файлы
     для языка Turbo Pascal;
ENCRYPT.INC - включаемый файл описаний для языка Ассемблера;
TEST1.C -  TEST5.C -  тестовые примеры использования функций
     на языке C++;
TEST1.PAS  -  TEST5.PAS  -  тестовые  примеры  использования
     процедур на языке Turbo Pascal;
ENCRYPT.TXT - руководство пользователя (этот файл);
README.TXT - файл, который стоит прочитать первым.
     Данный пакет  могут использовать  и распространять  все
желяющие для  любых целей  при условии, что распространяются
все указанные  файлы в составе исходного архивного файла, ни
один  из   них  не   подвергся  никаким   изменениям  и   за
распространение не взымается никакой платы.
     Автор  не   дает  никаких  гарантий  применимости  Data
Encryption ToolKit  для каких-либо конкретных целей, а также
гарантий сохранности  и защищенности  обрабатываемых  с  его
помощью данных.
