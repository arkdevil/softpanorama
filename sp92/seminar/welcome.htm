<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=windows-1252">
<META NAME="Generator" CONTENT="Microsoft Word 97">
<TITLE>Outline of the cource</TITLE>
<META NAME="Template" CONTENT="C:\PROGRAM FILES\MICROSOFT OFFICE\OFFICE\html.dot">
</HEAD>
<BODY LINK="#0000ff" VLINK="#800080">

<FONT SIZE=2><P ALIGN="RIGHT">v.1.0 (Dec.17, 1997)</P>
</FONT><B><I><FONT FACE="Arial"><P>Welcome to Java seminar 1998</P>
</B></I></FONT><FONT SIZE=2><P>&nbsp;Welcome to the Softpanorama Java seminar. The Softpanorama is now devoted to the support of learning of major Internet -related technologies. It will provide links to free books and other useful online resources related to that Java language (and later Linux and Perl).</P>
<P>I would like to teach Java in 1998 from the following point of view:</P>

<UL>
<LI>Java is about component programming and Java development will eventually come to creating and using Javabeans in GUI environment.</LI>
<LI>Java is a platform (see below).</LI>
<LI>Java is complex and need substantial efforts to master (21 days are NOT feasible for anybody, but programmers with vstrong background in C++, PL/1, Ada or other complex universal programming language). C programmers need some (painful) retraining.</LI>
<LI>The number one application area for Java is database programming for Intranets.</LI></UL>

<P>My main point is in order to successfully switch to Java (i.e. to achieve better productivity) one need to use GUI based environment (Jbuilder, Caf&eacute;, etc.) as much as possible. And in order to use GUI generation capabilities successfully one need to understand much more that pure Java - how Java GUI works and what component linking code is generated automatically. The GUI builder does not explain this part of its job to the programmer although Borland Jbuilder is pretty decent in keeping generated code and GUI picture in sync (IMHO Jbuilder is preferable in environments that use Oracle as a database). Of course there no silver bullet in programming and return on investment in this new class of programming tools will be decent only with discipline and hard labor.</P>
<P>The lack of adequate teaching materials is the single biggest problem in teaching Java in the university environment. Another major concern is unreasonable student expectations regarding how easy it is to program in Java programming. Of course Java has some strong points as a first or second language at the universities:</P>

<UL>
</FONT><LI>Decent implementation is freely available(JDK). Excellent implementation can be bought for $99 or less (Jbuilder);</LI></UL>


<UL>
<FONT SIZE=2><LI>Java is smaller and easier to learn than C++ as a first or second language;</LI>
<LI>Most students find it enjoyable and programming applets can be fun("small is beautiful");</LI>
<LI>Students believe that knowing Java is a valuable skill in commercial environment, and they are probably right;</LI>
<LI>Because it is interpretive language debugging is simpler that in C or C++ (and memory leaks are absent). So students can spend more time learning about algorithms, programming design, and problem solving; </LI>
<LI>Java is well suited to teach Internet networking and concurrency - very important subjects these days;</LI>
<LI>For students with Fortran or Pascal background it is easier to become familiar with the whole C language family using Java as a second language (C, C++, Objective C, CORBA-IDL, Java, etc.).</LI></UL>

<P>One should not treat the Java as something without flaws - ultimate solution of all world problems. It has pretty wide applications domain, but will never replace languages like Fortran for numerical computations, or Perl for text processing. The language is far from being perfect and some design decisions are quite controversial. To certain extent the designers had fallen into the trap of trying to define languages like George Orwell's Newspeak, in which it is impossible to think bad thoughts </FONT><FONT FACE="Wingdings" SIZE=2>J</FONT><FONT SIZE=2>. So it is only natural that in many case sharper instrument like C would be appropriate. Fortunately natural methods mechanism in Java allow that.  Also Java now pretty heavyweight with all AWT classes and huge standard library.</P>
<P>I should stress that as a language Java is quite complicated. For example Java is the one of 3 known to me languages that supports coroutines (other two are Simula 67 - the grandmother of object-oriented programming and Modula) and since v.1.1 has pretty decent (i.e. pretty complex) exception handling mechanism. Generally speaking Java complexity can be compared with PL/1 which in seventies was considered a huge language </FONT><FONT FACE="Wingdings" SIZE=2>J</FONT><FONT SIZE=2>. Java is definitely much more complex that Pascal or Fortran. The Java's mix of objects and native types is confusing and over reliance on object paradigm makes procedural programming problematic even for tasks that should be better solved using procedural approach. Strings as immutable data type and limited flexibility of input/output makes "file processing" programming more complicated than necessary( that prevents Java from being a strong competitor to Perl in CGI scripts). With regards to the language itself, programmers that previously use PL/1 or Ada generics or C++ templates will find Java restrictive, sometimes to the point of making programming more difficult. The language standard is still a moving target. While the syntax of Java resembles C++ Java lacks such important features as templates, pointers-to-methods, explicit parameter passing modes, enumerated types, and operator overloading.  While the omission of these features simplifies the Java language, it also affects the way that programmer design their programs. For example converting C++ code to Java, while keeping the same functionality, can be tedious due to the absence of some C++ language constructs. Java often significantly increased the number of classes that one need to wrote compared to C++, where templates are used to factor out common code.</P>
<P>But weak points do not matter much if you have such a strong momentum on the marketplace</FONT><FONT FACE="Wingdings" SIZE=2>J</FONT><FONT SIZE=2> . No language is perfect and language adoption is not directly connected with its quality. I would like to suggest that Java has become cultural phenomenon. Programming is dynamic and we all move from one OS culture to another, and even more often from one language subculture to another. For example we can distinguish IBM mainframe culture (with its reliance on memory dumps </FONT><FONT FACE="Wingdings" SIZE=2>J</FONT><FONT SIZE=2> ), UNIX culture with its powerful file system and love for regular expressions ;-), DOS/Windows culture with OLE and DDE, etc. The new Java culture incorporates a lot of UNIX culture and gives a chance to DOS/Windows programmers to see how cultural context switch works. That is, your new cultural context will change the way you accomplish the same thing. </P>
<P>From that point of view Java is not only somewhat less complicated that C++, but a new culture that make possible to do things differently and debug programs differently. At the same time although Java does protect a programmer from some errors typical in C++, but there is no free lunch and you need to pay for this with speed and problems of interfacing with huge number of built in classes and libraries.(from the point of view of efficiency Java problems are far from being resolved and C++ will probably coexists with Java for at least couple of decades as (now) first and (later) second major programming language). </P>
<P>So mastering Java needs a lot of hard work and dedication. Do not try to master the whole language, try to create your own subset and master it. We don't expect a native Russian speaker to use the same subset of English as a native Mandarin speaker. The same situation exists in mastering Java. The best way to master Java is to try to form your own subset based on your previous programming experience, if any. And do not hurry. As my own experience in 1997 showed it definitely cannot be done in 21 days. Libraries are especially difficult to grasp and that still change from one release to another. That means that one needs not only work on exercises but a lot of work on your own projects in order to create your own subset of the language. That's the bad news. The good news is that decent programmers in Java will be decently paid and are in demand. </P>
<P>IMHO now the main application area for Java is not client site, but server side Java, especially database programming and mainframe/UNIX middleware. Despite all shortcomings Java most probably will become major language for developing commercial applications and commercial applications domain is were the money are. I see huge potential of Java in database programming (the reason is easy to understand - anybody who used to built-in languages in Oracle, FoxBASE, etc. really hate them ;-) and I plan to pay substantial attention to JDBC in this course.</P>
<P>Java is a platform. And that to certain extent liberates programmer from "need to know"  three or more incompatible API. "Real OSes" like Windows 95 or UNIX in Java world are relegated to the role of BIOS. IMHO that is second key point in understanding Java. One can consider Java as a second attempt to create a language for a portable OS much like C/UNIX two decades ago.  And taking into account perspective or relegating Windows to the role of BIOS it is only natural that the Microsoft camp will try to avoid this perspective, if possible ;-). But to muster OS API takes additional time and effort. That again means a lot of work.</P>
<P>I plan to present lessons in the sequence that more or less corresponds to the structure of "Thinking in Java".</P>
<P>Regards, Nikolai Bezroukov</P>
<P>Dec.17, 1997</P></FONT></BODY>
</HTML>
