From: morgan@unix.sri.com (Morgan Kaufmann Publishers)
Newsgroups: comp.arch,comp.edu,comp.os.misc,comp.programming,comp.software-eng
Subject: Publ. Announcement for Patterson/Hennessy: Computer Organization
Message-ID: <25erlt$3ah@unix.sri.com>
Date: 25 Aug 93 05:00:45 GMT
Organization: SRI International, Menlo Park, CA
Lines: 252
NNTP-Posting-Host: unix.sri.com

Morgan Kaufmann Announces the publication of:

COMPUTER ORGANIZATION AND DESIGN: THE HARDWARE/SOFTWARE INTERFACE
by David A. Patterson and John L. Hennessy

ISBN 1-55680-281-X; 648 pages; $64.95 U.S.; $71.45 International

From the Foreword by Maurice V. Wilkes
This is an excellent time for a new book on computer design. During
the last ten years the subject has undergone a marked renaissance.
It has become less dependent on intuition and personal opinion, and
more on measurement and rational analysis...RISC instruction sets
have made it possible to apply in a single chip processor, subtle
techniques for instruction level concurrency that were previously
to be found only in large computers.

There is a lot more to computer design than is comprised in the
RISC philosophy...But RISC has been a unifying influence. Another
major unifying influence has been the need to work within the
boundaries of a silicon chip, where there is never enough space
and, if  one thing goes in, another must go out. Performance
depends critically on decisions taken at the chip level. No longer
can system design be a subject divorced from computer
implementation, a change which may have left some people high and
dry, but which is nevertheless wholly to the good. Nor can system
design be divorced from consideration of the software interface, a
point which the authors bring out both in their subtitle and in
their text.

The computer field, particularly on the software side, abounds with
examples of new ideas that have found their way into industrial
practice by being taught in universities...In hardware, it is often
the other way round; teaching follows practice. This is another
reason for welcoming a book by two engineers who can write of
current practice with authority.

A note from the Authors:
Computers have changed so fundamentally in the last two decades
that what everyone needs to know about computer organization has
changed as well. Professionals in every specialty of computing need
to appreciate the organizational paradigms that determine the
capabilities, performance, and ultimately the success of computer
systems. Whether your primary interest is in computer science or
electrical engineering, the central ideas of computer organization
and design are the same.

The performance of software systems is dramatically affected by how
well software designers understand the basic hardware techniques at
work in a system. Thus compiler writers, operating system
designers, database programmers, and most other software engineers
need a firm grounding in the principles presented in this book.
Similarly, hardware designers must clearly understand the effects
of their work on software applications. Our emphasis in this book
is to show the relationship between hardware and software and to
focus on the concepts that are the basis for modern computers. We
hope that readers will find new insights in every section, as well
as a complete introduction to the abstractions and principles at
work in a modern computer.

CONTENTS:
Chapter 1 - COMPUTER ABSTRACTIONS AND TECHNOLOGY
1.1  Introduction
1.2  Below Your Program
1.3  Under the Covers
1.4  Integrated Circuits: Fueling Innovation
1.5  Fallacies and Pitfalls
1.6  Concluding Remarks
1.7  Historical Perspectives and Further Reading
1.8  Exercises

Chapter 2 - THE ROLE OF PERFORMANCE
2.1  Introduction
2.3  Relating the Metrics
2.4  Popular Performance Metrics
2.5  Choosing Programs to Evaluate Performance
2.6  Comparing and Summarizing Performance
2.7  Fallacies and Pitfalls
2.8  Concluding Remarks
2.9  Historical Perspectives and Further Reading
2.10 Exercises

Chapter 3 - INSTRUCTIONS: LANGUAGE OF THE MACHINE
3.1  Introduction
3.2  Operations of the Computer Hardware
3.3  Operands of the Computer Hardware
3.4  Representing Instructions in the Computer
3.5  Instructions for Making Decisions
3.6  Supporting Procedures in Computer Hardware
3.7  Other Styles of MIPS Addressing
3.8  Alternatives to the MIPS Approach
3.9  An Example to Put It All Together
3.10 A Longer Example
3.11 Arrays versus Pointers
3.12 Fallacies and Pitfalls
3.13 Concluding Remarks
3.14 Historical Perspectives and Further Reading
3.15 Exercises


Chapter 4 - ARITHMETIC FOR COMPUTERS
4.1  Introduction
4.2  Negative Numbers
4.3  Addition and Subtraction
4.4  Logical Operations
4.5  Constructing an Arithmetic Logic Unit
4.6  Multiplication
4.7  Division
4.8  Floating Point
4.9  Fallacies and Pitfalls
4.10 Concluding Remarks
4.11 Historical Perspectives and Further Reading
4.12 Exercises

Chapter 5 - THE PROCESSOR: DATAPATH AND CONTROL
5.1  Introduction
5.2  Building a Datapath
5.3  A Simple Implementation Scheme
5.4  A Multiple Clock Cycle Implementation
5.5  Microprogramming: Simplifying Control Design
5.6  Exceptions
5.7  Fallacies and Pitfalls
5.8  Concluding Remarks
5.9  Historical Perspectives and Further Reading
5.10 Exercises

Chapter 6 - ENHANCING PERFORMANCE WITH PIPELINING
6.1  Introduction
6.2  A Pipelined Datapath
6.3  Pipelined Control
6.4  Data Hazards
6.5  Control for Data Hazards: Stalls
6.6  Reducing Data Hazards: Forwarding
6.7  Branch Hazards
6.8  Exceptions
6.9  Performance of Pipelined Systems
6.10 Fallacies and Pitfalls
6.11 Concluding Remarks
6.12 Historical Perspective and Further Reading
6.13 Exercises

Chapter 7 - LARGE AND FAST: EXPLOITING THE MEMORY HIERARCHY     
7.1  Introduction
7.2  Caches
7.3  Virtual Memory
7.4  A Common Framework for Memory Hierarchies
7.5  Fallacies and Pitfalls
7.6  Concluding Remarks
7.7  Historical Perspective and References
7.8  Exercises

Chapter 8 - INTERFACING PROCESSORS AND PERIPHERALS
8.1  Introduction
8.2  I/O performance Measures: Some examples from Disk and File
     Systems
8.3  Types and Characteristics of I/O Devices
8.4  Buses: Connecting I/O Devises to Processor and Memory
8.5  Interfacing I/O Devices to the memory, Processor, and
     Operating
     System
8.6  Fallacies and Pitfalls
8.7  Concluding Remarks
8.8  Historical Perspective and References
8.9  Exercises

Chapter 9 - PARALLEL PROCESSORS
9.1  Introduction 
9.2  SIMD Computers-Single Instruction Stream, Multiple Data
     Streams
9.3  MIMD Computer-Multiple Instruction Streams, Multiple Data
     Streams
9.4  Programming MIMDs 
9.5  MIMDs Connected by a Single Bus 
9.6  MIMDs Connected by a Network 
9.7  Future Directions for Parallel Processors 
9.8  Fallacies and Pitfalls 
9.9  Concluding Remarks-Evolution versus Revolution in Computer
     Architecture 
9.10 Historical Perspective and Further Reading 
9.11 Exercises


APPENDIX A - Assembler, Linkers, and the SPIM Simulator
A.1  Introduction
A.2  Assemblers
A.3  Linkers
A.4  Loading
A.5  Memory Usage
A.6  Procedure Call Convention
A.7  Exceptions and Interrupts
A.8  Input and Output
A.9  SPIM
A.10 MIPS R2000 Assembly Language
A.11 Concluding Remarks
A.12 Historical Perspectives and Further Reading
A.13 Exercises

APPENDIX B - The Basics of Logic Design
B.1  Introduction
B.2  Gates, Truth Tables, and Logic Equations
B.3  Combinational Logic
B.4  Clocks
B.5  Memory Elements
B.6  Finite State Machines
B.7  Timing Methodologies

APPENDIX C - Mapping Control to Hardware
C.1  Introduction
C.2  Implementing Finite state Machine Control
C.3  Implementing the Next-State Function with a Sequencer
C.4  Translating a Microprogram to Hardware
C.5  Concluding Remarks
C.6  Exercises

APPENDIX D - Introducing C to Pascal Programmers
D.1  Introduction
D.2  Variable Declarations
D.3  Assignment Statements
D.4  Relational Expressions and Conditional Statements
D.5  Loops
D.6  Examples to Put it All Together
D.7  Exercises

APPENDIX E - Another Approach to Instruction Set Architecture-VAX
E.1  Introduction
E.2  VAX Operands and Addressing Modes
E.3  Encoding VAX Instructions
E.4  VAX Operations
E.5  An Example to Put it All Together
E.6  A Longer Example: sort
E.7  Fallacies and Pitfalls
E.8  Concluding Remarks
E.9  Historical Perspective and Further Reading
E.10 Exercises

ORDERING INFORMATION:

Orders may be placed by
Phone:  North America (800) 745-7323/International (415) 578-9911
Fax:    (415) 578-0672
E-Mail  morgan@unix.sri.com
Mail:   Morgan Kaufmann Publishers
        2929 Campus Drive, Suite 260
        San Mateo, CA 94403
        USA

American Express, MasterCard, VISA and Personal checks drawn on US
banks accepted for payment.

Shipping: In the U.S. and Canada, please add $3.50 for the first
book and $2.50 for each additional book for surface shipping. For
International shipping please add $6.50 for the first book and
$3.50 for each additional book.

