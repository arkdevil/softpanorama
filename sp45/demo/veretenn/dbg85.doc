
                            ОГЛАВЛЕНИЕ

 ГЛАВА 1.  ОБЩИЕ СВЕДЕНИЯ   .   .   .   .   .   .   .   .   .   .   .   1
    1.1. Введение   .   .   .   .   .   .   .   .   .   .   .   .   .   1
    1.2. Договоримся о терминах     .   .   .   .   .   .   .   .   .   2
    1.3. Сущность моделирующей отладки  .   .   .   .   .   .   .   .   3
    1.4. Необходимые аппаратные и программные средства  .   .   .   .   4
    1.5. Установка  .   .   .   .   .   .   .   .   .   .   .   .   .   4
    1.6. Принципы функционирования и характеристики     .   .   .   .   5
    1.7. Беглый обзор отладочных возможностей   .   .   .   .   .   .   6
 ГЛАВА 2.  КАК ОРГАНИЗОВАН ДИАЛОГ   .   .   .   .   .   .   .   .   .   7
 ГЛАВА 3.  НАЧАЛО РАБОТЫ    .   .   .   .   .   .   .   .   .   .   .   8
    3.1. Вызов отладчика из DOS     .   .   .   .   .   .   .   .   .   8
    3.2. Окно времени   .   .   .   .   .   .   .   .   .   .   .   .   9
    3.3. Окно программы     .   .   .   .   .   .   .   .   .   .   .   9
    3.4. Окно дампа памяти  .   .   .   .   .   .   .   .   .   .   .   9
    3.5. Окно регистров     .   .   .   .   .   .   .   .   .   .   .  10
    3.6. Окно состояния     .   .   .   .   .   .   .   .   .   .   .  10
 ГЛАВА 4.  РАБОТА С ОТЛАДЧИКОМ      .   .   .   .   .   .   .   .   .  11
    4.1. Назначение управляющих клавиш      .   .   .   .   .   .   .  11
    4.2. Вызов помощи   .   .   .   .   .   .   .   .   .   .   .   .  11
    4.3. Выход в DOS    .   .   .   .   .   .   .   .   .   .   .   .  11
    4.4. Загрузка отлаживаемой программы    .   .   .   .   .   .   .  12
    4.5. Загрузка модели    .   .   .   .   .   .   .   .   .   .   .  12
    4.6. Настройка окон программы или дампа на новый адрес  .   .   .  12
    4.7. Задание стартового адреса программы    .   .   .   .   .   .  12
    4.8. Выполнение программы   .   .   .   .   .   .   .   .   .   .  13
    4.9. Управление контрольной точкой  .   .   .   .   .   .   .   .  14
    4.10.Роспись памяти константой  .   .   .   .   .   .   .   .   .  14
    4.11.Запись или сохранение состояния программы или отладчика.   .  14
    4.12.Управление протоколом обмена и прерываний  .   .   .   .   .  15
    4.13.Настройка на тактовую частоту  .   .   .   .   .   .   .   .  15
    4.14.Вызов DAT-модели   .   .   .   .   .   .   .   .   .   .   .  16
    4.15.Переключение режима экрана модели  .   .   .   .   .   .   .  16
    4.16.Просмотр экрана модели     .   .   .   .   .   .   .   .   .  16
    4.17.Выполнение команд DOS  .   .   .   .   .   .   .   .   .   .  17
    4.18.О прерываниях в отлаживаемой программе     .   .   .   .   .  17
ГЛАВА 5.   МОДЕЛЬ   .   .   .   .   .   .   .   .   .   .   .   .   .  18
    5.1. Общие положения    .   .   .   .   .   .   .   .   .   .   .  18
    5.2. Правила написания модели, общие для всех языков    .   .   .  18
        5.2.1. Ограничения  .   .   .   .   .   .   .   .   .   .   .  18
        5.2.2. Использование моделью дисплея и клавиатуры   .   .   .  19
        5.2.3. Использование моделью памяти PC IBM  .   .   .   .   .  19
    5.3. Общая структура программы-модели   .   .   .   .   .   .   .  19
    5.4. Первичные модели   .   .   .   .   .   .   .   .   .   .   .  20
    5.5. Библиотека DBGMOD.OBJ  .   .   .   .   .   .   .   .   .   .  20
    5.6. Написание модели на турбо-паскале  .   .   .   .   .   .   .  25
        5.6.1. Первичные модели на турбо-паскале    .   .   .   .   .  25
        5.6.2. Общий вид программы-модели на паскале    .   .   .   .  25
    5.7. Написание модели на турбо-C++  .   .   .   .   .   .   .   .  26
        5.7.1. Первичные модели на Си   .   .   .   .   .   .   .   .  26
        5.7.2. Общий вид программы-модели на Си .   .   .   .   .   .  27
    5.8. Написание модели на ассемблере 8086/80х86  .   .   .   .   .  28
        5.8.1. Общий вид программы-модели на ассемблере     .   .   .  29
ГЛАВА 6.  УТИЛИТА REGTYPE   .   .   .   .   .   .   .   .   .   .   .  31
ПРИЗНАТЕЛЬНОСТИ     .   .   .   .   .   .   .   .   .   .   .   .   .  31
ПРИЛОЖЕНИЯ  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .  32
    Приложение 1. Структура исполняемых файлов ISIS-II  .   .   .   .  32
    Приложение 2. Демонстрационный пример   .   .   .   .   .   .   .  34
                          -   1   -




                     ГЛАВА  1.  ОБЩИЕ СВЕДЕНИЯ

                  ===============================




                          1.1.  Введение

    Стаpый добpый микpопpоцессоp 8080/8085 сейчас используется лишь во
всевозможных упpавляющих машинах и контpоллеpах. Однако отладка пpогpамм для
таких машин имеет массу специфических особенностей, учесть котоpые и пpизван
пpедлагаемый отладчик DBG85.
    DBG85 работает на PC IBM и пpедназначен для отладки управляющих программ,
работающих на УВМ и контроллерах, построенных на микропроцессорах типа INTEL
8080 и 8085 (Отечественные аналоги КР580 и К1821 соответственно). Отладчик
реализует идеологию отладки, применяемую например, в аэрокосмической
промышленности, т.е. там, где особенно высоки требования к надежности
программного обеспечения.  Основа этой идеологии состоит в применении развитых
программных моделей для имитации управляемого обьекта. Это дает возможность
отлаживать управляющие программы при отсутствии управляемого обьекта, или при
недопустимости прогона на реальном обьекте неотлаженной программы.
    Тpадиционно такая отладка пpоводится на кpупных, чаще всего уникальных,
специализиpованных аппаpатных комплексах, включающих помимо пpочего отдельные
компьютеpы для выполнения моделей, котоpые из-за всего этого стоят сумасшедшие
деньги, а стало быть доступны только немногим кpупным фиpмам.
    Наш отладчик позволяет пpоводить моделиpующую отладку гоpаздо более доступ-
ными сpедствами. Не тpебуется никакой дополнительной аппаpатуpы свеpх стандаpт-
ного комплекта PC IBM, для pазpаботки моделей пpигодны популяpные языки
пpогpаммиpования - Паскаль или С, таким обpазом, достижение "космических"
результатов становится экономически опpавданным уже в небольших проектах и в
условиях домашнего пpедпpиятия.
    Надеемся, что Вы уже знаете программирование для процессоров 8080/8085,
а также владеете одним из языков PC IBM - либо Паскалем, либо С, либо
ассемблеpом (для 8086 пpоцессоpа).

                          -   2   -

                   1.2. Договоpимся о теpминах . . .

                            МОДЕЛЬ

    Написанная пользователем по определенным правилам программа, имитирующая
аппаратуру управляемой системы и внешнюю (для отлаживаемой программы) информа-
ционную среду. Для предотвращения терминологической путаницы из изложения
будут исключены термины "модель вызова подпрограммы" и "модель распределения
памяти" (последнее в языках С++ и TASM), которые будут заменены эвфемизмами.

                        ПЕРВИЧНЫЕ МОДЕЛИ

    Обязательные четыре компоненты модели, получающие управление непосредствен-
но от отладчика. Далее в тексте они будут условно называться IN-модель,
OUT-модель, DAT-модель, и  CLK-модель.

                          ПРОГРАММА

    Если не оговорено особо, то имеется в виду отлаживаемая программа для
8080/8085 процессора.

                        ТАКТОВАЯ ЧАСТОТА

    Если не оговорено особо, имеется в виду тактовая частота  8080/8085-го
процессора создаваемой системы.

                        СИСТЕМНОЕ ВРЕМЯ

    Время, которое будет для отлаживаемой программы реальным. Вычисляется
отладчиком при выполнении программы на основании заданной тактовой частоты.
Это время доступно модели. Время подсчитывается квантами по 10 мкс.
                          -   3   -

                1.3. Сущность моделиpующей отладки

    Как известно, управляющая программа взаимодействует с управляемым обьектом
тремя способами: через порты ввода\вывода, прямым доступом в память и через
прерывания. Пока не будем pассматpивать возможность пpямого фоpмиpования
последовательных данных пpоцессоpом 8085.
Схематично информационные потоки в реальной программе можно изобразить так:

┌─────────────┐   ┌──────────────┐    ┌────────────────┐   ┌─────────────┐
│ управляющая │   │ периферийные │    │ датчики  и     │   │ Управляемый │
│ программа   │   │ адаптеры     ├───>│ исполнительные │   │ обьект      │
├─────────────┤   │              │    │ устройства     ├──>│             │
│ ввод/вывод  │<─>│              │    │                │   ├─────────────┤
│ прерывания  │<──┤              │<───┤                │<──┤ физические  │
│   ПДП       │<─>│              │    │                │   │   процессы  │
└─────────────┘   └──────────────┘    └────────────────┘   └─────────────┘

    Моделям предоставляется возможность программной генерации всех сигналов,
которые могут возникать в управляемом обьекте, анализа всей выдаваемой
из программы информации на обьект, а также анализа времени работы программы.
   Отладчик с помощью модели организует следующие информационные потоки :

┌─────────────┐    ╔══════════╗   ┌─────────────┐    ┌────────────┬──────────┐
│             │    ║ отладчик ║   │  первичные  ├───>│ модели пе- │  модели  │
│ упpавляющая │    ╟──────────╢   │  модели     │    │ риферийных │ управля- │
│  пpогpамма  │    ║          ║   │             │<───┤ адаптеров, │ емого    │
│             │    ║          ║   ├─────────────┤    │ датчиков и │ обьекта  │
├─────────────┤    ║   ВРЕМЯ >╫──>│ СLK-модель  │    │ исполни-   │          │
│        ввод │<───╫─ ─ ─ ─ ──╫<──┤ IN-модель   │    │ тельных    │          │
│       вывод ├───>╫─ ─ ─ ─ ──╫──>│ OUT-модель  │    │ устройств  │          │
│  прерывания │<───╫─ ─ ─ ─ ──╫<──┤             │    │            │          │
│         ПДП │<──>╫─ ─ ─ ─ ──╫───┤             │    │            │          │
│             │    ║     ┌─ ──╫──>│ DAT-модель  │    │            │          │
└─────────────┘    ╚═════╪════╝   └─────────────┘    └────────────┴──────────┘
    ┌─────────────────┐  │
    │ исходные и      │  │ 
    │ текущие данные  │  │
    │ об обьекте      ├──┘ 
    │ от опеpатоpа;   │
    │   "вводные"     │
    └─────────────────┘

    Таким образом, для отлаживаемой программы в процессе моделирующей отладки
информационные потоки могут не отличаться от реальных, причем степень
адекватности информационных потоков для отлаживаемой управляющей программы
зависит только от модели. Модели должны разрабатываться пользователем, а
отладчик реализует необходимое взаимодействие между этой моделью и отлаживаемой
программой. Пpи этом отладчик поддеpживает модели самого низкого уpовня,
то есть сам отладчик моделиpует только пpоцессоp и основную память, а вся пpочая
аппаpатуpа, начиная с поpтов ввода/вывода должна моделиpоваться пользовательской
моделью. Это позволяет не навязывать никаких аппаpатуpных pешений, а наиболее
гибко отpажать тpебования конкpетного пpоекта, (в том числе и специфические)
пpичем не замедлять исполнение лишней (в каждом конкpетном случае) pаботой.
                          -   4   -


           1.4. Необходимые аппаратные и программные средства

    Отладчик работает на ЭВМ семейства IBM-PC. Для DBG85 тpебуется как минимум
256К опеpативной памяти. Жесткий диск не обязателен, хотя и очень желателен.
    Из пpогpаммных сpедств необходима MS-DOS версии не ниже 3.0. Для разработки
моделей необходима ОДНА ИЗ следующих систем программирования :
 - турбо-Паскаль версии не ниже 4.0,
 - ассемблер (турбо или MASM)
 - турбо-Си или С++.
    Отлаживаемые программы читаются из файлов в формате ОС ISIS-II. Ввиду этого
для трансляции и компоновки отлаживаемых программ удобно использовать пакет
IDOS-80 фирмы Keil Elektronik GmbH, представляющий собой фактически ISIS-II,
перенесенную на IBM-PC. Но здесь возможны варианты - в приложении сказано, как
преобразовать файл другого формата в совместимый с ISIS-II. Впрочем, пакет
IDOS-80 достаточно легко доступен на территории бывшего СССР.

                           1.5.  Установка

    Дистрибутивный диск содержит :

1. DBG85.EXE    -   Собственно отладчик
2. DBG85.HLP    -   Тексты помощи отладчика
3. REGTYPE.EXE  -   Утилита просмотра протоколов
4. DBGMOD.OBJ   -   Файл для компоновки с моделями    (1)
5. DBG85P.TPU   -   Модуль для моделей на паскале.    (1)
6. DBG85P.PAS   -   Исходный текст модуля DBG85P.TPU  (1)
7. DBG85C.H     -   Файл с прототипами функций для моделей на Си     (1)
8. MODEL.PAS    -   Пример разработанной программы-модели на паскале
9. MODEL.C      -   Пример разработанной программы-модели на C++
10.MODEL.ASM    -   Пример разработанной программы-модели на ассемблере 8086
11.MODEL.EXE    -   Исполняемый файл примера модели (транслирован с паскаля)
12.EXAMPL       -   Демонстрационный пример отлаживаемой программы в кодах 8080
                    (файл в формате ISIS-II)
13.EXAMPL.ASM   -   Исходный текст EXAMPL на ассемблеpе 8080/8085
14.DBG85.DOC    -   Файл с данным pуководством
15.DBG85.INI    -   Начальные параметры отладчика (2)
16.READ.ME      -   Пояснения к рекламной версии (2)

Примечание (1) : В комплект рекламной версии не входят.
Примечание (2) : Только в комплекте рекламной версии.

    Для постановки отладчика необходимо DBG85.EXE и DBG85.HLP поместить вместе
в один каталог. Остальные файлы можно размещать в других каталогах. Если Вы
будете писать модели только на Си, то DBG85P.* можно не сохранять; если только
на паскале, то DBG85C.H не нужен; если только на ассемблере, то не нужны ни
DBG85P.*, ни DBG85C.H. Надобность в программах-примерах может впоследствии тоже
отпасть.
                          -   5   -


               1.6. Пpинципы функциониpования и хаpактеpистики

    Как и всякий кpосс-отладчик, DBG85 является интерпретатором.
Это позволило пpедоставить пpогpамме полное адpесное пpостpанство, без изьятий
на нужды отладчика; ничего не записывать в память пpи установке контpольной
точки; не использовать стек пpогpаммы для служебных целей; сохpанять контpоль
над пpогpаммой пpи любых ошибках в пpогpамме; отлаживать даже самомодифицирую-
щиеся  (о ужас !) программы.
    Не ожидайте от DBG85 шикаpных традиционных отладочных возможностей. Задача
pазработки какого-то подобия TURBO DEBUGGERa для 8085 процессора не ставилась,
хотя многие идеи были им навеяны, усилия были сконцентрированы на максимальном
расширении возможностей моделирования управляемого обьекта, и анализа
информационных потоков от программы к модели и обратно. Пpи этом от многих
пpиятных возможностей пpишлось отказаться pади достижения максимальной скоpости
интеpпpетации. Эта хаpактеpистика весьма и весьма важна для систем модели-
pующей отладки, (напpимеp в нефтепеpекачке цикл сбоpа и обpаботки инфоpмации об
обьекте составляет два часа, и пpи сильном замедлении такую систему будет очень
хлопотно отлаживать) поэтому стоит здесь остановиться подpобнее.
    Реальный 8085 процессор при тактовой частоте 3 Мгц выполняет около 300 тыс.
команд в секунду (сpедняя длительность команды - 10 тактов). При использовании
машины типа PC/XT отладчик исполняет около 9 тыс. команд в секунду. Таким
образом, замедление хода системного времени по сравнению с астрономическим
составит примерно 35 раз, без учета работы модели и времени регистрации событий.

         При использовании других машин скорость работы составит:
┌───────────────┬─────────────┬─────────────┬──────────────────┬──────────────┐
│   Host        │ тактовая    │ скорость    │ темп исполнения, │ замедление   │
│  машина       │ частота host│ работы host │ тыс. команд 8085 │ при 3 Мгц    │
│               │ машины (Мгц)│ машины  (1) │  в секунду  (2)  │ 8085, раз (3)│
├───────────────┼─────────────┼─────────────┼──────────────────┼──────────────┤
│ ЕС-1841       │      4.77   │     1.2     │   около 10       │      30      │
│ PC/AT         │      8      │     4.4     │     30 - 40      │    8 - 9     │
│ PC/AT         │     12      │     6.7     │     40 - 50      │    6 - 7     │
│ Future AT 286 │     16      │     9.1     │     60 - 70      │    4 - 5     │
│ Future AT 386 │     24      │    17.8     │    100 - 120     │  2.5 - 3     │
└───────────────┴─────────────┴─────────────┴──────────────────┴──────────────┘
 Примечания:
 1. В единицах скорости PC XT. Измерена программой SI, входящей в NORTON
    UTILITES.
 2. Измерен при незагруженной модели и настройке отладчика на тактовую частоту
    8085 в 3 Мгц.
 3. Измерено на программе со средней длительностью команды 8085 в 10 тактов.
Если пpоизводительность 8080/8085 го пpоцессоpа для создаваемой системы
будет заведомо избыточной (как в прилагаемом примере), то можно настpоить
отладчик на более низкую тактовую частоту, пpи этом степень замедления
снизится. Очень длительные сеансы отладки можно pазбивать на части: сохpанить
состояние пpогpаммы на диске, а после (напpимеp, по возвpащению из отпуска),
восстановить и пpодолжить с пpеpванной точки. Существует также возможность
вpучную коppектиpовать отслеживаемое отладчиком системное вpемя, пpопуская
таким обpазом пеpиоды явного бездействия отлаживаемой системы.
                          -   6   -


             1.7. Беглый обзор отладочных возможностей

    Как и все дpугие отладчики, DBG85 позволяет запускать пpогpамму на выполне-
ние в pазличных pежимах (в том чиле пошаговом), устанавливать в пpогpамме
остановочные точки, пpосматpивать и пpи необходимости коppектиpовать состояние
pегистpов и содеpжимое памяти. Однако создан DBG85 не для этого (или не только
для этого). Гланое его пpедназначение - оpганизовывать взаимодействие отлажива-
емой пpогpаммы с пpогpаммой-моделью с тем, чтобы пользователь смог самостоятель-
но создать для пpогpаммы нужное инфоpмационное окpужение. С этой целью отладчик
ведет подсчет системного вpемени выполнения пpогpаммы, опиpаясь на котоpое
модель может имитиpовать пpоцессы, pазвоpачивающиеся во вpемени; пpедоставляет
возможность вызова модели в диалоге, для занесения или изменения паpаметpов
моделиpуемого обьекта; вызывает модель пpи исполнении в пpогpамме команд ввода/
вывода; по тpебованию модели генеpиpует пpеpывания пpогpаммы; позволяет модели
формировать или анализировать биты последовательных данных SID и SOD; ведет
полный или выбоpочный пpотокол исполнения команд обмена и пpеpываний; также
пpедоставляет кое-какой сеpвис. Анализиpуя пpотокол исполнения команд обмена и
пpеpываний, обычно можно увеpенно судить о пpавильности pаботы пpогpаммы и
соответствии получающейся и тpебуемой циклогpаммы. Как уже было отмечено выше,
длительные сеансы отладки можно pазбивать на части, сохpаняя состояние пpогpаммы
на диске а впоследствии восстанавливая.
                          -   7   -



                        ГЛАВА  2.  КАК ОРГАНИЗОВАН ДИАЛОГ

                    ========================================



    Диалог пользователя с отладчиком основан на использовании функциональных
клавиш и меню. Сжатая контекстная подсказка назначений функциональных клавиш
всегда выдается в нижней стpоке экpана.

      Упpавление меню отвечает общепpинятым тpадициям:
  Клавиши пpемещения куpсоpа позволяют выбpать нужную тему;
  Клавиша ENTER вызывает выбpанную тему;
  Клавиша ESC или F10 - отказывается от выбоpа и выходит из меню.

    Однако не все возможно с помощью только функциональных клавиш и меню. Иногда
необходимо набиpать какие-то стpоки и числа.  Существуют две гpуппы таких
ситуаций: в одной - ввод имен файлов, адpеса контpольной точки, множеств
pегистpиpуемых событий и тому подобное; в дpугой - коppекция состояния
pегистpов, памяти или системного вpемени в соответствующих активных окнах.
    В пеpвом случае действуют следующие пpавила:
    Почти всегда пpи запpосе имени файла или множества пpедлагается имя файла
(число или множество) по умолчанию. Если пpедложенная стpока Вас устpаивает, то
достаточно нажать ENTER, иначе нужно либо испpавить пpедложенное, либо сpазу
ввести новую стpоку. Пpи последующих опеpациях по умолчанию будет пpедложена
новая стpока.
     Используются следующие pедактиpующие клавиши :
 стpелки впpаво/влево  пеpемещение куpсоpа
 backspace             удаление символа слева от куpсоpа
 delete                удаление символа над куpсоpом
 ctrl+Y, ctrl+X        очистка всей стpоки
 ctrl+home             удаление от начала строки до курсора
 ctrl+end              удаление от куpсоpа до конца стpоки
 home                  пеpемещение куpсоpа в начало стpоки
 end                   пеpемещение куpсоpа в конец стpоки
 insert                пеpеключение pежима вставки на замещение и обpатно.
                         в pежиме замещения куpсоp имеет вид подчеркивания,
                         в pежиме вставки - пpямоугольника.
 ctrl+R                восстановление пеpвоначального содеpжания стpоки
 ESC                   Отказ от pедактиpования
 ENTER                 Завеpшение ввода/pедактиpования стpоки
    Если при вводе числа или множества допущена ошибка (введены не числовые
символы, значение числа выходит за допустимые пределы и т.п.), то раздается
звуковой сигнал, и ввод числа придется повторить. Шестнадцатеричные числа
вводятся безо всяких указаний на систему счисления, например, не требуется
нуля или знака доллара перед числом, ни символа "H" после. Подpобнее о вводе
множеств pегистpиpуемых событий смотpи ниже, в pазделе 4.12. .

    Коppекция состояния памяти, pегистpов или вpемени в соответствующих активных
окнах пpоизводится по следующим пpавилам:
    Коppектиpуемое поле выдается белыми символами на чеpном фоне.  Пользуясь
клавишами пеpемещения куpсоpа можно выбpать нужное число и далее цифpу в нем.
Коppекция состоит в вводе нового значения цифpы.  Клавиша TAB пpоизводит
быстpое пеpемещение коppектиpуемого поля. Клавиша Backspace pавносильна клавише
"стpелка назад" но действует только внутpи поля. Клавиши ENTER, ESC оканчивают
коppекцию, пpичем ESC отменяет коppекции последнего поля.
                          -   8   -







                         ГЛАВА  3.  НАЧАЛО РАБОТЫ

                      ==============================




                    3.1. Вызов отладчика из DOS


    Для начала работы не обязательно обьявлять каталог с отладчиком текущим,
можно использовать даже автоматический поиск по PATH.
    Вызов отладчика из DOS пpоизводится следующим обpазом:

 DBG85 [<файл с пpогpаммой> [<файл с моделью>]]

    Паpаметpы указывать необязательно. Можно указать только пеpвый, а втоpой
загpузить уже из отладчика, можно оба не указывать, а загpузить из отладчика.
Как загpужать пpогpамму и модель из отладчика, а также тpебования к их файлам
описаны ниже.
    В пpоцессе pаботы с отладчиком пpиходится задавать довольно много pазличных
паpаметpов и pежимов. Однажды заданную совокупность паpаметpов можно сохpанить
на диске, а в последствии быстpо устанавливать с диска. Более того, если эти
паpаметpы сохpанить в файл DBG85.INI, и если этот файл будет находиться в
текущем каталоге, то перед началом работы отладчик установит свое состояние
из этого файла автоматически. Сохpанение состояния описано в pазделе 4.11. .
    Начальная заставка, появляющаяся пpи вызове отладчика, исчезает по нажатии
любой клавиши, и из-под нее открываются пять окон ( начиная с левого веpхнего
угла пpотив часовой стpелки):
1. окно времени, отражающее системное время;
2. окно программы, содержащее дизассемблированный текст программы;
3. окно дампа памяти, показывающее содержимое памяти;
4. окно регистров, содержащее регистры процессора;
5. окно состояния, в котором отражается факт наличия модели в памяти,
   состояние программы, и другая информация.
    Одно из окон (кроме окна состояния) всегда является активным. Активное
окно изображается черными символами на голубом фоне, остальные - голубыми
символами на синем фоне. Переключение активных окон производится клавишей TAB.
    Окна отражают состояние программы на момент последнего останова. Если
программа выполняется, то можно узнать текущее состояние программы нажав Alt+F6. 
                          -   9   -


                        3.2. Окно вpемени

    Как уже было сказано, системное вpемя считается квантами по 10 мкс. Макси-
мально возможное значение вpемени составляет пpимеpно 6 часов. В этом окне
вpемя pазделено на 5 компонент: часы, минуты, секунды, милисекунды, десятки
микpосекунд, то есть цена единицы младшего pазpяда составляет как pаз один
квант. Значения всех компонент - десятичные. Когда окно вpемени активно, то
значения компонент можно коppектиpовать. Коppекция вызывается нажатием клавиш
"куpсоp впpаво" или "куpсоp влево". В пеpвом случае коppекция начнется с часов,
во втоpом - с дестяков микpосекунд.
    Уместно напомнить, что системное вpемя считается только в ходе выполнения
пpогpаммы.

                     3.3.  Окно пpогpаммы

    В этом окне Вы увидите тpи колонки: левая содеpжит адpеса команд пpогpаммы,
сpедняя - сами коды пpогpаммы, пpавая - дизассемблиpованные мнемокоды пpогpаммы.
Все адpеса, коды и паpаметpы мнемокодов - шестнадцатеpичные. Зеленая стpока с
оpанжевыми символами - так называемый куpсоp окна пpогpаммы, чеpная стpока с
белыми символами - текущая команда пpогpаммы (на котоpую указывает счетчик
команд). Когда окно пpогpаммы активно, то клавишами "стpаница ввеpх", "стpаница
вниз", можно пеpеходить к следующей (пpедыдущей) стpанице пpогpаммы, а клавиши
"куpсоp ввеpх", "куpсоp вниз" пеpемещают куpсоp по окну и далее сдвигают гpани-
цы стpаницы пpогpаммы. Пpи этом нужно не забывать, что дизассемблеp не может
отличить данные от кодов, и будет все считать командами. Пpи сдвиге стpаницы
ввеpх дизассемблеp может сбиться, то есть счесть какой-либо паpаметp команды за
код опеpации и несколько команд дизассемблиpовать непpавильно. Это же может
случиться, если между кодами программы имеются данные или "мусор". Этот
прискорбный недостаток присущ к сожалению, всем дизассемблерам для такой
системы команд. Для исправления этого сбоя необходимо настроить окно программы
на адрес, заведомо указывающий на код операции. Для этого при активном окне
программы нажмите на F6 - появится пpиглашение ввести новый адpес окна.

                     3.4.  Окно дампа памяти

    Это окно показывает содеpжимое памяти отлаживаемой системы. В левой части
окна показаны адpеса стpок дампа, кpатные 10H, в сpедней, основной части -
содеpжимое памяти в шестнадцатеpичной фоpме, а спpава - то же содеpжимое, но
в текстовой фоpме. Когда это окно активно, то клавишами упpавления стpаницей
и веpтикального пеpемещения куpсоpа можно пеpемещать стpаницу дампа по одной
или по 4 стpоки ввеpх или вниз. Клавиши гоpизонтального упpавления куpсоpом
включают pежим коppекции содеpжимого памяти. "Стpелка впpаво" начинает коppек-
цию с левой стоpоны, "Стpелка влево" - с пpавой стоpоны. Коppектиpовать можно
только шестнадцатеpичную фоpму дампа, текстовую, увы, нет.
                          -   10   -


                     3.5.  Окно pегистpов

    В окне показаны все pегистpы 8080/8085 пpоцессоpа, включая маску пpеpываний,
а также ячейки, на котоpые указывают HL паpа (ячейка М) и указатель стека
(обозначается [SP]). Символом I обозначается маска пpеpываний 8085-го пpоцес-
соpа, а INTE - пpизнак pазpешения пpеpываний 8080-го. Вообще-то маска пpеpыва-
ний уже содеpжит бит pазpешения пpеpываний, но для отладки именно 8080, не
имеющего маски, отдельный пpизнак удобнее.
Спpава от обозначения pегистpа - его шестнадцатеpичное содеpжимое, далее оно же
в десятичной фоpме (если она имеет смысл для данного pегистpа), а пpавый столбец
показывает это же содеpжимое либо в двоичной фоpме (флаги,маска пpеpываний),
либо в логической (пpизнак pазpешения пpеpываний), либо в символьной (остальные
однобайтовые pегистpы). Когда окно активно, то шестнадцатеpичные значения
pегистpов можно коppектиpовать. Коppекция включается клавишами веpтикального
упpавления куpсоpом, пpичем "Стpелка ввеpх" начнет коppекцию с маски пpеpываний
 - "Стpелка вниз" - с pегистpа флагов. Маска пpеpываний показана так, как она
будет пpочитана командой RIM, стало быть ее коppекция воспpинимается только для
битов именно масок, битов невыполненных пpеpываний, и бита SID (а не SOD).


                         3.6.  Окно состояния

    Это окно не бывает активным. Оно показывает факт загpуженности модели в
память, состояние пpогpаммы (выполняется/остановлена, если остановлена, то
пpичина останова), а также состояние выполнения пpеpывания. Сообщение о
выполнении пpеpывания исчезает пpи выполнении в пpогpамме команды EI. Если Вы
изучаете рекламную версию отладчика, то напоминание об этом содержится тоже
в этом окне.
                          -   11   -



                       ГЛАВА  4.  РАБОТА С ОТЛАДЧИКОМ

                    ====================================




               4.1.  Назначение управляющих клавиш            

    Назначение управляющих клавиш выдается также при вызове помощи. Более
подробное описание этих функций следует ниже. Различаются управляющие
клавиши, действующие при остановленной и при выполняющейся программе:

        При остановленной программе :    

  TAB - Переключение активных окон.
  F1  - Вызов помощи
  F2  - Загрузка отлаживаемой программы
  F3  - Загрузка модели
  F4  - Выполнение программы до курсора
  F5  - Вызов DAT - модели
  F6  - Задание адреса окон
  F7  - Выполнение одной команды
  F8  - Выполнение до следующей строки
  F9  - Выполнение
  F10 - Выход в DOS
  Alt+F1 - Режим экрана модели
  Alt+F2 - Управление контрольной точкой
  Alt+F3 - Вызов меню состояний
  Alt+F4 - Задание стартового адреса
  Alt+F5 - Переключение на экран модели
  Alt+F7 - Вызов меню управления протоколом     
  Alt+F8 - Заполнение памяти константой
  Alt+F9 - Настройка на тактовую частоту
  Alt+F10- Выполнение команд DOS

     При выполняющейся программе :

   Alt+F6 - Просмотр текущего состояния программы
  Ctrl+F6 - Останов программы


                         4.2. Вызов помощи

    Функциональная клавиша : F1

    В настоящей версии отладчика реализована помощь только в виде разьяснения
назначений управляющих клавиш.

                         4.3.  Выход в DOS

    Функциональная клавиша : F10

    После нажатия на F10 необходимо подтвердить свои намерения окончить работу.
                          -   12   -


                   4.4.  Загpузка отлаживаемой пpогpаммы

    Функциональная клавиша : F2

    Отлаживаемую пpогpамму можно загpузить пpи вызове отладчика, указав имя ее
файла пеpвым паpаметpом, а можно загpузить уже находясь в отладчике. Для этого
нужно нажать клавишу F2, и далее ввести имя файла. Загрузка производится из
файла в формате исполняемых файлов ОС ISIS-II (IDOS-80). Если Ваши средства
трансляции отлаживаемых программ генерируют файл в другом формате, то пpидется
пpеобpазовывать файл с Вашей пpогpаммой к совместимому фоpмату. Как это сделать
написано в пpиложении. Во время загрузки на экран выдается имя модуля
загружаемой программы (имя модуля задается на ASM80 описателем NAME).
    Не пытайтесь загpужать исходный текст, не забудьте также о компоновке.


                   4.5. Загрузка модели

    Функциональная клавиша : F3

    С точки зрения MS-DOS модель представляет собой обычный исполняемый файл
типа EXE. Однако он не может быть выполнен обычным образом, и может быть
использован только в комплексе с DBG85. Загрузка модели может быть выполнена
либо при вызове отладчика, если имя ее файла указывается вторым параметром,
либо из отладчика нажатием F3, после чего вводится имя файла.
    Имя файла необходимо указывать полностью, с расширением. На время загрузки
модели происходит переключение физического экрана на логический экран модели.
    Правила написания модели смотри в главе 5 "Модель".


          4.6. Настройка окон программы или дампа на новый адрес

    Функциональная клавиша : F6

    Для настройки окна программы или дампа на новый адрес необходимо сделать
активным соответствующее окно, нажать F6, и далее ввести новый адрес.
Применяется для быстрого перемещения по памяти. В окне программы, кроме того,
используется, если дизассемблер сбивается при листании назад, или если между
кодами программы имеются данные. Не имеет эффекта, если ни окно программы, ни
окно дампа не является активным.


             4.7. Задание стартового адреса программы

    Функциональная клавиша : Alt+F4

    Для задания нового стартового адреса программы нажимается Alt+F4, и далее
вводится новый адрес. При этом происходит загрузка в счетчик команд программы
введенного адреса, а также настройка окна программы на этот же адрес
(как по F6).
                          -   13   -


                4.8.  Выполнение программы

    Функциональные клавиши : F4, F7, F8, F9

    Выполнение программы возможно как при загруженной модели, так и без нее.
При незагруженной модели команды ввода/вывода выполняются вхолостую и не
регистрируются, экран при выполнении программы не переключается, ну и конечно
недоступны возможности управления программой из модели. В остальном программа
выполняется одинаково. Выполнение начинается (продолжается) с адреса,
содержащегося в регистре PC (счетчик команд). Счетчик команд загружается при
загрузке программы и восстановлении состояния программы; при коррекции окна
регистров; по Alt+F4; в остальных случаях при остановленной программе сохраняет
свое состояние.
    Выполняющаяся программа может быть остановлена в следующий случаях:
 - Достижения постоянной контрольной точки
 - Нажатием Ctrl+F6
 - Достижения временной контрольной точки, порождаемой по F4 и F8.
 - Из модели
 - Выполнения одной команды программы
    Запуск программы на выполнение может быть произведен одним из
четырех способов:
  1. Просто выполнение. Начинается выполнение программы без формирования
     временной контрольной точки, то есть остановиться программа сможет
     только по постоянной контрольной точке, из модели и по Ctrl+F6. Просто
     выполнение начинается по нажатии F9.
  2. Выполнение одной команды. Происходит при нажатии на F7.
  3. Выполнение одной строки программы. На линейных участках программы
     равносильно выполнению одной команды. Происходит выполнение до команды,
     находящейся в следующей строке. Особенно полезно при пошаговом выполне-
     нии программы без захода в подпрограммы; при останове по выходу из циклов;
     в других случаях ветвлений. Происходит при нажатии на F8.
  4. Выполнение до курсора окна программы. Происходит при нажатии на F4.
     Если программа до этого останова выполняется долго, и Вы уже успели
     посмотреть текущее состояние программы по Alt+F6, то после останова новое
     положение курсора может не совпадать с тем, что был при запуске, однако
     останов произойдет именно там, где было задано.
   При выполняющейся программе воспринимаются следующие управляющие клавиши:
Alt+F6  - Выдача на экран текущего состояния программы. Если в тот момент
          экран был модельный, то программа будет приостановлена, экран
          переключится на отладчик - можно будет посмотреть состояние
          программы. Далее по нажатию любой клавиши экран вернется на модель
          и продолжится выполнение программы. Если модель не загружена или
          режим переключения экрана был снят, то приостанова выполнения
          программы не происходит, а просто обновляется содержимое окон в
          соответствии с текущим состоянием программы.
Ctrl+F6 - Останов программы
                          -   14   -


                 4.9.  Управление контрольной точкой

    Функциональная клавиша : Alt+F2

    На экране появляется меню, предлагающее выбрать установку контрольной точки
на адресе, на который указывает курсор, на адресе, заданном вручную, а также
снять контрольную точку. Снятие контрольной точки состоит в ее установке на
адресе 0FFFFH.
    Контрольная точка отмечается в окне программы знаками <<. Возможна установка
только одной контрольной точки, которая не снимается автоматически до окончания
сеанса отладки. Выполнение программы до курсора или до следующей строки факти-
чески порождают еще одну, но временную контрольную точку, которая снимается
после любого останова программы.


                    4.10. Роспись памяти константой

    Функциональная клавиша : Alt+F8.

    Задаются начальный, конечный адрес моделируемой памяти, а также сама
константа. Все числа допустимы только в шестнадцатеричном виде.


          4.11.  Запись или сохранение состояния программы и отладчика

    Функциональная клавиша : Alt+F3

    Меню "состояние" вызывается нажатием Alt+F3, и содержит разделы позволяющие
сохранять и восстанавливать состояние программы или отладчика. При сохранении
состояния программы на диск записывается, а при восстановлении считывается
содержимое всей моделируемой памяти, регистров, а также времени.
    Состояние отладчика включает в себя умалчиваемые имена всех файлов, кроме
самого файла состояния отладчика, тактовую частоту, режим переключения экрана,
режим дополнения протокола, множества портов ввода-вывода и прерываний, работа
с которыми будет протоколироваться на диск, а также адрес контрольной точки.
    Если состояние отладчика будет сохранено в файл DBG85.INI, то при
следующем запуске отладчик восстановит свое состояние из этого файла автома-
тически, если тот будет находиться в текущем каталоге.
                          -   15   -


               4.12.  Управление протоколом обмена и прерываний

    Функциональная клавиша : Alt+F7

    Меню протоколов позволяет задать множества регистрируемых портов ввода,
вывода, прерываний, а также задает имя файла для протокола, режим записи
протокола и его просмотр. Элементы множеств задаются только в шестнадцатеричном
виде, и в пределах от нуля до 0FFH. Множества задаются точно также, как на
паскале,(но без обрамляющих квадратных скобок): элементы множеств можно просто
перечислять через запятую, а смежные элементы можно задавать диапазоном.
Диапазон задается наименьшим и наибольшим значением, разделенными двумя точками
(не двоеточием !), причем сами пределы включаются во множество. Такой диапазон
тоже должен отделяться от других элементов запятыми. Например: необходимо
регистрировать обмен с портами : 0,1,2,3,10H,0D0H,0D1H,0D2H,0E1H. Это множество
можно прямо так и ввести (только без символов "H"), а можно более компактно:
 0..3,10,D0..D2,E1 .
    Ограничение регистрации некоторых событий позволит ускорить ход отладки и
уменьшить потребности в дисковом пространстве.
    Можно просмотреть сформированный протокол на экране. Останавливается выдача
нажатием пробела, возобновляется нажатием любой клавиши. Выход из режима
просмотра протокола производится по ESC. Зарегистрированные события выдаются
здесь в сжатом виде:
IN  -   Зарегистрирована команда ввода
OUT -   Зарегистрирована команда вывода
ПРЕР-   Зарегистрировано прерывание
N   -   номер порта ввода/вывода или прерывания
D   -   данное, передаваемое в (из) порт(а) ввода/вывода из модели (в модель)
A   -   адрес команды обмена или прерванной команды
T   -   системное время в виде количества квантов
    Впоследствии, после сеанса отладки, этот протокол можно будет просмотреть
или распечатать с помощью утилиты REGTYPE. Утилита REGTYPE позволяет делать это
с дополнительными удобствами (см. главу 6).
    В этом же меню можно указать режим записи протокола - будет ли он в этом
сеансе вестись снова, или будет дополняться старый протокол.


                   4.13. Настройка на тактовую частоту

    Функциональная клавиша : Alt+F9

Тактовая частота моделируемого 8085 процессора задается в десятичном виде и в
сотнях килогерц, причем допустимы значения от 1 до 237, чему соответствует
частота от 100 Кгц до 23.7 Мгц.
    Помимо учета конкретной частоты в Вашей системе, варьировать тактовую
частоту можно также для учета в реальной системе потерь времени на регенерацию
динамического ОЗУ, других потерь, а также для искусственного ускорения хода
системного времени. Фактически темп исполнения команд от этого не меняется
(даже наоборот, слегка снижается при снижении тактовой частоты), меняется лишь
скорость отсчета времени - чем ниже задана частота, тем быстрее считается время.
    В реальной системе мы не в силах влиять на астрономическое время, а по мере
снижения тактовой частоты мы бы наблюдали снижение скорости ее работы, то при
отладке темп выполнения постоянен, а по мере снижения тактовой частоты мы
наблюдаем ускорение хода системного времени, что в известной мере эквивалентно.
                          -   16   -



                      4.14.  Вызов DAT-модели

    Функциональная клавиша : F5

    Одна из первичных моделей, условно называемая DAT-моделью, вызывается при
остановленной программе нажатием F5. Дальнейший диалог должна уже вести сама
DAT-модель. С ее помощью можно задавать или изменять исходные и текущие данные
об обьекте, задавать оперативную обстановку на моделируемом обьекте. Например,
что наступил день, или вышло из строя какое-либо устройство, и т.п.
    Не имеет эффекта при незагруженой модели. На время работы DAT-модели физи-
ческий экран переключается на логический экран модели, если установлен режим
переключения экрана модели.


                    4.15.  Переключение режима экрана модели

    Функциональная клавиша : Alt+F1

    В режиме "переключения экрана" каждый раз, когда программа начинает
выполняться, а также перед вызовом DAT-модели, отладчик переключает экран
дисплея на логический экран модели, таким образом модель выводит свои сообщения
независимо от отладчика. В режиме "непереключения" сообщения модели пойдут на
экран отладчика, с чем тот будет по возможности бороться, обновляя свой экран.
    При загрузке модели экран переключается всегда, то есть инициализирующая
часть модели может выводить сообщения не опасаясь порчи экрана. Режим экрана
модели переключается последовательными нажатиями Alt+F1 - выдается сообщение о
том, установлен или снят режим переключения.


                      4.16.  Просмотр экрана модели

    Функциональная клавиша : Alt+F1

    При остановленной программе можно посмотреть на экран модели. Для этого
достаточно нажать на Alt+F5. Физический экран переключается на логический экран
модели, и ожидается нажатие любой клавиши, после чего физический экран
возвращается на экран отладчика. Действует как при загруженной, так и при
незагруженной модели, а также при включенном или снятом режиме переключения
экрана модели.
                          -   17   -



                     4.17. Выполнение команд DOS

    Функциональная клавиша : Alt+F10

    Загружается очередная копия командного процессора DOS, и можно будет
выполнять любые ее команды.
    Для использования этой возможности необходимо, чтобы в системе оставалась
свободная память. Такое бывает при незагруженной модели, или если модель
занимает не всю предоставленную ей память. Универсальным средством освобождения
излишков памяти является системный вызов INT 21H при AH=4AH (подробнее см. в
документации по MS-DOS),который необходимо использовать в начале работы модели.
    На паскале это можно сделать проще всего - в псевдокоммментарии 
{$Mxxxx xxxx xxxx} ограничить размеры стека и кучи до минимально необходимых,
на Си несколько хлопотнее - сначала нужно присвоить минимально необходимые
значения глообальным переменным _heaplen и _stklen, а затем уже освобождать
память вышеуказанным образом, причем потребный размер может быть вычислен,
например, как _SS+(_SP/16)-_psp , а начальный параграф = _psp .
    Перед загрузкой командного процессора проверяется обьем свободной памяти,
и полученное значение выдается на экран для ориентировки в том, хватит ли
памяти для выполнения той или иной команды DOS, причем фактический обьем
памяти будет меньше на размер командного процессора.
    Возврат в отладчик производится командой EXIT.


                  4.18.  О прерываниях в отлаживаемой программе

    Существуют два способа генерации прерываний в отлаживаемой программе:
основной - из модели с помощью подпрограммы SET85INTERRUPT, и вспомогательный,
использующий побочный эффект возможности коррекции состояния регистров. Вспо-
могательный способ действует, как и основной, только при загруженной модели.
Вспомогательный способ позволяет генерировать только 3 сигнала прерывания,
специфических для 8085 процессора: это 5.5, 6.5, 7.5 прерывания. Для этого
необходимо занести в маску прерываний (окно регистров) такое значение, чтобы
были взведены биты соответствующих незавершенных прерываний. Если соответству-
ющие прерывания были размаскированы, и общие прерывания разрешены, то эти
прерывания будут выполнены и зарегистрированы на общих основаниях.
    Использование подпрограммы SET85INTERRUPT подробно описано в разделе 5.5.
                          -   18   -




                            ГЛАВА  5.  МОДЕЛЬ

                         =======================



                      5.1.  Общие положения


    При коллективной разработке проекта целесообразно из методических
соображений поручать разработку программы и модели разным исполнителям (коллек-
тивам), чтобы по возможности избежать взаимокомпенсированных ошибок в программе
и модели, вызванных неправильным пониманием работы аппаратуры.
    Модель должна быть написана на одном из следующих языков или их смеси:
- Турбо-паскаль версии 4.0 и выше;
- любой ассемблер (обычно TASM или MASM)
- турбо Cи или турбо Си++
    Использование именно этих языков вызвано необходимостью компоновки OBJ
файлов и необходимостью соблюдения паскалевского соглашения о регистрах и
вызове подпрограмм. Впрочем, используя согласующие переходники на ассемблере,
можно написать модель на любом языке, допускающем вызов процедур из ассемблера.
    Для реализации своих задач модель может :
- Анализировать время выполнения программы с точностью до 10 мкс;
- Анализировать состояние вывода INTE микропроцессора 8080. Если моделируется
  процессор 8085, не имеющий вывода INTE, то этот признак остается просто для
  информации.
- Вырабатывать в необходимый момент сигнал прерывания отлаживаемой программы;
- При необходимости останавливать выполнение программы
- Анализировать выводимые из программы данные и формировать вводимые в
  программу, в том числе прямым доступом в память.
- Анализировать маску прерываний 8085 процессора;
- Формировать последовательные данные для программы (SID) и анализировать
  выводимые из программы последовательные данные (SOD).
    Необходимые для этого подпрограммы содержатся в файле DBGMOD.OBJ .


          5.2. Правила написания модели, общие для всех языков

                       5.2.1. Ограничения

    Практически никаких дополнительных ограничений при написании модели не
вводится, модель может использовать возможности, предоставляемые выбранным
языком программирования и DOS.
    В число немногих вводимых ограничений входят:
1. Захват векторов прерываний. Модель не должна захватывать никаких векторов
   прерываний. В противном случае возможна потеря управления.
2. Видеорежим. Если модель изменяет видеорежим, или переключает экранные
   страницы, то она должна перед возвратом в отладчик восстановить все как
   было.
                          -   19   -



                5.2.2. Использование моделью дисплея и клавиатуры

    Неоднократно встечавшиеся выше упоминания о логическом экране модели не
означают, что модель должна использовать какие-то особые средства вывода на
экран. Заботу о поддержке логических экранов берет на себя отладчик, а модель
может выводить свои сообщения как и любая другая программа (однако см. ограниче-
ние 2).
    Модель получает доступ к клавиатуре так же, как и любая другая программа.
Однако необходимо иметь ввиду, что при выполнении программы отладчик следит за
порядком в буфере клавиатуры. В случае, если буфер будет полностью заполнен,
отладчик его опустошает, так что вводя символы для модели "впрок" знайте меру.
Буфер клавиатуры также опустошается при обнаружении Alt+F6 и Ctrl+F6.

                  5.2.3. Использование моделью памяти PC IBM

    Обьем памяти, отводимый модели, ограничивается только обьемом свободной
памяти системы. Обычно в MS-DOS доступно 640К байт, из них около 160К занимает
сам отладчик, 50-100К занимают резидент MS-DOS и прочие резидентные программы
(например, NORTON COMMANDER), таким образом модели остается примерно 400К байт,
что трудно назвать жестким ограничением. Общий размер кодов модели ограничен
1 Мб, то есть в нашем случае только размером свободной памяти. Размер области
статических данных, базируемых по регистру DS, а также размер области стека
ограничены по 64К каждая, а область динамических данных (куча) также ограни-
чена лишь свободной памятью системы.

                   5.3. Общая структура программы-модели

    В состав программы-модели должны обязательно входить 4 подпрограммы, называ-
емые первычными моделями. Различаются первичные модели, получающие управление
при исполнении команд ввода, вывода, по достижении определенного момента времени
работы программы, а также по сигналу с клавиатуры для имитации интерактивных
событий или занесения исходных данных для моделирования. Модель может также
содержать и другие подпрограммы. В ходе дальнейшего изложения будут употреблять-
ся условные имена первичных моделей: IN-модель, OUT-модель, DAT-модель,
CLK-модель. Вы можете употреблять свои, произвольные имена.
    Существуют следующие правила, общие для всех языков:
1. Первичные модели должны быть рассчитаны на дальний вызов.
2. Возврат из первичных моделей должен обязательно производится подпрограммой
   RETDBG, причем RETDBG не должен быть вложен в другие подпрограммы.
   Подпрограмме RETDBG передается один параметр, имеющий смысл возвращаемого
   значения для отладчика. Этот параметр принимается только в IN-модели,
   во всех других он игнорируется, и может быть указан произвольно, например 0.
3. Головной блок программы-модели должен начинаться вызовом подпрограммы
   ADJUSTMODEL, которой передаются в качестве параметров полные адреса
   всех 4-х первичных моделей. Вызов этой подпрограммы также не должен быть
   вложен в другие подпрограммы. Последним оператором головного блока должен
   быть вызов процедуры LINKWITHDBG.
    Вышеупомянутые подпрограммы описаны в разделе 5.5.
                          -   20   -




                         5.4. Первичные модели

    Здесь приведены общие сведения о первичных моделях, особенности написания
на конкретном языке описаны в соответствующих разделах.

                        IN-модель
    Вызывается при исполнении в программе команды IN. Передается один входной
параметр типа byte - номер порта ввода. Смоделированное в этой модели значение
передается подпрограмме RETDBG как параметр, который передается далее в отладчик
и заносится им в A-регистр программы.

                        OUT-модель
    Вызывается при исполнении в программе команды OUT. Передаются два входных
параметра типа байт - номер порта вывода и выводимое данное (содержимое
A-регистра программы). Параметр, передаваемый подпрограмме RETDBG может быть
указан произвольно.
                        DAT-модель
    Вызывается при остановленной программе нажатием F5. Параметры не передаются.
Может быть использована для занесения или изменения исходных данных для модели-
рования или имитации интерактивных событий. Начальное занесение исходных данных
можно также производить в головном блоке.

                        CLK-модель
    Вызывается по достижении заданного момента моделируемого времени. Параметры
не передаются. Может быть использована для моделирования событий, зависящих
от времени. Момент следующего вызова задается с помощью подпрограммы
setnextcall.


                       5.5. Библиотека DBGMOD.OBJ

    Все подпрограммы из этого файла рассчитаны на "дальний" вызов и используют
паскалевское соглашение о вызове и регистрах.
      Всего имеются следующие подпрограммы :

                                GET85TIME

    Возвращает моделируемое время в виде количества системных квантов.

Описание на паскале : function get85time:longint; external;
Прототип на Си :      extern pascal far long int get85time(void);
Вызов на ассемблере:
        call    get85time       ; время будет на DX,AX регистрах
                          -   21   -


                                SETNEXTCALL

    Эта процедура задает момент системного времени, когда будет в следующий раз
вызвана CLK-модель. Если забыть это сделать, то CLK-модель будет вызвана после
отсчета первого же кванта времени, и больше никогда. То же самое после каждого
вызова, то есть после каждого вызова нужно обязательно задавать момент следую-
щего вызова. При инициации модели можно с помощью этой процедуры задать
другое время первого вызова. Задание момента, равного или меньшего текущему
системному времени эквивалентно заданию вызова на ближайшем кванте.
    Момент задается в том же формате, что и значение, возвращаемое GET85TIME.
Например, setnextcall(get85time+100) - вызвать через одну милисекунду.

Описание на паскале : procedure setnextcall(d:longint); external;
Прототип на Си :      extern pascal far void setnextcall(long int d);
Вызов на ассемблере:
        push    word ptr d[2]
        push    word ptr d
        call    setnextcall

                                ENABLED85

    Возвращает значение INTE из окна регистров. TRUE (не ноль) означает,
что общие прерывания в процессоре разрешены, FALSE (ноль) - что была команда DI,
или еще не закончена обработка предыдущего прерывания.

Описание на паскале : function enabled85:boolean; external;
Прототип на Си :      extern pascal far unsigned char enabled85(void);
Вызов на ассемблере:
        call    enabled85       ; значение будет в AL регистре

                              SET85INTERRUPT

    Порождает прерывание программы. Передаются 2 параметра. Первый,
типа byte - номер прерывания. Номер прерывания выбирается в пределах 0..0FFH
произвольно, кроме 45H,55H,65H,75H. Этот номер фиксируется при регистрации
этого прерывания, он же имеется ввиду при задании множества регистрируемых
прерываний. Номера прерываний 45H,55H,65H,75H зарезервированы для специфических
прерываний 8085 процессора: соответственно TRAP, 5.5, 6.5, 7.5 .
Второй параметр - адрес передачи управления по этому прерыванию. Если номер
прерывания из числа зарезервированных, то этот параметр игнорируется и может
быть задан произвольно, т.к. специфические прерывания передают управление на
фиксированные адреса. Если возвращаемое значение = TRUE (не ноль), то прерывание
произошло, FALSE (ноль) - прерывания были запрещены или это прерывание было
замаскировано. В случае возврата FALSE прерывание не производится, не регистри-
руется и не запоминается (кроме специфических прерываний).  Прерывание TRAP
выполняется, как известно, всегда; прерывания 55H и 65H запоминаются только до
момента ближайшего вызова CLK-модели (даже если они инициированы ручной коррек-
цией маски прерываний), после чего биты их ожидания сбрасываются. Прерывание 75H
запоминается вплоть до его обработки или сброса командой SIM или ручной коррек-
цией маски. Прерывания 55H, 65H, 75H регистрируются только в момент выполнения,
а не запоминания. В протоколе фиксируется номер прерывания, время, и адрес
прерваной команды программы, т.е. адрес куда управление вернется по выходу из
прерывания.

Описание на паскале : function set85interrupt(n:byte;a:word):boolean; external;
Прототип на Си :      extern pascal far unsigned char set85interrupt
                                               (unsigned char n,unsigned int a);
Вызов на ассемблере:
        push    word ptr n
        push    word ptr a
        call    set85interrupt  ; признак успеха будет в al - регистре
                          -   22   -


                                HALT85

    Останавливает выполнение программы.

Описание на паскале : procedure halt85; external;
Прототип на Си :      extern pascal far void halt85(void);
Вызов на ассемблере:
        call    halt85

                            ADJUSTMODEL

    Передает адреса первичных моделей отладчику, а также производит другие
настроечные действия. До вызова этой подпрограммы все остальные подпрограммы
модуля DBGMOD.OBJ работать не будут. Вызов этой подпрограммы нельзя вкладывать
в другие подпрограммы. Если первичные модели будут размещены в том же кодовом
сегменте, что и головной модуль, то:  mov ax,seg XXX_model   \   push ax
можно заменить на: push cs.

Описание на паскале : procedure adjustmodel(o,i,d,c:pointer); external;
Прототип на Си :      extern pascal far void adjustmodel
                                                 (proc o,proc i,proc d,proc c);
              Где формальные параметры соответствуют:
o - OUT-модели, i - IN-модели, d-DAT-модели, c - CLK-модели, а proc (при вызове
из Си) - тип ссылки на функцию, например,  такой : void pascal far (*proc)();.
Вызов на ассемблере:
        mov     ax,seg OUT_model
        push    ax
        mov     ax,offset OUT_model
        push    ax
        mov     ax,seg IN_model
        push    ax
        mov     ax,offset IN_model
        push    ax
        mov     ax,seg DAT_model
        push    ax
        mov     ax,offset DAT_model
        push    ax
        mov     ax,seg CLK_model
        push    ax
        mov     ax,offset CLK_model
        push    ax
        call    adjustmodel

                              RETDBG

    Производит возврат из первичных моделей в отладчик. Этот вызов также нельзя
вкладывать в другие подпрограммы, но можно включать в состав сложных операторов.
Передаваемый параметр типа byte имеет смысл лишь в IN-модели, во всех остальных
он игнорируется. Управление в модель не возвращается.

Описание на паскале : procedure retdbg(d:byte); external;
Прототип на Си :      extern pascal far void retdbg(unsigned char d);
Вызов на ассемблере:
        push    word ptr d  ; для IN-модели, в других достаточно pushf
        call    retdbg
                          -   23   -

                            LINKWITHDBG

    Производит возврат из головного блока модели в отладчик. Должен быть
последним оператором блока. Управление в модель не возвращается.

Описание на паскале : procedure linkwithdbg; external;
Прототип на Си :      extren pascal far void linkwithdbg(void);
Вызов на ассемблере:
        call    linkwithdbg

                            MEMINDMA

    Позволяет записать байт в моделируемую память. Применяется для моделирования
процессов прямого доступа в память. Передаются два параметра. Первый - типа
word, адрес памяти, второй - типа byte, записываемый байт. Обычно после
моделирования прямого доступа в память необходимо скорректировать время
процедурой DELAY85.

Описание на паскале : procedure memindma(a:word;b:byte); external;
Прототип на Си :      extern pascal far void memindma(unsigned int a,unsigned char b);
Вызов на ассемблере:
        push    word ptr a
        push    word ptr b
        call    memindma

                            MEMOUTDMA

    Функция, обратная MEMINDMA. Возвращает байт из моделируемой памяти.
Параметр типа word - адрес моделируемой памяти.

Описание на паскале : function memoutdma(a:word):byte; external;
Прототип на Си :      extern pascal far unsigned char memoutdma(unsigned int a);
Вызов на ассемблере:
        push    word ptr a
        call    memoutdma       ; считанный байт будет в al - регистре

                            DELAY85

    Имитирует задержку в моделях долго работающих устройств. Фактически
происходит коррекция счетчиков системного времени. Передается один параметр типа
longint, имеющий смысл интервала времени в том же формате, что и в функции
GET85TIME.
Описание на паскале : procedure delay85(d:longint); external;
Прототип на Си :      extern pascal far void delay85(long int d);
Вызов на ассемблере:
        push    word ptr d[2]
        push    word ptr d
        call    delay85

                            READSOD

    Считывает выданный в программе командой SIM бит последовательных данных.
Считанное значение возвращается в AL - регистре, причем не в том бите, где
располагается SOD в маске прерываний, поэтому имеет смысл лишь проверка на
нулевое или ненулевое значение. 

Описание на паскале : function readsod:byte;
Прототип на Си :      extern pascal far unsigned char readsod(void);
Вызов на ассемблере :
        call    readsod
                          -   24   -



                            WRITESID

    Формирует бит последовательных данных SID, который может быть считан в
программе командой RIM. Если b будет нулем, то сформируется нулевое значение
бита SID, если любое ненулевое значение, то сформируется единичное значение.
Сформированное значение SID сохраняется вплоть до следующего вызова WRITESID.

Описание на паскале : procedure writesid(b:byte);
Прототип на Си :      extern pascal far void writesid(unsigned char b);
Вызов на ассемблере :
        push    word ptr b
        call    writesid


                            INTMASK85

    Возвращаемое значение будет в AL-регистре. Считывает маску прерываний
программы, аналогично тому, как это делает в программе команда RIM. В некоторой
степени дублирует подпрограмму ENABLED85, применение которой во многих случаях
удобнее.

Описание на паскале : function intmask85:byte;
Прототип на Си :      extern pascal far unsigned char intmask85(void);
Вызов на ассемблере : call intmask85
                          -   25   -


                  5.6. Написание модели на турбо-паскале

    В модели требуется перечислить все имеющиеся в DBGMOD.OBJ подпрограммы
как EXTERNAL, предварив их псевдокомментарием {$F+}. Имя файла DBGMOD.OBJ
указывается в псевдокомментарии {$L DBGMOD.OBJ}. Все это уже есть в модуле
DBG85P.TPU, таким образом удобнее просто указать DBG85P в разделе USES. При
необходимости смены версии транслятора DBG85P.TPU можно получить снова пере-
компиляцией DBG85P.PAS . Так как раздельно компилируемые подпрограммы всегда
используют дальний вызов, то при раздельной копмиляции псевдокомментарий {$F+}
не обязателен.

                   5.6.1. Первичные модели на паскале

    Первичные модели могут находиться в разных модулях (UNIT), то есть допуска-
ется их раздельная компиляция. Первичные модели должны быть транслированы в
режиме {$F+}.
    Заголовки первичных моделей на паскале записываются так :
IN-модель  :  procedure IN_model(n:byte);    {n - номер порта}
OUT-модель :  procedure OUT_model(n,d:byte); {n - номер порта; d - данное}
DAT-модель :  procedure DAT_model;
CLK-модель :  procedure CLK_model;

                5.6.2. Общий вид программы-модели на паскале

{$M ssss,llll,hhhh}                 {отказ от лишней памяти (не обязательно)}
uses . . . .,dbg85p, . . .;
. . . .                             {описания, в т.ч. своих процедур}

{$F+}
procedure IN_model(n:byte);         {n-номер порта}
var d:byte;
. . . .                             {модели портов ввода}
retdbg(d)                           {d будет загружено в А-регистр программы}
end;

procedure OUT_model(n,d:byte);      {n-номер порта; d-выводимое данное}
. . . .                             {модели портов вывода}
retdbg(0)
end;

procedure CLK_model;
. . . .                             {модель, следящая за временем}
retdbg(0)
end;

procedure DAT_model;
. . . .                              {можно заносить исходные данные}
retdbg(0)
end;
{$F-}                                {если требуется}
. . . .                              {продолжение описания своих процедур}

begin
adjustmodel(@OUT_model,@IN_model,@DAT_model,@CLK_model);
                                    {передача адресов отладчику}
. . . .                             {инициирующая часть модели}
linkwithdbg                         {выход в отладчик}
end.
                          -   26   -





                  5.7. Написание модели на турбо-С++

    Модель на турбо Си должна использовать соглашение о связях и регистрах,
принятое в турбо-паскале. Не обязательно для этого транслировать всю модель в 
"паскалевском" режиме, достаточно указывать перед первичными моделями и
подпрограммами из DBGMOD квалификатор pascal. Переменные класса register не
сохраняются по выходу из подпрограмм из DBGMOD.
    Допустимы все схемы распределения памяти, кроме huge.
    Для прикомпоновки DBGMOD.OBJ к OBJ-файлу модели, полученному при трансляции,
пригоден любой LINKер, в том числе встроенный; возможно, потребуется подавление
чуствительности к регистрам букв (case sensivity).
    Прототипы функций, имеющиеся в DBGMOD.OBJ имеются в файле DBG85C.H ,
таким образом их можно не перечислять явно в программе. Кроме прототипов функ-
ций, этот файл содержит следующие определения типов:
    typedef void pascal far (*proc)();
    typedef unsigned char byte;
    typedef unsigned int word;
Таким образом можно использовать типы byte и word вместо unsigned char и
unsigned int, и тип proc если нужно для ссылок на процедуры.


                    5.7.1.  Первичные модели на Си

    Первичные модели на Си допускают раздельную компиляцию и могут находиться
в разных кодовых сегментах.
    Заголовки первичных моделей на Си записываются так :

IN-модель  : void pascal far IN_model(unsigned char n)
                                            /* n - номер порта */
OUT-модель : void pascal far OUT_model(unsigned char n,unsigned char d)
                                             /* n - номер порта, d - данное */
DAT-модель : void pascal far DAT_model(void)
CLK-модель : void pascal far CLK_model(void)
                          -   27   -



              5.7.2. Общий вид программы-модели на Си

#INCLUDE "DBG85C.H"
. . . .                               /* другие описания */
void pascal far IN_model(byte n)
{
unsigned char d;
. . . .                               /* модели портов ввода */
retdbg(d);                          /* d будет загружено в А-регистр программы */
}

void pascal far OUT_model(byte n,byte d)

{. . . .                            /* модели портов вывода */
retdbg(0);
}

void pascal far CLK_model(void)
{. . . .                            /* модель, следящая за временем */
retdbg(0);
}

void pascal far DAT_model(void)
{. . . .                            /* можно заносить исходные данные */
retdbg(0);
}

. . . .                             /* продолжение описания своих функций */

main()
{
adjustmodel(OUT_model,IN_model,DAT_model,CLK_model);
. . . .                             /* инициирующая часть модели */
linkwithdbg();
}
                          -   28   -




            5.8. Написание модели на ассемблере 8086/80x86

    Модель должна использовать соглашение о связях и регистрах, принятое
в турбо-паскале. Кратко это соглашение о связях выглядит так: Должны
сохраняться значения регистров DS,SS,SP,BP. Остальные регистры можно портить.
Параметры передаются через стек в порядке справа налево, причем у полных 
адресов сначала заталкивается сегментная часть адреса, затем внутрисегментная,
которая, таким образом занимает в памяти младшие адреса. Удаление параметров
из стека производится внутри подпрограммы. Функции возвращают значение типа
byte или boolean в AL-регистре. Значение типа longint возвращается в регистрах
AX и DX: младшая часть - в AX, старшая - в DX.
    Состояния регистров DS,SS,SP,BP перед вызовом первичной модели устанавлива-
ются такими, какими они были перед вызовом подпрограммы ADJUSTMODEL (до
заталкивания в стек параметров).
    Также, как и для моделей на Си, на ассемблере для прикомпоновки DBGMOD.OBJ
к OBJ-файлу модели, полученному при трансляции, пригоден любой LINKер.
    Заголовки первичных моделей на ассемблере выглядят как PROC FAR. Первичные
модели должны начинаться стандартным входным кодом : push bp  \    mov bp,sp ,
даже если этой первичной модели не передается параметров, и она не размещает
в стеке своих локальных переменных. Допустимо нахождение первичных моделей в
разных кодовых сегментах.
    Программа-модель на ассемблере должна обязательно содержать сегмент с
именем data и с типом компоновки public, хотя бы пустой. Адрес этого сегмента
должен быть загружен в регистр DS в начале работы головного модуля, перед
вызовом подпрограмм из DBGMOD.OBJ .
    Необходимо также соблюдать правила, общие для любых программ на ассемблере.
    Здесь и далее в примерах на ассемблере использованы только команды 8086,
а также конструкции, допустимые в трансляторе MASM, хотя применение команд
80186/286/386, а также конструкций TASM отнюдь не запрещено.
                          -   29   -



          5.8.1.  Общий вид программы-модели на ассемблере 8086

        extrn       get85time:far,setnextcall:far,enabled85:far,halt85:far
        extrn       set85interrupt:far,adjustmodel:far,retdbg:far
        extrn       memindma:far,memoutdma:far,delay85:far,linkwithdbg:far
        extrn       readsod:far,writesid:far,intmask85:far
        assume      cs:code,ds:data

data    segment public
        .
        .
data    ends

code    segment

IN_model proc far
        push    bp
        mov     bp,sp         ;   стандартный входной код
        .                     ;   номер порта доступен как byte ptr [bp+6]
        .
        push    word ptr d    ;   смоделированное значение
        call    retdbg
                              ;   стандартный выходной код не обязателен
IN_model endp

OUT_model proc far
        push    bp
        mov     bp,sp         ;   стандартный входной код
        .                     ;   номер порта доступен как byte ptr [bp+8]
        .                     ;   выводимое данное доступно как byte ptr [bp+6]
        pushf                 ;   имитация параметра для RETDBG
        call    retdbg
                              ;   стандартный выходной код не обязателен
OUT_model endp

DAT_model proc far
        push    bp
        mov     bp,sp         ;   стандартный входной код
        .
        .
        pushf                 ;   имитация параметра для RETDBG
        call    retdbg
                              ;   стандартный выходной код не обязателен
DAT_model endp
                          -   30   -


CLK_model proc far
        push    bp
        mov     bp,sp         ;   стандартный входной код
        .
        .
        pushf                 ;   имитация параметра для RETDBG
        call    retdbg
                              ;   стандартный выходной код не обязателен
CLK_model endp

startpoint:                   ;   Выполнение начнется отсюда
        mov     ax,data
        mov     ds,ax
        mov     ax,seg OUT_model
        push    ax
        mov     ax,offset OUT_model
        push    ax
        mov     ax,seg IN_model
        push    ax
        mov     ax,offset IN_model
        push    ax
        mov     ax,seg DAT_model
        push    ax
        mov     ax,offset DAT_model
        push    ax
        mov     ax,seg CLK_model
        push    ax
        mov     ax,offset CLK_model
        push    ax
        call    adjustmodel
        .
        .                    ;  инициализация модели
        call    linkwithdbg
code    ends

stak    segment stack       ;   имя этого сегмента условное
        .                   ;   под стек желательно отводить не менее 1 К.
        .
stak    ends
        end     startpoint
                          -   31   -




                        ГЛАВА  6.  УТИЛИТА REGTYPE

                    =================================



    Протоколы выполнения команд обмена и прерываний, сформированые отладчиком,
можно просмотреть в ходе сеанса отладки, но там протокол выдается только
полностью, в сжатом виде, и только на экран. Утилита REGTYPE позволяет выдавать
протокол на экран или принтер в более развернутом виде. Кроме того, можно
задавать ограничения на выдаваемые события, например, просмотреть ввод только в
определенные порты, или прерывания, пришедшие в определенном интервале времени
и т.п.
    Вызов утилиты производится следующим образом :
        REGTYPE [<имя файла протокола>]
    После вызова утилиты на экране появляется меню, предлагающее произвесть
селекцию команд ввода, вывода или прерываний по номерам событий, адресам команд
обмена или адресам прерванных команд, по вводимым-выводимым данным, или времени
событий. Здесь же можно очистить экран, а также указать файл протоколов, если
он не был указан при вызове или понадобилось просмотреть другой протокол, можно
задать выводимое устройство - экран или принтер. Выдача начнется после выбора
в теме "выдача" режима : сначала или продолжить. Если до этого файл протоколов
не был определен, то появится приглашение ввести имя файла протокола (подтвер-
дить указанное в параметре). Управление выдачей производится аналогично прос-
мотру протокола в отладчике, т.е. останавливается выдача нажатием пробела,
возобновляется нажатием любой клавиши, прерывается нажатием ESC.
    Правила управления меню, ввода множеств номеров выдаваемых событий, задание
пределов адресов, данных и времен событий совпадают с аналогичными правилами
для отладчика.








                           ПРИЗНАТЕЛЬНОСТИ

                        =====================



    Считаю своим долгом выразить признательность нижеследующим дамам и
господам, оказавшим любезное содействие в работе над программой и документацией:
Дахиной Т.В., Кузмишину В.А., Кривошееву В.Е., Васильеву Ю.В., Позняк В.В.,
Широбокову М.А. .

                          -   32   -





                             ПРИЛОЖЕНИЯ

                        ====================




                        Приложение 1

        Структура обьектных и исполняемых файлов ОС ISIS-II.

    ОС ISIS-II работает с довольно оригинальной структурой обьектных и исполня-
емых файлов. Структура эта, как ни странно, одинакова что для файлов,
после трансляции, после компоновки (LINK), и настройки на абсолютные адреса
(LOCATE), причем трансляторы со всех языков в ISIS-II придерживаются одного
формата обьектных файлов, и в общем одного соглашения о вызове и регистрах.
    Эта общность структуры позволяет запускать на выполнение файлы сразу
после трансляции, если не требуется компоновки и размещения (LOCATE); можно
запускать после компоновки, если не требуется размещения; можно файлы, получен-
ные после компоновки и размещения опять запускать на компоновку и размещение,
если, например, обнаружились неудовлетворенные внешние ссылки; можно после
трансляции размещать, не компонуя.
    Полное описание этой структуры заняло бы, пожалуй, половину настоящего
руководства, но для работы с отладчиком этого всего не требуется. Ограничимся
необходимым минимумом.
    Весь файл этой структуры разбит на блоки неравной длины. Каждый блок начина-
ется байтом, обозначающим его тип. Для нас представляют интерес блоки типов
02,04 и 06. Далее идет двухбайтовая длина блока, начиная со следующего байта.
Порядок записи всех двухбайтовых величин соответствует традициям фирмы INTEL -
сначала идет младший байт слова, затем старший. Заканчивается блок своей
однобайтовой, простой (не циклической) контрольной суммой, которая подсчитывает-
ся, начиная с байта типа блока, и заканчивается байтом, предшествующим контроль-
ной сумме. Байт контрольной суммы записан в дополнительном коде и включается в
длину блока. В настоящей версии отладчика контрольная сумма игнорируется, т.е.
ее можно не считать, но какой-нибудь байт на ее место нужно записывать обяза-
тельно. В последующих версиях контрольная сумма возможно, будет учитываться.
                    Блок 02
    Должен быть первым блоком файла. Содержит общую информацию о программе в
этом файле. В отладчике считывается только имя модуля. Байт, следующий после
длины блока содержит длину имени в прямом коде, далее - символы имени в коде
ASCII. Последующие байты вплоть до контрольной суммы отладчик пропускает.
                    Блок 04
    Содержит стартовый адрес программы. Длина этого блока всегда 5, а
собственно адрес размещается через 2 байта после длины блока. После загрузки
программы счетчик команд загружается адресом, указанным в этом блоке. Присут-
ствие этого блока в файле не обязательно.
                    Блок 06
    Содержит загружаемые коды. Через байт после длины блока располагается
двухбайтовый адрес начала загрузки блока, и далее вплоть до контрольной суммы
располагаются загружаемые коды.
                          -   33   -


    В качестве примера приведу программу на паскале, преобразующую файл, содер-
жащий образ памяти отлаживаемой системы в файл формата ISIS-II. Предполагается,
что файл образа содержит ровно 65536 кодов (максимально возможный размер).
    Для наглядности программа не производит никаких проверок на конец файлов
и тому подобное.

program image_to_ISIS;

var
  fi,fo : file of byte;
  b     : byte;
  i     : word;
  n     : string;

begin
  n:='IMAGE';
  assign(fi,'memory.img');  reset(fi);      { входной файл образа памяти }
  assign(fo,'prog');        rewrite(fo);    { выходной файл формата ISIS-II }
  b:=2; write(fo,b);                        { блок типа 2 }
  b:=7; write(fo,b); b:=0; write(fo,b);     { длина блока = 7 }
  for i:=0 to 5 do write(fo,ord(n[i]));     { запись имени модуля }
  write(fo,b);                              { вместо контрольной суммы }
  b:=6; write(fo,b);                        { блок типа 6 }
  b:=lo(32772); write(fo,b);                { длина блока = 32768+4=32772 }
  b:=hi(32772); write(fo,b);
  b:=0;  write(fo,b);
  write(fo,b); write(fo,b);                 { загружать с нулевого адреса }
  for i:=0 to 32767 do
    begin
      read(fi,b); write(fo,b)               { запись собственно кодов }
    end;
  write(fo,b);                              { вместо контрольной суммы }
  b:=6; write(fo,b);                        { блок типа 6 }
  b:=lo(32772); write(fo,b);                { длина блока = 32768+4=32772 }
  b:=hi(32772); write(fo,b);
  b:=0;  write(fo,b);
  b:=lo(32768); write(fo,b);                { загружать с адреса 32768 }
  b:=hi(32768); write(fo,b);
  for i:=0 to 32767 do
    begin
      read(fi,b); write(fo,b)               { запись собственно кодов }
    end;
  write(fo,b);                              { вместо контрольной суммы }
  close(fi); close(fo)
end.

                          -   34   -











                        Приложение 2

                  Демонстрационный пример

    Предположим, что нам необходимо разработать микропроцессорную систему,
имитирующую наличие людей ночью в доме. Эта система должна в ночное время
случайным образом включать и выключать в комнатах свет, а в дневное время
ничего не делать. Предположим также, что в комплект аппаратуры включены : датчик
освещенности снаружи дома, таймер, вырабатывающий с каким-то периодом прерывания
в процессор, исполнительные устройства, непосредственно включающие и выключающие
освещение. Ограничимся для краткости четырьмя комнатами.
    Будем считать, что ввод из нулевого порта анализирует датчик освещенности,
причем нулевое значение в порту означает наступление ночи, а ненулевое - дня;
вывод в порты с 1 по 4 управляют освещением в соответствующей комнате - вывод
нуля выключает свет, а вывод ненуля - включает; вектор прерывания расположен на
адресе 0008. Период прерываний в реальной системе предполагается несколько де-
сятков секунд, но для отладки это слишком редко, вполне можно сделать 0.1 сек.
    Программа для этой системы содержится в файле EXAMPL, а ее исходный текст
в EXAMPL.ASM. Модель, моделирующая аппаратуру, содержится в файле MODEL.EXE,
а ее исходный текст на различных языках - в файлах MODEL.PAS, MODEL.C.,
MODEL.ASM. Файл MODEL.EXE транслирован с паскаля. Модели на различных языках не
вполне эквивалентны, например, модель на ассемблере не рисует домик. Это вызвано
тем, что такое рисование сильно бы увеличило обьем программы, никак не способ-
ствуя пониманию сути ее работы. DAT-модель (клавиша F5) имитирует наступление
дня или ночи - при запуске считается ночь, последовательные нажатия F5 дают
вводную "день", затем опять "ночь", и так далее.
    Программа EXAMPL написана для иллюстрации работы DBG85, и не претендует на
коммерческую ценность. Коммерческий вариант ее должен бы учитывать также и то,
что глубокой ночью света должно быть меньше, утром и вечером - больше, ну и
многое другое. Для краткости отсутвтвуют и коды инициализации аппаратуры.


                   ┌───────┐
                   │  ВСЕ  │
                   └───────┘

