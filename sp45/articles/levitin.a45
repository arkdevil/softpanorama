                             Игорь Левитин

                         ДЕСЯТЬ  ЛЕТ ЯЗЫКА СИ
                                  или
             ВТОРОЕ  ИЗДАНИЕ  КНИГИ  Б.КЕРНИГАНА  И  Д.РИТЧИ


    В   1992   году    отечественные   издатели   приподнесли    подарок
многочисленной армии программистов и тем, кто себя к ним относит:  вышел
в свет перевод  второго издания книги  Бриана Кернигана и  Денниса Ритчи
"Язык  программирования  Си".  Надо  отметить  прогресс  в  деятельности
издателей.  Перевод  появился  спустя  "всего"  четыре года после выхода
американского  издания,  тогда  как  перевод  первого издания опоздал на
целых семь лет.

    На книге авторов языка  Си воспитаны миллионы программистов  во всем
мире.  До  принятия  стандарта  языка  ANSI  С  (1989  г.)  книга   была
единственным  официальным  документом  по  языку  -  в  руководствах  по
трансляторам всегда находилось  место главе с  отличиями от K&R.  В этой
главе  говорилось,  чем  данная  реализация  языка  отличалась от языка,
описанного в этой книге.

    Как изменился язык Си за  десять лет? Какие новые особенности  языка
вошли в  стандарт ANSI  C, с  учетом которого  готовилось второе издание
книги Кернигана и Ритчи  (далее K&R)? В этой  статье будет идти речь  об
основных различиях  в языке  Си, описанном  в первом  и втором  изданиях
книги. Скажу сразу, что в статье ничего не будет сказано о другом  языке
программирования - языке Б.Страуструпа Си++, это тема других статей.

    0. Различие нулевое - терминология.

    Десять  лет  в  программировании  и  вычислительной  технике  - срок
огромный. Как сказано в  предисловии ко второму изданию,  многие понятия
за этот период уточняются, создаются новые понятия. Переводчик должен  с
этим считаться. Перевод первого издания книги выполнен  Д.Б.Подшиваловым
и В.А.Иващенко,  перевод второго  издания -  Вик.С.Штаркманом. Во втором
издании  термин  "символ"  стал  "литерой"  (по-английски  - character),
"описание" - "декларацией (declaration)," элемент" - "членом"  (member),
"операция"  -  "оператором"   (operator),  "оператор"  -   "инструкцией"
(statement),  "строка"  -  "стрингом"  (string), "запись" - "структурой"
(structure), "смесь" - "объединением" (union)  и т.д. Об этом указано  в
предисловии ко  второму русскому  изданию. К  изменениям в  терминологии
надо  будет  привыкать,  т.к.  практически  вся  русскоязычная (в т.ч. и
переводная)  литература  по  языку  Си использовала терминологию первого
издания,  новые  книги  по  языку  Си,  наверное,  будут  ис- пользовать
терминологию  второго.  Во  втором  издании  переведены и многие стринги
литер.  Так  строка  символов   "hello,  world"  стала  стрингом   литер
"здравствуй,  мир",  чтобы  никто  теперь  не  захотел перевести это как
"привет, Вася".

    1. Различие первое - базовые типы данных.

    Введение нового  ключевого слова  signed позволяет  вместе с  другим
ключевым словом unsigned представлять данные со знаком или без него  для
типов  данных  char,  short,   int  или  long.  Это   позволит  повысить
мобильность  программ.  Например,  если  данные  типа char могли быть со
знаком или без него в  зависимости от реализации, то данные  типа signed
char всегда со знаком, а unsigned char - всегда без знака. Впрочем, если
конкретная реализация языка Си поддерживает  стандарт, а вместе с ним  и
эти типы данных.

    Для  повышения  точности  вычислений  с  данными  с плавающей точкой
введен тип long double. Размер объектов этого типа зависит от реализации
(Например, в компиляторе MSC версии 6.0 фирмы Microsoft размер  элемента
long double -  80 бит). Зато  из языка изъят  тип long float,  служивший
синонимом для double.

    При вычислениях операнды типа float уже автоматически не  приводятся
к типу  doudle, как  10 лет  назад в  версии языка,  описанной в  первом
издании  книги.  Этот  факт  в  ряде  случаев  может привести к экономии
памяти.

    Введен новый  тип void  (пустой). Если  спецификатор void  указать в
объявлении  функции,  это  означает,что  функция  не возвращает никакого
значения.  Если  указать  его  вместо  списка  аргументов при объявлении
функции, значит, эта функция  не принимает аргументов. Нельзя  объявлять
переменную типа void.  Возникает вопрос, можно  ли выражения этого  типа
преобразовать к выражениям другого типа и наоборот? Существует правило:

    - любое  выражение можно  привести к  типу void  с помощью оператора
приведения;
    - никакое выражение  типа void нельзя  привести к выражению  другого
типа.

    Возможно и использование указателей на void.

    В   качестве   базового   типа   введены   перечисления.   Поскольку
перечисления представляют собой множество  констант - о них  в следующем
пункте  статьи.  Спецификатор  для  типа перечислений enum. Перечисления
относятся к так называемому арифметическому типу.

    Вывод:  Десять  лет  развития  языка  Си  привело  к   существенному
изменению  базовых  типов  языка.  Появились  новые  спецификаторы типов
signed (абсолютно равноправный с unsigned), void, enum и, следовательно,
и новые типы данных.

    Пример  1.  Использование  типа  long  double  приводит  к повышению
точности.

    (Все  примеры   реализованы  на   компиляторе  MSC   версии  6.0  на
персональном  компьютере  типа  IBM  PC.  Нумерация примеров совпадает с
номером пункта.)

#include <math.h>

main()
  {
   long double pi_long=3.1415926535897932385l;  /* Число пи объявля- */
   double pi=3.1415926535897932385l;            /* ется с различной  */
                                                /* точностью         */


   /* В библиотеке языка Си введены специальные  функции
      для работы с данными типа long double            */
   printf("\nРезультаты вычислений с использованием типа long double\n");
   printf("%21.19Lf\n",pi_long);
   printf("%21.19Lf\n",pi_long/8);
   printf("%21.19Lf\n",tanl(pi_long/8));
   printf("%21.19Lf\n",atanl(tanl(pi_long/8)));
   printf("%21.19Lf\n",atanl(tanl(pi_long/8))*8);

   /* А теперь для сравнения не будем использовать
      данные типа long double и соответствующие функции */
   printf("\nРезультаты вычислений без использования типа long double\n");
   printf("%21.19f\n",pi);
   printf("%21.19f\n",pi/8);
   printf("%21.19f\n",tan(pi/8));
   printf("%21.19f\n",atan(tan(pi/8)));
   printf("%21.19f\n",atan(tan(pi/8))*8);
  }

   Запустив программу, получим:
                                                                               L
G:\>example1

Результаты вычислений с использованием типа long double
3.1415926535897932385
0.3926990816987241548
0.4142135623730950488
0.3926990816987241548
3.1415926535897932385

Результаты вычислений без использования типа long double
3.1415926535897930000
0.3926990816987241000
0.4142135623730950000
0.3926990816987241000
3.1415926535897930000

    Девятнадцать  значащих  цифр  вместо  пятнадцати  -  так  повышается
точность вычислений с плавающей точкой в данной реализации.

    2. Различие второе - константы.

    В первом издании K&R в качестве суффиксов при записи целых  констант
могли быть использованы только буквы  l или L (запись 12l  означало, что
константа относилась  к типу  long). Теперь  набор суффиксов существенно
расширен. Целую константу можно явно сделать беззнаковой (суффикс u  или
U),  а  константу  с  плавающей  точкой  (ранее  не  употреблявшейся   с
суффиксами вообще) можно отнести  к типу float (cуффиксы  f или F )  или
long  double  (l  или  L).  Для целых констант допускается одновременное
использование двух суффиксов  (12ul - константа  типа unsigned long).  В
восьмеричной форме записи целых констант нельзя употреблять цифры 8 и  9
(ранее они означали восьмеричные значения 10 и 11 - более нелепую запись
трудно  представить).  Изменились  и  правила  соотнесения  типа   целой
константы с ее записью. Ранее, любая целая константа без суффикса l  или
L, которая  не могла  быть представлена  в данной  реализации как  int -
считалась long. Сейчас необходимо  учитывать три фактора: форму  записи,
суффикс и значение константы.

    Сведения о влиянии этих факторов помещены в таблицу:

──────────────────────────────────────────────────────────────
 -   Форма +  │     Десятичная        │      Восьмеричная
    -  Суффикс│                       │   (шестнадцатиричная)
 Тип   -      │───────────────────────│───────────────────────
 данных   -   │  -  │  u  │  l  │ ul  │  -  │  u  │  l  │ ul
──────────────│─────│─────│─────│─────│─────│─────│─────│─────
int           │  +  │  -  │  -  │  -  │  +  │  -  │  -  │  -
unsigned      │  -  │  +  │  -  │  -  │  +  │  +  │  -  │  -
long          │  +  │  -  │  -  │  -  │  +  │  -  │  +  │  -
unsigned long │  +  │  +  │  +  │  +  │  +  │  +  │  +  │  +
──────────────────────────────────────────────────────────────

    Eсли  значение   константы  представимо   как  данное   верхнего  из
отмеченных плюсом типов,  она принимает этот  тип. Иначе -  следующий из
отмеченных плюсом типов и т.д.

    Для констант с плавающей точкой проще- суффикс определяет тип, а его
отсутствие - тип double.

    Что  касается  литерных  констант.  то существенно расширился список
эскейп-последовательностей,  которые  могут  использоваться  в  качестве
литеры-константы: \а -  звонок, \v -  вертикальная табуляция, \?  - знак
вопроса, \" -  двойная кавычка. Появилась  возможность шестнадцатиричной
записи  эксейп-последовательностей  -  \xdd,  где dd - шестнадцатиричные
цифры. После \ не могут следовать недопустимые литеры. Результат в  этом
случае непредсказуем.   (Во многих  реализациях в  этом случае  литера \
просто  игнорируется).  Введен  расширенный  набор  литер. Константы для
такого  набора  имеют  префикс  L  (например, L'x'). Тип такой константы
определяется  как  тип  wchar_t   и  зависит  от  файла   <stddef.h>  (в
компиляторе  MSC  версии  6.0  такой  тип  не  обнаружен,  а в известном
компиляторе TurboC фирмы Borland Int'l совпадает с типом char).

    Стринговые  литералы  теперь  конкатенируются  компилятором  в  один
стринг с  литерой '\0'  на конце.  Как и  для литерных  констант введены
"расширенные" стринговые литералы с префиксом L (L"..."), тип которых  -
массив элементов типа wchar_t.

    Перечислимые константы - удобное нововведение. Список целых констант
объявляется так:

enum [<Тег>] {<список перечислителей} <декларатор>
                                   [,<декларатор>...>];
   либо так

enum <Тег> <идентификатор>, [<идентификатор>...];

    Здесь <декларатор> - переменная, массив переменных или указатель  на
переменную перечислимого типа;
    <Тег> - имя для перечислимого типа;
    <идентификатор> - имя переменной перечисленного типа;
    <список  перечислителей>  -  одна  или  несколько  конструкций  вида
        <идентификатор>[=<константное выражение>].

    При использовании перечислений надо учитывать следующее:

    - между фигурными скобками находится список констант, а <декларатор>
и <идентификатор> - это переменные перечислимого типа;
    - идентификаторы, входящие в список перечислителей имеют тип int;
    - если  нет  явного   присваивания  элементу  списка  перечислителей
какого-либо значения, то первый элемент этого списка будет константой 0,
второй -  константой 1  и т.д.  Если одному  из элементов  присваивается
какое-либо значение, то следующий -  на единицу больше этого значения  и
т.д.

    Использование   перечислимых   констант   более   удобно,   чем  ис-
пользование  списка   констант,  заданных   с  помощью   директивы  пре-
процессора #define.

    И,  наконец,  введен  квалификатор  типа  const, который не позволит
менять значение  объекту любого  типа. Например  декларация

                  const int three = 3;

    позволит использовать идентификатор three вместо константы 3 в любом
месте программы. Изменить значение этого индентификатора нельзя.

    Вывод: Развитие  языка Си  привело к  появлению новых  суффиксов для
записи   констант,   изменились   правила   "привязывания"   констант  к
определенным  типам  данных,   появились  так  называемые   перечислимые
константы.

    Пример 2. Использование перечислимых констант удобно.

main()
  {
    enum DAYS_WEEK              /* Декларация перечисления DAYS_WEEK    */
    {
       saturday,                /* saturday и sunday получат            */
                                /* значение 0                           */
       sunday = 0,
       monday,                  /* monday будет присвоено значение 1,   */
       tuesday,                 /* tuesday -              значение 2    */
       wednesday,               /* и т.д.                               */
       thursday,
       friday
    } today;                    /* Переменная today типа enum DAYS_WEEK */

    enum DAYS_WEEK tomorrow = tuesday; /* Переменная tomorrow имеет тип */
                                /* DAYS_WEEK и начальное значение       */
                                /* tuesday, вышеопределенное как 2      */

    printf("\n%d",saturday);    /* Печать членов перечисления           */
    printf("\n%d",sunday);
    printf("\n%d",monday);
    printf("\n%d",tuesday);
    printf("\n%d",wednesday);
    printf("\n%d",thursday);
    printf("\n%d",friday);

    printf("\n\n%d",sizeof today);  /* Печать размеров переменной типа */
    printf("\n%d",sizeof(enum DAYS_WEEK));  /* enum DAYS_WEEK          */

  }

   Запустив программу, получим:
                                                                               L
G:\>example2

0            Итак, определены сразу  семь
0            идентификаторов для констант
1
2
3
4
5

2            Обратите внимание, что размер перемен-
2            ной типа enum DAYS_WEEK равен двум


    3. Различие третье - выражения и операторы.

    Во  втором  издании  K&R  объявлено  о  том,  что  минимальное число
значимых литер для всех  внутренних идентификаторов доведено до  31, для
внешних - до 6. Естественно,  что не все реализации языка  следуют этому
правилу. В компиляторах  фирмы Borland Int'l  первое число равно  32, но
это не принципиально - пишущим на фортране на все случаи жизни хватало 6
литер.

    Добавлен только  один оператор:  унарный +  сомнительного назначения
для симметрии с унарным -. Что касается оператора & (адресация), то  его
разрешено применять  к массивам  (результат- указатель  на массив), зато
запрещено  применять  к  любым  регистровым переменным (интересно, какой
адрес,  скажем  регистра  СХ?).  Теперь  тип результата оператора sizeof
size_t из головного файла <stddef.h>, а не тип int, как в первоначальной
версии языка (в обоих вышеупомянутых компиляторах - size_t определен как
unsigned).

    Что  касается  преобразования  типов  в  выражениях,  то справедлива
следующая цепочка типов:

char
short->unsigned->long->unsigned long->float->double->long double
int

    Тип результата при вычислении с данными различных типов совпадает  с
типом более правого элемента этой цепочки. Операнды типов char и short в
результате всегда  дают тип  int, как  и в  предыдущей редакции языка. В
первом  издании  K&R,  во-первых,  типа  long  double  не  было  вообще;
во-вторых, если один  из операндов был  float, то результат  был double;
в-третьих тип unsigned был более "весомым", чем тип long.

    Вывод: Различия в двух изданиях K&R незначительны, однако,  неверное
преобразование   типов   данных   в   выражениях   может   привести    к
труднообнаруживаемым ошибкам.

    4. Различие четвертое - инструкции.

    Здесь  изменения   минимальны.  В   инструкции  switch   управляющее
выражение и case-метки могут иметь любой целочисленный тип (char, short,
int, unsigned, long, enum), а не только целый.

    5. Различие пятое - декларации.

    Спецификаторы классов памяти остались без изменений, а о  запрещении
оператора  &  над  регистровыми  объектами  говорилось  выше.  Выше было
сказано и о новых спецификаторах типа void, signed, enum. Введено  новое
понятие - квалификатор-типа. В стандарте языка это квалификаторы const и
volatile, а в конкретных реализациях их гораздо больше (В МSC версии 6.0
это interrupt, cdecl, pascal и др.).

    Конечно, квалификатор  const в  раздел "Константы"  в данной  статье
попал  случайно.  Его  применение  помогает  выявить несанкционированные
присваивания  переменным.  Переменные   с  квалификатором  const   можно
загружать в память, доступную  только для чтения. Квалификатор  volatile
("изменчивый")  противоположен   по  смыслу   квалификатору  const.   Он
указывает, что переменная может меняться не только программой, но и  вне
программы. Такие  переменные могут  измениться даже  в момент вычисления
выражения. Назначение volatile - подавить оптимизацию, которая без  ука-
зания  квалификатора  могла  бы  возникнуть.  Любопытно,  что   возможно
одновременное использование в одной декларации и квалификатора const,  и
квалификатора  volatile.  Объект,  объявленный  таким  образом, не может
модифицироваться   программой,   но   может   быть   изменен    внешними
воздействиями.

    Усложнены  (в  книге  написано  "уточнены")  правила  декларирования
структур  или  объединений.  Введено  понятие  "незавершенный тип". Если
спецификатор  с  тегом  без  списка  обнаружен  тогда,  когда тег еще не
декларирован,  то  считается,  что  специфицирован  незавершенный тип. В
структуру или объединение не могут входить члены с незавершенным типом -
об  этом  (правда  другими  словами)  говорилось  и в первом издании. Во
втором  издании  имена  членов  всегда  локализованы  в  своей структуре
(объединении).   Стандартом   запрещены   декларации   без деклараторов.
Разрешены  декларации  вида  struct/union  <декларатор>. Такая структура
(объединение)  переобъявляется,  даже  если  была  объявлена  во внешней
области действия. Что  касается полей битов,  то в этом  случае стандарт
делает  этот  элемент  языка  реализационно-зависимым, т.е. призывает по
этому вопросу следовать документации по конкретному компилятору.

    Про перечисления в статье уже говорилось - это совершенно новый тип,
поэтому  декларация  перечислений-  новое  понятие  в языке Си. Но самое
серьезное,на  мой  взгляд,  изменение  касается  деклараций функций и их
определений.

    Давайте сравним старый  и новый способ  деклараций функций, как  это
делается в книге K&R:

Старый способ                            Новый способ

                      Т          D
                     тип     декларатор

D1([список-идентификаторов])  │  D1 (список-типов-параметров)
                              │
Список-идентификаторов (если  │  Список-типов-параметров спе-
он имеется) это либо иденти-  │  цифицирует  типы параметров,
фикатор,либо несколько иден-  │  а  если  они отсутствуют, их
тификаторов, разделенных за-  │  заменит ключевое слово void.
пятыми.                       │
Если декларатор не использу-  │  Если список-типов-параметров
ется  в  качестве заголовка   │  заканчивается    многоточием
определения функции, список   │  ("..."),  это означает,  что
индентификаторов  должен от-  │  функция  может  иметь больше
сутствовать.                  │  аргументов,  чем  число явно
                              │  описанных параметров.

                          Например
                              │
int max ();                   │  int max (int a, int b);

    Какой способ лучше - об этом судить самим программистам, тем  более,
что  подавляющее  большинство  современных  трансляторов  понимают   оба
способа. Старый способ короче, но новый позволяет компилятору  проверять
аргументы и  приводить их  к нужному  типу. Ясно,  что при новом способе
ошибок будет меньше.

    Расширились  возможности   инициализации  объектов.   Массиву  литер
разрешено присваивать начальные значения стринговым литералом:

    char array [] = "стринговый   литерал";

    В декларированном таким образом массиве 19 литер - последняя  литера
- '\0'.

    Когда-то вообще было запрещено инициировать автоматические  массивы,
структуры и объединения. Теперь это разрешено с помощью инициализатора в
фигурных  скобках.  Для  инициализации  объединения  существует  правило
"первого члена": инициализатором его  может быть либо выражение  того же
типа,  либо  заключенный  в  фигурные  скобки  инициализатор его первого
члена.

    При декларировании указателей  существенных изменений за  десять лет
языка не произошло,  кроме появления указателей  на тип void  (ранее они
заменялись указателями на тип char).

    Вывод: Существенные изменения произошли при появлении нового способа
декларирования  функций,  благодаря  чему  легче  выявить  ошибки  из-за
несогласования типов и числа аргументов. По сравнению с этим изменением,
остальные изменения носят локальный характер.

    Пример 5. Новый способ декларирования функций способствует выявлению
ошибок.

    Новый способ:

main()
  {
   float max(float a,float b);  /* Тип фактических параметров */
   float a,b;
   a=3.;  b=4.;
   printf("\n%f",max(a,b));
  }

  float max(int x, int y)  /* не совпадает с типом формальных */
          {
           if (x > y) return x;
             else
                      return y;
          }
                                                                               L
     Как на это среагирует компилятор MSC ? На мониторе ПЭВМ
видим:

G:\>cl /AL /FPi87 /G2 /Fs example5.c
Microsoft (R) C Optimizing Compiler Version 6.00
Copyright (c) Microsoft Corp 1984-1990. All rights reserved.

example5.c
example5.c(10) : warning C4028: parameter 1 declaration different
example5.c(10) : warning C4028: parameter 2 declaration different

Microsoft (R) Segmented-Executable Linker  Version 5.10
Copyright (C) Microsoft Corp 1984-1990.  All rights reserved.

Object Modules [.OBJ]: example5.obj /farcall
Run File [example5.exe]: "example5.exe" /noi
List File [NUL.MAP]: NUL
Libraries [.LIB]:
Definitions File [NUL.DEF]: ;

G:\>

    Итак,  предупреждение  выдано  и  программист  может  сделать  соот-
ветствующий вывод.

    А вот и старый способ:

main()
  {
   float max();                 /* Тип фактических параметров */
   float a,b;
   a=3.;  b=4.;
   printf("\n%f",max(a,b));
  }

  float max(x,y)
     int   x,y;            /* не совпадает с типом формальных */
          {
           if (x > y) return x;
             else
                      return y;
          }

     И никакой реакции компилятора:
                                                                               L
G:\>cl /AL /FPi87 /G2 /Fs example5.c
Microsoft (R) C Optimizing Compiler Version 6.00
Copyright (c) Microsoft Corp 1984-1990. All rights reserved.

example5.c

Microsoft (R) Segmented-Executable Linker  Version 5.10
Copyright (C) Microsoft Corp 1984-1990.  All rights reserved.

Object Modules [.OBJ]: example5.obj /farcall
Run File [example5.exe]: "example5.exe" /noi
List File [NUL.MAP]: NUL
Libraries [.LIB]:
Definitions File [NUL.DEF]: ;

     Но может быть ошибка и не произойдет ? Проверим:

G:\>example5

0.000000
G:\>

    Теперь выбор способа за Вами.

    6. Различие шестое - агрегатные элементы языка

    Различия  в   декларировании  структур   и  объединений   описаны  в
предыдущем  разделе.  Важным  шагом  вперед  стало разрешение применения
оператора   присваивания   над   структурами.   Теперь   структуры можно
передавать  в  качестве  аргументов  функциям  и  наоборот  - в качестве
результата функций может служить структура.

    Вывод: Оператор присваивания над структурами - шаг вперед в развитии
языка. Следующим шагом, возможно, будет применение других операторов над
ними.

    Пример 6. Структуры можно присваивать и использовать в
              качестве аргументов и результата функции.


    struct complex {
                    double x,y;
                   } ;

main()
   {
    struct complex z1,z2,z3,addcpl(struct complex z2,struct complex z3);

    z1.x=3.;
    z1.y=4.;

    z3=z2=z1;          /* Так можно присваивать структуры */

    printf("\nx=%f;y=%f",z1.x,z1.y);
    printf("\nx=%f;y=%f",z2.x,z2.y);
    printf("\nx=%f;y=%f",z3.x,z3.y);

    z1=addcpl(z2,z3);

    printf("\nx=%f;y=%f",z1.x,z1.y);
   }


    struct complex addcpl(struct complex a,struct complex b)
    /* Функция сложения для двух структур */
             {
              a.x+=b.x;
              a.y+=b.y;
              return a;
             }

     Вот результат работы программы:                                           L

G:\>example6

x=3.000000;y=4.000000
x=3.000000;y=4.000000
x=3.000000;y=4.000000
x=6.000000;y=8.000000
G:\>

    7. Различие седьмое - структура программы.

    По-прежнему  исходная  программа   состоит  из  директив,   указаний
компилятору, деклараций и определений.

    Что касается деклараций - об изменениях в декларировании функций уже
было  сказано.  Но  в  стандарте  ANSI  С  заголовок определения функции
полностью соответствует  ее декларации.  Это сделано  с целью сокращения
количества ошибок в программах, связанных с несоответствием типа и числа
аргументов при вызове функций.

    Расширен список директив препроцессора - об этом в следующем  пункте
статьи.

    Вывод . Структура  программы на языке  Си существенных изменений  не
претерпела. Изменились сами составные  части ее: декларации и  директивы
препроцессора.

    8. Различие восьмое - препроцессор языка Си.

    В   ANSI-стандарт   введены   так   называемые   трехзнаковые после-
довательности, которые  заменяются препроцессором  на одиночный  символ.
Это делается для работы с инвариантным кодом литер ISO 646-1983. Хотя  в
IBM   PC-совместимых   компьютерах   используется   ASCII   код,  но эти
последовательности и здесь могут иметь место.

    Итак,          ??=  соответствует  #,
                   ??/     --"--       \,
                   ??'     --"--       ^,
                   ??(     --"--       [,
                   ??)     --"--       ],
                   ??!     --"--       |,
                   ??<     --"--       {,
                   ??>     --"--       },
                   ??-     --"--       ~.

    Остальные изменения в директивах препроцессора для языка Си касаются
и  программирующих  на  IBM  PC.  Новая  директива  #elif (сокращение от
else-if) появилась среди директив условной компиляции. Вот как  выглядит
теперь участок программы с директивами условной компиляции:

     #if OKB
        [текст]
     [#elif OKB1
        [текст 1]]
     [#elif OKB2
        [текст 2]]
     [#elif OKBN
        [текст N]]
     [#else
        [текст Е]]
     #endif

    Здесь используется термин  ОКВ - ограниченное  константное выражение
(в  K&R  -  константное  выражение).  Термин "ограниченное" возник из-за
того,  что  не  все  операторы  могут использоваться внутри константного
выражения - оператор приведения и sizeof использоваться здесь не  могут.
Другие  ограничения  -  константное  выражение  для  директив   условной
компиляции должно быть всегда целочисленным и не содержать  перечислимых
констант.

    Вместо #if, как  и раньше, могут  использоваться директивы #ifdef  и
#ifndef. Но во втором издании книги уже указано, что имеется специальный
оператор препроцессора  defined. Поскольку  директива #ifdef  в точности
соответствует   конструкции    #if  defined ,  а   директива   #ifndef -
#if ! defined, то смысл ввода этого оператора препроцессора неясен.

    Директива  #define  имелась  и  в  языке, описанном в первом издании
книги K&R. Ее  использование в стандарте  ANSI существенно расширено  за
счет   введения   операторов   #   и   ##.   Оператор   # используется в
макроопределениях с параметрами и ставится перед параметром. Появление в
конструкции оператора # означает, что подставленный вместо параметра  (и
знака  #  перед  ним)  текст  заключается  в двойные кавычки. При этом в
литерных контактах  и стринговых  литералах вместо  литеры "  включается
эскейп-последовательность   \",   а   вместо      литеры   \   - эскейп-
последовательность \\.

    Если нужно напечатать результат выражения вместе с самим выражением,
то можно поступить аналогично примеру из второго издания книги:

    #define dprint(expr)  printf(#expr "=%g\n", expr)

    Если  обратиться  к  такому  макроопределению  с  параметром x/y, то
препроцессор    заменит   конструкцию   dprint(x/y)    на    конструкцию
printf("х/у" "=%g\n",x/y); , причем  "склеит" стринговые литералы внутри
круглых скобок. Компилятор получит следующюю инструкцию:

                 printf("х/у=%g\n",x/y);

    Оператор ## приведет к "склеиванию" лексем слева и справа от него  в
единую лексему, например при вызове директивы

               #define concat(x,y) x##y

    c  параметрами  ааа  и  bbb  препроцессор  даст  aaabbb. Отмечу, что
суперпозиция  нескольких  concat  не  приведет  к  желаемому результату,
например

    concat(concat(aaa,bbb),ccc)         будет заменен на

    concat(aaa,bbb)ccc,     где )ссс - некорректная лексема.

    Здесь не является лишним напоминание  о том, что препроцессор -  это
сильное орудие в умелых руках, но в руках идиота...

    В первом издании ничего не говорилось ни о пустой директиве

    #               ,

которая не вызывает никаких действий, ни о директиве

    #error [<последовательность лексем>]      ,

    которая  приказывает  препроцессору  выдать  диагностическое   сооб-
щение, включающее заданную последовательность лексем.

    Директива (а точнее, указание компилятору)

    #pragma [<последовательность лексем>]

    заставляет   препроцессор   выполнить   ряд  реализационно-зависимых
действий. Так, в компиляторе MSC версии 6.0 имеется семнадцать прагм:

  alloc_text        intrinsic     pack         subtitle
  check_pointer     linesize      page         title
  check_stack       loop_opt      pagesize
  comment           message       same_seg
  function          optimize      skip

    Еще одно различие  двух изданий книги  - появление в  ANSI C заранее
определенных идентификаторов, которые нельзя повторно переопределять. Их
пять (обратите внимание  на два знака  подчеркивания спереди и  сзади, а
также на верхний регистр букв): __LINE__, __FILE__, __DATE__,  __TIME__,
__STDC__.  Это,  соответственно,  десятичная  константа  -  номер строки
исходного текста, стринг - имя компилируемого файла, стринг - дата  ком-
пиляции  ("Ммм  дд  гггг"),  стринг  -  время  компиляции  ("чч:мм:сс"),
константа  1.  Считается,  что  __STDC__  определен  как  1 только в тех
реализациях языка, которые  соответствуют стандарту. Так,  в компиляторе
MSC версии 6.0  константа __STDC__ равна  1 при компиляции  с ключом /Za
-иначе  она  не  определена.  В  предыдущих  версиях  этого  компилятора
__STDC__ принималась равной нулю, т.е.  полной совместимости с ANSI C  у
этих версий не было.

    Вывод:  Изменений,  касающихся  препроцессора,  в  ANSI  - стандарте
достаточно. Введены новые директивы #, #elif, #error операторы  defined,
# и ##, указания компилятору #pragma и заранее определенные имена.

    Пример 8. Директива #error - дополнительное диагностическое средство

   #if !defined(EOF)
   #error Идентификатор EOF не определен
   #endif
                                                                               L
     Экран компьютера будет иметь следующий вид:

G:\>cl /AL /c example8.c
Microsoft (R) C Optimizing Compiler Version 6.00
Copyright (c) Microsoft Corp 1984-1990. All rights reserved.

example8.c
example8.c(2) : error C2189: #error :  Идентификатор EOF не определен

G:\>

    9. Различие девятое - стандартная библиотека.

    Хотя библиотека не  является частью языка,  однако заложенный в  ней
набор деклараций функций, определений типов и макросов составляет среду,
поддерживающую стандарт языка Си. Уже то, что в ANSI C вводится  понятие
"стандартная библиотека" с перечнем  головных файлов, говорит о  многом:
язык не  может развиваться  без окружения  - значит,  и окружение должно
быть стандартизировано в той или иной степени.

    Во  втором  издании  K&R  приведено  разбиение  функций  стандартной
библиотеки на  категории. Каждой  из этих  категорий соответствует  свой
головной файл.

    Примерно   треть   библиотеки   составляют   функции   ввода-вывода,
определенные в файле <stdio.h>. Здесь декларированы функции, оперирующие
над файлами, функции форматного ввода и вывода, функции прямого ввода  и
вывода, функции  позиционирования файла  и функции  обработки ошибок при
вводе и выводе. Другие категории функций: функции проверки класса литеры
<ctype.h>, функции манипуляций над стрингами <string.h.>, математические
функции <math.h>, функции общего назначения <stdlib.h>,  диагностические
функции   <assert.h>,   функции   манипуляций   над   списком аргументов
<stdarg.h>,  функции  для  далеких  переходов  <setjmp.h>,  средства для
обработки  исключительных  ситуаций  <signal.h>,  функции даты и времени
<time.h>. В описании стандартной библиотеки упомянуты и некоторые другие
головные файлы:

    <limits.h> и <float.h> - реализационно зависимые пределы;
    <stddef.h>     -  декларации часто используемых констант,
                      переменных и типов;
    <errno.h>      -  ошибки, связанные с системными вызовами;
    <locale.h>     -  декларации функций и макросов локализа-
                      ции.

    Естественно,  что  конкретные  реализации  могут  иметь много других
головных  файлов  с  декларациями  самых  разных функций. Но ядро всегда
составляет  именно  стандартная  библиотека,  краткое  описание  которой
приведено в K&R.

    Вывод:  Введение  понятия  "Стандартная  библиотека"  - еще один шаг
вперед  к  стандартизации  языка  и  его окружения. Библиотека дополняет
возможности языка, делает его еще более гибким и мощным. Принцип  "язык"
+  "стандартная  библиотека"  +  "дополнительные библиотеки" делает язык
пригодным для решения задач любой сложности и любых областей знаний.


    Заключение.

    Язык  Си  за  десять  лет  своего  развития претерпел ряд изменений,
сделавших его  более совершенным  языком программирования.  За это время
разработаны десятки различных трансляторов с языка Си (среди них есть  и
интерпретаторы) для ЭВМ  различного класса -  от бытовых компьютеров  до
супер-ЭВМ.  На  языке  Си  написаны  самые  разные  программы - от задач
бухгалтерского учета (что не делает чести их создателям) до операционных
систем,  используемых  во  всем  мире  (UNIX  и MSDOS). На базе языка Си
создан   язык   Си++   -   язык   для   объектно-ориентированного  прог-
раммирования.

------------------------------------------------------------------------

    Автор cтатьи - Левитин Игорь Абрамович - пишет программы на языке Си
с  1988  г.  Работает  начальником  бюро  программирования   Украинского
государственного производственного предприятия "ИЗОТОП". Язык Си  сейчас
применяет для реализации "узких мест" задач АСУ предприятием в локальных
сетях и задач защиты информации от "пользователя".

    Контактный телефон (044) 268-94-90.
