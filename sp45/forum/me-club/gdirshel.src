{******************************************************************************
														MULTI-EDIT MACRO FILE

Name:   DIRSHELL

Description:  The Multi-Edit DOS Shell.

DIRSHELL - The main DOS Shell interface
DIRMOVE - Enables mouse movement in the DOS Shell
MARKLOAD - Loads marked files in the DOS Shell
ARCDIR - Creates a list of files contained in an arced or zipped file

		 (C) Copyright 1989 by American Cybernetics, Inc.

Дополнение к ARCDIR  и изменение раскладки (в стиле Norton Commander) -
				Stern i K°  14-04-92 15:36
*******************************************************************************}

$MACRO DIRSHELL FROM EDIT TRANS;
{******************************************************************************
																MULTI-EDIT MACRO

Name: DIRSHELL

Description:	This implements the user interface to the Multi-Edit dos shell.

Parameters:		/S=nn		Select type, where:
						0 = Normal DOS Shell
						1 = Invoked from the Load File prompt.
									Should not load any files, just return
									a file name in Return_Str.
						2 = Single directory, limited use.

			All parameters below have defaults.
			/X= Upper left corner X coordinate of directory list.
			/Y= Upper left corner Y coordinate of directory list.
			/W= Width of directory list.
			/L= Length of directory list.
			/D= Directory mask.  Defaults to *.*.

Returns:
							Return_Int  If 1, load file was selected.
							Return_Str  The last highlited directory entry

							 (C) Copyright 1989 by American Cybernetics, Inc.
******************************************************************************}

  def_str( tstr[150], ev_string[20], drive_str[32], mask[12] );
	def_int( jx, Select_Type, j1,j2, wx, wy, cur_dir, old_refresh );
	def_int( x, y, l, w, ev_count, dd_row );
	def_int( old_x, old_y, dir_result );
	def_int( t_d_t_color, t_d_b_color, t_d_h_color, t_d_s_color, t_fkey_row );
	def_int( min_dir_row, max_dir_row, t_mode );

	def_char( cur_drive );

	ev_string := '@DSLEV';
	t_mode := mode;
	mode := dos_shell;
	dir_result := 0;
	old_refresh := refresh;
	refresh := true;
	cur_dir := 1;
	wx := wherex;  wy := wherey;  {get the cursor position}
	Return_Str := '';
	Select_Type := Parse_Int('/S=', MParm_Str);

	t_fkey_row := fkey_row;
  RM('DIRSHELL^InitDirShell /S=' + str(select_type));
	tstr := global_str('@DIR_PARMS@');
	max_dir_row := parse_int('/MAXR=',tstr);
	min_dir_row := parse_int('/MINR=',tstr);
	drive_str := parse_str('/DS=', tstr );
	Push_Labels;
		{this is for a single directory list}
	if select_type = 2 then
		t_d_s_color := d_s_color;
		t_d_h_color := d_h_color;
		t_d_t_color := d_t_color;
		t_d_b_color := d_b_color;

		d_b_color := m_b_color;
		d_s_color := m_s_color;
		d_h_color := m_h_color;
		d_t_color := m_t_color;

		cur_dir := 5;
		set_global_int('@DIR_CUR_DIR@', cur_dir);
		x := parse_int('/X=', mparm_str);
		y := parse_int('/Y=', mparm_str);
		w := parse_int('/W=', mparm_str);
		l := parse_int('/L=', mparm_str);

		if y < min_dir_row then
			y := min_dir_row;
		end;
		IF y > (max_dir_row - 10) THEN
			y := max_dir_row - 10;
		END;

		if x < 1 then
			x := 1;
		end;
		if x > (screen_width - 28) THEN
			x := screen_width - 28;
		END;
		if (y + l) > (max_dir_row) then
			l := (max_dir_row - y) + 1;
		end;
		if (x + w + 2) >= (screen_width) then
			w := (screen_width - x) - 1;
		end;

    Tstr := 'Help  ChDir DeleteCopy  RenameDir OfCMD   Print SelectSort              MrkDelMrkCpyMrkRepView  AttribMrkPrt      Tree  ';

		Jx := 1;
    WHILE (Jx <= 20) DO
			FLABEL(Copy(Tstr,((Jx - 1) * 6) + 1,6),Jx,-1);
			++ Jx;
		END;

		open_dir(5);
		switch_dir(5);
		size_dir(x,y,x + w - 1, y + l - 1, 1);
		Dir_Sort_Str := Global_Str('DIR_SORT_STR');

		tstr := parse_str('/D=', mparm_str );
		call process_dir_string;
		call Update_Cur_Dir;
	else
		x := 1;
		y := min_dir_row;
		cur_dir := global_int('@DIR_CUR_DIR@');
		if cur_dir = 0 then
			cur_dir := 1;
		end;
		if cur_dir > 4 then
			cur_dir := 1;
		end;
		set_global_int('@DIR_CUR_DIR@', cur_dir);
		if dir_active(cur_dir) then
			switch_dir(cur_dir);
		else
			Open_Dir( cur_dir );
			Dir_Mode := Global_Int('@DIR_MODE@');
		end;

	{Assign labels for dos shell}
	Tstr := 'Help  Dir Of VieW  Load  Copy RenameMkDir DeletePrint Sort  NxtDirSizWin DOS        MrkCpyRepMrkAttribMrkDelMrkPRNTree  ';

		Jx := 1;
    WHILE (Jx < 21) DO
			FLABEL(Copy(Tstr,((Jx - 1) * 6) + 1,6),Jx,-1);
			++ Jx;
		END;

		FLABEL('Create',31,-1);
		FLABEL('Kill  ',32,-1);
		FLABEL('Archiv',33,-1);
		FLABEL('ChgDir',34,-1);
		{FLABEL('MkDir ',37,-1);}
		FLABEL('DelDir',38,-1);

		IF (Select_Type <> 1) THEN
			FLABEL('MrkLd',14,-1);
		END;
		FLABEL('Record',40,-1);

		If Select_Type = 1 THEN
			Make_Message( 'Select file and press <ENTER>, or <ESC> to exit without selecting.' );
		END;

	{Instructions for right of directory list}

		Dir_Sort_Str := Global_Str('DIR_SORT_STR');
		Call Update_All_Dirs;
	end;
	Dir_Sort_Str := Global_Str('DIR_SORT_STR');
	Update_Status_Line;
main_loop:
	cur_dir := global_int('@DIR_CUR_DIR@');
	If error_level <> 0 THEN
		RM('MEERROR');
		error_level := 0;
	end;
	refresh := TRUE;
	read_key;
	if (key1 = 0) then
		if (select_type <> 2) then
			if (key2 = 84) then  {Switch dir window}
				RM('DIRSHELL^DirWindow /M=0');
				goto main_loop;

			elsif (key2 = 104) then  {Create dir window}
				RM('DIRSHELL^DirWindow /M=1');
				goto main_loop;


			elsif (key2 = 105) then   {Delete dir window}
				RM('DIRSHELL^DirWindow /M=2');
				goto main_loop;
			end;
		end;

		if (key2 = 59) then   { Help }
			help('DIRSHELL^*');
			goto main_loop;

		elsif (key2 = 238) or (key2 = 85) then  {Resize dir window }
			RM('DIRSHELL^DirWindow /M=3');
			goto main_loop;

		elsif (key2 = 107) then  {change directory}
			RM('DIRSHELL^DirOperation /M=1');
			goto main_loop;

		elsif (key2 = 66) or (key2 = 83) then {delete file or directory }
			If (Dos_File_Attr and $10) <> 0 THEN
				goto RD;
			RM('DIRSHELL^DirOperation /M=3');
			end;
			goto main_loop;

		elsif (key2 = 63) then {copy file}
			RM('DIRSHELL^DirOperation /M=2');
			goto main_loop;

		elsif (key2 = 64) then {Rename file}
			RM('DIRSHELL^DirOperation /M=4');
			goto main_loop;

		elsif (key2 = 60) then  {change directory mask}
			RM('DIRSHELL^DirOperation /M=0');
			goto main_loop;

		elsif (key2 = 86) then  {dos command}
			call strip_boxes;
			RM( 'MEUTIL1^SHELLDOS' );
			call update_all_Dirs;
			goto Main_Loop;

		elsif (key2 = 67) then  {print command}
			Call CHECK_PRINT_SPOOLER;
			IF (Return_Int) THEN
				Goto MAIN_LOOP;
			END;
			return_str := 'PRINT ' + Dir_Entry;
			RM('DIRSHELL^RunDosCmd');
			Goto Main_Loop;
		end;

		if (key2 = 62) then  {load file or look at directory}
Load_Dir_Entry:
			If (Dos_File_Attr and $10) <> 0 THEN
				tstr := FExpand(Dir_Entry);
				if Copy(tstr,length(tstr), 1) <> '\' then
					tstr := tstr + '\';
				end;
				Return_Str := get_path( dir_mask );
				Dir( tstr + truncate_path( dir_mask ) );
				CALL find_old_entry;
				call update_cur_dir;
				Goto Main_Loop;
			end;

			tstr := Caps(Get_Extension(Dir_Entry));
			If (Tstr = 'EXE') or (TStr = 'COM') or (TStr = 'BAT') THEN
				IF (Tstr = 'BAT') THEN
					Create_Global_Str('DIRBAT_1','/H=DIRSHELL^*');
					Create_Global_Str('XDIRBAT_1','Load batch file');
					Create_Global_Str('DIRBAT_2','/H=DIRSHELL^*');
					Create_Global_Str('XDIRBAT_2','Run batch file');

					RM('USERIN^TOPMENU /M=XDIRBAT_/G=DIRBAT_/#=2/S=1/BC=1/GCLR=1/L=' + Truncate_Path(Dir_Entry));
					IF (Return_Int = 1) THEN
						Goto BAT_LOAD;
					ELSIF (Return_Int < 1) THEN
						Goto MAIN_LOOP;
					END;
				END;
				return_str := Dir_Entry;
				RM('DIRSHELL^RunDosCmd');
				goto main_loop;
			END;
if (tstr = 'ZIP') or (tstr = 'ICE') or (tstr = 'LZH') or (tstr = 'ARC') or (tstr = 'PAK') or (tstr = 'ARJ') then
				RM('DIRSHELL^ArcDir ' + dir_entry);
				call redraw_cur_dir;
				goto main_loop;
			end;

BAT_LOAD:
			If Select_Type = 0 THEN
				tstr := Dir_Entry;
				Call Dos_Exit;
				Refresh := True;
				Set_Global_Int('LOAD_COUNT', 1);
				return_str := tstr;
				RM( 'LDFILES /LC=1' );
				Redraw;
				goto exitx;
			END;

			If (Select_TYpe = 1) or (select_type = 2) THEN
				dir_result := TRUE;
				Goto Exit;
			END;
		end;

		if (key2 = 68) then {sort}
			RM('DIRSHELL^DIRSORT');
			If return_int > 0 THEN
				call update_cur_dir;
			ELSE
				call redraw_cur_dir;
			END;
		end;

		if (key2 = 91) then {delete marked files}
			RM('userin^VERIFY /L=2/C=2/H=DIRSHELL^DODELMARKED/T=Are you sure you want to delete these files?');
			If Return_Int THEN
				RM('DIRSHELL^DelMarkedFiles');
				if select_type <> 2 then
					Make_Message('Marked files deleted.');
				end;
				dd_row := RETURN_INT;
			end;
		end;

		if (key2 = 88) then {copy marked files}
			return_str := '';
			RM('USERIN^QUERYBOX /L=' + str( y ) + '/C=' + str(x) +
					'/W=60/H=DIRSHELL^DOCOPYMARKED/T=Please enter destination');
			If Return_Int THEN
				RM('DIRSHELL^CopyMarkedFiles');
				if select_type <> 2 then
					Make_Message('Marked files copied.');
				end;
				dd_row := RETURN_INT;
			end;
			goto main_loop;
		end;
		if (key2 = 89) then {repeat command on marked files}
			return_str := '';
			RM('USERIN^QUERYBOX /L=' + str( y ) + '/C=' + str(x) +
					'/W=60/H=DIRSHELL^MARKEDREPEAT/T=Please enter command line');
			If Return_Int THEN
				RM('DirMarkRepeat');
			end;
			dd_row := RETURN_INT;
			goto main_loop;
		end;
		If (key2 = 61) THEN {view file}
			return_str := dir_entry;
			RM('DirFileView');
			goto main_loop;
		END;
		If (key2 = 90) THEN {view file attributes}
			return_str := dir_entry;
			RM('Fileattr');
			IF (Return_Int) THEN
				call update_cur_dir;
			ELSE
				call redraw_cur_dir;
			END;
			goto main_loop;
		END;

		if (key2 = 92) then {print marked files}
			Call CHECK_PRINT_SPOOLER;
			IF (Return_Int) THEN
				Goto MAIN_LOOP;
			END;
			RM('userin^VERIFY /L=2/C=2/H=DIRSHELL^DOPRINTMARKED/T=Are you sure you want to print these files?');
			If Return_Int THEN
				RM('DIRSHELL^PrintMarkedFiles');
				if select_type <> 2 then
					Make_Message('Marked files printed.');
				end;
			end;
			goto main_loop;
		end;

		if (key2 = 87) then {load marked files}
			If Select_Type = 0 THEN
				call strip_boxes;
				RM('DIRSHELL^MARKLOAD');
				Goto Exitx;
			ELSE
				if select_type <> 2 then
					Make_Message('NOT Available from the Load_File prompt.');
				end;
				Goto Main_Loop;
			END;
		end;
		IF (key2 = 93) THEN
			RM('DIRSHELL^TREE /CP=' + get_path(dir_mask) + '/CD=' + get_path(dir_mask));
			IF return_int THEN
			return_str := return_str + truncate_path(dir_mask);
			RM('DIRSHELL^ProcessDir');
			END;
			RM('DIRSHELL^UpdateDir /M=0');
			goto main_loop;
		END;

		if (key2 = 82) then
			Mark_File;
			Dos_Down;
			goto main_loop;
		end;

		IF (key2 = 65) THEN
  			Return_Str := '';
  			RM('Userin^Querybox /C=2/L=3/W=8/ML=8/T=Create Dir');
  			if Return_int <> 0 then
    			jx := MKDIR(Get_Path(Dir_Mask)+Return_Str);
    			if jx  <> 0 then
      				RM('MEERROR^MESSAGEBOX /T=Error/M=Dos error '+Str(jx)+' /B=1');
    			end;
    		Update_Dir;
    		Dir(Dir_Mask);
    		Dos_Home;
			goto main_loop;
  			end;
		END;

		IF (key2 = 111) THEN
RD:    			Shell_to_Dos('RD '+Dir_Entry ,True);
    			Update_Dir;
    			Dir(Dir_Mask);
    			Dos_Home;
			goto main_loop;
		END;

		if (select_type <> 2) and (key2 = 113) then { start/stop recording of keystroke macro }
			key_record;
			goto Main_Loop;
		end;
		if (Key2 = 245) then
			goto do_escape;
		end;
		if (Key2 = 244) then
			goto do_enter;
		end;
		if (Key2 = 246) then
			goto do_mark;
		end;
		IF (key2 = 251) THEN
			CALL MOUSE_EVENT2;
			GOTO MAIN_LOOP;
		END;
		IF (key2 = 250) THEN  {mouse event}
			CALL MOUSE_EVENT1;
			IF (Return_Int) THEN
				Goto Load_Dir_Entry;
			END;
			GOTO main_loop;
		END;
	  RM('DIR_SHELL_EVENT /FM=1/DDR=' + str(dd_row));

	else
		if (key1 = 32) then
do_mark:
			Mark_File;
			goto main_loop;
		elsif (key1 = 27) then
do_escape:
			Return_Str := '';
			Goto Exit2;
		elsif ((key1 = 43) and (Key2 = 78)) then
			RM('DIRSHELL^MRKFLS');
			goto main_loop;
		elsif ((key1 = 45) and (Key2 = 74)) then
			RM('DIRSHELL^MRKFLS U');
			goto main_loop;
		elsif ((key1 = 47) and (Key2 = 224)) then
			RM('DIRSHELL^MRKFLS I');
			goto main_loop;
		elsif (key1 = 13) then
do_enter:
			Goto Load_Dir_Entry;
		elsif (key1 = 9) then
			dir_mode := not(dir_mode);
	{ We will probably want to get rid of this line when we get an
		install screenfor the DOS shell}
			Set_Global_Int('@DIR_MODE@',Dir_Mode);
			call redraw_cur_dir;
			goto main_loop;
		else
	  	RM('DIR_SHELL_EVENT /FM=1/DDR=' + str(dd_row));
		end;
	end;

	jx := Inq_Key(Key1,Key2,DOS_SHELL, tstr);
	IF (jx = 1) OR (jx = 2) THEN
		Pass_Key( key1, key2 );
{		RM(TStr); }
	END;
	goto main_loop;

Find_Old_Entry:
	refresh := false;
	dos_home;
	IF copy( return_str, length(return_str), 1) = '\' THEN
		return_str := copy( return_str, 1, length( return_str ) - 1 );
	END;
	WHILE dir_num < dir_total DO
		IF dir_entry = return_str THEN
			REFRESH := TRUE;
			RET;
		END;
		DOS_RIGHT;
	END;
	dos_home;
	REFRESH := TRUE;
	RET;

{********************************* SUBROUTINES *******************************}

		def_int( jy );

redraw_all_dirs:
		RM('DIRSHELL^UpdateDir /M=4' );
		dd_row := return_int;
		RET;

XRedraw_Cur_Dir:
	RM('DIRSHELL^UpdateDir /M=1');
	dd_row := return_int;
	ret;

Redraw_Cur_Dir:
	RM('DIRSHELL^UpdateDir /M=0');
	dd_row := return_int;
	ret;

Update_Cur_Dir:
	Dir( dir_mask );
	call redraw_cur_dir;
	ret;

XUpdate_Cur_Dir:
	Dir( dir_mask );
	call xredraw_cur_dir;
	ret;

lo_cur_dir:
	RM('DIRSHELL^UpdateDir /M=2');
	dd_row := return_int;
	ret;
	RET;

process_dir_string:
		return_str := tstr;
		RM('DIRSHELL^ProcessDir');
		tstr := get_path( dir_mask );
		mask := truncate_path( dir_mask );
		ret;

MOUSE_EVENT1:
		old_x := Mou_Last_X;
		old_y := Mou_Last_Y;
		ev_count := parse_int('/EVC=', global_str('@DIR_PARMS@'));
		RM('UserIn^CheckEvents /M=1/G=' + ev_string + '/#=' + str( ev_count ));
		IF return_int <> 0 THEN
			return_int := parse_int('/R=', return_str );
			IF return_int = 0 THEN
				push_key( 27, 1 );
			ELSIF return_int = 1 THEN
				push_key( 13, 28 );
			END;
		ELSIF (Mou_Last_Y = Fkey_Row) THEN
			RM( 'MOUSE^MouseFkey' );
		ELSIF (Mou_Last_X >= dir_x1) AND (Mou_Last_X <= dir_x2) AND
				(Mou_Last_Y >= dir_y1) AND (Mou_Last_Y <= dir_y2) THEN
			RM('DIR_SHELL_EVENT /FM=1/DDR=' + str(dd_row));
			IF (Return_Int) THEN
				Ret;
			END;
		ELSIF select_type <> 2 THEN
			{Check to see if the mouse was clicked inside another dos window}
			def_int( tcd );

			jx := 0;
			while jx < 4 do
				++jx;
				if dir_active(jx) and (jx <> cur_dir) then
					switch_dir( jx );
					IF (Mou_Last_X >= dir_x1) AND (Mou_Last_X <= dir_x2) AND
							(Mou_Last_Y >= dir_y1) AND (Mou_Last_Y <= dir_y2) THEN
						tcd := jx;
						switch_dir( cur_dir );
						call lo_cur_dir;
						switch_dir( tcd );
						cur_dir := tcd;
						set_global_int('@DIR_CUR_DIR@', cur_dir);
						call redraw_cur_dir;
						jx := 5;
					END;
				END;
			end;
			switch_dir( cur_dir );
		END;
		Return_Int := 0;
		RET;

MOUSE_EVENT2:
		IF (Mou_Last_X > dir_x1) AND (Mou_Last_X < dir_x2) AND
			(Mou_Last_Y > (dir_y1 + 1)) AND (mou_last_y < dir_y2) THEN
			IF Dir_Locate_Mouse THEN
				Mark_File;
			END;
		END;
		RET;


{*****************************************************************************}
CHECK_PRINT_SPOOLER:
{This routine checks to see if the print spooler has been loaded in DOS
versions > 3.0}
	Return_Int := 0;
	IF (((Dos_Version and $FF) > 2) and ((Dos_Version shr 8) > 0)) THEN
		R_AX := $0100;
		Intr($2F);
		IF ((R_Flags and 1) = 0) THEN
			IF ((R_AX and $FF) <> $FF) THEN
				RM('MEERROR^MESSAGEBOX /B=2/T=ERROR/M=DOS Print Spooler has not been loaded.  Please exit Multi-Edit and load the print spooler before printing a file.');
				Return_Int := 1;
			END;
		END;
	END;
	RET;

update_all_dirs:
	RM('DIRSHELL^UpdateDir /M=3');
	dd_row := RETURN_INT;
	RET;

strip_boxes:
	jx := parse_int('/BC=', global_str('@DIR_PARMS@'));
	while box_count > jx do
		kill_box;
	end;
	ret;

Dos_Exit:
		call strip_boxes;
{
	close_dir( 1 );
	close_dir( 2 );
	close_dir( 3 );
	close_dir( 4 );
}

	if dir_active(5) then
		close_dir(5);
	end;
	if select_type <> 2 then
		set_global_int('LAST_DIR', cur_dir);
	ELSE
		d_s_color := t_d_s_color;
		d_h_color := t_d_h_color;
		d_t_color := t_d_t_color;
		d_b_color := t_d_b_color;
	end;
	pop_labels;
	fkey_row := t_fkey_row;
	kill_box;
	GotoXy(wx,wy);
	mode := t_mode;
	refresh := old_refresh;
	Ret;

exit:
exit2:
	ev_count := parse_int('/EVC=', global_str('@DIR_PARMS@'));
	RM('UserIn^CheckEvents /M=3/G=' + ev_string + '/#=' + str( ev_count ));
	Return_Str := Dir_Entry;
	Call Dos_Exit;
	return_int := DIR_RESULT;

exitx:

END_MACRO;

$MACRO Dir_Shell_Event;
	def_int( result := 0,
					j1, jx, jy, old_x, old_y,
					dm := parse_int('/DM=', mparm_str),
					full_mode := parse_int('/FM=', mparm_str)
				 );

	def_int( dd_row := parse_int('/DDR=', mparm_str) );
	def_str( drive_str[32], tstr[128] );

	drive_str := parse_str('/DS=', global_str('@DIR_PARMS@') );

	IF (key1 = 0) THEN
		IF (key2 = 250) THEN
			old_x := mou_last_x;
			old_y := mou_last_y;
			IF (Mou_Last_X < dir_x2) AND (Mou_Last_X > dir_x1) AND
				(Mou_Last_Y > (dd_row)) THEN
				jx := dir_num;

				IF Dir_Locate_Mouse THEN
					RM('DIRSHELL^DirMove /V=1/H=' + str(dir_mode));
					IF jx = dir_num THEN
						result := 1;
					END;
				END;
			{ Check for drive change }
			ELSIF (Mou_Last_Y > dir_y1) AND (Mou_Last_Y <= dd_row) THEN
				jx := (Mou_Last_Y - dir_y1 - 1) * (( dir_x2 - dir_x1) / 3);
				JX :=  (((Mou_Last_X - dir_x1) - 1) / 3) + 1 + jx;
				IF jx <= svl( drive_str ) THEN
					Return_Str := fexpand( (str_char( drive_str, jx ) + ':' + truncate_path( dir_mask )) );
					Dir( Return_Str );
					call redraw_cur_dir;
				END;
			ELSIF (Mou_Last_X = dir_x1) and (Mou_Last_Y = dir_y1) THEN
				jx := 1;
				call mouse_set_size;
			ELSIF (Mou_Last_X = dir_x2) and (Mou_Last_Y = dir_y1) THEN
				jx := 2;
				call mouse_set_size;
			ELSIF (Mou_Last_X = dir_x2) and (Mou_Last_Y = dir_y2) THEN
				jx := 4;
				call mouse_set_size;
			ELSIF (Mou_Last_X = dir_x1) and (Mou_Last_Y = dir_y2) THEN
				jx := 3;
				call mouse_set_size;
			ELSIF (Mou_Last_X = dir_x2) THEN
				IF (Mou_Last_Y = (dir_y2 - 1)) THEN
					refresh := TRUE;
					ll4:
						Dos_Down;
						CALL Mouse_Repeat_Loop;
						IF return_int = 1 THEN
							Goto ll4;
						END;
				ELSIF (Mou_Last_Y = (dd_row + 2)) THEN
					refresh := TRUE;
					ll1:
					Dos_Up;
					CALL Mouse_Repeat_Loop;
					IF return_int = 1 THEN
						Goto ll1;
					END;
				ELSIF (Mou_Last_Y > (dd_row + 1)) AND (Mou_Last_Y < (dir_y2 - 1)) THEN
					jx := Mou_Last_Y - dd_row - 2;
					IF dir_scroll_pos > jx THEN
					ll2:
						Call Page_Up;
						CALL Mouse_Repeat_Loop;
						IF return_int = 1 THEN
							Goto ll2;
						END;
					ELSIF dir_scroll_pos < jx THEN
					ll3:
						Call Page_Dn;
						CALL Mouse_Repeat_Loop;
						IF return_int = 1 THEN
							Goto ll3;
						END;
					ELSIF dir_scroll_pos = jx THEN
						Mou_Set_Limits(dir_x2,dd_row + 3,dir_x2, dir_y2 - 2);
						du3:
							Mou_Check_Status;
							IF ((Mou_Last_Status AND 1) <> 0) THEN
								IF old_y <> mou_last_y THEN
									old_y := mou_last_y;
									jy := Mou_Last_Y - dd_row - 2;
									IF dir_scroll_pos > jy THEN
										while dir_scroll_pos > jy do
											call page_up;
										END;
									ELSIF dir_scroll_pos < jy THEN
										while dir_scroll_pos < jy do
											call page_dn;
										END;
									END;
								END;
								goto du3;
							END;
						Mou_Set_Limits(1,1,screen_width, screen_length);
					END;
				END;
			ELSIF (Mou_Last_X > dir_x1) and (Mou_Last_X < dir_x2) AND
				(Mou_Last_Y = dir_y1) THEN
				jx := length( dir_mask );
				jy := (dir_x1 + ((dir_x2 - dir_x1) / 2)) - (jx / 2);
				IF (Mou_Last_X >= jy) AND (Mou_Last_X < (jy + jx)) THEN
					jx := (mou_last_x - jy) + 1;
					tstr := dir_mask;
					WHILE (str_char( tstr, jx ) <> '\') AND (jx <= svl(tstr)) DO
						++jx;
					END;
					Draw_Attr( jy, dir_y1, d_h_color, jx );
					IF jx < svl(tstr) then
						tstr := copy( tstr, 1, jx ) + truncate_path( tstr );
						return_str := get_path( dir_mask );
						dir( tstr );
						call find_old_entry;
					END;
					CALL redraw_cur_dir;
				ELSE
					jx := 0;
					call mouse_set_size;
				END;
			END;
		ELSif (key2 = 80) or (Key2 = 241) then {cursor down}
			dos_down;
		ELSif ((key2 = 72) or (Key2 = 240)) then {cursor up}
			dos_up;
		ELSif ((key2 = 77) or (key2 = 243)) then
			dos_right;
		ELSif ((key2 = 75) or (key2 = 242)) then
			dos_left;
		ELSif (key2 = 71) then {home}
			dos_home;
		ELSif (key2 = 79) then {end}
			refresh := false;
			while dir_num < dir_total do
				dos_down;
				dos_right;
			end;
			refresh := true;
			update_dir;
		ELSif (key2 = 73) then {Page up}
			Call Page_Up;
		ELSif (key2 = 81) then {Page dn}
			Call Page_Dn;
		ELSE
			result := -1;
		END;
	ELSIF (key1 = 127) THEN
		tstr := get_path(dir_mask);
		jx := svl(tstr) - 1;
		WHILE (jx > 0) AND (str_char(tstr,jx) <> '\') AND
					(str_char(tstr,jx) <> ':') DO
			--jx;
		END;
		tstr := copy(tstr,1,jx );
		IF str_char( tstr, jx ) = ':' THEN
			tstr := tstr + '\';
		END;
		return_str := get_path( dir_mask );
		dir( fexpand( tstr + truncate_path( dir_mask ) ) );
		call find_old_entry;
		call redraw_cur_dir;
	ELSIF (key1 > 0) AND (key1 < 27) THEN
		tstr := char( key1 + 64 );
		IF xpos( tstr, drive_str, 1 ) > 0 THEN
			Return_Str := fexpand( tstr + ':' + truncate_path( dir_mask ) );
			Dir( Return_Str );
			call redraw_cur_dir;
		END;
	ELSE
		jx := wherex - dir_x1 - 2;
		IF dir_mode THEN
			WHILE jx > 14 DO
				jx := jx - 15;
			END;
			return_str := copy(truncate_path(dir_entry), 1, jx );
		ELSE
			IF jx >= 9 THEN
				return_str := truncate_path(truncate_extension(dir_entry)) + '.';
				tstr := get_extension(dir_entry);
				IF svl(tstr) > 0 THEN
					return_str := return_str + copy(tstr, 1, jx - 9);
				END;
			ELSE
				return_str := copy(truncate_path(dir_entry), 1, jx );
			END;
		END;
		IF key1 = 8 THEN
			IF return_str <> '' THEN
				return_str := copy(return_str,1, length(return_str) - 1);
			END;
		ELSE
			return_str := CAPS( return_str + char(key1));
		END;
		IF dir_inc_search( return_str ) THEN
			IF dir_mode THEN
				gotoxy( wherex + length(return_str), wherey );
			ELSE
				tstr := truncate_extension( return_str );
				IF length(return_str) > length(tstr) THEN
					gotoxy( wherex + 9 + length(get_extension(return_str)), wherey );
				ELSE
					gotoxy( wherex + length(return_str), wherey );
				END;
			END;
		END;
	END;
	goto mouse_exit;

Page_Up:
	refresh := false;
	jx := 1;
	j1 := dir_y2 - dir_y1 - 2;
	while (jx < j1)  and (dir_num > 1) do
		++jx;
		dos_up;
	end;
	refresh := true;
	update_dir;
	RET;

Page_Dn:
	refresh := false;
	jx := 1;
	j1 := dir_y2 - dir_y1 - 2;
	while (jx < j1) and (dir_num < dir_total) do
		++jx;
		dos_down;
	end;
	refresh := true;
	update_dir;
	RET;

mouse_set_size:
	IF full_mode THEN
		tstr := Global_Str( '@DIR_PARMS@');
		j1 := parse_int('/MAXR=', tstr );
		jy := parse_int('/MINR=', tstr );
		RM('WINDOW^MOVE_WIN /X1=' + str(dir_x1)+'/Y1=' + Str(dir_y1) + '/X2=' +
			Str(dir_x2) + '/Y2=' + Str(dir_y2) + '/MS=' + str(0) +
			'/MX1=0/MY1=' + Str(jy) + '/MX2=' +
			Str(Screen_Width + 1) + '/MY2=' + Str(j1) +
			'/MM=' + str( jx ) );
		size_dir( parse_int('/X1=', return_str),
							parse_int('/Y1=', return_str),
							parse_int('/X2=', return_str),
							parse_int('/Y2=', return_str),
							1
						);
		RM('DIRSHELL^UpdateDir /M=4' );
		dd_row := return_int;
	END;
	RET;

redraw_cur_dir:
	RM('UPDATEDIR /M=' + str( dm ));
	RET;

Update_Cur_Dir:
	Dir( dir_mask );
	call redraw_cur_dir;
	ret;

Mouse_Repeat_Loop:
		Mou_Repeat := TRUE;
		du2:
			Mou_Check_Status;
			IF ((Mou_Last_Status AND 1) <> 0) AND (old_x = Mou_Last_X) AND
				(old_y = Mou_Last_Y) THEN
				IF check_Key THEN
					IF (key2 = 250) AND (key1 = 0) THEN
						return_int := 1;
						RET;
					ELSE
						push_key( key1, key2 );
					END;
				ELSE
					GOTO du2;
				END;
			END;
		return_int := 0;
		Mou_Repeat := FALSE;
		RET;


Find_Old_Entry:
	refresh := false;
	dos_home;
	IF copy( return_str, length(return_str), 1) = '\' THEN
		return_str := copy( return_str, 1, length( return_str ) - 1 );
	END;
	WHILE dir_num < dir_total DO
		IF dir_entry = return_str THEN
			REFRESH := TRUE;
			RET;
		END;
		DOS_RIGHT;
	END;
	dos_home;
	REFRESH := TRUE;
	RET;


mouse_exit:
	return_int := RESULT;

END_MACRO;


$MACRO InitDirShell;
	def_int( drive_count, jx, jy, max_dir_row := screen_length,
					 min_dir_row := 1, t_bc := 0 );
	def_str( drive_str[32] );

	IF NOT(parse_int('/SMALL=', mparm_str)) THEN
		save_box(1,1,screen_width,screen_length);

		if fkey_row = 0 THEN
			fkey_row := screen_length;
		END;
		IF fkey_row = status_row THEN
			fkey_row := status_row - 1;
		END;
		max_dir_row := max_window_row;
		IF (max_dir_row >= fkey_row) then
			max_dir_row := fkey_row - 1;
		END;

		min_dir_row := min_window_row;
		IF (min_dir_row <= message_row) AND (max_window_row > message_row) then
			min_dir_row := message_row + 1;
		END;
		IF (min_dir_row <= status_row) AND (max_window_row > status_row) then
			min_dir_row := status_row + 1;
		END;
		IF (min_dir_row <= 0) THEN
			min_dir_row := 1;
		END;
		t_bc := box_count;
	END;


{get active drives on system}
	R_AX := $1900;
	Intr($21);
	jy := R_AX and $00FF;
	R_DX := jy;
	R_AX := $0E00;
	Intr($21);
	jx := 0;
	drive_count := R_AX AND $00FF;
	drive_str := '';
	while jx < drive_count DO
		R_DX := jx;
		R_AX := $0E00;
		Intr($21);
		R_AX := $1900;
		Intr($21);
		IF (R_AX and $00FF) = jx THEN
			drive_str := drive_str + char( jx + 65);
		END;
		++jx;
	END;
	R_DX := jy;
	R_AX := $0E00;
	Intr($21);
	drive_count := svl( drive_str );

	Set_Global_Str( '@DIR_PARMS@', '/MAXR=' + str( max_dir_row )+
											'/BC=' + str(t_bc) +
											'/MINR=' + str(min_dir_row ) +
											'/DS=' + drive_str +
											'/DC=' + str(drive_count)  +
											'/S=' + parse_str('/S=', mparm_str)
									);

END_MACRO;


{*******************************MULTI-EDIT MACRO******************************

Name: UpdateDir

Description:  Screen refresh for DIR windows.

Parameters:		/M=n		u_mode
								 0	= Total redraw of current window
								 1  = Partial redraw of current window
								 2  = Lo-light current window
								 3  = Update all windows
								 4  = Redraw all windows
							/TL=1 = No top label.

               (C) Copyright 1989 by American Cybernetics, Inc.
******************************************************************************}
$MACRO UpdateDir;
	def_int( u_mode, jx, jy, t_b_color, t_d_color, t_h_color, dd_row, ev_count, cur_dir );
	def_int( max_dir_row, min_dir_row, select_type ,nohelp);
	def_str( ev_string[20], tstr[128] );

	working;
	set_virtual_display;
	u_mode := parse_int('/M=', mparm_str);
	nohelp := Parse_int('/NH=',mparm_str);

	IF u_mode = 0 THEN
		call Redraw_Cur_DIr;
	ELSIF u_mode = 1 THEN
		call XRedraw_Cur_DIr;
	ELSIF u_mode = 2 THEN
		call Lo_Cur_Dir;
	ELSIF u_mode = 3 THEN
		call update_all_dirs;
	ELSIF u_mode = 4 THEN
		call redraw_all_dirs;
	END;
	goto exit;

Update_Drive_Display:
		RM('DIRSHELL^UpdateDrives');
		dd_row := return_int;
		RET;

XRedraw_Cur_Dir:
	redraw_dir;
	call update_drive_display;
	update_dir;
	jy := dir_x1 + ((dir_x2 - dir_x1) / 2);
	IF parse_int('/TL=', mparm_str) = 0 THEN
		tstr := dir_mask;
		IF svl(tstr) > (dir_x2 - dir_x1) THEN
			tstr := str_del( tstr,1,2);
			IF svl(tstr) > (dir_x2 - dir_x1) THEN
				tstr := truncate_path(tstr);
			END;
		END;
		write( tstr, jy - (svl( tstr ) / 2),
									 dir_y1, 0, d_s_color );
	END;
	tstr := str( disk_free( ASCII(copy( dir_mask, 1,1 )) - 64 ) / 1024 );
	write( copy( dir_mask, 1, 2 ) + tstr + 'K', dir_x1 + 1, dd_row + 1, 0, d_b_color );
	write( str( dir_total ) + ' files', SVL(tstr) + 5 + dir_x1,
					dd_row + 1, 0, d_b_color );
	ret;

Redraw_Cur_Dir:
	CALL XRedraw_Cur_Dir;
	ev_count := 2;
	ev_string := '@DSLEV';
	Set_Global_Str(ev_string + '1', '/T=Select/KC=<ENTER>/K1=13/K2=28/R=1/X='
				+ str(  jy - 11 ) + '/Y=' + str( dir_y2 ) + '/W=13');
	Set_Global_Str(ev_string + '2', '/T=Done/KC=<ESC>/K1=27/K2=1/R=0/X='
				+ str(  jy + 3) + '/Y=' + str( dir_y2 ) + '/W=9');
	RM('UserIn^CheckEvents /M=2/G=' + ev_string + '/#=' + str( ev_count ));
	Return_Str := '/EVC=';
	RM('USERIN^CHNGPARM /G=@DIR_PARMS@/P=' + str(ev_count) );
	RET;

lo_cur_dir:
	t_d_color := d_s_color;
	t_h_color := d_h_color;
	t_b_color := d_b_color;
	d_h_color := d_s_color;
	d_s_color := d_t_color;
	d_b_color := d_t_color;
	call xredraw_cur_dir;
	d_s_color := t_d_color;
	d_h_color := t_h_color;
	d_b_color := t_b_color;
	RET;


Update_Cur_Dir:
	working;
	Dir( dir_mask );
	call redraw_cur_dir;
	ret;

XUpdate_Cur_Dir:
	working;
	Dir( dir_mask );
	call xredraw_cur_dir;
	ret;

set_vars:
	cur_dir := global_int('@DIR_CUR_DIR@');
	select_type := parse_int('/S=', global_str('@DIR_PARMS@'));
	max_dir_row := parse_int('/MAXR=', global_str('@DIR_PARMS@'));
	min_dir_row := parse_int('/MINR=', global_str('@DIR_PARMS@'));
	ret;

update_all_dirs:
	working;
	call set_vars;
	call strip_boxes;
	restore_box;
  Call Dos_Help;
	t_h_color := d_h_color;
	d_h_color := d_t_color;
	t_d_color := d_s_color;
	d_s_color := d_t_color;
	jx := 0;
	if select_type <> 2 then
		while jx < 4 do
			++jx;
			switch_dir(jx);
			IF dir_active( jx ) THEN
				if (dir_y2 > max_dir_row) then
					size_dir( dir_x1, dir_y1, dir_x2, max_dir_row, 1 );
				end;
				if (dir_y1 < min_dir_row) then
					size_dir( dir_x1, min_dir_row, dir_x2, dir_y2, 1 );
				end;
				if (jx <> cur_dir) then
					call xupdate_cur_dir;
				end;
			END;
		end;
	ELSE
		if (dir_y2 > max_dir_row) then
			size_dir( dir_x1, dir_y1, dir_x2, max_dir_row, 1 );
		end;
		if (dir_y1 < min_dir_row) then
			size_dir( dir_x1, min_dir_row, dir_x2, dir_y2, 1 );
		end;
	end;
	d_s_color := t_d_color;
	d_h_color := t_h_color;

	switch_dir(cur_dir);
	call update_cur_dir;
	ret;

strip_boxes:
	jx := parse_int('/BC=', global_str('@DIR_PARMS@'));
	while box_count > jx do
		kill_box;
	end;
	ret;

redraw_all_dirs:
	working;
	call set_vars;
	call strip_boxes;
	restore_box;
	call dos_help;
	t_d_color := d_s_color;
	t_h_color := d_h_color;
	d_h_color := d_t_color;
	d_s_color := d_t_color;
	jx := 0;
	if select_type <> 2 then
		while jx < 4 do
			++jx;
			if (dir_active(jx)) THEN
				switch_dir(jx);
				if (dir_y2) > (max_dir_row) then
					size_dir( dir_x1, dir_y1, dir_x2, max_dir_row, 1 );
				end;
				if (dir_y1) < (min_dir_row) then
					size_dir( dir_x1, min_dir_row, dir_x2, dir_y2, 1 );
				end;
				IF (jx <> cur_dir) then
					call XRedraw_cur_dir;
				END;
			end;
		end;
	end;
	d_s_color := t_d_color;
	d_h_color := t_h_color;
	switch_dir(cur_dir);
	call redraw_cur_dir;
	ret;


dos_help:
		if (select_type <> 2) and (Nohelp = False) then
			Put_Box(48,3,80,Screen_Length - 1,0,M_B_Color,'Multi-Edit DOS Shell',false);
			Write('Use cursor keys to move.',49,4,0,m_t_color);
			Write('',49,5,0,m_t_color);
			Write('<TAB> Toggle display mode      ',49,5,0,m_t_color);
			Write('<Space><INS> Mark/Unmark file  ',49,6,0,m_t_color);
			Write('<CtrlBackSpace> Parent dir     ',49,7,0,m_t_color);
			Write('<F2>  Get New Dir Listing      ',49,08,0,m_t_color);
			Write('<F3>  View File                ',49,09,0,m_t_color);
			Write('<F4>  Load File into window    ',49,10,0,m_t_color);
			Write('<F5>  Copy File(s)             ',49,11,0,m_t_color);
			Write('<F6>  Rename File(s)           ',49,12,0,m_t_color);
			Write('<F7>  Create Directory         ',49,13,0,m_t_color);
			Write('<F8>  Delete File(s)           ',49,14,0,m_t_color);
			Write('<F9>  Print file with PRINT.COM',49,15,0,m_t_color);
			Write('<F10> Sort directory           ',49,16,0,m_t_color);
			Write('<ShftF1> Next DIR Window       ',49,17,0,m_t_color);
			Write('<ShftF2> Resize DIR Window     ',49,18,0,m_t_color);
			Write('<ShftF3> Do any DOS Command    ',49,19,0,m_t_color);
			Write('<ShftF4> Load Marked files     ',49,20,0,m_t_color);
			Write('<ShftF5> Copy Marked files     ',49,21,0,m_t_color);
			Write('<ShftF6> Repeat command on mrk ',49,22,0,m_t_color);
			Write('<ShftF7> File attributes       ',49,23,0,m_t_color);

	 		IF (Screen_Length > 38) THEN
				Write('<ShftF8> Delete Marked files ',49,24,0,m_t_color);
				Write('<ShftF9> Print Marked files  ',49,25,0,m_t_color);
				Write('<ShftF10> Directory Tree     ',49,26,0,m_t_color);
				Write('<AltF1> Create Dir Window    ',49,27,0,m_t_color);
				Write('<AltF2> Delete Dir Window    ',49,28,0,m_t_color);
				Write('<AltF3> View Archive Contents',49,29,0,m_t_color);
				Write('<AltF4> Change Current Dir   ',49,30,0,m_t_color);
				Write('<AltF8> Delete SubDir        ',49,31,0,m_t_color);
				Write('<Grey+> Select Group of Files',49,32,0,m_t_color);
				Write('<Grey-> Unselect Group       ',49,33,0,m_t_color);
				Write('<Grey/> Reverse Selection    ',49,34,0,m_t_color);
	  		END;
		Write('Press <F1> for more HELP',52,Screen_Length - 1,0,m_t_color);
		end;
		ret;

EXIT:
	update_status_line;
	update_virtual_display;
	reset_virtual_display;
	return_int := dd_row;
END_MACRO;


{*******************************MULTI-EDIT MACRO******************************

Name: DirWindow

Description:  Performs various directory window operations.

Parameters:		/M=n		w_mode
									= 0 Switch to next dir window
									= 1 Create dir window
									= 2 Delete dir window
									= 3 Resize dir window

               (C) Copyright 1989 by American Cybernetics, Inc.
******************************************************************************}
$MACRO DirWindow;
		def_int( w_mode, jx, cur_dir, select_type, min_dir_row, max_dir_row );

		cur_dir := global_int('@DIR_CUR_DIR@');
		select_type := parse_int('/S=', global_str('@DIR_PARMS@'));
		max_dir_row := parse_int('/MAXR=', global_str('@DIR_PARMS@'));
		min_dir_row := parse_int('/MINR=', global_str('@DIR_PARMS@'));

		w_mode := parse_int('/M=', mparm_str);
		IF w_mode = 0 THEN
			call switch_dir;
		ELSIF w_mode = 1 THEN
			call create_dir;
		ELSIF w_mode = 2 THEN
			call delete_dir;
		ELSIF w_mode = 3 THEN
			call resize_dir;
		END;
		goto exit;


switch_dir:
		RM('DIRSHELL^UpdateDir /M=2');
    call switch_dir2;
		RM('DIRSHELL^UpdateDir /M=0');
		RET;

switch_dir2:
		jx := 1;
switch_again:
		++cur_dir;
		++jx;
		if cur_dir > 4 then
			cur_dir := 1;
		end;
		set_global_int('@DIR_CUR_DIR@', cur_dir);
		switch_dir(cur_dir);
		if dir_active( cur_dir ) = 0 then
			if jx < 5 then
				goto switch_again;
			end;
		end;
		error_level := 0;

    ret;

create_dir:
	jx := 1;
open_again:
	if dir_active(jx) then
		++jx;
		if jx < 5 then
			goto open_again;
		end;
	end;
	error_level := 0;
	if jx < 5 then
		RM('DIRSHELL^UpdateDir /M=2');
		cur_dir := jx;
		set_global_int('@DIR_CUR_DIR@', cur_dir);
		open_dir(cur_dir);
		Dir_Mode := Global_Int('@DIR_MODE@');
		if cur_dir = 1 then
			size_dir(1,min_dir_row,47,max_dir_row, 1);
		end;
		if cur_dir = 2 then
			size_dir(48,min_dir_row,80,max_dir_row, 1);
		end;
		if cur_dir = 3 then
			size_dir(30,5,65,max_dir_row - 3, 1);
		end;
		if cur_dir = 4 then
			size_dir(15,7,50,max_dir_row - 5, 1);
		end;
		Dir_Sort_Str := Global_Str('DIR_SORT_STR');
		Dir( dir_mask );
		RM('DIRSHELL^UpdateDir /M=0');
	END;
	RET;


delete_dir:
	{Delete dir}
	jx := dir_active(1) + dir_active(2) + dir_active(3) + dir_active(4);
	if jx > 1 then
		close_dir(cur_dir);
    call switch_dir2;
		RM('DIRSHELL^UpdateDir /M=4');
	end;
	ret;

resize_dir:
	RM(
			'WINDOW^MOVE_WIN /K=1/X1=' + str(dir_x1) +
			'/Y1=' + Str(dir_y1) +
			'/X2=' + Str(dir_x2) +
			'/Y2=' + Str(dir_y2) +
			'/MX1=1/MY1=' + str(min_dir_row ) +
			'/MX2='+str(screen_width) +
			'/MY2='+str(max_dir_row)
		);

	IF (Return_Int) THEN
		Size_Dir(Parse_Int('/X1=',Return_Str),Parse_Int('/Y1=',Return_Str),
			Parse_Int('/X2=',Return_Str),Parse_Int('/Y2=',Return_Str), 1);
	end;
	RM('DIRSHELL^UpdateDir /M=4');
	ret;

EXIT:

END_MACRO;


{*******************************MULTI-EDIT MACRO******************************

Name: ProcessDir

Description:  Gets a directory of the path and mask stored in RETURN_STR.

Returns:		Nothing.

               (C) Copyright 1989 by American Cybernetics, Inc.
******************************************************************************}
$MACRO ProcessDir;
		def_str(dstring[128]);
		IF caps(return_str) = '?NO-FILE?' THEN
			return_str := '*.*';
		END;
		dstring := fexpand(return_str);
		if truncate_path(dstring) = '' THEN
			dstring := dstring + '*.*';
		ELSIF (xpos('.',truncate_path(dstring),1) = 0) THEN
			dstring := dstring + '.*';
		END;
		dir( dstring );
		if (dir_total = 1) AND ((dos_file_attr and $10) <> 0) THEN
			IF caps(truncate_path(dir_entry)) = caps(truncate_path(return_str)) THEN
				dir( dir_entry + '\*.*' );
			END;
		END;

END_MACRO;


{*******************************MULTI-EDIT MACRO******************************

Name: DIRSORT

Description:  User interface for setting the directory sort string.

               (C) Copyright 1989 by American Cybernetics, Inc.
******************************************************************************}
$MACRO DIRSORT TRANS;
		def_int(jx);
		set_global_str('DIR_IPARM_1','/TP=10/C=1/T=Extension/QK=1');
		set_global_str('DIR_IPARM_2','/TP=10/C=1/T=Name/QK=1');
		set_global_str('DIR_IPARM_3','/TP=10/C=1/T=Size/QK=1');
		set_global_str('DIR_IPARM_4','/TP=10/C=1/T=Date/QK=1');
		set_global_str('DIR_IPARM_5','/TP=10/C=1/T=Time/QK=1');
		set_global_str('DIR_IPARM_6','/TP=10/C=1/T=-Reverse/QK=1');
		set_global_str('DIR_IPARM_7','/TP=0/T=/C=14/L=1/W=9');
		set_global_str('DIR_ISTR_7', Dir_Sort_Str);
		RM('USERIN^DATA_IN /#=7/A=2/S=7/T=INPUT SORT KEY/PRE=DIR_');
		IF return_int THEN
			Dir_Sort_Str := Global_Str('DIR_ISTR_7');
			Set_Global_Str('DIR_SORT_STR', Dir_Sort_Str );
			var_parse_int( '/UPDATE=', mparm_str, jx );
			IF jx <> 0 THEN
				IF dir_active(jx) THEN
					switch_dir(jx);
					IF dir_total > 0 THEN
						working;
						dir( dir_mask );
						update_status_line;
					END;
				END;
			END;
		END;
		set_global_str('DIR_ISTR_7', '');
END_MACRO;


{*******************************MULTI-EDIT MACRO******************************

Name:   DirOperation

Description: Dos Directory shell file operations:

Parameters:		/M=n		o_mode
									= 0 New dir mask
									= 1 Change directory
									= 2 Copy file
									= 3 Delete file
									= 4 rename file

               (C) Copyright 1989 by American Cybernetics, Inc.
******************************************************************************}
$MACRO DirOperation TRANS;
		def_int( o_mode, select_type );
		def_str( tstr[128] );
		select_type := parse_int('/S=', global_str('@DIR_PARMS@'));
		o_mode := parse_int('/M=', mparm_str);

		IF o_mode = 0 THEN
			call new_dir_mask;
		ELSIF o_mode = 1 THEN
			call change_directory;
		ELSIF o_mode = 2 THEN
			call copy_file;
		ELSIF o_mode = 3 THEN
			call delete_file;
		ELSIF o_mode = 4 THEN
			call rename_file;
		END;
		goto exit;

new_dir_mask:
		Return_Str := Dir_Mask;
		if select_type <> 2 then
			Make_Message('Please note that this will NOT actually change the current directory.');
		end;
		RM('USERIN^QUERYBOX /L=' + str( dir_y1 + 1 ) + '/C=' + str( dir_x1 + 1) +
			'/W=60/H=DIRSHELL^*/T=Please enter new directory mask');
		if select_type <> 2 then
			Make_Message('');
		end;
		If Return_Int THEN
			RM('DIRSHELL^processdir');
		END;
    RM('DIRSHELL^UpdateDir /M=0');
		ret;
change_directory:
		Return_Str := Dir_Path;
		If (Dos_File_Attr and $10) <> 0 THEN
			Return_Str := Dir_Entry;
		END;
		RM('USERIN^QUERYBOX /L=' + str( dir_y1 ) + '/C=' + str(dir_x1) +
			'/W=60/H=DIRSHELL^DOCD/T=Please enter new directory');
		If Return_Int THEN
			Change_Dir(Return_Str);
			Dir('*.*');
{If you want to retain the old directory mask when changing directories, use
this line instead of the line above
			Dir( Truncate_Path( dir_mask ));
}
		END;
		RM('DIRSHELL^UpdateDir /M=0');
		RET;

delete_file:
			Return_Str := Dir_Entry;
			RM('USERIN^QUERYBOX /L=' + str( dir_y1 ) + '/C=' + str(dir_x1) +
				'/W=60/H=DIRSHELL^DODELFILE/T=Please enter file to delete');
			If Return_Int THEN
				Return_Str := 'DEL ' + Return_Str;
				RM('DIRSHELL^RunDosCmd');
			END;
			ret;

copy_file:
			Return_Str := Dir_Entry;
			RM('USERIN^QUERYBOX /L=' + str( dir_y1 ) + '/C=' + str(dir_x1) +
				'/W=60/H=DIRSHELL^DOCOPYFILE/T=Please enter file to copy');
			If Return_Int THEN
				tstr := return_str;
				{return_str := '';}
				RM('USERIN^QUERYBOX /L=' + str( dir_y1 ) + '/C=' + str(dir_x1) +
						'/W=60/H=DIRSHELL^DOCOPYFILE/T=Please enter destination');
				If Return_Int then
					return_str := 'COPY ' + Tstr + ' ' + Return_Str;
					RM('DIRSHELL^RunDosCmd');
				end;
			END;
			ret;

rename_file:
			Return_Str := Dir_Entry;
			RM('USERIN^QUERYBOX /L=' + str( dir_y1 ) + '/C=' + str(dir_x1) +
					'/W=60/H=DIRSHELL^DORENAME/T=Please enter file to rename');
			If Return_Int THEN
				tstr := return_str;
				{return_str := '';}
				RM('USERIN^QUERYBOX /L=' + str( dir_y1 ) + '/C=' + str(dir_x1) +
						'/W=60/H=DIRSHELL^DORENAME/T=Please enter new file name');
				If Return_Int then
					return_str := 'RENAME ' + Tstr + ' ' + Return_Str;
					RM('DIRSHELL^RunDosCmd');
				end;
			END;
			ret;
EXIT:
END_MACRO;


{*******************************MULTI-EDIT MACRO******************************

Name: RunDosCmd

Description:  Runs the dos command specified in RETURN_STR using
							COMMAND.COM.  Use under DIR SHELL ONLY.

               (C) Copyright 1989 by American Cybernetics, Inc.
******************************************************************************}
$MACRO RunDosCmd TRANS;
	def_int( j1,j2 );
	j1 := parse_int('/BC=', global_str('@DIR_PARMS@') );
	WHile box_count > j1 DO
		kill_box;
	END;
	j1 := Status_Row;
	Status_Row := 0;
	j2 := Fkey_Row;
	Fkey_Row := 0;
	Clear_Screen( (Dos_Back shl 4) or Dos_Color);
	gotoxy(1,2);
	Write_Sod('>' + return_str + '|13|10');
	Shell_To_Dos(return_str,true);
	Write_Sod('|13|10Press any key to continue...');
	Read_Key;
	fkey_row := j2;
	status_Row := j1;
	RM( 'UpdateDir /M=3' );

END_MACRO;


$MACRO UpdateDrives;
    def_int( redx, redc, um );
    def_int( jy, dd_row, drive_count, x1, y1, x2, y2 );
		def_char( cur_drive );
		def_str( drive_str[32] );

    um := parse_int('/M=', mparm_str);
    IF um THEN
      x1 := parse_int('/X1=', mparm_str);
      y1 := parse_int('/Y1=', mparm_str);
      x2 := parse_int('/X2=', mparm_str);
      y2 := parse_int('/Y2=', mparm_str);
      cur_drive := parse_str('/CD=', mparm_str);
    ELSE
      x1 := dir_x1;
      x2 := dir_x2;
      y1 := dir_y1;
      y2 := dir_y2;
      cur_drive := copy(dir_mask,1,1);
    END;
		drive_count := parse_int('/DC=', global_str('@DIR_PARMS@'));
		drive_str := parse_str('/DS=', global_str('@DIR_PARMS@'));
		redx := 0;
    redc := x1 + 1;
    dd_row := y1 + 1;
    jy := x2 - 1;
    WHILE (redx < Drive_Count) AND (dd_row < y2) DO
			++redx;
			IF str_char( drive_str , redx ) = cur_drive THEN
				write( str_char(drive_str,redx ) + ':', redc, dd_row, 0, d_h_color );
			ELSE
				write( str_char(drive_str,redx ) + ':', redc, dd_row, 0, d_s_color );
			END;
			redc := redc + 3;
			IF redc >= jy THEN
				IF redx < drive_count THEN
					++dd_row;
          redc := x1 + 1;
				END;
			END;
		END;

    IF um = 0 THEN
      Size_Dir( x1, y1, x2, y2, (dd_row - y1) + 1 );
    END;
    draw_char( 196, x1 + 1, dd_row + 1, d_b_color, x2 - x1 - 1 );
		return_int := dd_row;
END_MACRO;




$MACRO DirMarkRepeat TRANS;

	def_int( jx, j1, j2 );
	def_str( tstr );

	tstr := return_str;

	Refresh := False;
	j1 := parse_int('/BC=', global_str('@DIR_PARMS@') );
	WHile box_count > j1 DO
		kill_box;
	END;
	DOS_HOME;
	jx := 0;
	j1 := Status_Row;
	Status_Row := 0;
	j2 := Fkey_Row;
	Fkey_Row := 0;
	Clear_Screen( (Dos_Back shl 4) or Dos_Color);
	gotoxy(1,2);
	While Dir_Num <> jx do
		jx := dir_num;
		If File_Marked THEN
			return_str := tstr;
			RM('XLATECMDLINE /F=' + dir_entry);
			Write_Sod('>' + return_str + '|13|10');
			Shell_To_DOS(return_str,true);
		end;
		Dos_right;
	end;
	Write_SOD('|13|10Press any key to continue...');
	Read_Key;
	fkey_row := j2;
	status_Row := j1;
	Refresh := True;
	RM('DIRSHELL^UpdateDir /M=3');

END_MACRO;



{*******************************MULTI-EDIT MACRO******************************

Name: CopyMarkedFiles

Description:  Copies all marked files in the current dir window to the
		destination stored in RETURN_STR.

               (C) Copyright 1989 by American Cybernetics, Inc.
******************************************************************************}
$MACRO CopyMarkedFiles TRANS;

	return_str := 'COPY <FILE>.<EXT> ' + return_str;
	RM( 'DirMarkRepeat' );

END_MACRO;

$MACRO DelMarkedFiles TRANS;
		def_int( jx, j1, j2 );
		Refresh := False;
	j1 := parse_int('/BC=', global_str('@DIR_PARMS@') );
	WHile box_count > j1 DO
		kill_box;
	END;
	DOS_HOME;
	jx := 0;
	j1 := Status_Row;
	Status_Row := 0;
	j2 := Fkey_Row;
	Fkey_Row := 0;
	Clear_Screen( (Dos_Back shl 4) or Dos_Color);
	gotoxy(1,2);
	While Dir_Num <> jx do
		jx := dir_num;
		If File_Marked THEN
			Write_Sod('>DEL ' + Dir_Entry + '|13|10');
			Del_File(Dir_Entry);
			If Error_Level <> 0 THEN
				Write_Sod('->Error on ' + Dir_Entry);
				Error_Level := 0;
			end;
		end;
		Dos_right;
	end;
	Write_SOD('|13|10Press any key to continue...');
	Read_Key;
	fkey_row := j2;
	status_Row := j1;
	Refresh := True;
	RM('DIRSHELL^UpdateDir /M=3');

END_MACRO;

$MACRO PrintMarkedFiles TRANS;
		def_int( jx, j1, j2 );

	Refresh := False;
	j1 := parse_int('/BC=', global_str('@DIR_PARMS@') );
	WHile box_count > j1 DO
		kill_box;
	END;
	DOS_HOME;
	jx := 0;
	j1 := Status_Row;
	Status_Row := 0;
	j2 := Fkey_Row;
	Fkey_Row := 0;
	Clear_Screen( (Dos_Back shl 4) or Dos_Color);
	gotoxy(1,2);
	While Dir_Num <> jx do
		jx := dir_num;
		If File_Marked THEN
			Write_Sod('>PRINT ' + Dir_Entry + '|13|10');
			Shell_To_DOS('PRINT ' + Dir_Entry,true);
		end;
		Dos_right;
	end;
	Write_SOD('|13|10Press any key to continue...');
	Read_Key;
	fkey_row := j2;
	status_Row := j1;
	Refresh := True;
	RM('DIRSHELL^UpdateDir /M=3');

END_MACRO;


$MACRO DIRMOVE FROM DOS_SHELL TRANS;
{******************************************************************************
																MULTI-EDIT MACRO

Name:   DIRMOVE

Description:  Enables mouse movement in the DOS Shell.

Parameters:
							/H= If 1, enables horizontal mouse movement.
							/V= If 1, enables vertical mouse movement.

							 (C) Copyright 1989 by American Cybernetics, Inc.
*******************************************************************************}

	def_int( jx,old_mouse_mode, vertical, horizontal, tmhs, old_x, xoffs );

	tmhs := Mouse_H_Sense;
	Mouse_H_Sense := tmhs * 3;
	vertical := parse_int('/V=', mparm_str);
	horizontal := parse_int('/H=', mparm_str);
	old_mouse_mode := mouse_mode;
	Mou_Check_Status;
	mou_reset;
	mouse_mode := TRUE;
	old_x := Mou_Last_X;
	xoffs := old_x - wherex;
	delay(5);
	Mou_Remove_Ptr;
loop:
	Mou_Check_Status;
	IF ((Mou_Last_Status AND 3) = 0) THEN
		GOTO exit;
	END;
	IF check_key THEN
		IF key1 = 0 THEN
			IF vertical and (key2 = 240) THEN
				DOS_UP;
			ELSIF vertical and (key2 = 241) THEN
				DOS_DOWN;
			ELSIF horizontal and (key2 = 242) THEN
				DOS_LEFT;
			ELSIF horizontal and (key2 = 243) THEN
				DOS_RIGHT;
			END;
		ELSIF key1 = 27 THEN
			goto exit;
		END;
	END;
	GOTO loop;

exit:
	Mouse_H_Sense := tmhs;
	mouse_mode := old_mouse_mode;
	jx := wherex + xoffs;
	IF jx < 1 THEN
		jx := 1;
	END;
	Mou_Set_Pos( jx, wherey );
	IF NOT( horizontal ) THEN
		Mou_Set_Pos( old_x, wherey );
	END;
	Mou_Draw_Ptr;
END_MACRO;


$MACRO MARKLOAD FROM DOS_SHELL TRANS;
{******************************************************************************
																MULTI-EDIT MACRO

Name:   MARKLOAD

Description:  From the DOS_SHELL, loads all marked files into new windows.

							 (C) Copyright 1989 by American Cybernetics, Inc.
*******************************************************************************}

	Def_Int(jx,tcount);

{ Go to the top of the DIR listing }
	Working;
	Refresh := False;
	Dos_Home;

{Now scan down the entire DIR list, building a global string for
each Marked entry}
	jx := 0;
	tcount := 0;
	while jx < Dir_Total DO
		JX := JX + 1;
		IF File_Marked then
			++tcount;
			Set_Global_Str('ML!!' + Str(tcount),Dir_Entry);
		end;
		DOS_RIGHT;
	END;

{	close_dir( 1 );
	close_dir( 2 );
	close_dir( 3 );
	close_dir( 4 );
}
	pop_labels;
	kill_box;
	mode := edit;

{Go through the list of global strings and load in the files.
Set the global strings to NULL when done in order to deallocate them.}
	jx := 1;
	While jx <= tcount do
		Return_str := Global_Str('ML!!' + Str(jx));
		RM( 'LDFILES /LC=1' );
		Error_Level := 0;
		++jx;
	end;
	RM('WINDOW^SetWindowNames');
	Refresh := True;
	redraw;
END_MACRO;




$MACRO MarkRepeat TRANS;

	def_int( jx, j1, j2 );
	def_str( tstr );

	tstr := return_str;

	Refresh := False;
	j1 := parse_int('/BC=', global_str('@DIR_PARMS@') );
	WHile box_count > j1 DO
		kill_box;
	END;
	DOS_HOME;
	jx := 0;
	j1 := Status_Row;
	Status_Row := 0;
	j2 := Fkey_Row;
	Fkey_Row := 0;
	Clear_Screen( (Dos_Back shl 4) or Dos_Color);
	gotoxy(1,2);
	While Dir_Num <> jx do
		jx := dir_num;
		If File_Marked THEN
			return_str := tstr;
			RM('XLATECMDLINE /F=' + dir_entry);
			Write_Sod('>' + return_str + '|13|10');
			Shell_To_DOS(return_str,true);
		end;
		Dos_right;
	end;
	Write_SOD('|13|10Press any key to continue...');
	Read_Key;
	fkey_row := j2;
	status_Row := j1;
	Refresh := True;
	RM('DIRSHELL^UpdateDir /M=3');

END_MACRO;


$MACRO ARCDIR FROM ALL TRANS;
{******************************************************************************
																MULTI-EDIT MACRO

Name: ARCDIR

Description:	List an archive file.  Now supports both .ARC and .ZIP files.

Parameters:		MParm_Str = the archive file name.

Global Strings:
		'ARCDIR_COMMAND'  is the parameters for running the
			archive program to generate the list for .ARC files.
		'ZIPDIR_COMMAND'  is the parameters for running the
			archive program to generate the list for .ZIP files.
			/D1=nn  The number of lines at the top of the list to
				delete.  This is to get rid of the startup message and
				other junk.
			/D2=nn  The number of lines at the bottom of the list to
				delete.  This gets rid of any junk at the bottom.
			/S1=nn  The number of lines at the top of the list to
				leave in but skip.  This is done after the deleting.
			/S2=nn  The number of lines at the bottom of the list to
				leave in but skip.  This is done after the deleting.
			/C=str  The command to user to run the program.  Must be
				the last parameter.
		 Example:
			 Set_Global_Str('ARCDIR_COMMAND',
						'/D1=6/D2=0/S1=2/S2=2/C=C:\UTIL\PKPAK -V' );

	   			 (C) Copyright 1989 by American Cybernetics, Inc.

    Возможность работы с ARJ, LHA, PAK и извлечение  Файлов из архивов
   			        (C)  Stern i K°  14-04-92

******************************************************************************}

	def_int( t_win, jx, d1, d2, s1, s2 ,sc);
	def_str( arc_cmd[80], extr[12], ext[4],afile,efile[13],outpath, delim[4]);
	ext := caps(get_extension(mparm_str));
	afile := mparm_str;

		if ext = 'ARJ' then
			arc_cmd := global_str('ARJDIR_COMMAND');
			if arc_cmd = '' then
			arc_cmd := '/D1=3/S1=4/S2=2/C=arj l ';
			end;
			extr := 'arj e ';
			delim := ' ';
			sc := 1;
		elsif  ext = 'ZIP' then
			arc_cmd := global_str('ZIPDIR_COMMAND');
				if arc_cmd = '' then
				arc_cmd := '/D1=5/S1=4/S2=2/C=PKUNZIP -vb ';
				end;
			extr := 'pkunzip ';
			delim := ' ';
			sc := 48;
		elsif ((ext = 'ARC') or  (ext = 'PAK'))then
			arc_cmd := global_str('ARCDIR_COMMAND');
			if arc_cmd = '' then
			arc_cmd := '/D1=4/S1=3/S2=2/C=PAK v ';
			end;
			extr := 'pak e ';
			delim := '\';
			sc := 1;
		elsif ((ext = 'ICE') or  (ext = 'LZH'))then
    		arc_cmd := global_str('ICEDIR_COMMAND');
    		if arc_cmd = '' then
            arc_cmd := '/D1=1/S1=4/S2=2/C=LHA l ';
			end;
			extr := 'lha e ';
			delim := '\ ';
			sc := 3;
		else
			Make_Message('NOT Suppoted for '+ ext + ' file extension !!!');
			goto EM;
		end;
	refresh := false;
	t_win := cur_window;
	switch_window(window_count);
	create_window;
	working;
	d1 := parse_int('/D1=', arc_cmd);
	d2 := parse_int('/D2=', arc_cmd);
	s1 := parse_int('/S1=', arc_cmd);
	s2 := parse_int('/S2=', arc_cmd);
	jx := xpos('/C=', arc_cmd, 1);
	arc_cmd := copy(arc_cmd, jx + 3, 80);
	make_message(arc_cmd + afile);
	shell_to_dos( arc_cmd + afile + ' > ' + temp_path + 'DIR.TMP', true);
	load_file( temp_path + 'DIR.TMP' );
	jx := 0;
	while jx < d1 do
		++jx;
		del_line;
	end;
	eof;
	jx := 0;
	while jx < d2 do
		++jx;
		del_line;
		up;
	end;
	tof;
	jx := 0;
	while jx < s1 do
		++jx;
		eol;
		goto_col(100);
		text('|254');
		down;
	end;
	eof;
	jx := 0;
	while jx < s2 do
		++jx;
		goto_col(100);
		text('|254');
		up;
	end;
	TOF;
DI: Set_Global_Str('AIPARM_1', '/TP=15/L=0/C=1/W=75/DC=1/WIN=' + str(cur_window) );
	RM('USERIN^DATA_IN /#=1/PRE=A/A=2/NK=1/H=DIRSHELL^DOSELECT%ARC/DBM=0/ABT=Extract File(s)/CBT=Cancel/T='+ dir_entry );
	if(return_int = 1 ) then
		IF ( C_Line = 1 )then
			efile := '';
		else
			arc_cmd := Get_Line;
			efile := Copy(Get_Line, sc, 12);
		  	if (extr = 'pak e ')then {PAK не ставит в имени файла "."}
				arc_cmd := Str_Ins('.', efile,10);
				jx := xpos(' ',arc_cmd,2);
				efile := Str_Del(Remove_Space(arc_cmd),jx,1);
		  	end;
		END;
		outpath := Get_Path(afile);
		RETURN_STR := extr + afile +' '+ str_del(outpath,svl(outpath),1)+delim+efile;
  		RM('USERIN^QUERYBOX /C=5/L=7/W=64/ML=90/T=Extract Command');
			IF ( Return_Int = 1 ) THEN
			RM('DIRSHELL^RunDosCmd');
			make_message(extr + afile +' '+ str_del(outpath,svl(outpath),1)+delim+efile);
			else
			Kill_Box;
			END;
		goto DI;
	end;
	refresh := false;
	delete_window;
	switch_window(t_win);
	make_message('');
	refresh := true;
	Kill_box;
	Redraw;
EM:
END_MACRO;

$MACRO DirFileView TRANS;

	def_int( o_win, omode );
	def_str( tstr[128] );

	IF (File_Attr(Return_Str) and $18) THEN
		RM('MEERROR^Beeps /C=1');
	ELSE
		tstr := return_str;
		refresh := false;
		omode := mode;
		mode := edit;
		o_win := window_id;
 	{switch_window( window_count );
		create_window;}
		rm('LDFILES /LC=1/NC=1');
		read_only := TRUE;
		RM('USERIN^EDITWINDOW /X=5/Y=5/W=70/L=18/H=DIRSHELL^*/SE=1/T=' + tstr);
		read_only := false;
		refresh := false;
		delete_window;
		switch_win_id( o_win );
		mode := omode;
	END;

END_MACRO;


$MACRO tree TRANS;
{*******************************MULTI-EDIT MACRO******************************

Name: TREE

Description:  Creates a graphic directory "tree".

Parameters:
							/X= X coordinate of box
							/Y= X coordinate of box
							/CP= Current path
							/CD= Current drive

               (C) Copyright 1989 by American Cybernetics, Inc.
******************************************************************************}
	def_int( level_count, level, tfsa, done,  tins, ttab, oline, orow, ocol,
          line_counter, wl, screen_full, old_time, old_undo, current_path_line,
					tr,jx,jy, x, y, w, l, wc, premature_done, key_press,
          old_window, event_count, dd_row, rebuild, tm,
					t_d_b_color := d_b_color,
          t_d_h_color := d_h_color,
					t_d_s_color := d_s_color,
					tree_window, old_refresh, building := false );

  def_str( tstr[128], event_str[20],
					title[50], new_drive[2],
					cur_drive[2], tstr2,
					current_path[128], xstr[80] );

  old_refresh := refresh;
	old_undo := undo_stat;
	undo_stat := FALSE;
  level := 0;
  tm := mode;
  mode := edit;
	tins := insert_mode;
	insert_mode := FALSE;
	ttab := tab_expand;
	tab_expand := false;
	done := FALSE;

	d_b_color := m_b_color;
	d_s_color := m_s_color;
	d_h_color := m_h_color;

  IF global_str('@DIR_PARMS@') = '' THEN
    RM('DIRSHELL^InitDirShell');
  END;

	current_path := parse_str('/CP=', mparm_str);
  IF current_path = '' THEN
    current_path := get_path(dir_mask);
  END;
  tstr := global_str('@TREE_PARMS@');
  tree_window := parse_int('/W=', tstr );
  cur_drive := parse_str('/CD=', tstr );
  new_drive := parse_str('/CD=', mparm_str );
  IF new_drive = '' THEN
    new_drive := get_path( dir_mask );
  END;
  new_drive := copy(fexpand(new_drive), 1, 1 );
  rebuild := parse_int('/R=', tstr);
	current_path_line := parse_int('/CP=', tstr);
	dd_row := parse_int('/DDR=', tstr);
	x := parse_int('/X=', tstr );
	w := parse_int('/WD=', tstr );
	l := parse_int('/L=', tstr );
	y := parse_int('/Y=', tstr );
  IF new_drive = '' THEN
    new_drive := cur_drive;
  END;
{
	make_message( mparm_str );
}
  IF (new_drive <> cur_drive) or (cur_drive = '') THEN
 {   new_drive := copy(fexpand('\'), 1, 1 );}
    rebuild := TRUE;
  END;

	premature_done := FALSE;
	oline := 1;
	orow := 1;
	ocol := 1;
  event_count := 0;
  event_str := '@EVTREE#';
	old_window := window_id;
  push_labels;
	flabel('CDrive', 2, -1 );
	tfsa := file_search_attr;
	file_search_attr := $10;
	refresh := false;

  IF NOT(switch_win_id( tree_window ) ) THEN
    switch_window( window_count );
    create_window;
    tree_window := window_id;
    rebuild := TRUE;
		x := parse_int('/X=', mparm_str);
		y := parse_int('/Y=', mparm_str);
  	w := 53;
		l := 20;
  END;
	IF x <= 0 THEN
		x := 2;
	END;
	IF y <= 0 THEN
		y := 2;
	END;
	window_attr := $96;
	t_color := m_t_color;
	c_color := m_t_color;
	b_color := m_b_color;
	s_color := m_s_color;
	eof_color := (m_t_color and $F0) + (m_t_color shr 4);

	call draw_tree_window;
	old_time := system_timer;
  IF not(rebuild) THEN
    set_mark(1);
    eof;
    IF c_col = 1 THEN
      up;
    END;
    line_counter := c_line;
		call reset_line_changed;
		call find_current_path;
		c_color := m_s_color;
    get_mark(1);
    call draw_display;
    update_status_line;
    refresh := true;
    redraw;
    call highlight;
    insert_mode := TRUE;
  END;
loopx:
  IF done THEN
    goto exit;
  END;
  IF rebuild THEN
    tstr := new_drive + ':\*.*';
    call do_rebuild;
    insert_mode := TRUE;
  END;
	IF check_key THEN
		call master_key_loop;
	END;
	goto loopx;

draw_display:
  refresh := false;
  RM('DIRSHELL^UpdateDrives /M=1/X1=' + str(x) + '/Y1=' + str(y) + '/X2=' +
        str( x + w ) + '/Y2=' + str( y + l ) + '/CD=' + new_drive );
  dd_row := return_int;
  size_window( x, dd_row + 1, x + w, y + l );
	wl := win_y2 - win_y1 - 2;
  ret;

write_building:
  title := '  Building Tree  ';
  write( title, wc - (svl(title) / 2), y, 0, working_color );
	ret;

do_rebuild:
	key_press := false;
	c_color := t_color;
	current_path_line := 0;
	premature_done := FALSE;
  call draw_display;
  rebuild := false;
  erase_window;
  put_line( new_drive + ':');
	set_mark(1);
	down;
  put_line( '' );
	refresh := true;
	redraw;
  insert_mode := false;
	screen_full := 0;
  line_counter := 1;
	call write_building;
  level := 0;
	building := true;
	call get_dir;
	building := false;
  title := '─Directory Tree──';
  write( title, wc - (svl(title) / 2), y, 0, b_color );
	update_status_line;
	call reset_line_changed;
	c_color := m_s_color;
	call find_current_path;
	get_mark(1);
	IF NOT(key_press) AND (current_path_line > 0) THEN
		tof;
		down;
		down;
		down;
		down;
		goto_line( current_path_line );
    eol;
    left;
    goto_col( (((c_col - 1) / 13) * 13) + 1 );
	END;
	refresh := true;
	redraw;
  cur_drive := new_drive;
	call highlight;
  ret;

get_dir:
	level_count := 0;
	IF first_file( tstr ) = 0 THEN
loop:
		IF screen_full THEN
			IF check_key THEN
				tr := refresh;
				set_mark(2);
				get_mark(1);
				refresh := true;
				call master_key_loop;
				set_mark(1);
				refresh := tr;
				get_mark(2);
			END;
		END;
		IF (last_file_attr AND $10) THEN
			IF (last_file_name <> '.') AND (last_file_name <> '..') THEN
				IF level > 0 THEN
					jx := level * 13;
					goto_col( jx  );
					up;
					IF cur_char = '└' THEN
						text('├');
					ELSIF (cur_char = ' ') or (cur_char = '|255') THEN
						IF level_count = 0 THEN
							eol;
							text(copy('────────────', 1, jx-  c_col) + '┐');
						ELSE
							set_mark(3);
							WHILE cur_char = ' ' DO
								text('│');
								left;
								up;
							END;
							IF cur_char = '└' THEN
								text('├');
							END;
							get_mark(3);
						END;
					END;
					down;
					goto_col( jx );
					text('└' + last_file_name);
				ELSE
					goto_col(1);
					put_line( last_file_name );
				END;
		  	IF (line_counter >= wl) THEN
					refresh := false;
					IF screen_full = 0 THEN
						set_mark(2);
						refresh := true;
						screen_full := true;
						tof;
						call highlight;
						refresh := false;
						get_mark(2);
			  	END;
					goto_line( line_counter + 2 );
				ELSE
					DOWN;
				END;
				++line_counter;
				create_global_str( '@FILEREC@' + str(level), file_search_rec );
				create_global_str( '@FILETSTR@' + str(level), tstr );
				tstr := get_path(tstr) + last_file_name + '\*.*';
				++level;
				call get_dir;
				--level;
				file_search_rec := global_str( '@FILEREC@' + str(level));
				tstr := global_str( '@FILETSTR@' + str(level));
				set_global_str( '@FILEREC@' + str(level), '');
				set_global_str( '@FILETSTR@' + str(level), '' );
				++level_count;
			END;
		END;
    IF NOT(done) and (next_file = 0) and NOT(rebuild) THEN
			goto loop;
		END;
		premature_done := DONE;
	END;
	ret;

find_current_path:
	set_mark(4);
	current_path_line := 0;
	IF copy(current_path, 1, 1) = cur_drive THEN
		tof;
		tstr := copy(current_path, 4, 254);
		jx := xpos('\', tstr, 1 );
		IF jx = 0 THEN
			jx := svl(tstr) + 1;
		END;
		IF search_fwd('%' + copy(tstr,1, jx - 1), 0) THEN
		fcp_loop:
			call create_return_str;
			IF return_str = current_path THEN
				line_changed := TRUE;
				current_path_line := c_line;
			ELSE
				call skip_right;
				IF (c_col > 1) AND (NOT(at_eof)) THEN
					goto fcp_loop;
				END;
			END;
		END;
	END;
fcp_exit:
	get_mark(4);
	ret;


master_key_loop:
	key_press := TRUE;
  call lowlight;
	IF key1 = 27 THEN
   esc:
		done := TRUE;
    return_int := 0;
  ELSIF key1 = 13 THEN
   enter:
    return_int := TRUE;
    done := TRUE;
    call create_return_str;
	ELSIF key1 = 0 THEN
		IF (key2 = 60) THEN
			call get_new_drive;
		ELSIF (key2 = 80) AND ( c_line < (line_counter) ) THEN
      call skip_down;
		ELSIF (key2 = 72) THEN
      call skip_up;
		ELSIF (key2 = 77) THEN
      call skip_right;
		ELSIF (key2 = 75) THEN
      call skip_left;
    ELSIF (key2 = 71) THEN
      tof;
    ELSIF (key2 = 79) THEN
      eof;
      down;
      goto_col(1);
      call skip_right;
    ELSIF (key2 =  73) THEN
      page_up;
      call skip_up;
    ELSIF (key2 = 81) THEN
      page_down;
      call skip_down;
    ELSIF (key2 = 250) THEN
      call mouse_event;
		ELSE
			goto check_for_key_macro;
		END;
	ELSE
check_for_key_macro:
		IF inq_key( key1, key2, DOS_SHELL, xstr ) > 0 THEN
			pass_key(key1, key2);
		END;
	END;
	call highlight;
	ret;


lowlight:
	IF line_changed THEN
		draw_attr( wherex, wherey, c_color, 12 );
	ELSE
		draw_attr( wherex, wherey, t_color, 12 );
	END;
  ret;


create_return_str:
  return_str := '';
  set_mark(2);
crs_loop:
  refresh := false;
  ocol := c_col;
  return_str := get_word('─┐ |255|9') + '\' + return_str;
  IF ocol > 1 THEN
    goto_col(ocol - 13);
    call skip_up;
    goto crs_loop;
  END;
  refresh := false;
	IF copy( return_str, 2, 1) <> ':' THEN
  	return_str := cur_drive + ':\' + return_str;
	END;
  get_mark(2);
  ret;

skip_down:
  down;
skip_down2:
  IF (copy(get_line,c_col,12) = '            ') or at_eol THEN
    IF c_col > 1 THEN
      left;
      IF cur_char = '│' THEN
        WHILE NOT( at_eof ) and (cur_char = '│') DO
          DOWN;
        END;
        right;
        IF at_eof THEN
          goto skip_up;
        END;
        goto skip_down2;
      END;
      goto_col( c_col - 12);
      IF at_eof THEN
        goto skip_up;
      END;
      goto skip_down2;
    ELSE
      IF (at_eof) THEN
        goto skip_up;
      ELSE
        goto skip_down;
      END;
    END;
  END;
  ret;

skip_up:
  up;
skip_up2:
  IF (copy(get_line,c_col,12) = '            ') or at_eol THEN
{If we don't see the next level, keep looking}
    IF c_col > 1 THEN
      left;

      IF xpos(cur_char,' │',1) THEN
        WHILE ( c_line > 1 ) and (xpos(cur_char,'│ ',1) <> 0) DO
          UP;
        END;
        RIGHT;
        goto skip_up2;
      END;

{
      IF cur_char = '│' THEN
        WHILE ( c_line > 1 ) and (cur_char = '│') DO
          UP;
        END;
        RIGHT;
        goto skip_up2;
      END;
}
      goto_col( c_col - 12);
      goto skip_up2;
    ELSE
      IF c_line > 1 THEN
        goto skip_up;
      END;
    END;
  END;
  ret;

skip_right:
  down;
	refresh := false;
  goto_col( c_col + 13 );
  IF at_eol THEN
skip_right2:
    eol;
    left;
    goto_col( (((c_col - 1) / 13) * 13) + 1 );
  END;
  IF at_eof THEN
    call skip_up;
  END;
	refresh := TRUE;
  ret;

skip_left:
  UP;
  eol;
  left;
  goto_col( (((c_col - 1) / 13) * 13) + 1 );
  ret;

mouse_event:
  jx := c_line;
  ocol := c_col;
	RM('MOUSE^MouseInWindow');
  IF (return_int = 1) THEN
    goto_col( (((c_col - 1) / 13) * 13) + 1 );
    IF (jx = c_line) AND (ocol = c_col) THEN
      done := TRUE;
      call create_return_str;
    ELSE
      call skip_up2;
    END;
  ELSIF (Mou_Last_Y = Fkey_Row) THEN
    RM( 'MOUSE^MouseFkey' );
	ELSIF (Mou_Last_y = y) THEN
		IF (Mou_Last_X > X) AND (Mou_Last_X < (x + w)) THEN
			jx := 0;
			call Do_Resize;
		ELSIF (mou_last_x = x) THEN
			jx := 1;
			call do_resize;
    ELSIF (mou_last_x = (x + w)) THEN
      jx := 2;
			call do_resize;
		END;
  ELSIF (Mou_Last_Y = Win_Y2) AND (Mou_Last_X = (x + w)) THEN
    jx := 4;
    call do_resize;
  ELSIF (Mou_Last_Y = Win_Y2) AND (Mou_Last_X = x) THEN
    jx := 3;
    call do_resize;
  ELSIF (Mou_Last_X = Win_X2) THEN
    RM('MOUSE^HandleScrollBar /EOF=1/L=' + str(line_counter));
    IF (return_int = 1) THEN
      call skip_right2;
    ELSIF (return_int = 2) THEN
      call skip_right2;
    END;
  ELSIF (Mou_Last_Y > y) AND (Mou_Last_Y <= dd_row) THEN
    jx := (Mou_Last_Y - y - 1) * ( w / 3);
    JX :=  (((Mou_Last_X - x) - 1) / 3) + 1 + jx;
    tstr := parse_str('/DS=',global_str('@DIR_PARMS@'));
    IF jx <= svl( tstr ) THEN
      new_drive := str_char( tstr, jx );
      rebuild := TRUE;
    END;
  ELSIF (Mou_Last_X > X) AND (Mou_Last_Y <= (X + W)) THEN
    RM('CheckEvents /M=1/G=' + event_str + '/#=' + str(event_count));
    IF RETURN_INT <> 0 THEN
      RETURN_INT := Parse_Int('/R=', Return_Str );
      IF return_int = 1 THEN
        done := TRUE;
        call create_return_str;
      ELSIF return_int = 0 THEN
        done := TRUE;
      END;
    END;
  ELSIF (Mou_Last_X < X) OR (Mou_Last_X > (X + W + 3))
			OR (Mou_Last_Y < Y) OR (Mou_Last_Y > (WIN_Y2 + 1)) THEN
		Push_Key(0,250);
		RETURN_INT := 0;
    done := TRUE;
  END;
  ret;


draw_tree_window:
  if w < 26 then
    w := 26;
  END;
  if l < 6 THEN
    l := 6;
  END;
	IF (y + l) > (max_window_row) THEN
		IF y >= max_window_row THEN
			y := max_window_row - 10;
		END;
		l :=  max_window_row - y - 1;
	END;
	IF (x + w) > (screen_width) THEN
		IF x >= (screen_width - 20) THEN
			x := screen_width - 42;
		END;
		w :=  screen_width - x - 2;
	END;
	put_box( x, y, x + w + 2, y + l + 1, 0, m_b_color, 'Directory Tree', TRUE);
  wc := (x + (w / 2)) + 1;
  Set_Global_Str(event_str + '1',
      '/T=Cancel/KC=<ESC>/W=11/K1=27/K2=1/R=0/Y=' +
                  str(y + l) +
                  '/X=' + str( wc - 13));
  Set_Global_Str(event_str + '2',
      '/T=Select/KC=<ENTER>/W=13/K1=27/K2=1/R=1/Y=' +
                  str(y + l) +
                  '/X=' + str( wc - 1));
  event_count := 2;
  RM('CheckEvents /M=2/G=' + event_str + '/#=' + str(event_count));
	ret;

do_resize:
	refresh := false;
	IF jx = 0 THEN
		jy := 2;
	ELSE
		jy := 0;
	END;
	RM('WINDOW^MOVE_WIN /X1=' + str(x)+'/Y1=' + Str(y) + '/X2=' +
		Str(x + w) + '/Y2=' + Str(y + l) + '/MS=' + str(0) +
		'/MX1=1/MX2=' +	Str(Screen_Width) +
		'/MY1=2/MY2=' + str(screen_length - 1) +
		'/MM=' + str(jx) + '/M=' + str(jy) + '/K=' + str(return_int));
	x := parse_int('/X1=', return_str);
	y :=	parse_int('/Y1=', return_str);
  w := parse_int('/X2=', return_str) - x;
  l := parse_int('/Y2=', return_str) - y;
	IF (jy = 2) AND (virtual_display <> 0) THEN
		override_screen_seg;
    call draw_tree_window;
    reset_screen_seg;
	ELSE
		kill_box;
		set_virtual_display;
    call draw_tree_window;
	END;
	call draw_display;
  update_status_line;
  refresh := true;
  redraw;
  call highlight;
	IF building THEN
		call write_building;
	END;
	update_virtual_display;
	reset_virtual_display;
	ret;

highlight:
  IF (refresh = FALSE) OR (DONE) THEN
    ret;
  END;
	ocol := c_col;
	goto_col( c_col + 12 );
	goto_col(ocol);
	draw_attr( wherex, wherey, m_h_color, 12 );
	ret;

get_new_drive:
    tstr := parse_str('/DS=',global_str('@DIR_PARMS@'));
		jx := svl(tstr);
		while jx > 0 DO
			tstr := str_ins( ':()', tstr, jx + 1 );
			--jx;
		END;
		RM('USERIN^XMENU /B=1/L=Select Drive/M=' + tstr);
		IF return_int > 0 THEN
    	tstr := parse_str('/DS=',global_str('@DIR_PARMS@'));
      new_drive := str_char( tstr, return_int );
      rebuild := TRUE;
		END;
		ret;

reset_line_changed:
		mark_pos;
		tof;
		while NOT(at_eof) DO
			line_changed := FALSE;
			down;
		END;
		goto_mark;
		ret;

exit:
	d_b_color := t_d_b_color;
	d_s_color := t_d_s_color;
	d_h_color := t_d_h_color;
  tstr := '/W=' + str(tree_window) + '/CD=' + cur_drive + '/DDR=' + str(dd_row) +
		'/X=' + str(x) + '/Y=' + str(y) + '/L=' + str(l) + '/WD=' + str(w);

  IF premature_done THEN
		erase_window;
    tstr := tstr + '/R=1';
  END;
  set_global_str('@TREE_PARMS@', tstr);
  pop_labels;
  RM('CheckEvents /M=3/G=' + event_str + '/#=' + str(event_count));
	refresh := false;
  window_attr := $81;
	kill_box;
	switch_win_id( old_window );
  refresh := old_refresh;
	file_search_attr := tfsa;
	insert_mode := tins;
	tab_expand := ttab;
	undo_stat := old_undo;
  mode := tm;
	IF return_int THEN
		IF parse_int('/SD=', mparm_str) THEN
      working;
			rm('PROCESSDIR');
		END;
	END;
END_MACRO;

$MACRO FILEATTR TRANS;
{*******************************MULTI-EDIT MACRO******************************

Name: FILEATTR

Description:  Allows user to view/change file attributes.

Parameters:
							Return_Str = The default file name to change file attributes of.

               (C) Copyright 1989 by American Cybernetics, Inc.
******************************************************************************}
	Def_Str(F_Name[80]);
	Def_Int(T_Attr);

  RM('USERIN^QUERYBOX /C=15/W=40/T=FILE TO VIEW////CHANGE ATTRIBUTES/F2=Dir   /L=3/H=DIRSHELL^VIEWATTR');
	IF Not(Return_Int) THEN
		Goto EXIT;
	END;

	F_Name := Caps(Return_Str);

	T_Attr := File_Attr(F_Name);
	IF (Error_Level) THEN
		RM('MEERROR');
		Return_Int := 0;
		Goto EXIT;
	END;
	IF (T_Attr and $18) THEN
		RM('MEERROR^MESSAGEBOX /B=1/M=' + F_Name + 'is a ' +
				Copy('Volume LabelDirectory',(((T_Attr and $18) shr 4) * 12) + 1,12) +
				'!  Changing attributes is not allowed.');
		Return_Int := 0;
		Goto EXIT;
	END;

	Set_Global_Str('IPARM_1','/C=1/L=2/TP=10/T=' + f_name);
	Set_Global_Int('IINT_2',(T_Attr and $20) shr 5);
	Set_Global_Str('IPARM_2','/C=2/L=4/H=/TP=13/QK=1/T=Archive   ');
	Set_Global_Int('IINT_3',T_Attr and $01);
	Set_Global_Str('IPARM_3','/C=2/H=/TP=13/QK=1/T=Read Only ');
	Set_Global_Int('IINT_4',(T_Attr and $02) shr 1);
	Set_Global_Str('IPARM_4','/C=2/H=/TP=13/QK=1/T=Hidden    ');
	Set_Global_Int('IINT_5',(T_Attr and $04) shr 2);
	Set_Global_Str('IPARM_5','/C=2/H=/TP=13/QK=1/T=System    ');

  RM('USERIN^DATA_IN /A=0/#=5/H=DIRSHELL^VIEWATTR/S=1/X=4/Y=5/T=FILE ATTRIBUTES');


	IF Not(Return_Int) THEN
		Goto EXIT;
	END;

	Set_File_Attr(F_Name,(Global_Int('IINT_2') shl 5) + Global_Int('IINT_3') +
		(Global_Int('IINT_4') shl 1) + (Global_Int('IINT_4') shl 5));
	IF (Error_Level) THEN
		RM('MEERROR');
		Return_Int := 0;
		Goto EXIT;
	END;

EXIT:
	t_attr := 0;
	WHILE t_attr < 5 DO
		++t_attr;
		set_global_int('IINT_' + str(t_attr), 0);
	END;
END_MACRO;

{*******************************MULTI-EDIT MACRO******************************

Name:  MRKFLS

Description:  Mark/Unmark Files in DOS Shell mode

		  (C)  CopyRight  VSOFT   ( SoftPanorama #42)
   	  добавление и исправление Stern i K°  15-04-92 08:39

******************************************************************************}
$MACRO MRKFLS;
	Def_str(Fil, OldDir);
	Def_str(Fils[2048]);
	Def_Int(i := 1, Kol := 0,PosDir);

	Fils := '';
	if (MPARM_Str = 'I') then
		DOS_HOME;
			WHILE (i <= DIR_TOTAL) DO
				PosDir := Dos_File_Attr <> $10 ;
				IF ((not (FILE_MARKED)) and (PosDir)) THEN
					++Kol;
				end;
				if  PosDir <> 0 then
					Mark_File;
				end;
			Dos_down;
			++I;
		END; {while}
		DOS_HOME;
		Make_Message(Str(Kol)+' files');
 else
	Return_str := Global_Str('V_DirMask');
	IF (MPARM_Str = 'U') then
	Fil := ' UnMark ';
	else
	Fil := ' Mark ';
	END;
	OldDir := Dir_Mask;
	RM('Userin^Querybox /C=5/L=5/W=30/ML=64/T='+Fil+'/H=VSOFT.HLP^V6');
	if Return_int <> 0 then
		Set_Global_Str('V_DirMask' , Return_Str);
		Refresh := 0;
		RM('DIRSHELL^DirWindow /M=1'); {Создали окно}
  Dir(Get_Path(OldDir)+Global_Str('V_DirMask')); {Прочитали директорию}
		DOS_HOME;
		WHILE (i <= DIR_TOTAL) DO
			if XPos('..',DIR_ENTRY,1) = 0  then
				Fil := Truncate_Path(DIR_ENTRY);
				Fils := Fils+Fil;
			end;
			Dos_down;
			++I;
		END; {while}
		Refresh := 1;
		RM('DIRSHELL^DirWindow /M=2');{Удалили окно }
		DOS_HOME;
		i := 1;
		Kol := 0;
		WHILE (i <= DIR_TOTAL) DO
		Fil := Truncate_Path(DIR_ENTRY);
			 IF (XPOS(Fil,Fils,1) <> 0) then
				IF ((MPARM_Str <> 'U') and (not (FILE_MARKED)) and (Dos_File_Attr <> $10)) THEN
					Mark_File;
					++Kol;
				elsif ((MPARM_Str = 'U') and (FILE_MARKED)) then
					++Kol;
					Mark_File;
				end;
			 end;
			Dos_down;
			++I;
		END; {while}

		DOS_HOME;
		Make_Message(Str(Kol)+' files');
	end;
 end;
END_MACRO;
