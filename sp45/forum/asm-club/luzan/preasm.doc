                                                      Фирма ModDem
                            343929, г.Краматорск, Донецкая область
                                                ул.Дворцовая 57/30
                                         Лузан Сергей Владимирович
                                             телефон (06264) 43775

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                Препроцессор транслятора Assembler

                     Версия 1.2  от 16/11/91

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   Предлагаемая Вашему вниманию программа PREASM.EXE  представляет
собой препроцессор исходных текстов, написанных на языке ассембле-
ра с использованием структурных управляющих конструкций  типа  IF,
WHILE, DO, FOR и SWITCH. Предназначен для  совместного использова-
ния с наиболее  распространенными  трансляторами  Turbo  Assembler
(Borand International) и Macro Assembler (Micrisoft).


                      Что Вы будете иметь.
                      ~~~~~~~~~~~~~~~~~~~
   Препроцессор предоставит Вам возможность писать хорошо структу-
рированные программы на языке  ассемблера,  используя  практически
все основные управляющие  конструкции,  присущие  языкам  высокого
уровня. При этом количество конструкций в отдельном исходном моду-
ле практически не ограничивается, а уровень вложенности  КАЖДОЙ из
конструкций ограничен числом 512, что с избытком  перекрывает  все
разумные пределы вложения структур.
   По своим функциональным  возможностям  управляющие  конструкции
приближены к аналогам языка Си (синтаксис,  естественно, отличает-
ся). Например, исходный текст Вашей программы на ассемблере мог бы
выглядеть следующим образом:

        code SEGMENT
        ASSUME cs:code, ds:code
        ORG 100h

        start:
                ...
                $for(1 LE 10)
                   mov bx,cx
                   mov ax,WORD PTR [bx]
                   $switch(ax)
                      $case 10
                         ...
                         $break case
                      $case 20
                         ...
                         $if(bl GE 'a' $AND bl LE 'z')
                            and bl,0dfh
                         $else
                            add al,5
                            ...
                         $endif
                         $break case
                      $case 30
                         ...
                         $break case
                      $case 40
                         $while(es:flag NE 0ffh $OR es:flag NE 0)
                            mov al,BYTE PTR [si+2]
                            ...
                            $if(al E 32)
                               $break while
                            $endif
                            ...
                            and flags,al
                         $endwhile
                         $break case
                      $case 50
                         ...
                         $break case
                      $default
                         ...
                   $endcase
                   ...
                $endfor
                ...

        code ENDS
        END start

   Как видно из приведенного фрагмента, исходный текст  весьма чи-
табелен и его структура понятна даже программисту,  незнакомому  с
языком ассемблера. При продуманном подходе к  проектированию прог-
раммы практически отпадает необходимость использования меток, при-
чем истинность этого утверждения, по опыту автора, почти  не зави-
сит от сложности разрабатываемой программы.


                         Что Вы теряете.
                         ~~~~~~~~~~~~~~
   Во-первых - будьте осторожны при использовании в своих програм-
мах символических имен, ограниченных с обеих сторон символами '$',
а также имен макроопределений, начинающихся с  этого  же  символа.
Подобные имена препроцессор резервирует для своих служебных целей,
поэтому во избежание их пересечения лучше вообще отказаться от ис-
пользования таких имен.

   Во-вторых - семантический анализ обрабатываемых выражений преп-
роцессор НЕ ОСУЩЕСТВЛЯЕТ, поэтому  программисту  необходимо самому
следить за корректным написанием аргументов для управляющих конст-
рукций.

   И, наконец, в-третьих - Вы будете  вынуждены  затратить опреде-
ленное время на ознакомление с настоящей документацией, а также на
изучение особенностей применения описываемых управляющих конструк-
ций (что, впрочем, совсем несложно).

   Если вышеизложенное Вас не пугает, то желаю Вам  удачи  и наде-
юсь, что препроцессор PREASM.EXE Вы отнесете в разряд полезных до-
полнений к Assembler`у.



               Синтаксис, возможности, ограничения
       и особенности использования управляющих конструкций.
       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Если Вы уже "добрались" до этих строк, то есть  вероятность то-
го, что этот документ будет дочитан  до  конца.  Поэтому предвари-
тельно нам следует обговорить некоторые особенности  изложения ма-
териала и принятые условные обозначения:

   1) при описании синтаксиса управляющих конструкций:

        ■ в квадратных скобках - необязательные параметры
        ■ в фигурных скобках - выбор одного из перечисленных
          элементов

   2) все ключевые слова, обрабатываемые препроцессором, начинают-
ся с символа '$'.  Исключение  составляют  идентификаторы  условий
сравнения двух величин, которые образуются путем отбрасывания сим-
вола 'J' от мнемоники команд условного перехода.

   3) при написании ключевых слов  допускается  использование  как
строчных, так и прописных букв.


                Конструкция $IF...$ELSE...$ENDIF.
                ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Синтаксис:
   ~~~~~~~~~
   полная форма:
   ~~~~~~~~~~~~
   $if ( var1 cond1 arg1 [ {$or|$and} var2 cond2 arg2 ] )
      (block_TRUE)
   $else
      (block_FALSE)
   $endif

       var1  - проверяемый регистр или ячейка памяти с любым видом
               адресации
       arg1  - регистр, ячейка памяти с любым видом  адресации или
               константа
       cond1 - условие отношения var1 и arg1
       $or   - логическое ИЛИ для проверки второго необязательного
               условия
       $and  - логическое И для  проверки второго  необязательного
               условия
       var2  - проверяемый регистр или ячейка памяти с любым видом
               адресации
       arg2  - регистр, ячейка памяти с любым видом адресации  или
               константа
       cond2 - условие отношения var2 и arg2


   краткая форма:
   ~~~~~~~~~~~~~
   $if(cond)
      (block_TRUE)
   $else
      (block_FALSE)
   $endif

       cond  - мнемоника проверяемого бита  регистра  флагов. Если
               соответствующий  бит  установлен,  то   выполняется
               block_TRUE. Для выполнения block_TRUE при  условии,
               когда проверяемый бит сброшен, перед cond необходи-
               мо указывать символ 'n' или 'N'.


   Особенности:
   ~~~~~~~~~~~
   1) размер блоков block_TRUE и block_FALSE программы  не ограни-
чен.
   2) если при использовании  конструкции  в  качестве  cond1  или
cond2 указать значение Z или NZ (от JZ и JNZ  соответственно),  то
при проверке условия вместо команды
                          CMP   var,arg
будет использоваться команда
                          TEST  var,arg

   3) недопустимо использование символов пробела внутри каждого из
фактических параметров в строке $if. Например, недопустимо:

                     $if(cs:[si] [bx] NE al)
                                ^

   Ограничения:
   ~~~~~~~~~~~
   1) в строке $if полной формы допускается  использование  только
двух проверок, связанных между собой  ключевыми  словами  $OR  или
$AND. В строке $if краткой формы проверяется только одно условие.
   2) ограничения на сравниваемые значения - такие же, как  и  для
команд CMP и TEST.  Хотя  бы  один  из  операндов  var1(var2)  или
var2(arg2) должен явно определять тип сравниваемых данных  -  byte
ptr или word ptr. В противном случае транслятор  ассемблера  будет
фиксировать ошибки, хотя препроцессор не выдаст при  этом  никаких
сообщений.
   3) за программистом оставлена обязанность следить за соответст-
вием типов (byte ptr или word ptr) сравниваемых значений.


   Возможные ошибки использования:
   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   1) нет завершающей конструкции $endif.
   2) в строке $if некорректно заданы параметры.
   3) несоответствие типов сравниваемых величин (word ptr  и  byte
ptr).



        Конструкция $SWITCH...$CASE...[$BREAK]...$ENDCASE.
        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Синтаксис:
   ~~~~~~~~~
   $switch(var)
      $case x1
         (block1)
         [$break case]
      $case x2
         (block2)
         [$break case]
      ...
      $case xN
         (blockN)
         [$break case]
      [$default]
         [(blockDEFAULT)]
   $endcase

       var   - проверяемый регистр или ячейка памяти с любым видом
               адресации
       x?    - перечень значений для выбора соответствующего блока
               block?. Может быть регистром, ячейкой памяти  с лю-
               бым видом адресации или константой


   Особенности:
   ~~~~~~~~~~~
   1) размер блоков block? программы не ограничен. Количество бло-
ков $case xN не ограничено.
   2) при проверке условия выполняется команда CMP  и  формируется
переход к началу соответствующего блока программы.
   3) использование ключевого  слова  $break  необязательно:  если
$break не указывать, то после завершения выполнения текущего блока
block? сразу же будет выполняться следующий за ним блок  block?, и
так до тех пор, пока не встретится либо ключевое слово $break, ли-
бо конструкция $endcase.
   4) при использовании ключевого слова $break  обязательно указы-
вать имя конструкции, к  которой  он  относится.  Для  конструкции
$switch это будет выглядеть следующим образом: $break case.
   5) при многократном вложении конструкции $switch ключевое слово
$break case относится к той конструкции, внутри которой  оно  было
указано.


   Ограничения:
   ~~~~~~~~~~~
   1) ограничения на сравниваемые значения - такие же, как для ко-
манды CMP. Хотя бы один из операндов (var или xN) должен  явно оп-
ределять тип сравниваемых данных - byte ptr или word  ptr.  В про-
тивном случае транслятор ассемблера будет фиксировать ошибки, хотя
препроцессор не выдаст при этом никаких сообщений.
   2) за программистом оставлена обязанность следить за соответст-
вием типов (byte ptr или word ptr) сравниваемых значений.


   Возможные ошибки использования:
   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   1) нет завершающей конструкции $endcase.
   2) в строке $switch отсутствует параметр.
   3) несоответствие типов сравниваемых величин (word ptr  и  byte
ptr).
   4) в отличие от подобной конструкции языка Си  в  строке  $case
после параметра xN символ ':' не ставится.
   5) при ключевом слове $break не указан параметр 'case'.

            $switch(al)
                $case 16
                    ...
                    $break      <= ошибка: не указан параметр case
                $case 'A'
                    ...
                    $break case
                $case 'C':      <= ошибка: недопустим символ ':'
                    ...
                $default
                    ...
            $endcase



        Конструкция $WHILE...[$CONTINUE]...[$BREAK]...$ENDIF.
        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Синтаксис:
   ~~~~~~~~~
   полная форма:
   ~~~~~~~~~~~~
   $while (var1 cond1 arg1 [ {$or|$and} var2 cond2 arg2 ])
      ...
      [ {$continue|$break} while ]
      ...
   $endwhile

       var1  - проверяемый регистр или ячейка памяти с любым видом
               адресации
       arg1  - регистр, ячейка памяти с любым видом адресации  или
               константа
       cond1 - условие отношения var1 и arg1
       $or   - логическое ИЛИ для проверки второго необязательного
               условия
       $and  - логическое И для  проверки  второго необязательного
               условия
       var2  - проверяемый регистр или ячейка памяти с любым видом
               адресации
       arg2  - регистр, ячейка памяти с любым видом адресации  или
               константа
       cond2 - условие отношения var2 и arg2


   краткая форма:
   ~~~~~~~~~~~~~
   $while(cond)
      ...
      [ {$continue|$break} while ]
      ...
   $endwhile

       cond  - мнемоника проверяемого бита  регистра  флагов. Если
               соответствующий бит установлен, то  тело  цикла вы-
               полняется. Для выполнения тела цикла  при  условии,
               когда проверяемый бит сброшен, перед cond необходи-
               мо указывать символ 'n' или 'N'.


   Особенности:
   ~~~~~~~~~~~
   1) размер блока программы между $while и  $endwhile  не ограни-
чен.
   2) если при использовании  конструкции  в  качестве  cond1  или
cond2 указать условие Z или NZ (от JZ и  JNZ  соответственно),  то
при проверке условия вместо команды
                          CMP   var,arg
будет использоваться команда
                          TEST  var,arg

   3) недопустимо использование символов пробела внутри каждого из
фактических параметров в строке $while. Например, недопустимо:

                   $while(cs:[si] [bx]  NE al)
                                 ^
   4) при использовании ключевых слов  $continue  и  $break обяза-
тельно указывать имя конструкции, к  которой  они  относится.  Для
конструкции $while это будет выглядеть следующим образом:
                         $break while
                         $continue while

   5) при многократном вложении конструкции $while  ключевые слова
$break while и $continue while относятся к той конструкции, внутри
которой они были указаны.


   Ограничения:
   ~~~~~~~~~~~
   1) в  строке  $while  полной  формы  допускается  использование
только двух проверок, связанных между собой ключевыми  словами $OR
или $AND. В строке $while краткой формы  допускается использование
только одной проверки.
   2) ограничения на сравниваемые значения - такие же, как  и  для
команд CMP и TEST.  Хотя  бы  один  из  операндов  var1(var2)  или
var2(arg2) должен явно определять тип сравниваемых данных  -  byte
ptr или word ptr. В противном случае транслятор  ассемблера  будет
фиксировать ошибки, хотя препроцессор не выдаст при  этом  никаких
сообщений.
   3) за программистом оставлена обязанность следить за соответст-
вием типов (byte ptr или word ptr) сравниваемых значений.


   Возможные ошибки использования:
   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   1) нет завершающей конструкции $endwhile.
   2) в строке $while некорректно заданы параметры.
   3) несоответствие типов сравниваемых величин (word ptr  и  byte
ptr).
   4) при ключевых словах $break и $continue  не  указан  параметр
'while'.



       Конструкция $DO...[$CONTINUE]...[$BREAK]...$ENDDO.
       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Синтаксис:
   ~~~~~~~~~
   полная форма:
   ~~~~~~~~~~~~
   $do
      ...
      [ {$continue|$break} do ]
      ...
   $enddo (var1 cond1 arg1 [ {$or|$and} var2 cond2 arg2 ])


   краткая форма:
   ~~~~~~~~~~~~~
   $do
      ...
      [ {$continue|$break} do ]
      ...
   $enddo (cond)

   Эта конструкция во многом аналогична конструкции $while, поэто-
му подробное описание  ее  использования  не  приводится.  Следует
только помнить, ЧТО ТЕЛО ЦИКЛА $do ВЫПОЛНЯЕТСЯ ДО  ТЕХ  ПОР,  ПОКА
УСЛОВИЕ В СТРОКЕ $enddo БУДЕТ ЛОЖНО !!! Другими словами,  выход из
цикла осуществляется в том случае, если выполнится условие в стро-
ке $enddo.

   Очевидно также, что тело цикла в любом случае  будет  выполнено
хотя бы один раз, так как условие выхода из цикла проверяется пос-
ле его выполнения.



         Конструкция $FOR...[$CONTINUE]...[$BREAK]...$ENDFOR.
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Синтаксис:
   ~~~~~~~~~

   полная форма:
   ~~~~~~~~~~~~
   $for(arg1 cond arg2 [ step ])
      ...
      [ {$continue|$break} for ]
      ...
   $endfor

       arg1  - начальное  значение  счетчика  цикла.   Может  быть
               16-битным регистром, ячейкой памяти  (word  ptr)  с
               любым видом адресации или константой (а для краткой
               формы может быть  и  8-битным регистром или ячейкой
               памяти, но только не константой)
       cond  - условие, которое должно  выполняться  при сравнении
               текущего и конечного значения счетчика  для продол-
               жения работы цикла
       arg2  - конечное значение счетчика, при достижении которого
               цикл прекращает свою работу. Может  быть  16-битным
               регистром, ячейкой памяти (word ptr) с  любым видом
               адресации или константой
       step  - приращение счетчика  (необязательный параметр). Мо-
               жет быть  только  константой  (допустимы  и отрица-
               тельные значения)


   краткая форма:
   ~~~~~~~~~~~~~
   $for(count arg)
      ...
      [ {$continue|break} for ]
      ...
   $endfor

         arg - начальное значение счетчика цикла. Может быть любым
               регистром, ячейкой памяти с любым  видом адресации,
               или константой
       count - счетчик, который может  быть  любым  регистром  или
               ячейкой памяти с любым видом адресации


   Особенности:
   ~~~~~~~~~~~
   1) ДЛЯ ПОЛНОЙ ФОРМЫ $for:
   ■ в качестве счетчика используется регистр CX, а для хра-
     нения его текущего значения во время работы  тела цикла
     используется стек. Если в качестве arg2  также указыва-
     ется регистр, то и он на временя работы  цикла сохраня-
     ется в стеке. Оба эти действия выполняются неявно, т.е.
     при написании исходного текста программисту  не следует
     явно сохранять значения arg1 и arg2, это забота препро-
     цессора. Однако будьте очень внимательны при выполнении
     команды $break внутри тела цикла: перед строкой, содер-
     жащей команду $break, необходимо восстановить указатель
     стека SP в состояние, каким оно было при ВХОДЕ  В ЦИКЛ.
     Добивайтесь этого балансом команд типа  POP  или  явным
     изменением регистра SP.
        При использовании команды $continue также необходимо
     предварительно восстановить значение SP в состояние, ка-
     ким оно было при ВХОДЕ В ТЕЛО ЦИКЛА  (обратите внимание
     на разницу между понятиями "вход в цикл" и "вход в тело
     цикла").

   ДЛЯ КРАТКОЙ ФОРМЫ $for:
   ■ в качестве счетчика могут использоваться 8- или 16-бит-
     ные регистры или ячейки памяти с любым видом адресации.
     При этом обязанность следить за  сохранностью  счетчика
     оставлена за программистом.  При  использовании  команд
     $continue и $break внутри тела цикла не  забывайте  при
     необходимости осуществлять корректную  установку указа-
     теля стека.

   2) размер блока программы между $for и $endfor не ограничен.
   3) недопустимо использование символов пробела внутри каждого из
фактических параметров в строке $for. Например, недопустимо:

                     $for(cs:[si] [bx] NE 64)
                                 ^
   5) при использовании ключевых слов  $continue  и  $break обяза-
тельно указывать имя конструкции, к  которой  они  относится.  Для
конструкции $for это будет выглядеть следующим образом:
                          $break for
                          $continue for

   6) при многократном вложении конструкции  $for  ключевые  слова
$break for и $continue for относятся к той конструкции, внутри ко-
торой они были указаны.

   7) если в строке $for указан параметр step, то приращение счет-
чика будет осуществляться на его величину. В противном случае при-
ращение счетчика принимается равным единице. Значения  step  могут
быть и отрицательными числами.  При  использовании  краткой  формы
$for число итераций цикла определено значением аргумента arg1, над
которым осуществляется декремент при каждой итерации.


   Ограничения:
   ~~~~~~~~~~~
   1) за программистом оставлена обязанность следить за тем, чтобы
arg1 и arg2 были 16-битными данными (для полной формы цикла).
   2) в качестве начального и конечного значения  счетчика  полной
формы цикла могут быть только положительные числа в пределах  от 0
до 32767 включительно. Дело в том, что старший бит счетчика резер-
вируется для отслеживания выхода за  пределы  допустимых  значений
при приращении счетчика.
   3) если Вы используете краткую форму $for, то значения счетчика
могут находиться в диапазоне от 0 до 65535 при  16-разрядном счет-
чике и в диапазоне от 0  до  255  при  использовании  8-разрядного
счетчика. При использовании краткой формы  цикла  $for  необходимо
следить за тем, чтобы хотя бы один из аргументов (count  или  arg)
имел явно определенный тип данных.


   Возможные ошибки использования:
   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   1) нет закрывающей конструкции $endfor.
   2) в строке $for некорректно заданы параметры.
   3) arg1 и/или arg2 - не 16-битные данные (для полной формы цик-
ла).
   4) при ключевых словах $break и $continue  не  указан  параметр
'for'.
   5) в качестве параметра step задана не константа.
   6) некорректное использование $continue for  и/или  $break  for
(несоблюдение баланса между командами типа PUSH и POP  внутри тела
цикла).
   7) значения arg1 и/или arg2 выходят за пределы допустимых, т.е.
либо меньше 0, либо больше 32767 (для полной формы цикла).



                 Как использовать препроцессор.
                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   Использование препроцессора предельно просто. Для запуска преп-
роцессора в командной строке нужно указать:

                 PREASM  source  [ destination ]

    где:
         source - имя файла с исходным текстом программы (по умол-
                  чанию предполагается расширение .PRE)
    destination - имя результирующего файла с текстом программы на
                  языке  ассемблера  (по умолчанию  предполагается
                  расширение .ASM)

   Для управления ходом генерации ассемблерного  текста  программы
препроцессор допускает использование директив. Их всего две, .LONG
и .SHORT, и предназначены они для оптимизации  использования пере-
ходов внутри управляющих конструкций. Дело в том, что  размер бло-
ков   команд,   заключенных   между   ключевыми    словами    типа
begin_structure и end_structure, может быть меньше 128  байт, поэ-
тому  целесообразнее  применять  в  таких  конструкциях   короткие
(SHORT) переходы. Директива .SHORT как раз и служит  для  этих це-
лей. Указывать эту директиву необходимо в  исходном  тексте  перед
началом той управляющей конструкции, которую Вы  желаете оптимизи-
ровать. ПОМНИТЕ, ЧТО ДЛЯ КАЖДОЙ КОНКРЕТНОЙ  УПРАВЛЯЮЩЕЙ  СТРУКТУРЫ
МОЖЕТ ИСПОЛЬЗОВАТЬСЯ ТОЛЬКО ОДИН  ТИП  ПЕРЕХОДОВ.  Поэтому  будьте
внимательны при манипулировании директивами .SHORT и .LONG (обрат-
ная директиве .SHORT; принимается по умолчанию), так  как действие
директив носит глобальный характер. Это  ограничение  не  помешает
Вам оптимизировать другие управляющие структуры, вложенные  по от-
ношению к текущей, однако Вам необходимо будет  после завершающего
оператора каждой из таких конструкций  восстанавливать  предыдущее
состояние  применяемых  переходов.  Например,  фрагмент  исходного
текста

             ...
             .LONG
     ┌─────> $if(ax NE 12)
     │          ...
     ├─────> $else
     │          .SHORT
     │    ┌───> $while(cx LE 200)
     │    │        ...
     │    └───> $endwhile
     │          ...
     └─???─> $endif
             ...

содержит ошибку: после ключевого слова $endwhile не указана дирек-
тива .LONG, восстанавливающая предыдущее состояние применяемых пе-
реходов. Препроцессор при обработке подобных фрагментов  не выдаст
никаких сообщений об ошибках, однако на этапе трансляции результи-
рующего текста транслятор-ассемблер выдаст сообщения о несуществу-
ющих метках.

   ПОМНИТЕ ТАКЖЕ ОБ ОЧЕВИДНОМ СЛЕДСТВИИ ИЗ СКАЗАННОГО  ВЫШЕ: НЕДО-
ПУСТИМО ПРИМЕНЕНИЕ КОНСТРУКЦИЙ С LONG-ПЕРЕХОДАМИ  ВНУТРИ КОНСТРУК-
ЦИЙ С SHORT-ПЕРЕХОДАМИ (разумеется, если фактический размер блоков
программы, заключенных между конструкциями типа  begin_structure и
end_structure, превышает 128 байт).


                  Формат обработанного текста.
                  ~~~~~~~~~~~~~~~~~~~~~~~~~~~
   Препроцессор, формируя выходной файл, форматирует  его  в соот-
ветствии с некоторыми правилами, оговоренными в настоящем разделе:

   1) строки исходного текста, содержащие ключевые слова, пере-
      носятся в результирующий файл в виде комментариев.

   2) строки результирующего файла, содержащие расшифрованные в
      терминах ассемблера управляющие конструкции, начинаются с
      той же позиции, что и строка с  соответствующим  ключевым
      словом в исходном  файле.  Таким  образом  результирующий
      файл  сохраняет  все  особенности   структуры   исходного
      текста.

   3) строки исходного  текста,  содержащие директивы  .SHORT и
      .LONG, в результирующий файл не переносятся.

   4) остальные строки исходного текста переносятся в результи-
      рующий файл без изменений.

   Вышеизложенные правила помогут Вам быстрее разобраться в струк-
туре результирующего файла при  проведении  анализа  обработанного
препроцессором исходного текста.


                      Сообщения об ошибках.
                      ~~~~~~~~~~~~~~~~~~~~
   В ходе обработки исходного текста препроцессор  детектирует на-
личие некоторых типов ошибок, перечень  которых  приводится  ниже.
Сообщения об ошибках выдаются на экран и одновременно  заносятся в
выходной файл непосредственно за строкой, в которой эта ошибка бы-
ла обнаружена.

   Ошибки подразделяются на три группы:

     1) фатальные ошибки, после которых  дальнейшая трансля-
        ция исходного текста становится  нецелесообразной. К
        этой группе относятся ошибки  превышения установлен-
        ной вложенности  управляющих  структур.  Практически
        при грамотном построении тела программы  вероятность
        появления такой ошибки равна нулю, так  как  уровень
        вложенности КАЖДОЙ  из  управляющих  структур  равен
        512, что с избытком перекрывает все разумные пределы
        вложения структур. Тем  не менее препроцессор, обна-
        ружив подобную ошибку, выдает сообщение:

        "<имя_структуры>: inadmissible nesting level"
        ("<имя_структуры>: недопустимый уровень вложения")
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        и прекращает работу.

     2) нефатальные ошибки, появление которых не  влияет  на
        логику построения программы в целом. К  этой  группе
        относятся следующие ошибки:

     "Unknown keyword"
     ("Незнакомое ключевое слово")
      ~~~~~~~~~~~~~~~~~~~~~~~~~~~
        Появляется в случае, если оператор  исходного текста
        программы, начинающийся с символа '$', не  входит  в
        перечень ключевых слов,  обрабатываемых препроцессо-
        ром. Допустимыми для препроцессора  являются следую-
        щие ключевые слова:

 |~~~~~~~~|~~~~~~~~~~~|~~~~~~~~|~~~~~~~~~~|~~~~~~~~~|~~~~~~~~~~~|
 | $if    | $while    | $do    | $switch  | $for    | $break    |
 | $else  | $endwhile | $enddo | $case    | $endfor | $continue |
 | $endif |           |        | $default |         |-----------|
 |        |           |        | $endcase |         | $or       |
 |        |           |        |          |         | $and      |
 |        |           |        |          |         |           |
 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

 /========================= ВНИМАНИЕ ! =========================\
 |  Строка, содержащая ключевое слово, должна начинаться именно |
 |  с него.  В противном случае препроцессор не обработает  эту |
 |  строку (со всеми вытекающими последствиями).                |
 \--------------------------------------------------------------/

     "Bad parameters"
     ("Неверные параметры")
      ~~~~~~~~~~~~~~~~~~~~
        Появляется  в  случае,  если  в  строке  $if,  $for,
        $while, $switch или $enddo неверно заданы или вообще
        отсутствуют один или несколько параметров.


     "Bad condition"
     ("Неверное условие")
      ~~~~~~~~~~~~~~~~~~
        Появляется  в  случае,  если  в  строке  $if,  $for,
        $while, $switch или $enddo  неверно  заданы  условия
        сравнения операндов.


     "Unnecessary operator <имя_структуры>"
     ("Лишний оператор <имя_структуры>")
      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        Появляется в случае, если препроцессор в ходе транс-
        ляции  обнаружил  лишний  оператор  $else,   $endif,
        $endcase,  $endwhile,  $endfor,  $enddo,  $continue,
        $break или $default.


     3) ошибки, связанные с системными  ресурсами компьютера
        и не зависящие от исходного текста программы: причи-
        на возникновения этой ошибки  -  недостаточное коли-
        чество свободного ОЗУ  для  функционирования препро-
        цессора. При этом выдается сообщение:

                      "Insufficient memory"
                       ~~~~~~~~~~~~~~~~~~~


                        Немного о разном.
                        ~~~~~~~~~~~~~~~~
   При нормальном завершении трансляции препроцессор устанавливает
значение внутренней переменной DOS Errorlevel равным 0. Если в хо-
де трансляции препроцессор обнаружил ошибки в исходном  тексте, то
переменная Errorlevel устанавливается  равной  числу  обнаруженных
ошибок.

   Возможны также следующие варианты:

     1) если препроцессор был запущен без параметров, то вы-
        дается короткая подсказка по формату командной стро-
        ки и управление передается DOS.  Значение Errorlevel
        при этом устанавливается равным 100.

     2) если в командной строке указано только одно имя фай-
        ла, и это имя имеет расширение .ASM, то препроцессор
        выдает сообщение:

        "Inadmissible extension .ASM in source file"
        ("Недопустимое расширение .ASM в исходном файле")
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        После этого препроцессор завершает  работу, устанав-
        ливая значение Errorlevel равным 101.

     3) если в командной строке имена исходного  и результи-
        рующего файлов совпадают, то препроцессор выдает со-
        общение:

        "Coincidence names of files"
        ("Совпадение имен файлов")
         ~~~~~~~~~~~~~~~~~~~~~~~~
        Управление передается DOS. Значение  Errorlevel  при
        этом устанавливается равным 102.

     4) если препроцессор не может открыть исходный файл, то
        Errorlevel устанавливается равной 103, если не может
        создать результирующий файл - то 104. При этом преп-
        роцессор выдает на экран сообщение:

        "Cannot open <имя_файла>"
        ("Не могу открыть <имя_файла>")
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        и завершает свою работу.


                          Заключение.
                          ~~~~~~~~~~
   Представляемый препроцессор прежде всего был задуман как лекар-
ство от головной боли, неизменно сопровождавшей автора при написа-
нии ассемблерных программ (уверен, что то же испытывают  и  другие
поклонники ассемблера). Уверяю Вас, что  это  лекарство  оказалось
достаточно эффективным. И хотя препроцессор еще довольно  далек от
совершенства в силу ограничений, налагаемых  на  использование уп-
равляющих конструкций, отсутствия автоматической  оптимизации кода
и семантического анализа применяемых в конструкциях  выражений,  в
целом он зарекомендовал себя удобным и в  достаточной  степени на-
дежным инструментом для написания  структурированных  программ  на
языке ассемблера. С помощью препроцессора автором был  написан ряд
программ различного назначения, в том числе и  драйвер русификации
экрана и клавиатуры для IBM PC/XT/AT RKSD.COM.


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    Предлагается считать настоящую программу  SHAREWARE.  Желающие
могут перечислить некоторую денежную сумму  (на  Ваше  усмотрение)
почтовым переводом по адресу, указанному в начале этого документа,
и сообщить свои координаты. После этого Вы становитесь зарегистри-
рованным пользователем представляемого  программного  продукта  со
всеми вытекающими отсюда последствиями. Заранее благодарен.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
