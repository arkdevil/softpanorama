


                                  С++


          С++ -  это сравнительно новый универсальный язык программирова-
      ния фирмы АТ&Т Bell Laboratories (распространяется с 1983 года) [1,
      2, 3, 4],   реализованный как препроцессор к компилятору с языка С,
      чем обеспечивается его мобильность и благодаря чему  он  становится
      очень распространенным. Будучи надмножеством языка С, С++ с успехом
      используется во множестве приложений: СУБД, САПР, построении компи-
      ляторов,  графике,  сетях, моделировании и т.д. - с не меньшим, чем
      язык С.

           С++ унаследовал  такие важные черты,  как гибкость,  эффектив-
      ность,  мобильность,  в то же время повысив строгость  статического
      контроля типов. Программист, вводя новый тип данных (или класс объ-
      ектов),  наряду с этим должен в большинстве случаев  самостоятельно
      определять  допустимые неявные преобразования типов,  имеет возмож-
      ность задать для новых типов такие детали обработки, которые в дру-
      гих  языках  программирования имеют априорный смысл:  присваивание,
      равенство объектов, создание и уничтожение объектов. Наряду с обыч-
      ными  процедурами предусмотрены открытые подстановки процедур. Эти,
      а также некоторые другие элементы языка,  о которых  рассказывается
      ниже,  делают С ++ очень мощным программистским инструментом,  спо-
      собствуют написанию качественно структурированных программ при сох-
      ранении высокой степени их эффективности.

          Средства модульности языка С++ основаны на прагматической  кон-
      цепции модульности языка С. Фрагменты программы (процедуры, опреде-
      ления данных,  описания новых типов) могут быть  рассредоточены  по
      отдельно  компилируемым  модулям-файлам.  Учет  необходимого общего
      "описательного"  контекста  достигается  формированием  специальных
      файлов,  содержащих заголовки описаний и включаемых в компилируемый
      модуль-файл с помощью макрооператора #INCLUDE языка С.

           Программист имеет полные возможности введения новых типов дан-
      ных посредством описания классов как совокупности агрегата данных и
      процедур - операций над ними. В отличии от таких, теперь уже старых
      языков,  как СИМУЛА-67,  наряду с языком С,  послужившим прототипом
      для С++,  здесь можно определить операции над объектами новых типов
      не менее эффективно,  чем это сделано в компиляторе встроенных  ти-
      пов. Этому способствует возможность манипулирования собственно объ-
      ектами, а не обязательно ссылками на них, а также возможность опре-
      делить  доступ  к  внутренним  полям объекта,  обычно очень простое
      действие, через посредство открытой подстановки процедур.

           Предусмотрена возможность  "прегрузки"  определения процедур с
      разнотипными параметрами.

           Интересным средством     управления     видимостью    являются
      friend-процедуры. Например,

                  class complex
                      {double re, im;
                          . . . . .
                       friend complex plus (complex,complex);
                          . . . . .
                       }
                  complex plus (complex z1, complex z2)
                       {return complex (z1.re+z2.re, z1.im+z2.im)}

           Из приведенного примера видно,  что friend-процедуры позволяют
      отложить определение тела процедуры,  вынеся его за пределы опреде-
      ления класса, обеспечив при этом видимость идентификаторов внутрен-
      них полей класса внутри определяемого тела (естественно,  в обычных
      случаях идентификаторы полей вне класса невидимы).  Такая форма уп-
      равления видимостью имеет то преимущество,  что одна и та же проце-
      дура  может  иметь доступ к полям объектов сразу нескольких классов
      при условии ее предописания в них как friend-процедуры.

           Отметим также,  что имеется особая разновидность процедур, на-
      зываемых в языке операциями,  определение которых позволяет  ввести
      знаковое обозначение операций и инфиксную форму записи выражений.

           Компилятор с языка С++ преодолевает  присущий  языкам  с  абс-
      трактными  типами данных недостаток,связанный с тем ,  что совокуп-
      ность процедур, определенных в проблемно-ориентированной надстройке
      языка, как правило много больше, чем это требуется в конкретной це-
      левой программе.  С целью экономного расходования  памяти  ненужные
      сегменты процедур удаляются.

           Язык С++ имеет средства наследования  классов  (множественного
      типа) и виртуальных процедур,  что определяет его в полной мере как
      язык объектно-ориентированного программирования. Например,

                  class shape
                       { . . . . . .
                         virtual void rotate (int);
                         . . . . . .
                       }
                   class circle: public shape
                       { . . . . . .
                         void rotate (int)  { }
                         . . . . . .
                       }

           В данном  примере показано определение класса shape обобщенных
      геометрических фигур с заготовкой операции поворота,а  также circle
      разновидности  фигур,наследующего свойства класса shape.  Здесь уже
      присутствует конкретизация виртуальной процедуры rotate как пустого
      действия для окружностей.  Очевидно,  для другой разновидности гео-
      метрических фигур,  скажем, квадрата, такая конкретизация будет ме-
      нее тривиальной.

           Пользователь языка С++ фактически остается также программистом
      на языке С.  Более того,  утверждается, что вновь вводимые средства
      языка С++ следует использовать в разумных пределах,  исходя из  су-
      щества задачи программирования.

           В языке С++ не включено ничего,  что могло  бы  препятствовать
      следованию  традиционной  технологии с использованием компилятора с
      языка С и редактора связей.

           При очевидных  преимуществах предлагаемого языком С++ "мягкого"
      перехода от языка С здесь имеются и некоторые недостатки.  В  част-
      ности, поскольку в языке С нет средств обработки исключительных си-
      туаций,  отвечающих современным требованиям,  нет их и в С++.  Пос-
      кольку  во главу угла в языке С+ + ставится вопрос эффективности, в
      нем, несмотря на большую строгость статического контроля по отноше-
      нию к С,  имеются элементы ненадежности программирования. Так, пре-
      образование ссылки на объект надкласса к ссылке на объект подкласса
      (например,  при необходимости рассмотрения ссылки на геометрическую
      фигуру вообще как ссылки на окружность конкретно) не сопровождается
      динамическим контролем правомочности такого преобразования. Послед-
      ний, если есть подозрения, должен явно программироваться. (Следует,
      однако,  отметить,что  средство виртуальных процедур в значительной
      степени исключает необходимость таких преобразований).  Кроме того,
      на  программиста  ложится  ответственность  надежного использования
      ссылок на объекты, распределяемые в памяти вида "куча", так как уп-
      равление этой памятью, а точнее, освобождение ее от ненужных объек-
      тов должно программироваться явно.

          Распространенность языка С способствует широкому освоению языка
      С++,  благодаря их в значительной степени единой концептуальной ос-
      нове,  однако  в то же время язык С++ как и С остается языком прог-
      раммирования для квалифицированных  специалистов.  Он  легко  может
      быть приспособлен в целях расширения концептуальной базы, но не для
      разумного ее сужения до специализированной области приложения.

           Наряду  с  большими  запасами разработанных библиотек пакетов
      процедур на языке С для языка С++ на  основе  ОС  UNIX  разработана
      библиотека классов для поддержки объектно-ориентированного програм-
      мирования   (ООРS),   аналогичная   широко   известной   по   языку
      SMALLTALK-80 [5]. Сюда входят многочисленные определения классов (и
      подклассов) вторичных типов данных (с плавающей запятой, рациональ-
      ные дроби,  комплексные числа),  часто используемых структур данных
      (списки,  множества, ассоциативные множества, массивы), службы вре-
      мени и многое другое.

           OOPS включает также определение сопроцессов  и  операторов  их
      взаимодействия.  Реализация  этих средств не может быть выражена на
      языке С++ и частично выполнена на ассемблере.  Простейшие примитивы
      взаимодействия  основываются на определении класса объектов-семафо-
      ров. В любой момент времени в программе выполняется не более одного
      сопроцесса.  Текущий сопроцесс не прерывается и передает управление
      другому сопроцессу,  например, в результате ожидания открытия сема-
      фора.

           Более развитая форма взаимодействия сопроцессов осуществляется
      через буферную очередь,  представляющую собой массив ссылок на объ-
      екты,  выступающие в роли передаваемых сообщений.  Доступ к очереди
      регулируется парой семафоров (очередь пуста,  очередь заполнена). В
      некоторых реализациях предусмотрены возможности  обработки  внешних
      прерываний  ОС UNIX в виде помещения сообщений в буферную очередь и
      возбуждения сопроцесса-читателя,  если текущий сопроцесс отсутству-
      ет.

           Как видно из описанного,  язык С++ обладает всеми необходимыми
      средствами для использования его в качестве языка имитационного мо-
      делирования систем с дискретными событиями. Достаточно сказать, что
      он  полностью покрывает возможности такого традиционного в этой об-
      ласти языка, как СИМУЛА-67.

         Kак указывается в исторической справке, язык С++ был разработан
      как усовершенствование первоначального проекта " язык С++ с класса-
      ми" , который, в свою очередь, был создан как переосмысление СИМУЛЫ
      -67 приверженцами языка С.  значительно более эффективного, в связи
      с  ведшимися в АТ&T Bell Laboratories работами в области имитацион-
      ного моделирования.

           Библиотека классов   для  поддержки  объектно-ориентированного
      программирования является относительно более поздним  дополнением к
      языку С++.  Собственно язык не содержит средств квазипараллельности
      и подразумевает событийную концепцию моделей систем  с  дискретными
      событиями (не процессную).

           В целом следует полагать, что язык С++ может стать в ближайшее
      время наиболее популярным в области моделирования, противопоставляя
      вызвавшему интерес языку  SMALLTALK-80  значительно  более  высокую
      степень эффективности.


                           ЛИТЕРАТУРА.

          1. Gordon G.  System Simulation,  Muncher-Wien,  Oldenbourg,
      1972.

          2. Gorlen K.  An Object-Oriented Class Library for C++ Programs
      // Software - Practice and Experience,- Vol 17, No 12.- 1987.- pp.
      899-922.

          3. Stroustrup  B.  What is Object-Oriented Programming?// IEEE
      Sofftware.-1988.-Vol.5, N 3.-p. 10-20.

          4. Stroustrup  B.  A Better C?// Byte.1988.- Vol 13,  N 8.- p.
      215-216 .

          5. Goldbera A.,  Robson D., Ingalls SMALLTALK 80: the Language
      and its Implementation // BYTE.- 1981.- Vol.6,N8,- p 189-211

