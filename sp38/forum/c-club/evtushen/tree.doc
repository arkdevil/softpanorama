   ▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒ Elisoft Computer Group  Presents ▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒

			    About Tree.

	Программы представленые здесь имеют одну общую черту,
    а именно : в основе каждой из них лежит простой и достаточно 
    эффективный алгоритм рекурсивного обхода подкаталогов.

	Рассмотрим этот алгоритм. Основная структура данных
    выглядит так:
	typedef struct dir
	{
        	char DirName[14];
	        struct dir *Right;
        	struct dir *Down;
	} 
	Dir;
    Где указатель Down служит для связывания подкаталогов в текущем
    каталоге, а указатель Right указывает на подкаталоги которые
    имеюся в подкаталоге DirName , т.е. в памяти после сборки
    дерева получается примерно такая картина:
    
	 ┐
 	Right ───┐
 	Down    Right ── NULL
 	 │      Down  ── NULL
 	Right ───┐
 	Down    Right ───┐
 	 │      Down    Right ───┐
	 │	 │ 	Down    Right ── NULL
	 │	 │ 	 │      Down
	 │	 │	 │	 │
	 │	 │	 │	Right ───┐
	 │	 │	 │	Down    Right ── NULL
	 │	 │	 │	 │	Down  ── NULL
	 │	 │	 │	NULL
        ....    ....    ....
    Такая структура данных приводит к тому что дерево также 
    просто вывести на экран как и собрать,то есть с помощью рекурсивной 
    процедуры.Рассотрим например функцию recurser из etree2.
    Эта функция производит сборку дерева и одновременно выводит
    его на экран:
Dir * recurser(void)
{
	Dir *d,*t;
	Level++;	// Текущий уровень вложенности (глобальная переменная)
	d=one_dir_scan();// получаем список подкаталогов на текущем уровне
	t=d;		// запомним,этот указатель еще пригодится
	while(d)	// пока не NULL
	 {
		strcpy(tmp,Template);
/*
Template содержит шаблон такого вида: "│___│___│..."( '_' означает пробел)
вначале он сидержит только пробелы,затем в,зависимости от того
есть ли еще подкаталоги на текущем уровне,заполняется либо '│',либо пробелом.
*/
		tmp[Level*3]=(d->Down) ?'├':'└';
		tmp[Level*3+1]='─';
		tmp[Level*3+2]='─';
		Template[Level*3]=(d->Down) ?'│':' ';
		strcpy(&tmp[(Level+1)*3],d->DirName);
		puts_dos(tmp);
		puts_dos("\r\n");
		chdir(d->DirName);// перейдем в этот подкаталог
		d->Right=recurser();// и вызовем себя
		chdir("..");// вернемся назад
		d = d->Down;// берем следующий в списке
	 }
	Level --;
	return t;
}
Dir * one_dir_scan(void)// сборка дерева "вниз"
{
	struct ffblk ffblk;
	int done;
	Dir *d,*t;

	d=t=NULL;
	done = findfirst("*.*",&ffblk,0x10);// Все с атрибутом FA_DIREC
	while(!done)
	 {
		if(ffblk.ff_name[0] !='.' && ffblk.ff_attrib == 0x10)
		 { // если имя начинается не с точки
			if(!d) // Если указатель пустой 
			 {
				d = (Dir *)malloc(sizeof(Dir));
				t = d;
			 }
			else
			 {
				d->Down  = (Dir *)malloc(sizeof(Dir));
				d        = d->Down;
			 }
			d->Right = NULL; // во избежания неприятностей
			d->Down  = NULL; // обнулим оба указателя
			strcpy(d->DirName,ffblk.ff_name);
			all_dirs++;
		 }
		done = findnext(&ffblk);
	 }
	return t;
}
	Вот,пожалуй,и весь алгоритм.С некоторыми вариациями он лежит
    в основе всех представленых программ.
    ───────────────────────────────────────────────────────────────────────
    Некоторые подробности:
	Программы ETREE,ETREE1,ETREE2 выводят дерево текущего диска
	    на экран.
	Программы FIFI и FIFI2 осуществляют поиск файлов по маске
	    на всех устройствах начиная с C. Замечание:
	    программы могут не находить некоторых устройств если
	    в назначении логических имен имеются пропуски,например
	    существуют устройства C и D, а с помощью SUBST назначается
	    устройство F.
	    По скорости не уступает WHERE.COM.
	    		                            тм
	Программа ECD аналог Norton Change Directory
	    Принципиальная разница только в том,если конечно не считать
	    разницу в размере,что в ECD не предусмотрена возможность 
	    перехода на другие диски.
									 тм
	Все программы написаны и отлажены в среде Borland C++ Version 2.0.
	Окончательная компиляция производилась с помощью компилятора BCC.
				тм
	Прогон на Turbo Profiler   показал что вызовы функций 
	findfirst и findnext занимают порядка 85% всего времени работы
	программы,(соответственно 11% и 74%) еще порядка 4% "съедает"
	chdir. То есть существенного увеличения скорости можно попытаться 
	добиться прямым чтением ROOT DIR и подкаталогов. Ценой за это будет
	существенно больший размер программы.
    ───────────────────────────────────────────────────────────────────────
    Будут вопросы,звоните #(044)-442-69-88 ,пожалуйста не позже 20.00
	    Евтушенко Сергей.
