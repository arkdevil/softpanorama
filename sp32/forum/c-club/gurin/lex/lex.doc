                    Краткое справка по генератору
                      лексических анализаторов

Оригинальная версия генератора  - M.E. Lesk and E.Schmidt.

Модификация для русской лексики - Гурин С.В.
  (Томск, политехнический институт, кафедра электрических станций
   тел. 492-507)

Вызов Lex-программы
   lex [-v] имя   - ключ v формирует выдачу сообщения о действительных
                    размерах массивов

Формат исходного текста Lex-программы
               {определения}
               %%
               {правила}
               %%
               {пользовательские подпрограммы}

Правило содержит левую часть - регулярное выражение, разделитель - пробел и
правую  часть   -  си-фрагмент,   реализующий  действие,    соответствующее
регулярному  выражению.  Сложное  выражение  записывается  как  блок  {  },
простое завершается ;.

Операторные символы регулярных выражений
      " \ [ ] ^ - ? . * + | ( ) $ / { } % < >
Операторные символы, используемые как текстовые должны предваряться \.
Символы табуляции и новой строки записываются по Си-соглашению.

Классы символов определяются  в [ ].  В квадратных скобках  как операторные
используются только три символа
  \ - ^
  -  означает диапазон, например [a-z], знак - как текстовый символ
     записывается первым
  ^  записывается после [ и означает исключение перечисленных символов
     из полного набора символов, например [^0-9] - нецифра
  \  используется для экранирования символов ^ \ [ ]

Операторные символы:
  "   символы " ограничивают строку символов, непоследственно задаваемых в
      регулярном выражении
  .   любой символ кроме \n
  ?   выражение перед ? не является обязательным
  *   выражение перед * может повторяться 0 и более раз
  ()  скобки используются для группирования выражений
  |   альтернативный оператор "или"
  ^   если ^ первый символ выражения, то оно будет распознаваться только
      в контексте начала строки
  $   если $ последний символ выражения, то оно будет распознаваться только
      в контексте конца строки
  /   выражение перед / распознается в контексте выражения, записываемого
      за /. Например, ab/cd, ab распознается, если в исходном тексте будет
      находиться перед cd
  <x> правило, следующее за этим префиксом распознается, если
      Lex-интерпретатор находится в стартовом условии x
  {x} предопределенное в начале программы понятие подставляется в тело
      регулярного выражения, x это имя понятия
  {число1,число2} определяет коэффициент повторения предшествующего
                  выражения, например, а{1,6} означает, что а может
                  повториться от 1 до 6 раз
  %  используется как ограничитель частей Lex-программы

Действия.
  Действием  по  умолчанию  для  неопределенных лексем является копирование
входа  на  выход.  Пустое  действие  ; означает игнорирование распознанного
регулярного выражения и переход к распознаванию следующего.

  - Распознанная лексема помещается в буфер, именуемый yytext.
  - Для передачи буфера на выход определена процедура ECHO.
  - Длина распознанной лексемы хранится в yyleng. Доступ к последнему
    распознанному символу лексемы: yytext[yyleng-1].
  - Функция yymore() позволяет добавить следующую лексему к уже
    находящейся в буфере.
  - Функция yyless(n) позволяет оставить в буфере лексемы n символов и
    вернуть остальные символы во входной поток, стандартная библиотека
    позволяет возвращать до 100 символов.
  - Функция input() возвращает очередной входной символ, в конце файла
    возвращается 0.
  - Функция output(с) передает символ с на выход.
  - Функция unput(с) возвращает символ с во входной поток.
  - Функция  yywrap() вызывается  при достижении  конца файла,  стандартная
    Lex библиотека содержит  пустую функцию yywrap()  - она просто  возвра-
    щает 1, в  этом случае процесс  анализа завершается. Повторить  процесс
    анализа для нового входного  потока можно если написать  функцию, пере-
    устанавливающую входной поток и возвращающую 0.

Разрешение многозначных правил:
  - из нескольких удовлетворенных правил вибирается лексема, имеющая
    наибольшую длину
  - если длины лексем одинаковы, выбирается правило, определенное выше по
    исходному Lex тексту
  - Процедура REJECT возвращает символы во входной поток и переводит
    интерпретатор к обработке альтернативного удовлетворяющегося правила

Определения
   Программный фрагмент,  начинающийся после  первого разделителя  %% перед
первым правилом, каждая строка которого начинается с пробела или  табуляции
вносится  в  секцию  определений  Lex-функции,  содержащей действия. Другим
способом  введения  фрагмента  является  его  обрамление  скобками %{ и %}.
Третья часть Lex-программы (после второго разделителя %%) копируется  после
сгенерированного текста без  изменений. Программные фрагменты,  обрамленные
%{ и %} в первом разделе включаются в сгенерированный текст перед функцией,
содержащей действия.

Определения понятий для подстановки в правила имеют вид:
    имя определение   (имя должно начинаться с первой позиции в строке)
Имя подставляется в правило в виде {имя}.

Левый контекст - стартовые условия
Описание стартовых условий:
     %S имя1 имя2 ...   (начинается с первой позиции строки
                             в конце первого раздела Lex-программы)
Введение стартовых условий
     <имя>правило действие  (начинается с первой позиции строки)
Переход к стартовому условию:
     BEGIN имя;             (при описании действий)
Переход к начальному стартовому условию
     BEGIN 0;
Описание правила, которое выполняется при различных стартовых условиях:
     <имя1,имя2..>правило действие
Правило не имеющее префикса стартового условия активно всегда.

Набор символов
  Таблица используемых символов дается в первой секции в виде
     %T                (начинается с первой позиции строки)
     целое символы
     .....
     %T
  Здесь целому числу ставится в соответствие один или несколько символов.
  По этим целым эквивалентам символы из входного потока будут
  идентифицироваться.

Задание размеров внутренних массивов
    %x  размер_массива
     p  positions
     n  states
     e  tree nodes
     a  transitions
     k  packed character classes
     o  output array size

Отличие от оригинальной  версии состоят в  том, что в  лексических правилах
можно использовать символы  русского алфавита (используется  альтернативная
кодировка символов)  и применять  русские идентификаторы  для задания  имен
правил.

Прим: - сообщения LEX'а выдаются на русском языке
      - в  выходную  си_программу  данная  версия  LEX'а   вводит прототипы
        используeмых  функций,  поэтому  си-трансляция  не   сопровождается
        предупреждениями, как в оригинальной версии
      - выходную си-программу нужно компилировать компилятором tcc с ключом
        -K

В качестве примера приведен блок лексического анализатора препроцессора
русской лексики rcc, разработанного мной для языка Си.

%E 600
%P 1300
%N 200
%K 150
%A 3200
%O 4500
рус_бук        [А-Яа-пр-я_]
лат_бук        [A-Za-z_]
рус_бук_циф    [А-Яа-пр-я_0-9]
лат_бук_циф    [A-Za-z_0-9]
бук            [A-Za-z_А-Яа-пр-я]
бук_циф        [A-Za-z_А-Яа-пр-я0-9]
число          [0-9]+
лат_идент      {лат_бук}{лат_бук_циф}*
рус_идент      {рус_бук}{рус_бук_циф}*
смеш_идент     {бук}{бук_циф}*
ком_лат_идент  {лат_идент}'{смеш_идент}
ком_рус_идент  {рус_идент}'{смеш_идент}
ком_смеш_иден  {смеш_идент}'{смеш_идент}
литера         '{рус_бук}'
пробел         (" "|\t)
строч_коммент  "//".*
метасимволы    "::="|"::"|"<=>"|"=>"
равно          "равен"|"равна"|"равно"
неравно        "неравен"|"неравна"|"неравно"
определить     ^#({пробел}*)?("константа"|"определить"|"синоним"|"понятие")
отменить       ^#({пробел}*)?"отменить"
если           ^#({пробел}*)?"если"
иначе          ^#({пробел}*)?"иначе".*
конец          ^#({пробел}*)?"конец".*
макро          ^#({пробел}*)?"макро"
включить       ^#({пробел}*)?"включить"{пробел}+(\<|\")
defined        "определен"|"определена"|"определено"
кон_им_файла   (\>|\").*
%{
static int level_nest_comment = 0;
static int flag_macro         = 0;
static int level_nest_brace   = 0;
#include <dir.h>
#include <string.h>
#include "rccdef.h"
void rus_ident(void);
%}
%S src com inc str ind
%%
%{
register char *p;
static char buf[MAXPATH];
BEGIN src;
%}
<src>"{"             { out("{");
                       if (flag_macro)
                         ++level_nest_brace;
                     }
<src>"}"             { out("}");
                       if (flag_macro && (--level_nest_brace == 0))
                         flag_macro = 0;
                     }
<src>"и"             out("&&");
<src>"или"           out("||");
<src>"не"            out("!");
<src>{равно}         out("==");
<src>{неравно}       out("!=");
<src>{defined}       out("defined");
<src>{лат_идент}     |
<src>{литера}        |
<src>{число}         out(yytext);
<src>\"              { BEGIN str;
                       yymore();
                     }
<src>{ком_лат_идент} { for (p = yytext; *p != '\''; ++p) ; *p = '\0';
                       out(yytext);
                     }
<src>{рус_идент}     { rus_ident();
                       out(yytext);
                     }
<src>{ком_рус_идент} { for (p = yytext; *p != '\''; ++p) ; *p = '\0';
                       rus_ident();
                       out(yytext);
                     }
<src>{смеш_идент}    { if (OPTION_wmrl)
                         meserr("русские и латинские буквы в слове:", yytext, WARNING);
                       rus_ident();
                       out(yytext);
                     }
<src>{ком_смеш_иден} { if (OPTION_wmrl)
                         meserr("русские и латинские буквы в слове:", yytext, WARNING);
                       for (p = yytext; *p != '\''; ++p) ; *p = '\0';
                       rus_ident();
                       out(yytext);
                     }
<src>":="            out("=");
<src>{метасимволы}   out(" ");
<src>{строч_коммент} { yytext[1] = '*';
                       yytext[yyleng] = '*'; yytext[yyleng + 1] = '/';
                       yytext[yyleng + 2] = '\0';
                       out(yytext);
                     }
<src>{определить}    out("#define");
<src>{отменить}      out("#undef");
<src>{если}          out("#if");
<src>{иначе}         out("#else");
<src>{конец}         out("#endif");
<src>{макро}         { out("#define");
                       flag_macro = 1;
                     }
<src>{включить}      BEGIN inc;
<src>"/*"            { BEGIN com;
                       level_nest_comment = 1;
                       out(yytext);
                     }
<src,com>{пробел}+   { if (flag_macro) out(" ");
                       else            out(yytext);
                     }
<src,com>\n          { if (flag_macro) out(" \\\n");
                       else            out("\n");
                     }
<src,com>.           out(yytext);
<com>"/*"            { level_nest_comment++;
                       if (!OPTION_C)
                         meserr("вложенные комментарии не разрешены опцией С",
                                "", WARNING);
                       out(yytext);
                     }
<com>"*/"            { if (--level_nest_comment == 0) BEGIN src;
                       out(yytext);
                     }
<inc>{кон_им_файла}  { if (yytext[yyleng - 1] == '>')
                       { yytext[yyleng - 1] = '\0';
                         if (strlen(yytext) + strlen(OPTION_R) + 1 > MAXPATH)
                           meserr("слишком длинное имя файла", yytext, ERROR);
                         else
                         { stpcpy(buf, OPTION_R);
                           stpcpy(buf + strlen(OPTION_R), yytext);
                         }
                       }
                       else
                       { yytext[yyleng - 1] = '\0';
                         stpcpy(buf, yytext);
                       }
                       BEGIN ind;
                     }
<ind>\n              { io_open(buf);
                       BEGIN src;
                     }
<inc>\n              { meserr("неправильный оператор", " #включить", ERROR);
                       out("\n");
                       BEGIN src;
                     }
<inc>.               yymore();
<str>\"              { if (yytext[yyleng - 2] == '\\')
                         yymore();
                       else
                       { out(yytext);
                         BEGIN src;
                       }
                     }
<str>.               yymore();
<str>\n              { meserr("незавершенная строка", "", ERROR);
                       out("\n");
                       BEGIN src;
                     }
%%
