        Препроцессор русской лексики RCC 1.0 для Си-компилятора tcc

 Разработчик - Гурин Сергей Васильевич, Томский политехнический институт
 кафедра электрических станций, тел. 492-507

 Препроцессор преобразует текст Си-программы с русскими идентификаторами  в
 стандартную  Си-программу  и  вызывает  Cи-компилятор  tcc,  передавая ему
 командную строку. Возможности, предоставляемые препроцессором rcc:

  - распознавание окончаний прилагательных и существительных в именительном,
    родительном  и  дательном  падежах  единственного  числа, распознавание
    окончаний прилагательных  в именительном  падеже множественного  числа,
    удаление изменяемых окончаний

  - если идентификатор многословный, например:
      длина_строки, ТекущийУказатель, индекс1
    то распознавание изменяемых окончаний производится в каждом слове
    идентификатора. Идентификаторы, имеющие распознаваемые окончания,
    считаются эквивалентными, например:
      логический, логическая, логическому - эквивалентны
    Примеры описаний с изменяемыми окончаниями:
      статический  символьный массив БуферСтроки[ МАКС_ДЛИНА_СТРОКИ ];
      динамическая целая  длина_строки;
      регистровый  целый  номер_текущего_символа;
      ....
        номер_текущего_символа := 0;
        если (номер_текущего_символа < длины_строки) то
        ....
        если (номер_текущего_символа равен длине_строки и не конец_файла) то
        ....
  - замена русских букв на латинские буквы того же регистра, замена выпол-
    няется по принципу близости звучания букв:
          ╔════════════╦════════════╦════════════╦══════════════╗
          ║   а > a    ║   и > i    ║   р > r    ║   ш > sh     ║
          ║   б > b    ║   й > i    ║   с > s    ║   щ > shch   ║
          ║   в > v    ║   к > k    ║   т > t    ║   ъ > _      ║
          ║   г > g    ║   л > l    ║   у > u    ║   ы > i      ║
          ║   д > d    ║   м > m    ║   ф > f    ║   ь >        ║
          ║   е > e    ║   н > n    ║   х > h    ║   э > e      ║
          ║   ж > j    ║   о > o    ║   ц > c    ║   ю > u      ║
          ║   з > z    ║   п > p    ║   ч > ch   ║   я > ja     ║
          ╚════════════╩════════════╩════════════╩══════════════╝
    Кодировка русских букв - альтернативная (с разрывом маленьких русских
    букв между п и р).
    Примечание: русские буквы в комментариях, строковых и символьных
    константах передаются без изменения.

  - распознавание  идентификаторов,  содержащих  одновременно  и  русские и
    латинские буквы и  выдача предупреждающих сообщений.  Выдачу предупреж-
    дений  можно  подавить  опцией  -w-mrl.  Данное  распознавание  сделано
    для обнаружения ошибок, связанных с использованием русских и  латинских
    букв, имеющих одинаковое или похожее написание:
      у  к  е  х  а  р  о  с  м  К  Е  Н  Х  В  А  Р  О  С  М  Т

  - использование  идентификаторных комментариев  (идентификатор'комментарий),
    позволяющих уточнять смысл понятий или вводить сокращения, например:
      конец'цикла
      программа'анализ_типов()
      регистровая строковая тс'текущая_ссылка;
    Идентификаторный комментарий может  быть  добавлен как  к русским,  так
    и к английским  идентификаторам:  он  может  содержать  буквы, цифры  и
    символы подчерка. Все символы комментария, включая апостроф удаляются

  - использование строчных комментариев
      // текст до конца строки
    и замена их на обычные комментарии (/* текст */)
    Например:
      если (*p неравен '\0')  // не достигнут конец строки
        то ...
      иначе ...               // достигнут конец строки

  - включение файлов: операторы
       #включить <файл>
       #включить "файл"
    Включаемые файлы обрабатываются также,  как и исходные файлы.   Глубина
    вложения включаемых файлов задается опцией -Y в командной строке, и  по
    умолчанию принимается равной 4.  Для корректного отслеживания номерации
    строк препроцессор включает в выходной текст  директивы #line.   Файлы,
    включаемые директивой
       #включить  <файл>
    ищутся в каталоге, задаваемом опцией -R, по умолчанию используется каталог
    \tc\include. Файлы, включаемые директивой
       #включить "файл"
    ищутся по стандартному алгоритму MS-DOS. Оба оператора распознаются  до
    конца строки,  поэтому после  имени файла  может следовать произвольный
    текст, воспринимаемый  как комментарий  без специальных  ограничителей,
    например:
       #включить "lexdef.h" - файл, содержащий определения лексем
    Операторы
       #include <файл>
       #include "файл"
    не раскрываются препроцессором rcc, а передаются на обработку
    препроцессору cpp, входящему в состав tcc.

  - замена ключевых слов препроцессора cpp. Препроцессор rcc заменяет русские
    слова на соответствующие английские эквиваленты
      #константа     эквивалентно #define
      #макро         ............ #define
      #определить    ............ #define
      #синоним       ............ #define
      #понятие       ............ #define
      #отменить      ............ #undef
      #если          ............ #if
      #иначе         ............ #else
      #конец         ............ #endif
       определен     ............  defined
       определена    ............  defined
       определено    ............  defined
    Операторы #иначе и #конец распознаются до конца строки, поэтому после
    них может следовать произвольный текст, воспринимаемый как комментарий
    без специальных ограничителей, например:
       #конец определения отладочного фрагмента
    Оператор #макро, заменяемый на #define, отличается тем, что предназначен
    для описания многострочных макрофрагментов (макрофункций). Синтаксис
    оператора #макро следующий:
       #макро имя
              { тело
              }
    или
       #макро имя(список аргументов)
              { тело
              }
    то  есть,  синтаксис  макрофункции  подобен синтаксису обычной функции,
    вплоть   до   возможности   определения   локальных   переменных.  Тело
    макрофункции обязательно ограничивается символами { } и может  занимать
    одну и более строк. В отличие от традиционного многострочного  #define,
    для  которого  в  конце  каждой  строки, имеющей продолжение, требуется
    символ \, в операторе #макро такой символ не требуется. Таким  образом,
    препроцессор  автоматически  завершает  все  строки,  кроме  последней,
    символами \.  Кроме  того, все последовательно расположенные  пробелы в
    теле  оператора  #макро,  заменяются  одним,  что  позволяет  увеличить
    предельную длину макрофункции  и при этом  сохранить в исходном  тексте
    удобные отступы строк.

  - замена символов операций:
       :=       эквивалентно =
       и        ............ &&
       или      ............ ||
       не       ............ !
       равен    ............ ==
       равна    ............ ==
       равно    ............ ==
       неравен  ............ !=
       неравна  ............ !=
       неравно  ............ !=
    Операции и, или, не, равно, ..... можно использовать в директиве условной
    трансляции вместе с макро_функцией 'определено', например:
       #если определена(ОТЛАДКА) и определена(ИНДИКАЦИЯ)

  - распознавание и замена на пробелы метасимволов ::=  ::  <=>  =>
    Их можно использовать для улучшения читаемости текста, например:
     #константа МАКС_ИНДЕКС ::= 20
      переменные :: строковая ссылка;
                    целый     индекс;

   -  замена  ключевых  слов  языка  Си на русские эквиваленты производится
     включением  по  умолчанию  файла  rcc.h.  Определения в данном файл не
     является  принадлежностью  препроцессора,  поэтому  rcc.h  может  быть
     изменен  или  дополнен.  По  умолчанию   файл  rcc.h,  как  и   другие
     библиотечные файлы ищется в каталоге \tc\include, это умолчание  может
     быть изменено  опцией -Y.  В поставляемом  варианте файл  rcc содержит
     следующие определения:
     -  полностью   включается  файл   stdio.h  содержащий,   в  частности,
       определения  констант  EOF,  NULL,  файлового  типа данных, описания
       глобальных  переменных  стандартных  потоков ввода/вывода, прототипы
       часто используемых функций ввода-вывода
     - константы: ИСТИНА, ДА, ЛОЖЬ, НЕТ, КОНЕЦ_ФАЙЛА
     - метапонятия, которые используются для улучшения читаемости и структу-
       рируемости текста программ: функция, то, в, к, это, тело, массив,
                                   переменная, аргументов, делать, метка,
                                   диапазон()
       например: целая функция ввод_числа(без аргументов)
                 начало
                   переменные :: символьный массив буфер[МАКС_ИНДЕКС];
                                 целый индекс в диапазоне(1..МАКС_ИНДЕКС);
                                 .....
                   тело'функции
                     .....
                     пока (индекс < МАКС_ИНДЕКС) делать
                     .....
                     если ((а := индекс) равно б) то ....
                     переход к метке ОШИБКА;
                     .....
                 конец'функции_ввод_символа
     - классы и типы переменных:
         константный  эквивалентно  const
         изменяемый   ............  volatile
         близкий      ............  near
         далекий      ............  far
         большой      ............  huge
         перечислимый ............  enum
         двойной      ............  double
         короткий     ............  short
         длинный      ............  long
         динамический ............  auto
         статический  ............  static
         локальный    ............  static
         глобальный   ............  extern
         регистровый  ............  register
         знаковый     ............  signed
         беззнаковый  ............  unsigned
         целый        ............  int
         символьный   ............  char
         логический   ............  short int
         плавающий    ............  float
         файловый     ............  FILE
         строковый    ............  char *
     - операторы:
         перечисление ............  enum
         прерывание   ............  interrupt
         запись       ............  struct
         смесь        ............  union
         тип          ............  typedef
         переход      ............  goto
         возврат      ............  return
         размер       ............  sizeof
         выход        ............  break
         продолжение  ............  continue
         если         ............  if
         иначе        ............  else
         цикл         ............  for
         петля        ............  for(;;)
         повтор       ............  do
         пока         ............  while
         выбор        ............  switch
         вариант      ............  case
         прочие       ............  default
         блок         ............  {
         начало       ............  {
         конец        ............  }
         процедура    ............  void
         без          ............  void
         программа    ............  main
     - функция проверки утверждения (постусловия, предусловия):
       утверждение(p) - если условие p не выполняется, то в поток ошибок
                        stderr выводится сообщение в формате:
                          Утверждение (p) не выполняется: файл ..., строка ...
                        и программа аварийно завершается.
       Например, если в исходном тексте программы, записанной в файле main.c
       в строке номер 46 расположен оператор
         утверждение(индекс < МАКС_ИНДЕКС);
       и при запуске программы условие не выполняется, то на экране терминала
       появится сообщение:
       Утверждение (индекс < МАКС_ИНДЕКС) не выполняется: файл main.c, строка 46
       Проверку условия утверждения можно запретить, определив
       макроконстанту NDEBUG оператором
         #определить NDEBUG
       или  из   командной  строки   препроцессора  аргументом    -DNDEBUG.
       Использование  функции  утверждения  помогает  вводить  в свой стиль
       программирования понятия верификации программ и, в конечном итоге, к
       проектированию более надежных программ.

   - следует отметить, что  употребление русских ключевых слов  не является
     обязательным,  то  есть,  в  тексте  программы  можно использовать все
     стандартные ключевые слова языка Си, например:

     #define MAX_IND 20
     int прием_числа(void)
     { register int индекс;
       while (индекс < MAX_IND) {
         ....
       }
       ...
     }
     Функции препроцессора  фактически сводятся  здесь к  обработке русских
     идентификаторов. В этом случае  файл rcc.h можно не  подключать, задав
     в командной строке аргумент -h-.

                      Командная строка препроцессора rcc

   - формат командной строки:
       rcc [опции] файл[ы]

   - опции командной строки:
     - опции препроцессора rcc
       -t      - вызывать компилятор tcc (-t- не вызывать)
       -h      - подключать файл RCC.H (-h- не подключать)
       -wmrl   - предупреждать о смешении латинских и русских букв
                 в идентификаторах (-w-mrl не предупреждать)
       -Rпуть  - каталог для поиска файлов оператором #включить <имя>
                 (умолчание - с:\tc\include)
       -Yчисло - уровень вложенности включаемых файлов (умолчание 4)
     - совместные опции rcc и tcc:
       -C      - разрешить вложенные комментарии? (умолчание -C-)
       -gчисло - максимальное число сообщений (умолчание 100)
       -jчисло - максимальное число ошибок (умолчание 20)
       -K      - тип char (умолчание -K : unsigned)
     - все остальные опции компилятора tcc сохранены без изменений

   - расширения имен файлов
      .asm - файл ассемблерного текста
      .obj - файл объектного кода
      .lib - библиотечный файл
      .rc  - Си-программа с использованием русских идентификаторов
      .c   - Си-программа без использования русских идентификаторов
      .xxx - Си-программа без использования русских идентификаторов
      если расширение  отсутствует, то  по умолчанию  считается, что данный
      файл являетя Си-программой с использованием русских идентификаторов и
      препроцессор добавляет к имени файла расширение .rc

                       Пример использования препроцессора

/* Функция реализации переноса русских и английских слов.
   Разработана Гуриным  С.В. для  форматтера текстов.   Аргументами функции
   являются указатели на начало строки и на предполагаемую точку переноса в
   этой  строке.  Исходная  строка  не  должна  содержать символов перевода
   строки,  перевода  каретки,  перевода  формата, вертикальной табуляции и
   должна завершаться символом конца строки '\0'.  Функция возвращает:
     - указатель на первую переносимую букву (перенос в слове), или
     - указатель на пробел, табуляцию или конец строки, следующих за концом
       слова (перенос по границе слов), или
     - указатель на начало строки (перенос в строке невозможен).
   В  первом  случае  функция  учитывает  место,  требуемое  для  знака '-'
   (символа переноса). Во втором случае функция работает неизбыточно,  если
   текст  написан  корректно,  то   есть  слова  разделяются  пробелами   и
   табуляциями, после  знаков препинания  или скобок  следуют пробелы.  Это
   следует из трактовки слова как последовательности видимых знаков, причем
   разделителем слов служат пробелы или табуляции.
      Алгоритм формирования переноса  основан на циклической  сдвижке точки
   переноса от  предполагаемой точки  к началу  строки. Для  каждой текущей
   точки   переноса   определяется   разделитель   слов   или  допустимость
   чередования  гласных  и  согласных   букв.  При  проверки   допустимости
   проверяются  две  буквы  до  точки  переноса  и  две  буквы  после точки
   переноса.  Приводимый   алгоритм  и   набор  правил   чередования   букв
   практически всегда дает хорошо  читаемый перенос, кроме редких  случаев,
   например,  сложносочиненных  слов,  первая  часть  которых заканчивается
   гласной буквой, а вторая начинается двумя согласными буквами.  Например,
   слово  полупроводник   может  быть   перенесено  как:    по-лупроводник,
   полу-проводник,   полуп-роводник,   полупро-водник,   полупровод-ник.  К
   счастью, вероятность появления таких слов, с начальной позицией переноса
   на вторую согласную второй части слова, довольно невелика.
*/

// ══════════════════════════════════════════════════════════════════════════
глобальная строковая функция перенос( строковое начало_строки,
                                      строковая предполагаемая_точка_переноса )
начало'функции

#константа СБ ::= 0         // тип символа - согласная буква
#константа ГБ ::= 1         // тип символа - гласная буква
#константа РС ::= 2         // тип символа - разделитель слов
#константа ДР ::= 3         // тип символа - другие символы

  переменные  :: целые w1,  // тип предыдущего символа
                       w2,  // тип текущего символа
                       w3,  // тип следующего символа
                       w4;  // тип следующего следующего символа
                 регистровая строковая тп'точка_переноса;

  статический логический массив правил_переноса[16] =
  { ЛОЖЬ,   // чередование сс-сс         ╔════════════════════════════════╗
    ИСТИНА, // чередование сс-сг         ║ Гласная буква обозначается 'г' ║
    ЛОЖЬ,   // чередование сс-гс         ║ согласная - 'с'.               ║
    ЛОЖЬ,   // чередование сс-гг         ║ Значение ИСТИНА соответствует  ║
    ЛОЖЬ,   // чередование сг-сс         ║ допустимому переносу.          ║
    ИСТИНА, // чередование сг-сг         ╠════════════════════════════════╣
    ЛОЖЬ,   // чередование сг-гс         ║ В правилах представлены        ║
    ЛОЖЬ,   // чередование сг-гг         ║ все возможные сочетания        ║
    ЛОЖЬ,   // чередование гс-сс         ║ гласных и согласных букв.      ║
    ИСТИНА, // чередование гс-сг         ║ Выборка требуемого правила     ║
    ЛОЖЬ,   // чередование гс-гс         ║ производится с помощью         ║
    ЛОЖЬ,   // чередование гс-гг         ║ индекса, который вычисля-      ║
    ЛОЖЬ,   // чередование гг-сс         ║ ется как сумма типов четырех   ║
    ИСТИНА, // чередование гг-сг         ║ рядом стоящих букв с двоичными ║
    ЛОЖЬ,   // чередование гг-гс         ║ весовыми коэффициентами        ║
    ЛОЖЬ    // чередование гг-гг         ╚════════════════════════════════╝
    /*  следует   отметить,  что   приведенные  правила   довольно   сильно
       ограничивают  возможные   варианты  переноса.   Предельным   случаем
       ограничения  можно  считать  случай,  когда  все правила кроме сг-сг
       ложны  -  при  этом  число  вариантов  переноса невелико, но все они
       гарантированно  хорошо  читаемы.   Изменив  эти  правила  (в  строну
       уменьшения  количества   ложных  правил),   можно  увеличить   число
       вариантов,  но  при  этом  также увеличивается вероятность появления
       плохо читаемого переноса
     */
  };

  // типы всех символов альтернативной кодовой таблицы
  статический беззнаковый символьный массив типа_символа[256] =
  { РС, ДР, ДР, ДР, ДР, ДР, ДР, ДР, ДР, РС, ДР, ДР, ДР, ДР, ДР, ДР,
    ДР, ДР, ДР, ДР, ДР, ДР, ДР, ДР, ДР, ДР, ДР, ДР, ДР, ДР, ДР, ДР,
    РС, ДР, ДР, ДР, ДР, ДР, ДР, ДР, ДР, ДР, ДР, ДР, ДР, ДР, ДР, ДР,
    ДР, ДР, ДР, ДР, ДР, ДР, ДР, ДР, ДР, ДР, ДР, ДР, ДР, ДР, ДР, ДР,
//  @   A   B   C   D   E   F   G   H   I   J   K   L   M   N   O
    ДР, ГБ, СБ, СБ, СБ, ГБ, СБ, СБ, СБ, ГБ, ДР, СБ, СБ, СБ, СБ, ГБ,
//  P   Q   R   S   T   U   V   W   X   Y   Z   [   \   ]   ^   _
    СБ, ДР, СБ, СБ, СБ, ГБ, СБ, СБ, СБ, ГБ, СБ, ДР, ДР, ДР, ДР, ДР,
//  `   a   b   c   d   e   f   g   h   i   j   k   l   m   n   o
    ДР, ГБ, СБ, СБ, СБ, ГБ, СБ, СБ, СБ, ГБ, ДР, СБ, СБ, СБ, СБ, ГБ,
//  p   q   r   s   t   u   v   w   x   y   z   {   |   }   ~
    СБ, ДР, СБ, СБ, СБ, ГБ, СБ, СБ, СБ, ГБ, СБ, ДР, ДР, ДР, ДР, ДР,
//  А   Б   В   Г   Д   Е   Ж   З   И   Й   К   Л   М   Н   О   П
    ГБ, СБ, СБ, СБ, СБ, ГБ, СБ, СБ, ГБ, ДР, СБ, СБ, СБ, СБ, ГБ, СБ,
//  Р   С   Т   У   Ф   Х   Ц   Ч   Ш   Щ   Ъ   Ы   Ь   Э   Ю   Я
    СБ, СБ, СБ, ГБ, СБ, СБ, СБ, СБ, СБ, СБ, ДР, ГБ, ДР, ГБ, ГБ, ГБ,
//  а   б   в   г   д   е   ж   з   и   й   к   л   м   н   о   п
    ГБ, СБ, СБ, СБ, СБ, ГБ, СБ, СБ, ГБ, ДР, СБ, СБ, СБ, СБ, ГБ, СБ,
    ДР, ДР, ДР, ДР, ДР, ДР, ДР, ДР, ДР, ДР, ДР, ДР, ДР, ДР, ДР, ДР,
    ДР, ДР, ДР, ДР, ДР, ДР, ДР, ДР, ДР, ДР, ДР, ДР, ДР, ДР, ДР, ДР,
    ДР, ДР, ДР, ДР, ДР, ДР, ДР, ДР, ДР, ДР, ДР, ДР, ДР, ДР, ДР, ДР,
//  р   с   т   у   ф   х   ц   ч   ш   щ   ъ   ы   ь   э   ю   я
    СБ, СБ, СБ, ГБ, СБ, СБ, СБ, СБ, СБ, СБ, ДР, ГБ, ДР, ГБ, ГБ, ГБ,
    ДР, ДР, ДР, ДР, ДР, ДР, ДР, ДР, ДР, ДР, ДР, ДР, ДР, ДР, ДР, ДР
  };

// ══════════════════════════════════════════════════════════════════════════
// определение смысла понятий, используемых в тексте функции

#понятие тип_предыдущего_символа       :: тип_символа[*(тп - 1) & 0xFF]
#понятие тип_текущего_символа          :: тип_символа[*(тп    ) & 0xFF]
#понятие тип_следующего_символа        :: тип_символа[*(тп + 1) & 0xFF]
#понятие тип_след_следующего_символа   :: тип_символа[*(тп + 2) & 0xFF]
#понятие текущий_символ_разделитель    :: (тип_текущего_символа равен РС)
#понятие предыдущий_символ_разделитель :: (тип_предыдущего_символа равен РС)
#понятие пред_символ_разделитель       :: (w1 равен РС)
#понятие достигнуто_начало_строки      :: (тп <= (начало_строки + 1))
#понятие все_ближайшие_символы_гласные_и_согласные_буквы :: \
         ( w1 <= ГБ  и  w2 <= ГБ  и  w3 <= ГБ  и  w4 <= ГБ  )
#понятие перенос_возможен :: \
         ( правило_переноса [ 8*w1 + 4*w2 + 2*w3 + w4 ]  равно  ИСТИНЕ )
#понятие остаются_две_гласные_или_согласные_буквы  :: \
         ( ( тп >= (начало_строки + 2)          )  и \
           ( тип_символа[*(тп - 2) & 0xFF] >= РС)  и \
           ( w1 равно w2                        )  )
#понятие переносятся_две_гласные_или_согласные_буквы  :: \
         ( ( тип_символа[*(тп + 3) & 0xFF] >= РС )  и \
           ( w3 равно w4                         )  )
#макро   инициализация { тп := предполагаемая_точка_переноса; }
#макро   переход_на_разделитель_слов         { ++тп; }
#макро   переход_на_первую_переносимую_букву { ++тп; }
#макро   выход_из_функции                    { возврат (тп); }
#макро   сдвиг_точки_переноса
         { если (достигнуто_начало_строки) то
             возврат ( начало_строки );
           тп--;
         }
#макро   поиск_конца_предыдущего_слова
         { повтор сдвига_точки_переноса пока (текущий_символ_разделитель);
         }
#макро   начальное_формирование_типов_ближайших_символов
         { w1 := тип_предыдущего_символа;
           w2 := тип_текущего_символа;
           w3 := тип_следующего_символа;
           w4 := тип_след_следующего_символа;
         }
#макро   переформирование_типов_ближайших_символов
         { w4 := w3;
           w3 := w2;    // циклический сдвиг типов
           w2 := w1;
           w1 := тип_предыдущего_символа;
         }
#макро   мы_попали_на_разделитель_слов
         { поиск_конца_предыдущего_слова
           переход_на_разделитель_слов
           выход_из_функции
         }

// ══════════════════════════════════════════════════════════════════════════
  тело'функции

    инициализация

    если ( текущий_символ_разделитель ) то  мы_попали_на_разделитель_слов

    иначе если ( не достигнуто_начало_строки  и  предыдущий_символ_разделитель )
    { сдвиг_точки_переноса
      мы_попали_на_разделитель_слов
    }

    иначе
    начало'последней_альтернативы_если
      начальное_формирование_типов_ближайших_символов

      петля
      начало'петли
        сдвиг_точки_переноса   /* резервирование места под символ переноса
                                * при первом вхождении в цикл или изменение
                                * точки переноса при последующих итерациях */

        переформирование_типов_ближайших_символов

        если ( пред_символ_разделитель ) то
        { сдвиг_точки_переноса
          мы_попали_на_разделитель_слов
        }

        иначе если (все_ближайшие_символы_гласные_и_согласные_буквы  и
                    перенос_возможен                                 и
                    не остаются_две_гласные_или_согласные_буквы      и
                    не переносятся_две_гласные_или_согласные_буквы   ) то
        { переход_на_первую_переносимую_букву
          выход_из_функции
        }

        иначе продолжение'петли;

      конец'петли

    конец'последней_альтернативы_если

конец'функции_перенос
