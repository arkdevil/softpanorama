..
  ..   рекомендуется использовать для просмотра команду
  ..   >mica.com micro-c.doc
  ..   f8+f7, PgDn ..., ^Home, f8, PgDn ...,  f8 и т.д.
..           ---------------------------------------
..           !    * * *  ==== MICRO-C ====  * * *  !
..           ---------------------------------------
..
  Предупреждение !
  . 
  .   Язык  Micro-c  и   компилятор  Micro-c  ни  в  коем   случае  не
  . претендуют  на альтернативу  стандартному языку  С и  компиляторам
  . систем  QC  и  QC2.    Компилятор   предназначен  в  основном  для 
  . системного   программирования   с   получением  .сом-файлов    как 
  . результирующих   загрузочных   модулей.     Как   известно,  обьем 
  . .сом-файлов  не  превосходит  64К.   Полное   и  надежное владение 
  . языком    Micro-c    предполагает   навыки   программирования   на    
  . языке Макроассемблера с использованием компилятора masm5.
  . 
  .       Автор   хотел  бы   удержать  пользователей   от    соблазна    
  . расширять    самокомпилирующийся    компилятор     Micro-c    до    
  . компилятора    стандартного     языка   С.    Компилятор   Micro-c
  . следует   рассматривать   не    более   как   источник простых   и
  . изящных программ по сути на языке макроассемблера.
  . 
1. Описание языка Micro-C
{  ______________________
    . 
  1. Комментарии
  { ____________
    . Комментарии имеют вид /* ... */, комментарии могут
    . продолжаться на следующих строках
  } 
    .
  2. Идентификаторы
  { ____________
    . Идентификаторы  могут  иметь  произвольное  число  символов  в
    . пределах  строки,  но   значимы  только  первые  8   символов.
    . Среди  букв  и  цифр  допускается  знак  подчеркивания,  но не
    . вначале.
    .
    .    Иметь в  виду  чувствительность   идентификаторов  и   всех
    . других  символических  имен  к  размеру  букв  -  строчные или
    . прописные.
  } 
    .
  3. Ключевые слова
  { ____________
    . char,int,if,while,else,return,break,continue,
    . #define,#include,#asm,#endasm
  } 
    .
  4. Типы данных
  { ____________
      . 
    а/ константы:
      целые константы - 13,14,-32760
      спецсимволы /символьные константы / - 'a',';',...
      '\n' - конец строки
      '\t' - символ табуляции
      '\b' - символ  backspace
      '\r' - символ CR
      '\f' - символ FF
      '\\' - символ \
      '\0' - изображение кода 00
    б/ литералы /строковые константы /
      . имеют вид "...текст..."
      . длина строкового литерала до 70 байт
      . 
    в/ размер данных
      char - 1 байт
      int  - 2 байта
      . 
    в/ одномерные массивы, указатели
  } 
      .  из производных типов данных допустимы одномерные
      .  массивы с обьявлением вида 
      .  char <имя>[<число>]; или int <имя>[<число>];
      .  и массивы указателей с обьявлением вида
      . char *<имя>[<число>]; и int *<имя>[<число>]
      .
  5. Выражения
  { ____________
      . выражения образованы переменными, константами и 
      .   знаками операций:
      . присваивания   - =
      . арифметических - +,-,*,/,%,--,++,<<,>>
      . отношений      - ==,!=,<=,>=,<,>
      . битовых        - &,^,|
      . унарных        - &,*,(...)
      . 
    а/ операции над массивами и указателями
      . 
      . переменная,   обьявленная   как   массив   или   указатель,
      . содержит  адрес  области  памяти,  поэтому,  вообще  говоря,
      . допустимы  все  арифметические,  битовые  и унарные операции
      . над  такими  переменными.   Однако  на  практике  используют
      . лишь   линейные  арифметические   операции,  например,   для
      . перемещения по области массива на заданное число байт
      .
    б/ приоритет операций
      . 
      . по приоритету операции располагаются в следующем порядке
      . = | ^ & == != <= >= < > >> << + - * / %
      . -- ++ * & (...)
      . 
    в/ порядок обработки операндов в выражении
      . очень   полезно   представлять   себе   порядок  обработки  
      . операндов   в  выражении.   Выражение  обрабатывается   слева
      . направо,   появление  подвыражения   приводит  к   сохранению
      . текущего  аккумулятора   в  стек  (   push  ax)  и   переходу
      . к   рекурсивному    вычислению   значения   в    аккумулятор
      . значения    подвыражения.    Восстанавливается     значение
      . подвыражения во вспомогательную переменную bx (pop bx).
      .
    г/ преобразование типов
  } 
      . 
      . поскольку  базовых типов  всего 2  - 1-байтовый  и 2-байтовый,
      . при  вычислении  выражения  можно  автоматически  производить
      . преобразование  между  этими  двумя  типами. Все определяется
      . типом  аккумулятора  ax,  содержащего  2  байта. Все однобай-
      . товые   промежуточные  значения   подвыражений  заносятся   в
      . младший  байт  ax,  а  на  старший байт распространяются биты
      . знака.  Вспомогательная  переменная  bx  2-байтовая,  поэтому
      . в  бинарных  операциях   операнды  приводятся  к   2-байтовым
      . числам  и  результат  также  двухбайтовый  в  ax.  Если левый
      . операнд  операции  присвоения  1-байтовый,  ему присваивается
      . младший  байт  значения  выражения.  Наоборот,  если   правый
      . операнд  присвоения  1-байтовый,  то  он  заносится в младший
      . байт  левого  операнда.  Знание  этих особенностей вычисления
      . выражений  позволяет  имитировать  типы  данных  более общие,
      . чем стандартные, например, структуры и смеси.
      .
  6. Операторы
  { ____________
    а/ формат и вложенность операторов, управляющие операторы
      . 
      . в  Micro-c  как  и  в  С  поддерживается концепция унификации
      . конструкции  оператора,  функции,  выражения  и   логического
      . предиката.  То  есть,  всякое  выражение  может  одновременно
      . являться  и  функцией  с  текущим  значением этого выражения,
      . и  предикатом,  состоящим  в  том,  что  ЛОЖЬ  -  это нулевое
      . значение  выражения,  а  ИСТИНА  -  это  ненулевое   значение
      . выражения.  И  одновременно  выражение  может рассматриваться
      . как  команда-оператор  языка,  которая  состоит  в вычислении
      . этого   выражения.   Аналогично,    всякий   предикат   может
      . рассматриваться как функция  со значением  1/0. Это  касается
      . также  оператора  присвоения,  который  считается   функцией,
      . значение  которой  есть   результат  присвоения,  или   может
      . считаться  предикатом,  для  которого  ИСТИНА - это ненулевое
      . значение присвоения.
      .
    б/ составной оператор
  } 
      . 
      . составной   оператор   образуется   заключением   операторов
      . в фигурные скобки { ... }
      .
  7. Функции
  { ____________
      . 
    а/ Обьявление функции, уровень вложенности обьявлений
      . Обьявление функции имеет вид
      .
      . <имя функции> ( <аргументные переменные> )
      . char <обьявения>;
      . int  <обьявления>;
      . { 
      .   <операторы функции>
      . } 
      . 
      . Обратим внимание на то, что запятая после функции с аргументами
      . не ставится в отличие от формата вызова этой функции.
      .
    б/ Вызов функции, функция main
  } 
      . 
      . вызов функции имеет вид
      . <имя функции> ( <фактические параметры> );
      . вызов  функции  может  применяться  везде,  где  имеет  смысл
      . употребление переменной или константы.
      .      Функция  main  должна быть самой первой  на одном уровне
      . обьявлений   функций.  В   сгенерированном  .сом-файле    эта
      . функция должна получить управление первой.
      .
  8. Описания
  { ____________
      . 
    а/ простые типы 
      . 
      . char <>;
      . int  <>;
      . 
    б/ указатели, массивы, массивы указателей
      . 
      . char *<имя>;
      . int  *<имя>;
      . char <имя>[<число>];
      . int  <имя>[<число>];
      . char *<имя>[<число>];
      . int  *<имя>[<число>];
      . char <имя>[];
      . int  <имя>[];
      . 
    в/ локальные переменные
      . 
      . локальные переменные и массивы обьявляются в фигурных
      . скобках, следующих за обьявлением функции
      . 
    г/ аргументные переменные
      . 
      . аргументные переменные и массивы обьявляются непосредственно
      . за обьявлением функции с параметрами, но перед фигурными
      . скобками.
      .
    д/ глобальные переменные
      . 
      . глобальные переменные обьявляются в промежутке между 
      . обьявлениями функций. Обьявления функций только 
      . одноуровневые, иными словами, не допускаются вложенные
      . определения.
      .
    е/ инициализация глобальных переменных
      . 
      . глобальные    переменные    и    массивы    инициализируются    
      . компилятором    нулевыми     значениями    всегда.     Имея
      . в   виду,    что   располагаются   глобальныеы    переменные
      . и  массивы   в  самом  конце   программе,  являющейся   после
      . редактирования     .сом-файлом,    допускается     усечение
      . .сом-файла   по   этим    нулевым   переменным.   В    таком
      . случае   после    загрузки   .сом-файла   вместо    загрузки
      . этих   переменных    будет   использоваться    для   них    
      . оперативная     память     непосредственно     за   кодами
      . загруженного    модуля.    В   этом    случае    следует    
      . обеспечивать    динамическую    инициализацию    глобальных
      . переменных.
      .
    ж/ классы памяти
      . 
      . локальные  и  аргументные   переменные  имеют  по   умолчанию
      . класс  памяти  auto,   тогда  как  глобальные  переменные   и
      . метки   имеют  тип   static  по   умолчанию,  такой   же  тип
      . имеют и строковые литералы
      .
    з/ совпадение имен
  } 
      . 
      . одинаковые  имена  локальных  переменных  в  разных  областях
      . обьявления  разных  функций  относятся  к  разным переменным,
      . поскольку  эти  переменные  располагаются  временно  в стеке.
      . Если  локальное  имя   совпадает  с  глобальным  именем,   то
      . приоритет  за локальным  именем. В компиляторе это выражается
      . в  том,  что   при  идентификации  имен  поиск   производится
      . сначала  в  таблице  локальных  имен,  и  лишь при отсутствии
      . -  в  таблице   глобальных  имен.  Различение  имен   функций
      . от  имен  глобальных   переменных  производится  по   первому
      . символу,  который  для  функций  есть  символ  подчеркивания,
      . которые   присоединяется   компилятором    к   имени  данному
      . программистом.    Внутренние    метки    имеют    стандартную
      . идентификацию   в  виде   _сс<число>,  поэтому   следует  это
      . учитывать   также   при   составлении   глобальных   имен   и
      . имен функций.
      .
  9. Препроцессор
  { ____________
      . 
    а/ подстановки #define
      . 
      . формат оператора 
      . #define <имя> <текст для замены>
      . С   момента    определения   имени   всякое   его   вхождение
      . будет    замещаться   на   текст   замены   однократно    без
      . попытки  замены  в  полученном  тексте.  Желательно   следить
      . за  тем,  чтобы  результат  не  вышел  за  размер 80 символов
      . в  строке.  Можно  учитывать,  что  при  подстановке  пробелы
      . упаковываются
      .
    б/ включение файлов #include
      . 
      . формат оператора
      . #include <имя файла с маршрутом>
      . Производится   включение    текста   из   указанного   файла.
      . Включаемый   текст   уже   не   может   содержать   этого   
      . оператора,  то  есть  уровень  вложенности  операторов  -  1.
      .     Имя  файла  не  заключается  в  уголки,  как  это   имеет
      . место  в  стандартном  языке  С   (  и  не  заключается  в   
      . кавычки ).
      .
    в/ включение asm-текста #asm, #endasm
  } 
      . 
      . формат оператора
      . #asm
      . .............................
      . ....<ассеблерная команда>....
      . ....<ассеблерная команда>....
      . .............................
      . #endasm
      . 
      .  Эти  операторы  исключительно  удачно сочетаются со свойством
      . компилятора  давать  на  выходе  как  раз  ассемблерный текст.
      . Их   использование   как   через   библиотеку   дополнительных   
      . функций, так  и непосредственно в  Micro-c-тексте, существенно
      . расширяет   возможности   языка   Micro-c,  позволяя    писать
      . программы,   использующие   средства   не  доступные    языкам
      . высокого    уровня    и,   в   частности,   стандартному    С.
      . Это  касается  написания  драйверов,  резидентных   программ,
      . перехвата  системных   прерываний.   Отметим  еще,  что   имея
      . это  в виду,  выходной файл  компилятора Micro-c  приспособлен
      . для  компиляции   в  .com-файлы,  а не в .ехе-файлы, поскольку
      . первые более предпочтительны для системных работ.
      .
  10. Сравнение со стандартным языком С 
  { ____________
    . 
    .    Для   тех,   кто   знаком   со   стандартным  языком  С можно
    . определить   Micro-c   как   строгое   подмножество  С следующим
    . образом: 
    . 1. Типы данных:
    .     символы
    .     целые
    .     строки
    .     массивы
    .     указатели
    . нет   вещественной  арифметики,   типов  static,  register.
    . 2. Нет   структур,  обьединений  и  многомерных   массивов.
    . 3. Нет deftype.
    . 4. Операции && и || заменяются на  &  и   |,  поразрядными.
    . 5. Нет  унарных  операций  !  и ~, которые выражаются через
    .    поразрядные
    . 6. Нет  операции  "запятая"  совместно  с конструкцией for.
    . 7. Нет  конструкций   сложных  присваиваний  вида += и т.д.
    . 8. Нет  switch, case, default, goto, for, do-while.
    . 9. #include   не   могут   быть   вложенными
    . 10.Тип  static   заменяется   глобальным   описанием.
  } 
    .
  11. Некоторые дополнения и замечания
  { ____________
    .  
    . Обращаем внимание  на  различие между следующими конструкциями
    .  
    . if ( <A> & <B> ) ...<statement>...
    .  
    . и конструкцией вида
    .  
    . if ( <A> ) if ( <B> ) ...<statement>...
    .  
    .     Содержательно в  обоих  случаях  имеет  место  коньюнкция,
    . однако  в  первом  случае  производится   вычисление выражения 
    . и вычисление  всех подвыражений.   В то   время как  во втором 
    . случае если  первое подвыражение  окажется  ложным,  то второе 
    . уже не  вычисляется и  управление передается  в  другую  точку 
    . программы. Такое различие существенно отражается на выполнении 
    . программы,  например,  во  втором   подвыражении   может  быть  
    . инкрементация переменной цикла, или оператор ожидания.  
  } 
} 
    .
2. Гипотетическая   машина
{  ______________________
  { ____________
    . 
    .    Отметим,  что наш  вариант гипотетической  машины отличается
    . от  варианта,  предложенного  Берри  и Микинзом как универсаль-
    . ный переносимый вариант.
    .
    .     Гипотетическая  машина  -  это   язык  промежуточный  между 
    . языком  высокого уровня Micro-c и  языком ассемблера конкретной
    . машины  и  машинных  команд.  Один  оператор  этого языка - это
    . блок  команд ассемблера, с другой  стороны, выходом компилятора
    . Micro-c  является   последовательность  команд   гипотетической
    . машины   преобразованная  в   команды  ассемблера.   Компилятор
    . Micro-cd  специально  сконструирован  для  генерации  команд на
    . выходе в виде команд гипотетической машины.
  } 
    .
  1. примитивные переменные
  { ____________
    . 
    .     Команды  гипотетической  машины  можно  рассматривать   как
    . подмножество          команд          Micro-c.          
    . Четыре  двухбайтовые  примитивные  переменные   ax,bx,sp,bp
    . имеют следующий смысл:
    .
    .    ax - аккумулятор для текущего значения арифметических
    .         выражений, al - младший байт, ah - старший байт
    .    bx - вспомогательная переменная для сохранения значений
    .         бинарных операций
    .    sp - указатель вершины стека
    .    bp - указатель на переменную loc в стеке для прямого
    .         доступа к локальным и аргументным переменным
    .
    . кроме того:
    . 
    .    loc     - переменная в стеке, слева от нее располагаются
    .         локальные переменные текущей функции, справа - аргу-
    .         ментные переменные
    .    cc<номер>    - метка команды
    .    &loc-<номер> - адрес локальной переменной
    .    &loc+<номер> - адрес аргументной переменной
    .    &cc2.<номер> - адрес строкового литерала
    .    _<имя>       - метка функции
    .    <имя>        - глобальная переменная
    . 
  } 
  2. строение стека
  { ____________
    . 
    .    Стек, участвующий в гипотетической машине имеет следующее
    . строение:
    .     2    2    2    2    2   2   2   2   2   2
    . -----------------------------------------------
    .    !sp !    !    !    !bp !   !   !   !   !call
    . -----------------------------------------------
    .     ! локальные        loc  аргументные    !
    .     !    переменные            переменные  !
    .     !                                      !
    .     вершина стека                        адрес возврата
    . 
    .   Стек  всегда  растет  влево, одна  ячейка  занимает 2 байта.  
    . Локальные     и     аргументные переменные   располагаются  
    . в    порядке     обратном    их расположению    и обьявлению 
    . в   функции.   При   каждом  вызове   функции   стек  растет, 
    . при   каждом   возврате    из функции   стек    сокращается.  
    . Следует   иметь   в   виду,  что   в   области   ОП   в   64к 
    . программа     с    константами располагается    в    нижних  
    . адресах,     а    стек    растет вниз    начиная  с    самой  
    . верхней      границы.      Поэтому  следует   рассчитывать  
    . обьем    программы   таким    образом, что     не    затирать 
    . область    стека.    Область    стека  тем    больше,   чем  
    . глубже   вызовы,   рекурсия   и   сумма локальных  переменных 
    . и масивов.
  } 
    .
  3. примитивные команды
  { ____________
      . 
    . = начало и завершение =
      . 
      .   ====== header ======
      .   ====== trailer =====
      . 
    . = стековые операции =
      . 
      . push ax  (при этом sp=sp-2)
      . pop bx   ( при этом sp=sp+2)
      . 
    . = команды присвоения =
      . 
      . al=<имя>
      . al=<число>
      . ax=<имя>
      . ax=<число>
      . <имя>=al
      . <имя>=ax
      . *bx=al    присвоение значению указателя одного байта
      . *bx=ax    присвоение значению указателя двух байт
      . al=*ax, ah=sign(]ax) присвоение одного байта значения
      .           указателя, старший байт переменной заполняется
      .           битами знака младшего байта
      . ax=*ax
      . 
    . = разное =
      . 
      . call <имя функции>
      . sp=sp+<число> корректировка стекового указателя после 
      .           вызова функции
      . sp=bp
      . pop bp пара команд выхода из локальной области стека
      . push bp
      . bp=sp  пара команд входа в локальную область стека
      . 
    . = арифметические команды =
      . 
      . ax=ax*2
      . ax=bx+ax
      . ax=bx-ax
      . ax=bx*ax
      . ax=bx/ax
      . ax=bx%ax
      . ax=bx|ax
      . ax=bx^ax
      . ax=bx&ax
      . ax=bx/(2**ax) или ax=bx>>ax
      . ax=bx*(2**ax) или ax=bx<<ax
      . ax=-ax
      . ax=ax+1
      . ax=ax-1
      . 
    . = обеспечение предикатов =
  } 
      . 
      . if ( bx == ax ) ax=1; else ax=0; 
      . if ( bx != ax ) ax=1; else ax=0; 
      . if ( bx <= ax ) ax=1; else ax=0; 
      . if ( bx >= ax ) ax=1; else ax=0; 
      . if ( bx <  ax ) ax=1; else ax=0; 
      . if ( bx >  ax ) ax=1; else ax=0; 
      . if ( ax == 0 ) GOTO <метка> 
      . 
      .   Приведем    пример   разложения    выражения   Micro-c    на
      . на  примитивные  команды  гипотетической  машины,  полученные
      . с помощью компилятора Micro-cd
      .
      . ;    outsym ( string,564+80*k++,MWhite);
      . 
      . ax=&string
      . push ax
      . ax=564      |  Здесь:
      . push ax     |
      . ax=80       |  outsym   - функция
      . push ax     |  string   - глобальная переменная
      . ax=&loc-10  |  k        - локальная переменная с
      . push ax     |             адресом &loc-10
      . ax=*ax      |  MWhite   - число, равное 95,
      . ax=ax+1     |             определяемое по #define
      . pop bx
      . *bx=ax
      . ax=ax-1
      . pop bx
      . ax=bx*ax
      . pop bx
      . ax=bx+ax
      . push ax
      . ax=95
      . push ax
      . call _outsym
      . sp=sp+6
      . 
      .   Дальнейшие более развернутые примеры даны в файлах
      . ademo.as1,copy1.as1,convdemo.as1.
      . 
} 
3. Библиотеки   функций 
{  ______________________
  { 
    . 
    .     Приведем   описания   двух   библиотек    дополнительных
    . функций, написанных на ассемблере.
  } 
    .
  1. st.inc  - две стандартные функции приема аргументов
  { 
    . и завершения программы с выходом в ДОС
    .
    . setargv(argv);
    . int *argv[];       - argv - массив указателей,
    .              подготавливается как глобальный массив
    .              размерности равной предполагаемому числу
    .              параметров, передаваемых из командной
    .              строки. Функция настраивает значения 
    .              указателей в массиве на текстовые строки
    .              параметров, находящиеся в области PSP
    . 
    . exit();            - эта функция вызывает нормальное
    .              завершение всей программы с выходом в ДОС
    . 
  { 
  2. fio.inc - функции обеспечения ввода-вывода в файлы,
  } 
    .              обеспечивается одновременная обработка
    .              нескольких файлов (число одновременно
    .              открытых файлов определяется параметром
    .              в config.sys ) произвольного размера.
    .              Обьем буфера для обмена принят равным 16к.
    . 
    . fopen ( file, 0/1)
    . char *file;         - функция открытия файла на чтение
    .              или запись согласно значению 0/1 второго
    .              операнда. Первый операнд подготавливается
    .              как указатель на строку в формате ASCIIZ
    .              для маршрута и имени файла. Значением
    .              функции является внутренний номер файла
    .              ( т.н. "handle") . При неудачном открытии,
    .              например, при отсутствии требуемого файла,
    .              функция принимает нулевое значение.
    . 
    . fclose ( handle )
    . int handle;         - функция закрытия файла, только при
    .              закрытии выходных файлов создается их нормальная
    .              длина, иначе длина будет равной 0.
    . 
    . fgetc ( handle )
    . int handle;         - функция получения одного символа из
    .              входного файла с внутренним номером handle,
    .              этот символ является значеним функции. Проверить
    .              конец файла можно по функции feof(handle).
    . 
    . fputc ( c, handle)
    . char c; int handle; - функция вывода одного символа "с"
    .              в выходной файл с внутренним номером handle.
    .              Для удобства применения этот символ является
    .              и значеним функции.
    . 
    . feof ( handle )
    . int handle;         - проверка признака конца входного 
    .              файла. Значение функции 1/0 в соответствии
    .              с признаком конца входного файла или нет.
    . 
    . getchar()           - функция позволяет получить один
    .              символ из входного потока клавиатуры, прием
    .              символа производится с ожиданием, с эхом
    .              и с возможностью сброса по Ctrl-Break
    . 
    . putchar ( c )       - функция позволяет выводить один байт
    .              на экран по текущему положению курсора с
    .              его автоматическим продвижением и с текущими
    .              атрибутами цвета, значением функции является
    .              выводимый символ.
    . 
    .      Полезно  иметь  в  виду,  что  буфера располагаются начиная
    . с  cs+64k,  имеют  в  длину  по  16к  и  номер  буфера  равен  
    . внутреннему номеру файла за вычетом 5.
  } 
} 
    .
4. Компиляторы Micro-c0.com и Micro-cd.com
{  ______________________
  { 
  Ограничения реализации 
    . 
    . 1. Длина имени                - 8 байт
    . 2. Число глобальных имен      - 300
    . 3. Число локальных имен       - 60
    .    для одной функции
    . 4. Вложенность while          - 100
    . 5. Сумма строковых литералов  - 2.5к
    . 6. Число #define              - 75
    . 7. Сумма тел #define          - 1.5к
    . 8. Длина загрузочного кода    - 64к
    . 9. Длина литерала             - 70 байт
    . 10.Выдача приспособлена для masm5
    . 
  } 
  Разделение компилятора на пакеты функций 
  } 
    . 
    . main                      - главная функция
    . analyze of expression     - синт. анализатор
    . package for Symtab        - обеспечение таблиц символов
    . package for INPUT         - обеспечение сканера
    . package for OPEN and CLOSE- интерфейс с пользователем
    . Error                     - обработка ошибок
    . package for OUTPUT        - выдача листинга и результата
    . Library of Cod Generation - кодогенерация
    . St.inc                    - прием параметров и завершение
    . Fio.inc                   - файловый ввод-вывод
    . 
  } 
  Компиляция, редактирование и получение .сом-файлов 
  { 
    . 
    .    Приведем примеры bat-файлов для компиляции и получения
    . необходимого .сом-файла:
    . ==========================
    .   bat-файл c0.bat только для компиляции
    . 
    . micro-c0.com %1.c %1.asm
    . ==========================
    .   bat-файл cl0.bat для компиляции и получения .сом-файла
    . 
    . micro-c0.com %1.c %1.asm
    . masm.exe %1.asm,%1.obj,Nul.lst,nul.crf
    . link.exe %1.obj,%1.exe,Nul.lst
    . exe2com.exe %1.exe
    . ==========================
    .     Вопрос   "need C-text ?"   запрашивает    возможность
    . включения   в   выходной   ассемблерный   текст   в    строках
    . комментариев     строки     текста     исходной   программы.
    . Следует отвечать "y" или "пробел".
   } 
} 
    .
5. Сообщения  об  ошибках
{  ______________________
    . 
    "illegal function or ..."         - неверная функция или ...
    "missing opening parenthesis"     - пропущена открывающая скобка
    "Illegal argument name"           - неверное имя аргумента
    "expected comma"                  - ожидается запятая
    "wrong number of args"            - неверное число аргументов
    "expected argument name"          - ожидается имя аргумента
    "illegal address"                 - неверный адрес
    "cannot subscript"                - неверное написание массива
    "invalid expression"              - неверное выражение
    "globals symbol t.overflow"   - переполнение таблицы гл. символов
    "local symbol t. overflow"    - переполнение таблицы лок.символов
    "macro count exceeded"            - счетчик макро переполнен    
    "macro table full"                - макро таблица переполнена
    "too many active whiles"          - слишком много вложенных while
    "no active while"                 - нет активных while
    "string space exhausted"          - переполнение буфера литералов
    "must be constant"                - должна быть константа
    "negative size illegal"  - недопустима отрицательная размерность
    "missing semicolon"               - пропущена ";"
    "missing bracket"                 - пропущена скобка
    "missing quote"                   - пропущена кавычка
    "missing apostrof"                - пропущен апостроф
    "line too long"                   - слишком длинная строка
    "Open output failer"      - ошибка при открытии выходного файла
    "Open input failer"       - ошибка при открытии входного файла 
    "Open failer on include file"  - ошибка при открытии файла include
    "must be left value"              - должен быть тип переменной
    "already defined"                 - имя уже определено
    "illegal symbol name"             - неверное символическое имя
    "missing closing bracket"         - пропущена закрывающая скобка
    "output file error"               - ошибка в выходном файле
    . 
} 
6. История создания Micro-c
{  ______________________
      . 
      .     В  качестве прототипа  компилятора использован  компилятор
      . RatC  Р.Берри  и  Б.Микинза  из  книги  "Язык  СИ.  Введение 
      . для  программистов",  который,  в  свою  очередь,   опирается
      . на расширение,  сделанное Дж.Хендриксом, компилятора  Small-C,
      . созданного  Р.Каином.  Так  что  работа делалась не на пустом
      . месте.
      .
      .      Несмотря  на  то,  что  RatC  написан в переносимой форме, 
      .  то  есть  выходом  компилятора  является  текст  в  командах 
      .  гипотетической  машины,  эта  машина  носила на себе ощутимый 
      . отпечаток DEC-овской архитектуры ЭВМ. Это выражалось  в:
      .
      . - использовании однобайтовой и двухбайтовой структуры
      .   стека;
      . - недопустимости символов из второй половины таблицы;
      . - в однобайтовом символе конца строки, а не двухбайтовом
      . как того требуют соглашения MsDos;
      . - в отсутствии символа конца файла;
      . - в наличии операций обмена регистра с вершиной стека
      .   которой нет в MsDos;
      . - в совпадении некоторых имен с ключевыми словами
      .   макроассемблера;
      . - в необычном формате вывода литералов и глобальных массивов;
      . - в загрузке адреса имени при указании имени, а не 
      .   значения имени, как в MsDos;
      . - в обьявлении storage и static, которые затем нигде
      .   не использовались.
      .  Кроме  того,  были  исправлены  многочисленные  как  опечатки
      .         так         и          содержательные          ошибки.
      .                                                              
      .    Было создано  три компилятора  - Miccqc2.c,Micro-c0  и     
      .                                                      Micro-cd:
      .                                                              
      . -  Miccqc2.c  -  компилятор  для  MsDos подготовленный для
      . компиляции  его большим  С-компилятором QC2  с выходом  в виде
      . Miccqc2.exe, на  эту программу распространяются  все свойства,
      . ограничения  и сомнения,  касающиеся программ  сгенерированных
      . с помощью QC2. 
      .
      . - Micro-c0.c -  самокомпилирующейся  компилятор  с результатом
      . в виде Micro-c0.com;
      .
      . - Micro-cd.c - компилятор в коды описанной выше гипотетической
      . машины  с  модулем   в  виде  Micro-cd.com.  Этот   компилятор
      . исключительно  полезен   как  для  проверки  правильности, так
      . и для обучения языку Micro-c.
      .
      .   Текст RatC  подвергся  серьезному  разбору  и  переделке. В  
      . частности,  это  коснулось  интерфейса с  пользователем. Пред-
      . почтительным   считался  вариант   задания   параметров   в   
      . командной  строке,  а  не  в  диалоге,  как   это было в RatC.
      . Полность  переделана  часть  кодогенерации   и  все  фрагменты
      . в  основной  части,  вызывающие  пакет  функций кодогенерации.
      .
      .   Особую важность  представляла задача   получения  самокомпи-
      . лирующейся  версии   Micro-c.c,Micro-c.com.   Если  в   версии
      . Miccqc2  допускалось  использование   библиотечных  функций из
      . библиотеки  SLIBCE.lib  системы    QC2,  то  для   Micro-c.com
      . были  на  ассемблере   написаны   аналоги  всех  9   требуемых
      . функций   ввода-вывода  и    передачи  параметров    командной
      . строки. 
      .
      .     При  создании  компилятора,  как  и  при  создании   новых
      . версий, наиболее сложная и важная проблема - это  тестирование
      . компилятора необходимое для доказательства его правильности.
      .
      .     При  тестировании,  если  правильно  работает  Micro-c.com
      . как программа, то этого еще очень мало, надо, чтобы  правильно
      . работали все программы скомпилированные с помощью Micro-c.com.
      .
      .     Для этого следовало бы написать представительное множество
      . программ   на  языке  Micro-c,  скомпилировать  их  и доказать
      . правильность   полученных  программ.  В  случае  более  или  
      . менее  сложных   программ   получается  порочный  круг. А если 
      . тестировать   компилятор   на   мелких  тестовых   программах,
      . всегда  останется   сомнение   -  задействованы   ли  в   этих
      . программах   все    средства    и   потенциальные  возможности
      . языка ?
      .
      .     Поэтому,  самым  убедительным доказательством правильности
      . компилятора   служит   процесс   самокомпиляции   согласно  
      . диаграмме
      .
      .       Micro-c.c -------
      .                        \
      .                         --- Micro-c#.com
      .                        /
      .       Micro-c.com ----
      . 
      .    Совпадение программ  Micro-c.com и  Micro-c#.com и  опреде-
      . ляет  самокомпилирующийся  компилятор.  В этом процессе также
      . тестируется  вся библиотека  поддержки ввода-вывода  и переда-
      . чи параметров из командной строки.
      .
      ..........................................................
 
 
} 
 
