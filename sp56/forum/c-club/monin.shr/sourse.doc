
                      З А М Е Ч А Н И Я
                              и
                   краткая документация по
                  исходным текстам программ,
              поставляемых вместе с программой
                        DISTINCT.EXE


1.  "Исходники"  поставляются  не  в  полном  объеме. Но это не
   означает, что я пытался  что-то скрыть от программистов, или
   защитить таким образом свои авторские права. Ни одна идея не
   упущена.  Отсутствуют  лишь  оконная  библиотека, обработчик
   критических  ошибок,  а  также  17  исходных  файлов  пакета
   Codedase 4.02,  с помощью  которого велась  непосредственная
   работа с базой данных.

2. Для  того, чтобы  понять, как  работает программа необходимо
   иметь  некоторое  представление  о  работе  Codebase с базой
   данных.

   1. В памяти, для каждой базы данных, организуется структура,
      которая хранит ее текущее состояние. Полезно знать 2 поля
      этой структуры :
      buffer     - ссылка  на  внутренний  буфер базы данных. В
                   нем хранится текущая запись базы.
      buffer_len - длина буфера.
      Замечание.   В   первом  байте  буфера   хранится   флаг,
                   показывающий, удалена ли текущая запись.

   2. Функции, работающие с базой данных.
      d4prt      - возращает ссылку на внутреннюю структуру.
      d4use      - открыть базы данных.
      d4reccount - возращает число записей в базе данных.
      d4go       - считать запись во внутренний буфер.
         Коды возврата :
               1 - конец файла.
               0 - успех.
      d4deleted  - возврашает 1, если запись удалена.
      d4write    - сбросить  содержимое  внутреннего буфера  на
                   диск.
      d4adjust   - обрезать базу данных.
      d4close    - закрыть базу данных.

         Если происходит  ошибка, все  функции вызывают  внутри
      себя функцию u4error, и возвращают код возврата -1.


3. Назначение файлов.

   1. dist.c   -  содержит  функцию  main  ().  Он  отвечает за
      интерфейс, а также обработку параметров командной строки.

   2. distinct.h, distinct.c - содержат функцию  distinct_base,
      которая выполняет  удаление дублирующих  записей в  одной
      базе.  Эта  функция  является  "стержнем"  программы. Она
      может  показаться  сложной  при  разборе,  и  поэтому,  я
      советую   сначала   разобраться    в   функциях    класса
      NAMES_TABLE.
      Алгоритм.
      1. Как  можно  больше  записей   считывается  в   память.
         Одновременно  осуществляется  проверка  на  совпадение
         записей. Дублирующие записи удаляются.
      2. Если память исчерпана, функция переходит в режим LOOK.
         В этом  режиме осуществляется  проверка на  совпадение
         записей  находящихся  в  памяти,  со всеми оставшимися
         записями базы данных. Дублирующие записи удаляются.
      3. Вся  память освобождается, и в нее загружаются записи,
         начиная с той, которая первая не вошла в память.
      4. Процесс   продолжается,    пока  вся  база  не   будет
         обработана.

   3. option.h,  option.c -  класс, состоящий  из одной функции
      option. Назначение  - обработка  опций командной  строки.
      Достоинства :
      1. Легкость введения новых  ключей, и замены старых.  Для
         этого достаточно изменить управляющую структуру.
      2. Удобство использования.

   4. dir_.h, user_err.h,  dir_.c - обработать  файлы каталога.
      Для того, чтобы  сделать этот класс полностью независимым
      от   программы,   необходимо    скомпилировать   его    с
      определением  #define NO_DISPLAY_ERROR.
         Поля attrib, mode - в структуре DIRECTORY_MODE  задают
      ограничения  на   список  обрабатываемых   файлов.   Если
      ограничений будет недостаточно для реализации  некоторого
      режима, то рекомендую выполнить следующие действия :
      1. Установить  attrib = 0xFF,  mask = NULL - обрабатывать
         все файлы.
      2. Внутри  функции  function  поставте  свой  собственный
         ограничитель.

   5. stack.h,    stack.c    -   содержат   функции  управления
      программным стеком. Отличительной чертой этой  реализации
      от стандартной является :
      1. Работа  может  вестись  с данными  любого типа,  в том
         числе и со строками.
      2. Стек обладает свойством наращиваемости. Таким  образом
         не  требуется  под  него  сразу выделять большой объем
         памяти.  Стек  будет   наращиваться  только  по   мере
         необходимости, т.е. при его переполнении.

   6. b_tree.h, b_tree.c      -  работа   с  двоичным  деревом.
      n_table.h,  n_table.c   -  работа   с  таблицей  имен   -
      расширение класса BINARY_TREE.
         Гибкость  класса  BINARY_TREE  и  скорость,   даваемая
      классом NAMES_TABLE делают их незаменимыми при  обработке
      больших  объемов  информации.  Функция  distinct_base  не
      демонстрирует все достоинства этого класса, хотя является
      хорошим примером.
         Возможное применение класса  BINARY_TREE - сортировка.
      Для этого необходимо выполнить следующие действия :
      1. Установить флаг unique = 0.
      2. Написать  функцию  compare_key,  определяющую  порядок
         ключей.
      3. B_TREE bt = { ... } ;
         void * key = first_key () ;

         /*  Загрузить данные в дерево.  */

         while ( ! bt1_insert ( & bt, key, NULL )
            key = next_key () ;  /*  Взять следующее данное. */

         /*  Обработать элементы дерева. На обработку элементы
             поступают уже в нужном порядке.                 */

         bt1_process ( & bt ) ;
         bt1_clear ( & bt ) ;

         Функция  distinct_base  работает  столь  быстро только
      благодаря классу  N_TABLE. Если  в памяти  находится 1000
      записей, то  для того,  чтобы проверить  совпадение новой
      записи  со   всеми  записями,   находящимися  в   памяти,
      необходимо в среднем выполнить 3 сравнения + хеширование.
         Замечание !   Не советую  использовать  эти классы для
      обработки  небольших  объемов  информации  - используется
      слишком много накладной памяти.

      Модули 3 - 6  могут быть использованы в  любых прикладных
   программах.  Причем  для   их  использования  не   требуется
   выполнение каких-либо изменений в "исходниках".
