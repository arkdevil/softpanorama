глава 2.
Об'екты содержащие данные.


     В Си все об'екты содежащие данные можно поделить на
два вида:константы,значения которых не меняются при выпол-
нении программы и переменные ,которые могут изменять свои
значения.

2.1. Константы.

Константа определяется конструкцией #define обрабатываемой
препроцессором,в результате работы которого будет произве-
дена замена всех не заключенных в кавычки появлений имени
константы в тексте программы на соотвествующую строку в
описании.

Общий вид описания.
     
#define  идентификатор строка_символов
     
Идентификатор задает имя константы,а строка_символов может
быть либо литералом ,либо константным выражением.

2.1.1 Константа - литерал.

Литерал в описании может быть числовым,символьным,строковым.
     
Примеры:

/* 1 */
#define MAX 100      /* Константа с именем MAX числовой деся- */
                     /* тичный литерал равный 100             */
/* 2 */
#define CTRL-G 007      /* Константа с именем CTRL-G числовой */
                        /* воcьмеричный литерал               */
/* 3 */
#define STRING_1 "Привет!\n"  /* Константа с именем STRING_1  */
                              /* строковый литерал            */
/* 4 */
#define NEWLINE  '\n' /* Константа с именем NEWLINE символьный*/
                      /* литерал                              */

/* 5 */   /* Определения наиболее важных числовых констант из
             файла values.h для Turbo C Prof. 2.0 */

#define MAXSHORT  0x7FFF
#define MAXINT    0x7FFF
#define MAXLONG   0x7FFFFFFFL
#define MAXDOUBLE 1.797693E+308
#define MAXFLOAT  3.37E+38
#define MINDOUBLE 2.225074E-308
#define MINFLOAT  8.43E-37
     
Ссылки:
1.2  Литералы,1.4.1 Макроподстановка.

2.1.2 Константное выражение.
     
Константное выражение - это выражение состоящее из конс-
тант и литералов.Выражение будет обработано при обработке
препроцессором до начала основного этапа компиляции.
     
Примеры:
     
/* 1 */
#define MAX  1000
#define MAX2 MAX*5 /* Константа с именем MAX2 связана с
                      константой MAX,и будет изменяться
                      при ее изменении */
#define MAX3 MAX*MAX2+100 /* Константа с именем MAX3 связана
                             с константами MAX и MAX2,и будет
                             изменяться при их изменении */

2.2. Переменные.
     
Переменные характеризуются типом,областью действия,време-
нем существования и текущим значением.

2.2.1 Типы переменных.

Тип - это множество значений плюс множество операций,кото-
рые можно выполнить над значениями.

2.2.1.1 Типы предопределенные реализацией.
2.2.1.1.1 Целый тип - int.
     
Тип int - целочисленный тип,значения которого представляют
числа в диапазоне от -32768 до 32767.Переменные этого типа
занимают два байта памяти. Квалификаторы short(короткое) и
long(длинное) изменяют как размер памяти занимаемый пере-
менной,так и диапазон используемых чисел( для short не
всегда - единственное в чем ручается создатель Си Д.Рит-
чи,то что размер памяти занимаемый переменной типа short
int будет меньше размера памяти занимаемый переменной типа
long int.) Квалификатор unsigned(без знака) изменяет диа-
пазон значений типа, в классическом Си он применяется с
типами int и char.

Таблица показывающая влияние квалификаторов
short,long,unsigned на характеристики типа int для ПЭВМ
IBM PC.
     
     Тип           Занимаемая память,байт     Диапазон значений
         int                2                от -32768 до 32767
unsigned int                2                     от 0 до 65636
short    int                2                от -32768 до 32767
long     int                4              от -2 млрд. до 2 млрд.
unsigned long int           4                     от 0 до 4 млрд.

Ссылки:
1.2.1.1 Числовые десятичные литералы,1.5 Квалификаторы.

2.2.1.1.2 Символьный тип - char.

Тип char - символьный тип,значения которого представляют со-
бой символы из стандартного набора ASCII в диапазоне от 0 до
255 .Большая часть из них имеют графическое представление.Они
обозначаются соответствующими символьными литералами.Перемен-
ные этого типа занимают 1 байт памяти.
    
Ссылки:
1.2.2 Символьные литералы.

2.2.1.1.3 Плавающие типы.
2.2.1.1.3.1 Тип float.

Тип float - тип вещественных чисел в диапазоне от MINFLOAT до
MAXFLOAT, с плавающей точкой и одинарной точностью.Квалификатор
long применим к этому типу.Описание long float идентично
описанию double.Переменные этого типа занимают 4 байта памяти.
При вычислениях переменные типа float автоматически преобра-
зуются в тип double посредством добавления нулей в дробную
часть числа.
     
2.2.1.1.3.2 Тип double.
     
Тип double - тип вещественных чисел в диапазоне от MINDOUBLE
до MAXDOUBLE, с плавающей точкой и удвоенной точностью по сравнению
с типом float.Переменные этого типа занимают 8 байт памяти.


Примечание:Размер диапазона для типов float и double зависит
от типа ЭВМ,константы MAXDOUBLE,MAXFLOAT,MINDOUBLE,MINFLOAT
определены в файле values.h
     
Ссылки:
1.2.1.1 Числовые десятичные литералы,1.4.2 Включение файлов,
2.1.1 Константа - литерал.

2.2.1.2 Типы создаваемые программистом.
2.2.1.2.1 Образование типов-синонимов.

Спецификатор typedef позволяет определить необходимый
идентификатор,как синоним какому-то стандартному или
производному типу.
     
Общий вид описания:
     
typedef  определяющий_тип  идентификатор_типа_синонима;
     
Пример:
     
typedef float real_of_pascal;/* данное описание идентично */
real_of_pascal  x;           /* описанию float x;         */

typedef char x[79] STRING; /* описание типа STRING */
STRING a,b;                /* Как строки символов описывают-*/
                           /* ся переменные a,b             */

2.2.1.2.2 Перечислимые типы.

Множество значений перечислимого типа определяется явным
перечислением их значений.

Общий вид описания:
     
typedef enun {a0,a1,a2,..,an} перечислимый_тип;
     
Где a0,a1,a2,..,an - идентификаторы,причем любой из этих
идентификаторов должен соответствовать только данному
перечислимому типу.Все переменные перечисления
рассматриваются ,как тип int и поэтому по умолчанию
a0<a1<a2<..<an ,а также a0=0,a1=1 и т.д.Отсюда следует что
над этими переменными можно проводить все операции присущие
типу int.
     
Пример:
     
int p;
typedef enum {BLACK,WHITE,RED} our_color;
p=BLACK+WHITE; /* Эти выражения являются для компи- */
p=RED*WHITE;   /* лятора Си вполне законными        */

2.2.1.3 Производные типы.
2.2.1.3.1 Массивы.

Массив - это группа элементов одного типа.

Общий вид описания:
     
[класс_памяти]  тип_данных  имя_массива[n1][n2]..[nk];

Где n1,n2,..,nk - граница диапазона соответствующего по-
рядка.
k - размерность массива ограничиваемая только об'емом памяти.
Начало диапазона в Си берется по умолчанию за 0 и к сожалению
изменить его нельзя,что ведет в некоторых случаях к неудобст-
вам при написании программ.При описании массива компилятор
резервирует место в памяти для хранения всех его элемен-
тов(переменных).
     
Примеры:
     
/* 1 */
extern float tem_rezhim[100];  /* Описан глобальный массив
                                  tem_rezhim из 101 переменной
                                  типа float в диапазоне от
                                  0 до 100                    */
/* 2 */
char stran[24][79];            /* Описан массив stran из 25*80
                                  переменных символьного типа */
     
     
2.2.1.3.1.1 Строки.

В Си строки рассматриваются как одномерный символьный мас-
сив,оканчивающийся символом '\0' и имеющий класс памяти
static.При этом для строки генерируется адрес ее первого
символа,который идентифицирует ее.Этот адрес изменять нель-
зя.

Ссылки:
1.2.3 Строковые литералы,2.2.2.3 Класс памяти - static.

2.2.1.3.1.2 Доступ к элементам массива.
     
Доступ к элементам массива осуществляется при помощи операции
[].
     
Общий вид операции:

 имя_массива [x1][x2]..[xk]

где x1,x2,..,xk - координаты соответствующего элемента масси-
ва,количество координат должно быть равно размерности массива
при описании.Отсчет координат ведется от 0.
     
Пример:

char string_2[5]; /* Описывается символьный массив string_2 */
                  /* в диапазоне от 0 до 5                  */
string_2[0]='L';  /* В нулевой элемент массива записывается */
                  /* символ L                               */
     
2.2.1.3.2 Структуры.

Структура - это набор из одной или нескольких перемен-
ных,сгруппированных под одним именем для удобства обработки.
     
Общий вид описания:
     
  [класс_памяти] struct  [ярлык_структуры] {
                 тип_данных  переменная_1;
                 тип_данных  переменная_2;
                 ...
                 тип_данных  переменная_k;
                                           }[имя_структуры];

Каждая переменная в структуре также по другому может быть наз-
вана полем структуры,поэтому имя_поля структуры идентично
имени переменной.Переменная в описании может быть не только
простой,но и сложной,например массивом или структурой.Параметры
ярлык_структуры и имя_структуры могут совместно не использо-
ваться,поэтому они заключены в квадратные скобки.Однако если
оба параметра будут отсутствовать описание структуры становиться
бессмысленным.Возникает законный вопрос,а зачем при описании
используются два идентификатора.Об'ясняется все просто:под име-
нем структуры подразумевается имя конкретной переменной,а под яр-
лыком структуры подразумевается описание нового производного
типа,а потом используя этот тип можно описать несколько пере-
менных с их конкретными именами.
     
Примеры:

1) Использование ярлыка_структуры.
 struct  st_primer {          /* Описан новый производный тип */
 char x;                      /* struct st_r                  */
  int y;
float z[100];
                   };
     
 struct st_primer a1,a2,a3;  /* переменные a1,a2,a2 описывают-*/
                             /* ся производным типом:         */
                             /* struct st_primer              */

2) Описание массива структур.
 struct {
  float f1;
  float f2;
 double f3;
        }x[100];

3) Задание структуры одновременно нескольких переменных.
 struct {
  char tt1[100];
  char word[22];
   int param;
        }sa1,sa2,sa3;

Ссылки:
2.2.4 Значение переменных.

2.2.1.3.2.1 Структуры с битовыми полями.

Битовое поле - это набор смежных битов внутри одной перемен-
ной типа int.
     
Общий вид описания:
     
struct [ярлык_структуры] {
       [тип_данных переменная_1]: размер_в_битах;
       [тип_данных переменная_2]: размер_в_битах;
       ...
       [тип_данных переменная_k]: размер_в_битах;
                         }[имя_структуры];
     
В описании тип данных может быть либо unsigned,либо int.Пере-
менная может быть только простой переменной.
Синтаксис описания и обработки полей основывается на структу-
рах.Ссылка на отдельные битовые поля сходна ссылке на элемен-
ты структур.Поля ведут себя как небольшие целые без знака -
тип unsigned.Поля могут не иметь имени - (т.е. не описана пере-
менная ), в этом случае они используются для заполнения сво-
бодного места.

Ограничения:Битовые поля не имеют адресов,поэтому к ним не
применима операция унарного &.

Ссылки:
2.2.4 Значение переменных.

2.2.1.3.2.2 Доступ к элементам структур.

Доступ к элементу структуры обеспечивает операция  .(точка).

Общий вид операции:
     
имя_структуры.имя_поля

Пример:

struct {                /* Описание структуры name_str     */
     int p1;
     int xy;
    char p2;
       }name_str;
int a1=3;              /* Описание переменной a1 типом int */
name_str.p1=a1;        /* Присвоение полю p1 структуры     */
                       /* name_str значение переменной a1  */
     
2.2.1.3.2.3 Об'единения.

Об'единение - это переменная ,которая в различные моменты
времени может содержать переменные разных типов и размеров.
Об'единение можно рассматривать как подвид структуры,в кото-
рой все поля имеют относительно друг друга нулевое смещение.
Общий вид описания:
     
    [класс_памяти] union [ярлык_об'единения]{
                   тип_данных переменная_1;
                   тип_данных переменная_2;
                   ...
                   тип_данных переменная_k;
                                           }[имя_об'единения];
   
 Описание сходно с описанием структуры.Различие в ключевом
слове :для структуры - это struct,для об'единения - union.
     
Пример:
 
 union u1{      /* Описание производного типа union u1 */
  int NUMBER;
 char ZNAK;
         };
  
 union u1 kod;  /* Переменная kod описывается типом */
                /* union u1                         */
     
2.2.1.3.2.3.1 Доступ к элементам об'единения.

Доступ к полям об'единения аналогичен доступу к полям
структуры.
     
Общий вид операции:
     
имя_об'единения.имя_поля
 
Примеры:
     
/* 1 */ kod.NUMBER=54; /* 54 записывается в об'единение,занимает
                   2 байта */
/* 2 */ kod.ZNAK='$'; /* $ записывется в об'единение на это же
                  место    */

Описание переменной kod преведено в предыдущем параграфе.
     
2.2.1.3.4 Указатели.

Указатель - это переменная,содержащая адрес другой переменной.

Общий вид описания:
     
[класс_памяти] тип *имя_указателя1[,*имя_указателя2,..];
     
При этом тип указателя может быть либо типом предопределенным
реализацией,либо производным типом - структурой.
     
Примеры:
     
/* 1 */
char *point1,*point2;  /* Описание двух переменных point1 и
                          point2 - указателей на  переменные
                          типа char                          */
/* 2 */
struct ab{             /* ab описывается как ярлык_структуры */
       int fg;
    double ng;
         };
struct ab *pst;      /* Переменная pst описывается как указа
                        тель на производный тип struct ab    */

2.2.1.3.4.1.1.Указатели и ячейки памяти.

Указатели позволяют осуществлять ссылку на любую ячейку памяти.
     
Общий вид операции:
     
имя_указателя=(тип *)номер_ячейки_памяти;

В переменную с именем указателя заносится соответствующий ад-
рес.Номер ячейки памяти может быть записан либо десятичным
числовым литералом,либо восьмеричным числовым литералом,либо
шестнадцатиричным числовым литералом.Тип должен соответство-
вать типу указателя в его описании.
     
Пример:

char p,*x;
x=(char *)0x1000;
p=*x; /* p присваивается значение находящееся по адресу
         0x1000 */

2.2.1.3.4.2.Операции над указателями.
     
Над указателями проводятся операции сложения и вычитания,а
также сравнения.

2.2.1.3.4.2.1 Сравнение указателей.

При сравнении двух переменных,если хотя бы одна из них является
указателем,то обе они рассматриваются как целые положительные
без знака числа (т.е. с типом unsigned).Сравнение указателя и
значения целой переменный,вряд ли может иметь смысл,но однако
это не запрещено.
     
Пример:
/* 1 */
int p[10],*k1,*k2;
k1=&p[5];  /* В k1 храниться адрес шестого элемента массива */
k2=&p[0];  /* В k2 храниться адрес нулевого элемента массива */

while(k1>k2){ /* Цикл ,пока адрес в k1 больше адреса в k2 */
     ...
     k1--;
     ...    }
...

2.2.1.3.4.2.2 Сложение и вычитание указателя с целыми числами.
     
При этих операциях большое значение имеет тип на который ссы-
лается переменная-указатель (т.е. тип из описания указателя).
Так как прибавление к указателю или отнимание от него целого числа
k означает изменение ячейки памяти хранящейся в указатели на
+ или - соответственно k*sizeof(тип) байт.

Пример:
/* 1 */
main(){
...
float *f;
char  *p;
...
f++;  /* Адрес в указателе,если он был там, увеличился на 4,
         т.к. переменная типа float занимает 4 байта */
p++;  /* Адрес в указателе,если он был там,увеличился на 1 */
     
2.2.1.3.4.2.3 Вычитание одного указателя из другого.
     
Вычитание из одного указателя другого имеет смысл если оба
указателя указывают на один и тот же об'ект одного типа,нап-
ример имеет смысл разность указателей на разные элементы мас-
сива.

Пример:
     
double *p1,*p2;/* Пример вычитания указателя p1 из указателя
                   p2 */
double x[100];
p1=x;          /* p1 присваивается адрес 0-элемента массива */
p2=(x+100);    /* p2 присваивается адрес 100-элемента массива */
/* Разность p2-p1 даст число элементов в массиве,компилятор
учитывает ,что размер одного элемента массива 8 байт и поэто-
му автоматически делит разность между двумя адресами на это
число */
printf("Число элементов в массиве %d\n",p2-p1);
     
2.2.1.3.4.3.Указатели и переменные различных типов.

Адрес переменной всех классов памяти,кроме register указатель
может получить при помощи операции унарного &.

Общий вид операции:
     
   &имя_переменной
  
Где адрес присваивается либо ранее описанному указателю,либо
передается функции в качестве аргумента.
Доступ к значению по адресу осуществляется при помощи
операции унарного *.

Общий вид операции:
     
   *имя_указателя
     
2.2.1.3.4.3.1 Указатели и простые переменные.

Пример:
/* 1 */
int p1,*p2,*p3;
*p2=16; /* В определенную ячейку памяти записывается число
16,а адрес этой ячейки хранится в указателе p2 */
p3=p2;  /* Адрес хранящийся в p2 копируется в указатель p3 */
p1=*p3; /* p1 присваивается значение хранящееся в ячейке па-
мяти по адресу находящемуся в указателе p3,т.е. p1 присваива-
ется число 16 */
     
2.2.1.3.4.3.2 Указатели и массивы.

Для массивов существует возможность использовать так называе-
мый "подлый трюк",позволяющий получать адрес элементов масси-
ва без использования операции унарного &.Он заключается в
том,что имя массива несет в себе информацию о адресе его нуле-
вого элемента.

Примеры:
/* 1 */
int p,*y,x[10];
x[0]=1;
y=&x[0];
p=*y;

/* 2 */
int p,*y,x[10];
x[0]=1;
y=x;
p=*y;
     
Из примеров следует ,что выражение y=&x[0] аналогично выраже-
нию y=x,а выражение y=&x[4] будет аналогично выражению y=(x+4).
     
Пример:
/* 1 */
/* Используя указатели получить значение 4-ого элемента мас-
сива */
main()
{
static int p[10];
int *px;
px=(p+4); /* px присваивается адрес 4-элемента массива p */
printf("%d\n",*px); /* Выдача значения элемента по адресу */
}
2.2.1.3.4.3.3 Указатели и структуры.

Указатели на структуры в языке Си применяются очень часто,по-
этому имеется специальная операция позволяющая обращаться к
элементу структуры,на которую указывает указатель.
     
Общий вид операции:
     
указатель_на_структуру->имя_поля
     
Эта операция аналогична выражению - (*указатель_на_структуру).имя_поля

Примеры:
     
/* 1 */
char x;
struct x1 {
     char px;
     char py;
      int p[15];
          };
struct x1 *px1;
...
x=px1->px;   /* Выражение аналогично выражению */
             /* x=(*px1).px                    */
/* 2 */
struct x1 x2,*px2;
px2=&x2;    /* Операция используется для структур,   */
            /* также как и для простых переменных */
     
     
2.2.1.3.4.4.Динамическое резервирование.
     
Динамическое резервирование - это есть процесс образования
новых переменных в процессе выполнения программы.Главный
смысл этого процесса в том ,что для этих переменных не требу-
ется предварительного выделения памяти.
     
Строка символов в Си может быть опеределена как символьный
массив,в этом случае место под эту строку будет зарезервиро-
вано,или как указатель на char,тогда место для строки не ре-
зервируется и его нужно резервировать самому либо при помощи
функции malloc и ей подобных,или при помощи присвоения указа-
телю адреса уже существующей строки.
    
Пример:

/* 1 */
char *p;   /* Описание аналогично описанию char p[] */
p=(char *)malloc(sizeof(char));
*p='k'; /* По адресу выделенному функцией malloc записывается
символ 'k' */

/* 2 */
char *p;
p="12345\n"; /* p присваивается адрес 0-ого элемента присваева-
                емой строки */

Указатели можно использовать для образования n-мерного массива.

Пример:
     
/* 1 */
char *massiv[2]; /* Описывается двухмерный массив */
                /* При описании выделяется место для трех
                   указателей на массив символов */
     
/* 2 */
char **p={"Good Bye!",   /* Описывается двухмерный массив     */
          "Hello!",      /* При описании выделяется место для */
          "ПРИВЕТ!!!!"};/* массива указателей на указателей  */
                         /* на символы (на массив символов)   */
                         /* Сразу же проведена инициализация */

2.2.1.4 Операции над типами.

В языке Си свыше 30 различных операций и 15 уровней их приорите-
та , что ведет к усложнению языка.Также следует отметить ,что
некоторые приоритеты операций установлены не верно.
Поэтому самое лучшее,что остается - это использовать скобки.
     
Таблица операций языка Си.
     
    Уровень          Оператор               Порядок
   приоритета                              вычислений
       1             () [] -> .              ---->
       2           ! ~ ++ -- -
                   (новый_тип) * &           <----
                      sizeof
       3              * / %                  ---->
       4              +   -                  ---->
       5             <<   >>                 ---->
       6             < <= > >=               ---->
       7             ==   !=                 ---->
       8                &                    ---->
       9                ^                    ---->
      10                |                    ---->
      11               &&                    ---->
      12               ||                    ---->
      13               ?:                    <----
      14           = += -= и т.д.            <----
      15                ,                    ---->

Чем меньше уровень операции,тем выше ее приоритет.
Стрелки в графе порядок вычислений указывают в каком направ-
лении производится вычисление последовательности операций
данного вида ----> (слева направо) или <---- (справа налево).

В зависимости от числа операндов над которыми производиться
операция,операции деляться на унарные - один операнд,бинарные
- два операнда,тернарные - три операнда.

Эти операции описаны в других пунктах справочника.
     
()          - вызов функции.
[]          - доступ к элементу массива.
.           - доступ к элементу структуры или об'единения.
->          - доступ к элементу структуры или об'единения,
              адресуемого указателем.
(новый_тип) - явное преобразование типа.
*           - унарная операция получения значения по адресу.
&           - унарная операция получения адреса переменной.

Ссылки:
2.2.1.3.1.2 Доступ к элементам массива,2.2.1.3.2.2 Доступ к
элементам структур,2.2.1.3.2.3.1 Доступ к элементам об'едине-
ний,2.2.1.3.4.2.3 Указатели и переменные различных типов,
2.2.1.3.2.3.3 Указатели и структуры,2.2.1.5.2 Явное преобра-
зование типов,4.1.1.1 Вызов функции.

2.2.1.4.1 Операция sizeof.

Операция sizeof возвращает количество байт требуемых для хра-
нения переменной определенного типа,либо занимаемых данной
переменной.

Общий вид операции:

sizeof(тип_данных);
sizeof(переменная);
     
Типом_данных может быть любой тип предоопределенный реализа-
цией.Переменной может быть либо простая переменная,либо мас-
сив,либо структура.
                   
Пример:
int k,p;
k=sizeof(int); /* k присвоено значение длины переменной типа
                  int */
p=sizeof(struct name_str); /* p присвоено значение размера
                              структуры name_str описанной
                              ранее */
2.2.1.4.2 Логические операции.
  
     !    унарная операция логического отрицания операнда
          стоящего справа.Если значение операнда ложь,опера-
          ция дает значение истина,иначе значение ложь.Уровень
          приоритета - 2.Операнды группируются справа налево.
    
    &&    бинарная операция логического И.Если оба операнда дают
          значение истина операция также дает значение истина,
          иначе значение ложь.Если в выражении ряд таких операций ,
          то обработка идет пока одна из них не даст значение ложь.
          Уровень приоритета - 11.Операнды группируются слева
          направо.
    
    ||    бинарная операция логического ИЛИ.Если хотя бы один
          из операндов имеет значение истина ,то результатом опе-
          рации будет значение истина,иначе значение ложь.Если
          в выражение входит несколько операций,то их обработка
          продолжается пока одна из них не даст значение истина.
          Уровень приоритета - 12.Операнды группируются слева
          направо.
     
2.2.1.4.3 Побитовые логические операции.

     &    бинарная операция побитового И.Если соответствующие би-
          ты операндов равны единице,то соответствующий бит
          результата будет равен единице,иначе он равен нулю.
          Уровень приоритета - 8.Операнды группируются слева
          направо.
     
     ^    бинарная операция исключающего ИЛИ.Если один(но не оба
          ) из соответствующих битов операндов равен едини-
          це,то соответствующий бит результата равен едини-
          це,иначе он равен нулю.Уровень приоритета - 9.
          Операнды группируются слева направо.
     
     |    бинарная операция включающего ИЛИ.Если один(или оба)
          из соответствующих битов операндов равен единице,то
          соответствующий бит результата равен единице,иначе он
          равен нулю.Уровень приоритета - 10.Операнды группиру-
          ются слева направо.
     
     ~    унарная операция дополнения до единицы.Происходит пре-
          образование каждого бита операнда по следующему
          правилу:если бит операнда равен единице,то соответ-
          ствующий бит результата равен нулю,и наоборот.
          Операнды группируются справа налево.

Пример:
/* 1 */
int f1,f2,f3;
f1=5,f2=3;
f3=f1&f2;  /* 00000101
              00000011
              --------
              00000001
            Значение f3=1 */
f1=f2^f3;  /* 00000001
              00000011
              --------
              00000010
            Значение f1=2 */
f2=f1|f3;  /* 00000010
              00000001
              --------
              00000011
            Значение f2=3 */
f2=~f2;    /* 00000011
              --------
              11111100
            Значение f2=252 */
     
2.2.1.4.4 Операции сдвига.
     
    <<    бинарная операция сдвига влево - дает в результате левый
          операнд,сдвинутый влево на число позиций, указанное
          в правом операнде.При каждом сдвиге в младший разряд
          записывается нуль.Уровень приоритета - 5.
          Операнды группируются слева направо.
    
    >>    бинарная операция сдвига вправо - дает в результате
          левый операнд ,сдвинутый вправо на число позиций ука-
          занных в правом операнде.При каждом сдвиге знаковый
          разряд не изменяется и распостраняется в следующие
          младшие разряды.Уровень приоритета - 5.Операнды груп-
          пируются слева направо.

2.2.1.4.5 Операции отношения.
 
     <    бинарная операция "меньше,чем" дает значение исти-
          на,если левый операнд меньше,чем правый;иначе опера-
          ция дает значение ложь.Уровень приоритета - 6.Опера-
          нды группируются слева направо.
     
    <=    бинарная операция "меньше или равно" дает значение
          истина ,если левый операнд меньше ,чем правый,или
          равен ему;иначе операция дает значение ложь.Уровень
          приоритета - 6.Операнды группируются слева направо.
     
     >    бинарная операция "больше,чем" дает значение исти-
          на,если левый операнд больше чем правый;иначе опера-
          ция дает значение ложь.Уровень приоритета - 6.Операн-
          ды группируются слева направо.
     
    >=    бинарная операция "больше или равно" дает значение
          истина, если левый операнд больше,чем правый,или
          равен ему;иначе операция дает значение ложь.Уровень
          приоритета - 6.Операнды группируются слева направо.
    
    ==    бинарная операция "равно" дает значение истина,
          если левый операнд равен правому;иначе операция дает
          значение ложь.Уровень приоритета - 7.Операнды груп-
          пируются слева направо.
     
    !=    бинарная операция "не равно" дает значение истина,
          если левый операнд не равен правому,иначе операция
          дает значение ложь.Уровень приоритета - 7.Операнды
          группируются слева направо.
     
Примечание:
     
Если один из операторов является адресом,то оба они рассмат-
риваются ,как положительные целые числа - (тип unsigned),ина-
че происходит алгебраическое сравнение чисел со знаком.
     
2.2.1.4.6 Математические операции.
     
     +    бинарная операция алгебраического сложения двух со-
          седних операндов и дает в результате из сумму.Уро-
          вень приоритета - 4.Операнды группируются слева направо.
     
     -    бинарная операция алгебраического вычитания правого
          операнда из левого дает в результате их разность.Уро-
          вень приоритета - 4.Операнды группируются слева направо.
     
     *    бинарная операция умножения двух соседних операндов.
          Уровень приоритета - 3.Операнды группируются слева направо.
     
     /    бинарная операция,дающая частное от деления левого опе-
          ранда на правый.Уровень приоритета - 3.Операнды груп-
          пируются слева направо.
     
     %    бинарная операция,дающая остаток от деления левого опе-
          ранда на правый.Уровень приоритета - 3.Операнды груп-
          пируются слева направо.Операнды не могут быть типа float
          или double.
     
     -    унарная операция,изменяющая знак операнда находяще-
          гося справа от знака операции.Уровень приоритета - 2.
          Операнды группируются справа налево.

2.2.1.4.7 Операции увеличения или уменьшения на единицу.
     
    ++    унарная операция увеличения значения переменной на еди-
          ницу.Если знак операции стоит перед операндом,то ре-
          зультат увеличенное значение переменной,иначе резуль-
          том является исходное значение переменной,но перемен-
          нная увеличивает свое значение.
     
    --    унарная операция уменьшения значения переменной на еди
          ницу,знак также может стоять перед операндом или
          после него.(см.операцию ++).
     
Примеры:

/* 1 */
int x1,x2;
x1=5;
x2=++x1;     /* x1 увеличивает свое значение на ед.*/
             /* и x2 присваивается значение 6      */
/* 2 */
x2=x1++;     /* x2 присваивается значение 6,а потом*/
             /* x1 увеличивает свое значение до 7  */
/* 3 */
x2=--x1;     /* x1 уменьшает свое значение на ед. и*/
             /* x2 присваивается значение 6        */
/* 4 */
x2=x1--;     /* x2 присваивается значение 6,а потом*/
             /* x1 уменьшает свое значение до 5    */

Примечание:
Уровень приоритета операций - 2.Операнды группируются справа
налево.

2.2.1.4.8 Операции присваивания.
     
Операции присваивания присваивают левому операнду правый
операнд либо не измененный,либо измененный.К первому случаю
относиться операция =,ко второму случаю операции вида:
имя_операции=
где имя_операции может быть одной из перечислен-
ных:+,-,*,/,%,&,|,^,<<,>>.

Выражение - Операнд1 имя_операции= Операнд2,можно заменить на
его эквивалент Операнд1=Операнд1 имя_операции Операнд2.
     
Примеры:
/* 1 */
x+=2;   /* Выражение эквивалентно x=x+2 */
/* 2 */
y-=45;  /* Значение переменной уменьшается на 45 */
     
2.2.1.4.9 Условная операция.
     
Общий вид операции:
     
выражение_1 ? выражение_2 : выражение_3
     
В результате выполнения операции вычисляется выражение_1,если
его значение отлично от нуля,т.е. ИСТИНА,то результатом опе-
рации будет значение выражения_2,иначе выражения_3.Выражения
используещие данную операцию группируются справа налево.Уро-
вень приоритета - 13.
     
Пример:
/* 1 */
#define min(a,b) ((a>b)? b : a)
     
2.2.1.4.10 Операция запятая.
     
Операция разделяет выражения,при зтом они группируются слева
направо.тип и значение результата соответствуют типу и значе-
нию самого правого операнда.
     
Пример:
/* 1 */
...
z=1;
if (p=1,z==p) /* Значение выражения в скобках будет ИСТИНА.)
     ...
     
2.2.1.5 Преобразования типов.
2.2.1.5.1 Неявное преобразование типов.
     
При обработке выражения при наличии переменных разных типов
все они приводятся к одному типу автоматически по следующим
правилам:

1.Типы char и short преобразуются в тип int,тип float в тип
double.

2.Если один из операторов типа double,второй также преобразуется
в тип double,иначе если один из них имеет тип long,второй
также преобразуется в тип long,иначе если один из них имеет
тип unsigned,второй также преобразуется в этот тип,в против-
ном случае оба оператора должны быть типа int.

2.2.1.5.2 Явное преобразование типа.

Явное преобразование типа переменной производиться с помощью
операции приведения типов.
     
Общий вид операции:
     
(новый_тип) выражение;
     
новым_типом - может быть один из типов предопределенных реа-
лизацией.Выражение может состоять как из нескольких перемен-
ных и литералов соединенных знаками операций,так и из одной
переменной или литерала.
     
Примеры:
     
/* 1 */
float x;
sqrt((double)x);
     
/* 2 */
char p;
p=(char)(134-34+23);
     
2.2.2 Классы памяти переменных.

Класс памяти в Си определяет область действия и время сущест-
вования переменной.Он задается либо непосредственно при опи-
сании переменной,либо присваивается компилятором по умолчанию
исходя из местонахождения описания переменной.Всего в языке
определено четыре класса памяти переменных:auto,register,extern,
static.
     
Таблица классов памяти.
 
Класс памяти   Время существования переменной  Область действия
auto            Временно                       Локальная
register        Временно                       Локальная
static          Постоянно                      Локальная
extern          Постоянно                      Глобальная
extern static   Постоянно                      Глобальная(1 файл)

2.2.2.1 Класс памяти - auto.

Переменная с классом памяти auto - автоматическая(локальная)
переменная( от англ. automation -автоматический).Переменные
этого класса определяются внутри функции.Локальные переменные
действуют в пределах одной функции и они являются временными
(на время действия функции).По умолчанию если переменная опи-
сывается внутри функции и класс_памяти не указан,она становиться
локальной переменной.

2.2.2.2 Класс памяти - register.

Переменная с классом памяти register - регистровая переменная.
Этот класс памяти дает информацию компилятору о том,что эта
переменная наиболее использумая и ее необходимо поместить в
быстрые регистры центрального процессора,что может в некоторых
случаях увеличить скорость выполнения программы.Если компилятор
не может выполнить помещение переменной в регистры ЦП,то переменная
получает класс памяти auto.Число регистровых переменных и их
типы ограничены и зависят от конкретного центрального процес-
сора.Переменные этого класса не имеют адресов,поэтому к ним не
применима операция унарного &.

2.2.2.3 Класс памяти - static.

Переменная с классом памяти static - статическая переменная.
Характеризуется постоянным временем существования,однако
локальная по области действия.

2.2.2.4 Класс памяти - extern.

Переменная с классом памяти extern- глобальная переменная
(от англ. external - внешний).Характеризуются тем,что область
ее действия вся программа ,а время существования постояное.
Если переменная описана вне функции и класс памяти не указан,
она по умолчанию становиться глобальной.
     
2.2.3 Описание переменных.

Переменные должны быть описаны до их использования.
Если переменные описаны вне функции,класс их памяти может
быть только extern и static.

Общий вид описания:
     
[класс_памяти] [тип_данных] переменная_1[,переменная_2[,переменная_3,..]];
     
Примечание:
Если не указан тип_данных,по умолчанию берется тип int.
     
Примеры:
/* 1 */ int x1;             /* Описание переменной x1
                               как об'ект типа int   */
/* 2 */   long int y1,y2,y3;/* Описание переменных y1,y2,y3
                               как об'ектов типа long int */
/* 3 */   long y1,y2,y3;    /* Описание идентично предыдущему
                               т.к. тип int в данном случае ука-
                               зывать не обязательно      */
/* 4 */   extern char x;    /* Описание символьной переменной
                               x ,как глобальной переменной,
                               т.е. имеющей класс памяти
                               extern */
/* 5 */   register int p;   /* Описание целой переменной p как
                               имеющей тип register,описание
                               будет правильным только внутри
                               функции */
/* 6 */ char *kk;           /* Описание указателя kk на символы */
/* 7 */ int p1;             /* Описание целой переменной p1 вне */
        main()              /* функции,класс памяти по умолчанию */
          {                 /* extern */
          ...
          }
/* 8 */   main()
          {
          int p1;           /* Описание целой переменной p1 */
          ...               /* внутри функции,класс памяти по */
          }                 /* умолчанию auto */

/* 9 */ char x[100][100],y,z; /* Описание двухмерного масси-*/
                              /* ва x и переременных y,z с  */
                              /* типом char                 */
     
/* 0 */   struct {char y;int p;}massiv[50],ed1;
                            /* Описание массива из 51 структуры */
                            /* и структуры ed1 */
 
     
2.2.4 Значение переменных.
  
Переменные по виду их значения деляться на простые и слож-
ные.К простым переменным относяться переменные имеющие еди-
ничные значения,к сложным переменные имеющие значением список
данных в фигурных скобках.
     
2.2.4.1 Начальная инициализация.
     
Начальная инициализация или присвоение значения переменной при
ее описании возможно для всех классов памяти,однако с некото-
рыми ограничениями.Локальным переменным,т.е. переменные классов
auto и register,нельзя присваивать сложные значения,т.е. за-
писанный в фигурные скобки список значений переменных через
запятую,на переменные класса памяти static и extern эти огра-
ничения не распостраняются.

Пример:
     
main() {
...
...
int p[2]={1,2,3};              /* Инициализация не верна */
extern char p1={'a','b','c');  /* Инициализация верна */
...
...
      }
       
Если при описании переменным класса памяти extern и static не
присвоены значения,то по умолчанию переменные или их элементы
получают значение нуль.Переменные класса памяти auto и register
в этом же случае имеют неопределенные значения,так называемый
"мусор".
     
Общий вид начальной инициализации:
     
[класс_памяти] тип имя_переменной1=значение1[,имя_переменной2=значение2,..];

Значение может быть простым значением,т.е. единичным значени-
ем или сложным-(для производных типов:массивов и структур).

Примечание:
Начальная инициализация переменных с классом памяти extern и
static проводится один раз до начала выполнения программы,а
начальная инициализация переменных с классом памяти auto и
register проводится при каждом обращении к функции или соста-
вному оператору (в зависимости от того где находиться описа-
ние переменной).

Инициализация переменной сложным значением подчиняется нес-
кольким правилам.

1. При явной инициализации массива размер его можно не зада-
вать,его размер компилятор устанавливает сам исходя из коли-
чества значений в сложном инициализаторе.

Пример:
     
/* Размер массива усстанавливается равным  4  */
static int p[]={1,2,3,4,5};
     
2. Для символьных строк используется специальная нотация,поз-
воляющая использовать вместо списка переменных в фигурных
скобках строку символов.

Пример:

/* Первое описание по смыслу идентично второму, */
/* но в то же время гораздо удобнее в написании и осмыслении */

/* 1 */ extern char privet[]="ПРИВЕТ!";
/* 2 */ extern char privet[]={'П','Р','И','В','Е','Т','!','\0'};

     
3.Для массивов второго и более порядков,или для структур со-
держащих другие структуры или массивы используются в качестве
инициализаторов списки переменных содержащие подсписки.Обра-
ботка подсписков осуществляется по следующему принципам:
     
Если значений в списке меньше ,чем необходимо,то соответс-
твующие недостающие принимаются по умолчанию за нуль.
Если значений в списке больше,чем это необходимо,то это пов-
лечет за собой ошибку.
Если список содержит подсписки,то эти принципы применяются к
ним рекурсивно.

Примеры:
     
/* 1 */ /* В первом примере производиться инициализация двух-
           мерного символьного массива тремя равнозначными
           способами */
static char p[2][3]={"qwe","dfg","drt"};

static char p[2][3]={{'q','w','e','\0'},
                     {'d','f','g','\0'},
                     {'d','r','t','\0'}};
Подсписки можно и не использовать,в этом случае компилятор
инициализирует элементы согласно порядка их написания,напри-
мер таким образом можно записать предыдущий пример.
     
static char p[2][3]={'q','w','e','\0','d','f','g','\0','d','r','t','\0'};

/* 2 */
static int p[4][2]={1,2,3,4,5,6,7,8,9,0};

/* Массив будет инициализирован так:
         Столбцы 0  1  2
Колонки
   0             1  2  3
   1             4  5  6
   2             7  8  9
   3             0  0  0
   4             0  0  0              */
static int p[4][2]={{1,2},{3,4},{5,6},{7,8},{9,0}};

/* Массив будет инициализирован так:
         Столбцы 0  1  2
Колонки
   0             1  2  0
   1             3  4  0
   2             5  6  0
   3             7  8  0
   4             9  0  0             */

/* 3 */
struct {
       char *x;
       char y[5];
       }z[]={
       "ОДИН","ONE",
       "ДВА","TWO"};

2.2.4.2 Присвоение значения переменной после ее описания.
     
Присвоение значения переменной после ее описания производить-
ся с помощью операций присваивания.
     
Примеры:

/* 1 */ x=a;
/* 2 */ MAX=8;
/* 3 */ y-=(7-f+x);

     
