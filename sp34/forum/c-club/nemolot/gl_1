Глава 1.
Элементы языка.

1.1 Идентификаторы.

Программы в языке Си оперируют с об'ектами.Все они идентифи-
цируются именем (идентификатором).
В качестве идентификатора могут использоваться любые имена
удовлетворяющие синтаксису Си,кроме зарезервированных слов.
Первым символом имени должна являться буква,а остальные сим-
волы могут быть буквами,цифрами.Буквы могут быть только ла-
тинского алфавита.Символ '_' рассматривается как буква.Имя
может быть любой длины ,однако для Си описанного в K&R зна-
чение имеют первые восемь символов ,поэтому для классического
Си идентификаторы aaaaaaaa1 и aaaaaaaa2 являются одинаковыми.

Примеры правильных идентификаторов:
     
schetchik   get_line    a12   Param1  _ab
     
Примеры неправильных идентификаторов:
     
%ab  12abc -x

Пробелы внутри идентификаторов не допускаются.Следует отме-
тить ,что Си относиться к тем языкам,в которых прописные и
строчные буквы не являются эквивалентными и поэтому иденти-
фикатор primer не равнозначен идентификатору PRIMER.

1.1.1 Список зарезервированных слов (с переводом).
     
auto     -  автоматический     if        -  если
break    -  завершить          int       -  целое
case     -  вариант            long      -  длинное
char     -  символьный         register  -  регистровый
continue -  продолжить         return    -  возврат
default  -  по умолчанию       short     -  короткий
do       -  выполнить          sizeof    -  размер
double   -  двойной точности   static    -  статический
else     -  иначе              struct    -  структура
entry    -  вход(*)            switch    -  переключатель
extern   -  внешний            typedef   -  определение типа
for      -  для                union     -  об'единение
float    -  плавающее          unsigned  -  без знака
goto     -  перейти            while     -  пока
     
* - ключевое слово зарезервировано для использования в будущем.
     
1.2 Литералы.

Литерал - это либо числовой литерал,либо символьный лите-
рал,либо строковый литерал.

1.2.1 Числовые литералы.

Числовые литералы за которыми следует символ l(эль-маленькое)
или L(эль-большое),являются длинными литералами(т.е.литерала-
ми с значениями в диапазоне для типа long int для целых или
long float для вещественных чисел).

1.2.1.1 Числовые десятичные литералы.

Литерал не начинающийся с 0 или 0x,является числовым десятич-
ным литералом.Десятичный литерал - это литерал,выраженный в
общепринятой десятичной системе.Если литерал включает в себе
точку,то он является вещественным,иначе целым.
Порядок литерала задается с помощью символа E и идущих после
него цифр со знаком: - или + или без него.
Буква E в порядке может быть строчной или прописной с одним и
тем же значением.Для получения значения литерала необходимо
умножить значение литерала без порядка на степень десяти за-
данную порядком.

Примеры:

/* 1 */ 57          /* Целые десятичные литералы */
/* 2 */ 3200000l
/* 3 */ 2e3
/* 4 */ 5E3

Примеры:
   
/* 1 */ 0.00        /* Вещественные десятичные литералы */
/* 2 */ 5.3
/* 3 */ 7.1e-3
/* 4 */ 6.34E-2
/* 5 */ .21e+56
     
1.2.1.2 Числовые восьмеричные литералы.

Лидирующий нуль (0) указывает на числовой восьмеричный литерал.

Примеры:

/* 1 */  030   /* Десятичное 24 */
/* 2 */  040   /* Десятичное 32 - символ пробел */


1.2.1.3 Числовые шестнадцатиричные литералы.

Лидирующий 0x указывает на шестнадцатиричный числовой литерал.

Примеры:
     
/* 1 */  0x22  /* Десятичное 34 - символ " */
/* 2 */  0x6С  /* Десятичное 108 - символ i */

1.2.2 Символьные литералы.

Символьный литерал - это один символ,заключенный в одинарные
кавычки.

Примеры:

/* 1 */ 'c'
/* 2 */ '*'
/* 3 */ 'q'

Некоторые наиболее употребимые неграфические символы или
символы имеющие специальное употребление для Си
могут быть представлены в виде условных последовательностей
начинающихся с символа \(обратная косая черта).

    \n     перевод на новую строку.
    \t     табуляция.
    \0     код ASCII равный 0.
    \\     графическое изображение обратной косой черты.
    \'     одинарная кавычка.
    \"     двойная кавычка.
    \(     открывающая скобка.
    \)     закрывающая скобка.
     
1.2.2.1 Символьные восьмеричные литералы.

Символьный восьмеричный литерал можно записать,как
'\ddd' , где ddd - от  одной до трех восьмеричных цифр.
     
Пример:

/* 1 */  '\007'    /* Звонок */
     
1.2.2.2 Символьные шестнадцатиричные литералы.

Поддерживаются ANSI Си.Задаются в виде
'\xdd' , где dd - одна или две шестнадцатиричных цифр
/0..9,A..F/.Вместо строчных букв от A до F,можно использовать
с тем же значением прописные буквы от a до f.
     
Пример:

/* 1 */ '\x0a'    /* Перевод на новую строку */
     
1.2.3 Строковые литералы.

Последовательность из n-ого количества символов,заключенных в
двойные кавычки,называется строковым литералом.

Пример:

/* 1 */ "STRING\n"
/* 2 */ "" /* Строчный литерал состоит из одного символа '\0'  */
     
Длинный строковый литерал может быть продолжен на следующей
строке,если поместить в конце продолжаемого литерала символ
обратной косой черты.
     
Пример:
/* 1 */ "Очень,"\
        "очень,"\
        "очень длинный строковый литерал!"
     
Ссылки: Строки 2.2.1.3.1.1.
     
1.3 Комментарии.

Комментарии в Си это последовательность символов начинающаяся
с  символов /* и оканчивающаяся символами */ .В Си описанном
в K&R вложенные комментарии не поддерживаются.Комментарии не
влияют на программу и служат средством для ее более удобного
восприятия.Комментарии при компиляции не включаются в текст
программы,поэтому они не влияют на скорость ее выполнения.

Примеры:

/* Короткий комментарий */
     
/* Очень,
   очень,
   очень длинный комментарий */

1.4 Препроцесор.

Информация для препроцессора помещается в строку начинающуюся
с символа #.Эта строка может находиться в любой части текста
программы.Препроцессор обрабатывает все обращения к нему пе-
ред началом компиляции,именно поэтому он получил такое назва-
ние.Препроцессор выполняет три основных функции:осуществляет
макроподстановку,включает в текст программы тексты из указан-
ных файлов и выполняет условную компиляцию.

1.4.1 Макроподстановка.

Конструкция #define позволяет осуществлять подстановку вместо
идентификатора набора указанных символов во всем тексте прог-
раммы,кроме того случая когда идентификатор находиться внутри
двойных кавычек.

Общий вид:

#define  идентификатор  набор_символов

Набор_символов может быть литералом,либо вызовом функции,либо
набором выражений заключенным в фигурные скобки.

Примеры:
/* 1 */
#define STRING  "Добрый день!"
/* 2 */
#define ERROR  {printf("ОШИБКА !\n");exit(0);}

1.4.1.1 Макросы.
     
Идентификатор может быть определен как макрос с аргументами,в
результате чего заменяющий текст будет зависеть от вида обра-
щения к макросу.

Пример:

/* Определяем макрос PRINT_M с аргументами x,y,z */
#define PRINT_M(x,y,z) printf("%s-%d-%d",x,y,z)
/* В текст программы введем */
...
PRINT_M(a+b,ITOG,STRING1);
...
/* После работы препроцессора указанный оператор будет выгля-
деть так */
...
printf("%s-%d-%d",a+b,ITOG,STRING1);
...
     
Ссылки: Константы 2.1.
1.4.2 Включение файлов.

Конструкция #include позволяет включить вместо себя в тело
программы заранеее подготовленный текст из файла.

Общий вид:
     
/* 1 */
#include "имя_файла"
/* 2 */
#include <имя_файла>

Примечание:

В первом случае файл вначале ищеться в каталоге указанном в
имене_файла и если там не будет найден,то в каталогах указанных
в PATH и каталогах указанных в конфигурации Си транслятора.
Во втором случае поиск сразу производиться в каталогах по умол-
чанию  для операционной системы и транслятора.

Дополнительная информация:
     
Наиболее часто включаются в программу так называемые файлы
заголовков (header-файлы),т.е. файлы с типом h,поставляемые
вместе с транслятором Си.В них содержатся описания всех биб-
лиотечных функций,а также наиболее употребимых переменных и
констант.

Пример:
     
/* 1 */ #include <stdio.h> /* В текст программы включаются
                              описания функций,констант и пе-
                              ременных стандартного ввода/вывода */

1.4.3 Условная компиляция.
     
Эта функция препроцессора позволяет компилировать части прог-
раммы в зависимости от выполнения или не выполнения како-
го-либо условия.
В препроцессоре используются следующие выражения:

#if константное_выражение
если константное выражение истинно,т.е. отлично от нуля,про-
изводится компиляция всех строк программы либо до строки #else,
либо если ее нет до #endif.Команда #endif ограничивает ту
часть текста,которая управляется командой #if,#ifdef,#ifndef.
Если же константное_выражение ложно и использована конструк-
ция #else будет произведена компиляция всех последующих строк
до команды #endif.Аналогичным образом #else используется для
конструкций #ifdef и #ifndef.
     
#ifdef идентификатор
если идентификатор определен перед этим конструкцией #define ,
то условие истинно,иначе ложно.
     
#ifndef идентификатор
конструкция противоположна по смыслу предыдущей конструкции.
Условие истинно в том случае, если идентификатор не определен
в #define.
     
#undef идентификатор
Конструкция приводит к отмене определения данного идентифика-
тора,если он раньше был использован в конструкции #define.
                                                          
Пример:
...
#define SMALL   /* Определяем идентификатор SMALL */
#ifdef  SMALL   /* Если идентиф. SMALL определен компи- */
printf("МАЛАЯ МОДЕЛЬ\n");  /* лируется эта строка, */
#else                      /* иначе */
printf("БОЛЬШАЯ МОДЕЛЬ\n");/* эта строка */
#endif
#undef SMALL    /* Отменяем определение идент. SMALL */
#ifndef SMALL   /* Если идентиф. SMALL не определен */
printf("НЕ МАЛАЯ МОДЕЛЬ\n");  /* компилируется эта строка, */
#else                         /* иначе */
printf("НЕ БОЛЬШАЯ МОДЕЛЬ\n");/* эта строка */
#endif
...
     
/* В результате обработки препроцессора - эта часть программы
будет выглядеть так: */
     
...
printf("МАЛАЯ МОДЕЛЬ\n");
printf("НЕ МАЛАЯ МОДЕЛЬ\n");
...

1.5 Квалификаторы.

Квалификаторы используются для изменения диапазона значений
типа,за счет изменения количества памяти занимаемой переменной
изменяемого типа.
При описании типа_данных возможна следующая запись с исполь-
зованием квалификаторов.

[квалификатор] тип

Где тип предопределен реализацией.В Си описанном в K&R три
вида квалификаторов:short,long,unsigned.При использовании
квалификаторов с типом int,тип можно не указывать.

1.6 Выражения.
     
Выражение - это от 1 и более об'ектов,над которыми проводять-
ся операции,в результате которых вычисляется некоторое значение.
     
Примеры:
     
/* 1 */ ++x
/* 2 */ k=(f()+7)*y
/* 3 */ p-=56+y
