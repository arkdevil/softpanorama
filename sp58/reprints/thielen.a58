Уважаемые коллеги!

Хочу пpедложить вашему вниманию статью из позапpошлогоднего номеpа MSJ
(Microsoft System Journal). В ней pассматpиваются интеpесные, на мой взгляд,
оpганизационные пpинципы pазpаботки пpогpаммного обеспечения: фоpмиpование
пpогpаммистских коллективов, pазделение pабот, pоль pуководителя пpоекта,
оплата пpогpаммистского тpуда и т.п. Думаю, что многие из пpедлагаемых
автоpом подходов могут быть пpименены в наших условиях.

С уважением,
П.Ведин
paul@paul.sita.kiev.ua

--------------------------------------------------------------------------
Unconventional Thoughts on Managing PC Software Development

David Thielen
(MSJ, 1991, Volume 6, N 3)

Over the past several years I have successfully developed a number of
software programs and have had the opportunity to observe several software
companies, some very successful and some barely making it.
This article discusses the approach that I believe will lead to successful
software development. When I say _software development_, I am talking about
software for personal computers such as the PC, the Macintosh, workstations,
and so forth. Exceptional software is almost always developed quickly by
small teams of developers. Many of the top-selling PC programs today were
developed by one or two people. Meanwhile, the typical corporate method
of doing business, which works well for many other types of products, usually
involves extensive planning, numerous people, and a traditional
management style. This method is often completely ineffective for software
development.

The single most important change needed in this management style is that
each programmer must be given total responsibility and control for part of
a program. Each programmer should be responsible for the design, coding,
and debugging of a specific part of a program, and be encouraged to judge
for themselves how each part should appear and function. I have often had
developers who are working for me tell me that I am wrong about my approach
to a project. I talk to them to find out why they disagree with me and I
try to work out a compromise. But, if we can't reach an agreement, the
developer almost always has the final decision.

Also, programmers should not work on several projects at once. People will
work very hard and effectively to get a single project done. They will not
work nearly as efficiently if they are pulled in seven different directions to
get seven different projects completed. The point is to give each programmer a
sense of ownership in part of the program. People who have some control over
a project's success usually will work as hard as they can to make it as good
as possible.

This is a very big change from traditional work style. A programmer's job is
 no longer to work a set number of hours per day on a set task until that
 task happens to get done. The job now is to develop a finished piece of
 software as the sole person responsible for its design, coding, and testing.
As I see it, a person who is told what to code and how to do it is a
programmer. I call the person who determines what to do and does it on their
own a developer. Companies that have programmers usually write bad
software very inefficiently. Companies that have developers often write
super software efficiently. Obviously, we have to turn programmers into
developers. The increases in productivity, innovation, and quality are
incredible when this happens.

When I started as director of software development at my previous company,
a project with six programmers on it had been in development for more than
three years and was perhaps 25 percent completed. One person would specify
a section after which a second would design it and break it into server,
client, and fourth-generation language (4GL) components. These three parts
would then be given to three programmers to code separately. When they were
finished, a sixth person would test the programs.

Almost nothing was getting done. In addition, the programmers had realized
a year earlier that the 4GL chosen would not work in the final user
environment, but they kept on using it. These were intelligent people who
cared about getting the project done, but they were placed in a situation
where they couldn't succeed. The first change I made was to break the project
into six pieces and give each person one complete part. This change was
probably the largest factor in turning the project around. Because each
developer now had a piece of the project that was totally their responsibility,
the next quarter of the project was completed in four months.

The second big change in management style is to not rule by consensus.
When managed efficiently, many software programs can be written in three to
six months. And, if you don't write it that quickly, someone else probably
will in the meantime. If you take the time to study the project, arrive at
a consensus, and completely design a product, the people who instead just sat
down and started programming with only a basic plan will probably have already
been selling their product for several months. Timing is such a big factor
in the success of software that, if a new product is introduced six months
before its competitors, it can dominate its market. Meanwhile, a product
that is over eighteen months old may start to lose large amounts of market
share if a good update does not come out quickly. SideKick by Borland
International Inc. is a good example of the importance of being first.
Numerous desktop utilities came out six months to a year after SideKick that
may well have been superior to it. But, SideKick was good enough as well as
the first product of its type so it still dominates the market.

WordStar is a classic example of losing market share because of waiting too
long between updates. WordStar was one of the first successful PC word
processors, and the first version totally dominated the word-processing
market. However, MicroPro failed to produce major updates for several years
and lost a drastic amount of the market share to competitors such as
WordPerfect. Incidentally, my experience has been that most software designed
by group consensus is not that good anyway. The specification for the ADA
compiler was designed by the U.S. government and a number of big companies,
many of them aerospace firms. Today, few use it unless required to by
government contract. By contrast, the C language was designed (and initially
written) by two developers, and is now used to develop over 85 percent of
commercial PC software.

Finally, when developing a new software product, a number of the ideas that go
into a good product may seem bad ideas at first. Individual developers should
be allowed to take something that others don't initially like and prove it
to be a good idea. When I was developing a litigation support system for
attorneys, I created a menuing system that everyone hated. But I believed
that it was a good interface and kept it in. Once the product was finished
and people could really work with the interface, everyone (including the
people who had hated it) loved it.



Project Design

You should eliminate exhaustive and rigorous project design and review.
A project proposal should be less than a page long and preferably only a
sentence or two. Anything more bogs the project down in bureaucracy before
it even starts. Most of the design should evolve as the program is written.
There should be few formal, ongoing reviews of a project. At the end of four
to six months, the basic program should be working. At that time, look at it
and determine if it makes sense to continue. At the end of an additional four
to six months, it should be completed. You should monitor progress on the
project by talking frequently to the individual developers as it is being
written.

Faith is also an important element. Essentially, you have to trust your
developers to create a good product. If you are reviewing each step of the way,
developers no longer have control or responsibility and become just
programmers again. Also, they spend so much time in meetings that they have
almost no time left to program. You will still have failures using this
method. However, you'll now tend to have _fast failures_, as design flaws
and bugs surface sooner and more frequently. When you fail quickly, you have
more time left to find other approaches and solutions.

When I wrote my first commercial program, I knew very little about application
programming (I had written scientific programs for my own use up to that
point). I also knew almost nothing about the vertical market for which I was
writing the program. I did no studies, research, or design because I had
neither the time nor the money. I just started writing the program and six
months later I was selling the best product on the market and doing several
million dollars a year in business.

Developers must also feel free to say what they think to their supervisor.
Constant feedback is essential for the developers to be able to test new
ideas and for management to know what is happening. In a free market of
ideas, all have a chance to get brought forth and the good ones can survive.
The manager of a software project should be one of the developers of the
program. The majority of a manager's time should be spent designing and
writing part of the program. The rest of the time should be spent talking to
the others on the project to make sure the project is going in the right
direction.

The developers' supervisor must be a very good programmer in his or her own
right. A manager who cannot do nearly everything the developers under him or
her are doing cannot possibly follow what is happening. I don't know of a
single successful software company where the individual in charge of all
software development isn't a very good developer. I feel no project should
have more than six people working on it or take more than a year to develop.
Adding more people, especially late in the game when the project has gone
over schedule, just slows it down more. It's not just that the seventh person
adds no productivity to the group, but the seventh person actually lowers
total productivity. If Ford needs to produce more cars, they don't put more
people on an assembly line; they build another assembly line. If they put
too many people on an assembly line, the line produces fewer cars because
people get in each other's way. Software is very similar. Assigning large
numbers of people to a project essentially guarantees that you will turn
everyone into programmers and that the project will take several years to
develop.



Compensation

Compensation must be based on the developer's skill. Age, schooling, and
seniority should be irrelevant. You hire developers because you want them to
write great code. If they can, and you want to keep them, you'll need to pay
them well. One of the best programmers I know never went to college but that's
not reflected in his salary. There should be no overtime pay. A developer
is paid to develop software, so compensation should be based solely on how
well they do that. If one person works twice as many hours as another but
they both complete comparable projects in the same amount of time, they
should still be paid the same. If someone is paid overtime for working long
hours even though they get nothing done, you are sending your employees the
message that the appearance of work is more important than actual work
produced. If someone who does a great job is paid the same (or even worse,
less) than someone doing a mediocre job, you are giving that person the
message that their development abilities are not important to you. Nowadays,
good programmers often make over $50,000 a year and excellent programmers
often make over $100,000 a year. Great programmers, and there are a number
of them, can make over a million dollars a year. These highly paid people
produce the software that sells millions of copies and makes millions of
dollars for the firms that employ them.

When possible, a significant portion of each person's compensation should be
bonuses or profit-sharing based on the projects completed. This kind of
remuneration gives a developer an extra incentive to complete projects quickly
and deliver an excellent product. Remember, an employee's pay is the truest
measure of how much an employee is valued by a company. Employees will not
have much loyalty if they are poorly paid. Also, if a developer is good
enough, other companies will offer them what they are worth.



Work Environment

The most important part of the work environment is flextime. Developers should
be able to work the hours they choose. If someone worked late the night
before, it is counterproductive to demand that they show up at 9:00 the next
morning, too tired to do much. There is a saying (mostly true), that if a
developer is at the office at 9:00AM, it is because he or she worked through
the night. When a developer reaches a point where his or her brain stops
working (which will happen about once a month in an intense programming
environment), he or she should be able to take one or two days off. Until they
take this time off, their productivity is usually so low as to be almost
worthless.

When a project is completed, all the developers on the project should be given
an extra week to two weeks off immediately. Developing a product is like
running a marathon and you need to rest your brain when you are done.
Developers should each have their own office. At worst, there should only be
two in an office (not partitions, but a real office with walls to the ceiling
and a door that can be shut). It is amazing to me that anything gets done in
today's average _open-cubicled_ office. A developer needs to be able to
concentrate for extended periods of time and an office gives them the privacy
and quiet to do so. At my previous job, after I placed developers in separate
offices, each developer told me that their productivity shot up enormously.
They no longer had their train of thought interrupted all the time.

Finally, eliminate the dress code. I have never met a programmer who did an
adequate job and wore a tie to work. Many good programmers wear shorts and
sandals to work every day. If you require a developer to dress up, you are
telling them that part of their job is how they look rather than what they do.
Writing software is a lot like writing a book. Almost anyone can write garbage,
a number of people can write good stuff, and a few people can write
best-sellers. Most successful books are written by one or two people, just
like successful software.

In the software industry, many companies take ten people who aren't very good
and have them work together. The idea being that they will produce something
ten times better. Unfortunately it usually ends up being ten times worse.
Can you imagine a book publishing company working like a software company?
Imagine telling Hemingway that before he wrote, he had to design the plot with
a committee of writers. Then he would write some of the chapters, but others
would write the rest of the book and there would be weekly meetings to ensure
that the chapters flowed together. Many software companies work like this as
a matter of course. When you think of writing software, think of what you
would do if a best-selling author came to you and said they wanted to write
a book for you. A good software developer should be treated the same way.



Examples

The original Lotus 1-2-3 and dBASE programs were two of the most successful
application programs ever written. 1-2-3 was written mostly by one person in
eighteen months. The macro capability, one of the things that made 1-2-3
really successful, was added by the developer at the end because he had some
extra time it wasn't even in the informal spec he had. dBASE was written by
one person over a two-year period while he also held a full-time job. BRIEF
(a popular text editor) was written in six months by two developers who had
just graduated from college. The Zortech C++ compiler was written by one
person in under a year.



What It Will Take

What all this really comes down to is encouraging individuals to make their
own decisions and follow through on them. It means encouraging employees to
believe in themselves and to have the confidence to push to do things their
own way. I wonder how many people will implement the preceding ideas as they
contradict some of the basic tenets of standard business management. They
emphasize the individual instead of the group. They encourage disagreement and
they give the primary power and responsibility to the developer, rather than
to the manager and the firm.

The question is not can it be done, the question is, will your company do it?
If your company implements these ideas properly, the potential return is
limitless.

Copyright (c) 1991 David Thielen

---
Paul V. Vedin:  paul@paul.sita.kiev.ua
                paul@pmb.cs.kiev.ua
TRION Ltd.      23b, Krasnoarmeiskaya Str., 252004, Kiev, Ukraine
                +7 (044) 221-27-94




