                                  
                     INTEL 80860 - архитектура и применение
                     --------------------------------------
                                               
                                         Нил Маргулис
     
             │    Суперскалярная архитектура вы- │
             │ водит  микропроцессоры  на новый  │
             │ уровень производительности        │
                                                                    
                          В начале 1989 года фирма Intel аннонсирова-
                     ла выпуск своего первого коммерческого процессо-
                     ра  с архитектурой RISC - 80860. Процессор 80860
                     работает с тактовой частотой до 50 МГц;  он  был
                     назван суперкомпьютером на одном чипе.
                          Нил Маргулис - главный инженер фирмы  Intel
                     по  разработке  приложений  для высокопроизводи-
                     тельных процессоров.
     
                                          
      В микропроцессоре Intel 80860 используется передовая архитекту-
ра, позволившая сбалансировать целочисленные операции  и  операции  с
плавающей  запятой.  Имея более миллиона транзисторов, 80860 содержит
RISC-ядро, блок операций с плавающей запятой, блок управления памятью
(БУП: memory management unit - MMU), модуль графики, а также раздель-
ные кеш-буферы команд и данных.
      RISC-ядро и БУП позволяют процессору 80860 реализовывать много-
задачные операционные системы. Его возможности в отношении операций с
плавающей запятой поддерживают развитое моделирование, обработку сиг-
налов и звука, а так же приложения автоматизированного проектирования
(CAD). Процессор обеспечивает вычислительную поддержку и  отображение
трехмерных  изображений. Эти возможности позволяют системе отображать
огромный объем числовых данных в  качестве  генерируемых  компьютером
графических  образов, что облегчает пользователю отслеживание законо-
мерностей.
      В отличие от традиционных систем, где эти возможности рассредо-
точены по нескольким чипам, 80860 разрабатывался с  целью  интегриро-
вать все эти свойства. Результат - завершенная архитектура для выпол-
нения  целочисленных  операций,  управления памятью, высокопроизводи-
тельной математики с плавающей запятой и трехмерной графики.
      80860 исключает необходимость в  поддерживающих  чипах,  таких,
как  сопроцессоры плавающей арифметики, векторные процессоры, процес-
соры цифровой обработки сигналов  и  графические  сопроцессоры.  Пол-
ностью  завершенная архитектура, начинающаяся с процессора, облегчает
задачу разработчикам программных средств и позволяет создавать  более
мощные прикладные программы.


                          Анализ архитектуры
                          ------------------
                                             
      Главный  функциональный  узел микропроцессора 80860 и его связи
показаны на фиг.1 . Объединяя все функциональные модули в одном чипе,
его разработчикам удалось оптимизировать коммуникационные каналы меж-
ду ними. Объемная внутренняя магистраль уравновешивает поток данных и
скорость работы многочисленных узлов. Раздельные наборы по 32 регист-
ра в RISC-ядре и модуле плавающей арифметики  обеспечивают  поддержку
параллельного функционирования.
      Широкое использования внутричиповых конвейеров увеличивает про-
изводительность. RISC-ядро имеет четырехстадийный конвейер, состоящий
из операций выборки, декодирования, выполнения и записи. Умножитель и
сумматор  с  плавающей запятой также содержат трехстадийные конвейеры
каждый. Вдобавок трехстадийный загрузочный конвейер связан с  внешней
процессорной шиной, которая поддерживает три рассредоточенных цикла.
      RISC-ядро выбирает одновременно команды целочисленной и плаваю-
щей  арифметики из кеш-буфера команд. Центральный процессорный модуль
позволяет программисту указывать два режима команд: одно-  и  двухко-
мандный.
      Однокомандный  режим является традиционным режимом, при котором
команды выбираются последовательно. Конвейер  позволяет  преобразовы-
вать  последовательный поток команд так, что несколько инструкций мо-
гут выполнятся одновременно, каждая в своем блоке.
      80860 в двухкомандном режиме просматривает поток команд на  шаг
вперед и выбирает следующую команду. Этот режим инициализирует однов-
ременно  две команды - одну для RISC-ядра, а вторую - для модуля пла-
вающей арифметики. Этот модуль получает один результат за  один  цикл
синхронизации  и имеет "двухоперационные" команды, в которых операции
сложения и умножения выполняются одновременно.
      Программисты могут комбинировать двухкомандный режим и двухопе-
рационные команды для выполнения трех команд за один цикл синхрониза-
ции. В этой модели выполнения программы  RISC-ядро  может  выполнять,
загружать,  выгружать и выполнять команды ветвления во время выполне-
ния плавающей операции.
      Результат таков, что пиковая производительность может быть дос-
тигнута при выполнении внутренних циклов обычных прикладных программ.
Встроенный в чип кеш-буфер данных или внешняя память могут  загружать
данные в регистры плавающей запятой.


                                Графика
                                -------

      Аппаратные  средства  плавающей запятой процессора 80860 эффек-
тивно выполняют графические манипуляции, включая ротацию, масштабиро-
вание, перенос и развитые вычисления прохождения  лучей,  необходимые
для трехмерной графики. Проецирование трехмерного изображения требует
специальных  операций  для  затенения и удаления невидимых компонент.
Аппаратные средства графического модуля ускоряют эти многоступенчатые
операции, используя регистры с плавающей  запятой  и  широкие  потоки
данных для одновременного слежения за несколькими точками.
      Графические команды включают интерполяцию интенсивности, z- ин-
терполяцию  и проверку z-буфера. Интерполяция интенсивности позволяет
сгладить края переходов по интенсивности или цвету. Команды z  позво-
ляют программисту определить, с какой стороны по отношению к наблюда-
телю  должен быть отображен объект. Ядро RISC также выполняет команду
сохранения точки параллельно с графическими операциями.


                          Виртуальная память
                          ------------------

      Микропроцессор 80860 поддерживает адресное пространство объемом
4 гигабайта. БУП включает четырехканальный ассоциативный  64-входовый
просмотровый буфер. Просмотр  буфера  осуществляется  одновременно  с
доступом в кеш-буфер за один цикл синхронизации.
      В БУП используется виртуальная память со страничной организаци-
ей и защитой. Микропроцессоры Intel 80386 и 80486 имеют такую же схе-
му  двухуровневого  страничного  доступа. Это сходство позволяет этим
процессорам легче внедряться в общее операционное окружение, а  также
облегчает разбивку виртуальной памяти из программ, написанных на язы-
ке си.


                           Набор команд RISC
                           -----------------

      В  наборе  команд 80860 все команды имеют тип "загрузить/выгру-
зить", характерный для процессоров RISC (см. табл.1 ). Трехоперандный
формат команд позволяет задавать арифметические, логические команды и
команды сдвига с двумя регистрами-источниками и одним  регистром-при-
емником. Единственными командами, которые манипулируют памятью, явля-
ются  загрузка  и выгрузка с арифметическими операциями, выполняемыми
на регистрах.
_____________________________________________________________________
            
Таблица  1: Набор команд процессора 80860 имеет полный комплект ариф-
           метических команд для целых чисел и чисел с плавающей  за-
           пятой,  каждая из которых длиной 32 бита. RISC-ядро выпол-
           няет все перемещения данных в и из процессора.


                  НАБОР КОМАНД МИКРОПРОЦЕССОРА 80860

_________________________________________________________________

Мнемоника       Описание
_________________________________________________________________


        Модуль ядра
        -----------

Команды загрузки и выгрузки

id.x           Загрузить целое
st.x           Выгрузить целое
fld.y          Загрузить число с плавающей запятой (ЧПЗ)
pfld.z         Конвейерная загрузка ЧПЗ
fst.y          Выгрузить ЧПЗ
pstd           Выгрузить пиксел


Перемещение регистр-регистр

ixfr           Переслать целое в регистр ЧПЗ
fxfr           Переслать ЧПЗ в целочисленный регистр


Команды целочисленной арифметики

adu            Беззнаковое сложение
adds           Сложение со знаком
subu           Беззнаковое вычитание
subs           Вычитание со знаком


Команды сдвига

shl            Сдвиг влево
shr            Сдвиг вправо
shra           Арифметический сдвиг вправо
shrd           Арифметический сдвиг вправо числа с двойной точностью

Логические команды

and             Логическое И
andh            Логическое И высокого порядка
andnot          Логическое И-НЕТ
andnoth         Логическое И-НЕТ высокого порядка
or              Логическое ИЛИ
orh             Логическое ИЛИ высокого порядка
xor             Исключающее ИЛИ
xorh            Исключающее ИЛИ высокого порядка


Команды управления-передачи

trap            Программная ловушка
intovr          Программная ловушка на целочисленное переполнение
br              Прямой переход
bri             Непрямой переход
bc              Переход, если CC
bc.t            Переход, если CC воспринято
bnc             Переход, если не CC
bnc.t           Переход, если CC не воспринято
bte             Переход, если равно
btne            Переход, если не равно
bla             Переход, если LCC и сложение
call            Вызов подпрограммы
calli           Непрямой вызов подпрограммы


Команды управления системой

flush           Очистить кеш-буфер
ld.c            Загрузка из управляющего регистра
st.c            Поместить в управляющий регистр
lock            Начало непрерывной цепочки
unlock          Конец непрерывной цепочки


    Модуль плавающей арифметики
    ---------------------------

Команды плавающего умножения

fmul.p          Плавающее умножение
pfmul.p         Конвейерное плавающее умножение
pfmul3.dd       Трехстадийное конвейерное плавающее умножение
fmlow.p         Плавающее умножение нижнего уровня
frcp.p          Взаимное плавающее умножение
frsqr.p         Взаимный квадратный корень


Команды сумматора с плавающей запятой

fadd.p          Плавающее сложение
pfadd.p         Конвейерное плавающее сложение
fsub.p          Плавающее вычитание
pfsub.p         Конвейерное плавающее вычитание
pfgt.p          Конвейерное плавающее больше
pfeq.p          Конвейерное плавающее равно
fix.p           Преобразование ЧПЗ - целое
pfle.p          Конвейерное плавающее меньше или равно
famou.p         Продвижение ЧПЗ в сумматоре
pfamou.p        Конвейерное продвижение ЧПЗ в сумматоре
pfix.p          Конвейерное преобразование ЧПЗ в целое
ftrunc.p        Усечение ЧПЗ до целого
pftrunc.p       Конвейерное усечение ЧПЗ до целого


Двухоперационные команды

fam.p           Конвейерное плавающее сложение и умножение
pfsm.p          Конвейерное плавающее вычитание и умножение
pfmam           Конвейерное плавающее умножение со сложением
pfmsm           Конвейерное плавающее умножение с вычитанием


Команды для чисел типа длинное целое

fisub.z         Длинное целое вычитание
pfisub.z        Конвейерное длинное целое вычитание
fiadd.z         Длинное целое сложение
pfiadd.z        Конвейерное длинное целое сложение


Команды графики

fzchks          Проверка 16-битового z-буфера
pfzchks         Конвейерная проверка 16-битового z-буфера
fzchkl          Проверка 32-битового z-буфера
pfzchkl         Конвейерная проверка 32-битового z-буфера
faddp           Сложение с поглощением пиксела
pfaddp          Конвейерное сложение с поглощением пиксела
faddz           Сложение с поглощениемм z
pfaddz          Конвейерное сложение с поглощением z
form            ИЛИ с поглощением регистра
pform           Конвейерное ИЛИ с поглощением регистра


     Ассемблерные псевдо-операции
     ----------------------------

mov             Пересылка регистр-регистр целого числа
fmov.q          Пересылка регистр-регистр ЧПЗ
pfmov.q         Конвейерная пересылка регистр-регистр ЧПЗ
nop             Пустая операция ядра
fnop            Пустая операция плавающей арифметики
pfle.p          Конвейерное меньше или равно ЧПЗ
_____________________________________________________________________
     
      Модуль ядра может выполнять команды за один цикл синхронизации.
Существует несколько способов выполнения команд за один цикл, хотя их
завершение может потребовать дополнительные циклы. Загрузка из памяти
занимает один рабочий цикл, и в течение следующего цикла может  начи-
наться выполнение следующей команды.
      Процессор  использует  технику,  именуемую scoreboarding (т. н.
"метод узелков на память"), для обеспечения  максимальной  производи-
тельности  при выполнении собственно команд. При этом происходит наб-
людение за тем, откуда будет происходить загрузка регистров (блок под
названием scoreboard). Текущая загрузка  данных  занимает  один  цикл
синхронизации,  если  данные  находятся  в кеш-буфере, либо несколько
циклов, если они все еще в памяти.
      В традиционных микропроцессорах выполнение следующей команды не
может начаться до того, как будут  возвращены  данные.  Scoreboarding
позволяет продолжать выполнение независимо от того, будет ли последу-
ющая  команда  использовать занятые регистры. В этом случае процессор
будет ожидать возвращения данных. Оптимизированные для микропроцессо-
ра 80860 компиляторы организуют код так, что такая неудачная ситуация
случается редко.
      Набор команд 80860 включает  несколько  оптимизаций  управления
потоками.  Программисты могут задавать условные ветвления с задержкой
или без нее. Задержка позволяет процессору выполнять команду,  идущую
после  ветвления,  если переход происходит на нее. В обоих случаях, с
задержкой и без нее, компилятор может легко оптимизировать код, в со-
ответствии с наиболее вероятным исходом ветвления
      Ветвления могут выполнятся условно, исходя из бита кода условия
(например, bc, bnc, bc.t и bnc.t), либо  сравнения  содержимого  двух
регистров  (bte и btne). Существует также команда ветвление-цикл-сло-
жение, bla, которая выполняет проверку, ветвление и сложение в  одной
команде.  Эта  команда предназначена для организации цикла со счетчи-
ком.


                      Команды с плавающей запятой
                      ---------------------------

      Аппаратные средства плавающей математики могут оперировать чис-
лами с одинарной или двойной точностью по стандарту IEEE 754 для  ве-
личин  с плавающей запятой, а также 32- или 64-разрядными целыми чис-
лами. Модуль плавающей арифметики включает  конвейеризированые  блоки
сложения  и  умножения, которые могут функционировать в скалярном или
конвейерном режиме. Операнды-источники для каждого блока поступают из
регистров плавающей запятой общего назначения, из специальных регист-
ров (например, KK, KI и T), либо это может быть предыдущий  результат
этого же модуля.
      Команды  скалярного режима обозначают операцию, регистры-источ-
ники и регистры-приемники. Будучи выбранными, эти команды продвигают-
ся в модуле за каждый цикл синхронизации до тех пор,  пока  не  будут
завершены. Хотя единовременно может выполняться только одна команда с
плавающей запятой в скалярном режиме, она может выполнятся параллель-
но  с  работой RISC-ядра. Работа в скалярном режиме требует три цикла
синхронизации для сложения и умножения с одинарной точностью и четыре
цикла для умножения с двойной точностью.
      Конвейеризованные  команды  с  плавающей  запятой  обеспечивают
трехшаговое  сложение  и/или  умножение,  плюс еще один шаг на каждую
следующую команду. Это оптимизированное управление  позволяет  выпол-
нять  конвейеризованные  команды, затрачивая на каждую следующую лишь
один цикл синхронизации. Так же, как и команды скалярного режима, ко-
манды  конвейерного  режима  определяют  регистры-источники   и   ре-
гистр-приемник.  Однако регистр-приемник команд с плавающей запятой в
конвейерном режиме является результатом вычислений, которые  начались
в предыдущей команде.
      На фиг.2 показан пример, где сумматор начинает складывать числа
f2 и f7. Так как это первая команда в серии, и конвейер еще не запол-
нен,  результат, поступающий из сумматора, еще не нужен, и он отправ-
ляется в f0, который всегда обнулен и используется в качестве нулево-
го приемника. При каждом успешном цикле синхронизации команда  сложе-
ния  продвигает конвейер. Когда результат очередного сложения необхо-
дим следующему, он передается приемнику, указанному в этой команде.
      В этом примере три цикла после начала операции  сложения  f2  и
f7,  результат  размещается  в f12 в соответствии с командой, которая
инициализирует сложение f5 и f10. Так как начаты все требуемые коман-
ды сложения, в конце расположены три фальшивые команды сложения (бол-
ванки) для проталкивания нужных результатов по конвейеру. Если следу-
ет большая серия операций сложения, избыточность,  возникающая  из-за
необходимости  заполнения и очистки конвейера пренебрежимо мала. Если
необходимо выполнить лишь два сложения, использование скалярного  ре-
жима будет оптимальнее.


                              Параллелизм
                              -----------

      Двухоперационные команды позволяют программе выполнять действия
сложения  и умножения одновременно. Одна 32-битовая команда инициали-
зирует как сложение, так и умножение. Хотя две операции требуют шесть
операндов (четыре операнда-источника и два операнда-приемника),  фор-
мат команды позволяет указывать только три. Использование специальных
регистров  KR, KI и T для размещения данных обеспечивает дополнитель-
ные операнды.
      32 разновидности двухоперационных команд указывают операнды ис-
точника и приемника для сумматора и умножителя. Используя эти  коман-
ды,  программист может писать эффективные программы, такие, как быст-
рое преобразование Фурье (БПФ), графические преобразования и  матрич-
ные  операции. Следующий пример показывает, как становиться возможным
ускорить процесс, используя конвейеризованные операции. Серия из  100
чисел  умножается  на константу, складывается со второй серией из 100
чисел и отправляется по назначению:

                     DO 10,100,10 X[i]=A[i]*C+B[i]

     Если  сложение  и  умножение выполняются в скалярном режиме, ре-
зультат получается после шести каждых циклов синхронизации. Например,

                 fmul C,A[i],temp fadd temp,B[i],X,[i]
                                   
     Вначале выполняется умножение, и результат помещается во времен-
ный регистр. Затем выполняется сложение с временным регистром,  после
чего  результат  поступает по назначению. Каждое умножение и сложение
занимает три цикла синхронизации, и шестицикловая цепочка повторяется
100 раз, что всего составляет 600 циклов для выполнения этого процес-
са вычислений.
      В случае конвейера и использования двухоперационных команд сло-
жение и умножение выполняются параллельно, и очередной результат  по-
лучается после каждого цикла синхронизации. Например,

                        r2p1 B[i-3],A[i],X[i-6]

     Это  иллюстрирует  разновидности  двухоперационной команды pfam,
обозначаемые как r2p1  источник1,источник2,регистр-приемник.  Команда
означает, что умножение инициализируется с константным регистром KR и
источником2  в  качестве операндов, а сложение инициализируется с ре-
зультатом умножения и источником1 в качестве операндов,  а  результат
предыдущего сложения помещается в регистр-приемник.
      Так как три стадии конвейерного сложения и умножения вытянуты в
цепочку, результат получается для операции, начатой шесть циклов син-
хронизации назад. При таком совмещении сложения и умножения, 600 цик-
лов  скалярного режима уменьшаются до 100 циклов, необходимых для вы-
полнения операций с плавающей запятой.
      Возможность модуля плавающей арифметики выдавать результат каж-
дый цикл синхронизации возбуждает большой аппетит в отношении поступ-
ления данных. Для обеспечения данными RISC-ядро может оперировать па-
раллельно с модулем плавающей арифметики для выдачи и получения  дан-
ных из регистров с плавающей запятой и одновременно управлять течени-
ем программы. Процессор вводит двухкомандный режим, если указать пре-
фикс d. в мнемоники команд с плавающей запятой.
      Если имеет место двухкомандный режим, последовательность команд
рассматривается  как 64-битовые пары по две команды. Верхняя половина
содержит команду целочисленной арифметики, а нижняя  -  плавающей.  В
этом  режиме 64-битовый кеш-буфер команд позволяет выполнять пару ко-
манд за каждый цикл синхронизации. Режимы можно менять без применения
какихлибо дополнительных команд.
      Используя  преимущества   128-разрядного   кеш-буфера   данных,
RISC-ядро может загружать до четырех регистров с плавающей запятой за
каждый  цикл  с  помощью команды fld. Кроме того, специальная команда
загрузки под названием pfld загружает регистр с плавающей запятой  из
внешней памяти, не используя при этом кеш-буфер. Эта уникальная инст-
рукция  позволяет получать данные из внешней памяти, которые выпадают
из общего потока данных, не разрушая при  этом  кеш-буфер  последова-
тельного потока данных.
      Так же, как и блок выполнения арифметических действий с плаваю-
щей запятой, pfld использует трехстадийный конвейер загрузки. Эта ко-
манда  указывает  адрес  загрузки  и регистр-приемник. Каждая команда
pfld продвигает загрузочный конвейер на один шаг и выбирает результат
из адреса загрузки, который получен три шага назад.  Автоинкрементная
адресация  не позволяет использовать отдельную команду сложения с ав-
томатически инкрементируемым базовым регистром перед  каждой  загруз-
кой.


                          Производительность
                          ------------------

      Простая оценка показывает производительность в  миллионы  цело-
численных операций в секунду. На 40 мегагерцах процессор 80860 разви-
вает, как и ЭВМ VAX, 33 MIPS (миллионов операций в секунду, используя
термин Стэнфордского университета для вычисления скорости целочислен-
ных  операций)  и выпоняет 85000 драйстоунов (Dhrystone) версии 1.1 и
80000 версии 2.1. Эти результаты демонстрируют скорость набора  опти-
мизированных  команд  RISC-ядра и его способность выполнять несколько
команд за один цикл синхронизации. Вместе с  эффективным  управлением
памятью процессор 80860 хорошо функционирует в системах, использующих
виртуальную память.
      Уитстоун  (Whetstone) - обычная единица, используемая для подс-
чета производительности скалярных арифметических операций с плавающей
запятой. Процессор 80860 показывает 24 миллиона уитстоунов на частоте
40 МГц. Пиковая производительность для операций с  плавающей  запятой
для  80860  составляет 80 MFLOPS для одинарной точности и 60 MFLOPS -
для двойной (MFLOPS - миллион операций с плавающей запятой  в  секун-
ду).
      Хотя  подсчет пиковой производительности часто вводит в заблуж-
дение, двухкомандный и двухоперационный режимы позволяют микропроцес-
сору достичь пиковой производительности  для  циклов  самого  нижнего
уровня  вложения для простых матричных операций. По стандарту LINPACK
80860 демонстрирует 10 MFLOPS. Цикл самого нижнего уровня вложения  в
БПФ  требует 10 операций с плавающей запятой. 80860 выполняет 10 опе-
раций за 6 циклов синхронизации, затрачивая на вычисление 1024 точеч-
ного БПФ 1 миллисекунду.


                          Программы для рынка
                          -------------------

      Группы разработчиков фирмы Intel и независимые поставщики обес-
печили  полное  программное  обеспечение  и  операционные системы для
80860. На фиг.3 показано развитое программное окружение, включая ком-
пиляторы с языков си и фортран, а так же ассемблер/компоновщик, моде-
лировщик/отладчик и векторный процессор для фортрана. В добавок, име-
ются математические, векторные простые и трехмерные графические  биб-
лиотеки.
      На начальном этапе разработки окружения были использованы крос-
сассемблеры  в  системах  Unix V/386 и OS/2. Оптимизации, введенные в
компиляторы, включают окраску для аллокации регистров, передачу пара-
метров относительно базовых регистров при вызовах, простые  межблоко-
вые  подвыражения  ,  исключение инвариантных циклов, предварительное
вычисление констант, уменьшение длины, интенсивную просмотровую опти-
мизацию и составление списка команд.
      Многие программисты пишут прикладные научные и инженерные прог-
раммы на языке фортран, так как он хорошо приспособлен для  векторных
вычислений. Поддержка для 80860 включает "векторизирующий" препроцес-
сор  для фортрана. Векторизация выполняется в циклах DO и IF, внешних
циклах и операциях условного ветвления вперед. Препроцессор распозна-
ет эти структуры и генерирует вызовы из  набора  высокооптимизирован-
ных,  написанных  вручную  в  машинных кодах, процедур. Эти процедуры
полностью используют преимущества двухкомандного и  двухоперационного
режимов, используя кеш-буфер данных в качестве векторного регистра.
      Вдобавок  программисты  могут иметь доступ к этим процедурам из
других языков высокого уровня. Продолжаются  работы  над  увеличением
степени параллелизма процессора. Имеется также библиотека процедур на
языке ассемблера для скалярных математических операций.
      Мультипроцессорная  версия системы Unix V 4.0 находится на ста-
дии разработки для 80860. Этот проект - совместная работа фирм  AT&T,
Unisys, Intel, Olivetti, Prime, Okidata и других. Пакет программ фир-
мы Intel будет поддерживать совместимость программ на языках высокого
уровня  для  микропроцессоров 80386, 80486 и 80860. Имеется документ,
который описывает стандарт двоичного интерфейса для перемещения прог-
рамм на базе 80860 на системы разных производителей.


                    Суперкомпьютер на вашем столе?
                    ------------------------------

      80860 поддерживает сбалансированную производительность для  це-
лочисленных  операций  и операций с плавающей запятой, что могут себе
позволить лишь микропроцессоры, содержащие не менее миллиона транзис-
торов. Программное обеспечение, разработанное для 80860,  может  пол-
ностью  использовать преимущества архитектуры, доставляя мощность су-
перкомпьютера на стол владельца персонального компьютера.
      Помимо обеспечения нового уровня производительности,  процессор
80860  является первым из нового класса микропроцессоров. Преодолевая
барьер одной операции за один цикл синхронизации, он стал первым ком-
мерческим суперскалярным микропроцессором.  Появление  суперскалярной
архитектуры  позволит  наращивать производительность микропроцессоров
не только за счет развития полупроводниковой  технологии,  увеличивая
мощность настольных компьютеров.
         
                       
         ФУНКЦИОНАЛЬНЫЕ МОДУЛИ И ПОТОКИ ДАННЫХ В МИКРОПРОЦЕССОРЕ 80860
                       
                       

    Внешний <──┼────────────────────────────┐
     адрес    32                            │
                                            │
                ┌────────────┐      ┌───────┴───────┐      ┌────────────┐
                │ Кэш команд │      │ Блок управле- │      │ Кэш данных │
                │  (4К байт) │      │ ния памятью   │      │  (8К байт) │
                └─────┬─┬─┬──┘      └─────┬────┬────┘      └──┬───┬─────┘
                      │ │ ^               ^    ^              ^   ^  Данные
             Внешние  │ │ │ адрес команды │    │ адрес данных │   │   из/в
              данные  │ │ └───────────────█    █──────────────┘   │   кэш
                   ┌─>│─│─────────────────│────│─────────────────>│
                   │  │ │команда плавающей│    │ арифметики       ┼ 128
                   │  │ └─────────────────│────│─────────────┐    │
                   │  │  команда ядра  32 │32  │32     32    │    │
                   ┼  └───────────────┼─┐ ┼    ┼   ┌──┼──────│────█
                   │                    │ │    │   │         │    │
                   V                    V │    │   V         V    V
      Внешние   ┌──┴─────────┐       ┌──┴─┴────┴───┴─┐     ┌─┴────┴──────┐
       данные   │ Устройство │       │     RISC      │     │Блок управле-│
       <─────┼─>│ управления │       │     ядро      │     │ния плавающей│
           64   │ шиной      │       │               │     │ арифметикой │
                └────────────┘       ╠═══════════════╣     ╠═════════════╣
                                     ║ регистры ядра ║     ║регистры п.а.║
                                     ╚═══════════════╝     ╚══╤═══╤═══╤══╝
     Регистр                                               64 ┼ 64┼ 64┼
     прием.  ──────┬──────────────────┬────────────────────┬──┘   │   │
                   ^                  ^                    ^      │   │
                   │                  │                    │      │   │
  Источник 1 ──────│──────█───────────│───────────█────────│─────█┘   │
                   │      │           │           │        │     │    │
                   │      │           │           │        │     │    │
  Источник 2 ──────│──█───│───────────│──█────────│────────│──█──│────┘
                   │  │   │           │  │        │        │  │  █───────┐
                   │  │   │           │  │ ┌───█──│────────█  │  │     ┌─┴─┐
                   │  │   │           │  │ │ ╔═╧═╗│        │  │  │ ┌───┤ Kl│
                   │  │   │           │  │ │ ║ T ║│        │  │  │ │   ├───┤
                   │  V   V           │  │ │ ╚══╤╝│        │  │  │ │ ┌─┤ Kr│
                ┌──┴──┴───┴──┐        │  V V    │ V        │  │  V V │ └───┘
                │ Графический│        │┌─┴─┴─┐┌─┴─┴─┐      │  │ ┌┴─┴─┴┐
                │   модуль   │        │ \─┬─/  \─┬─/       │  V  \─┬─/
                ╠════════════╣      ┌─┴───┴──────┴──┐     ┌┴──┴────┴───┐
                ║  Merge     ║      │   Сумматор    │     │ Умножитель │
                ╚════════════╝      └───────────────┘     └────────────┘
           Рис.1. Объемные  шины данных внутри чипа и внешняя 64-битовая
                  шина обеспечивает необходимую  пропускную  способность
                  для выполнения нескольких операций за один цикл. Четы-
                  ре  регистра  с плавающей запятой могут быть загружены
                  по 128 битовому каналу из кэш данных за один цикл.

                        КОНВЕЙЕР ПЛАВАЮЩЕЙ АРИФМЕТИКИ


          ┌─────────┐            ┌─────────┐             ┌─────────┐
       f2 │    2    │        f7  │    7    │         f12 │         │
          ├─────────┤            ├─────────┤             ├─────────┤
       f3 │    3    │        f8  │    8    │         f13 │         │
          ├─────────┤            ├─────────┤             ├─────────┤
       f4 │    4    │        f9  │    9    │         f14 │         │
          ├─────────┤            ├─────────┤             ├─────────┤
       f5 │    5    │        f10 │    10   │         f15 │         │
          ├─────────┤            ├─────────┤             ├─────────┤
       f6 │    6    │        f11 │    11   │         f16 │         │
          └─────────┘            └─────────┘             └─────────┘
               
               X                      Y                        Z
               
       Последовательность           Конвейер              Направление
             команд                 сложения              результата
                        
                        
                ┌───────┬───┐  ┌─────┬─────┬─────┐
       pfadd.ss │f2, f7,│f0 │  │ 2+7 │  ?  │  ?  │          Нет
                └───────┘   │  └─────┴─────┴─────┘
                            │  ┌─────┬─────┬─────┐
       pfadd.ss  f3, f8, f0 │  │ 3+8 │ 2+7 │  ?  │          Нет
                            │  └─────┴─────┴─────┘
                            │  ┌─────┬─────┬─────┐
       pfadd.ss  f4, f9, f0 │  │ 4+9 │ 3+8 │ 2+7 │          Нет
                            │  └─────┴─────┴─────┘
                            V  ┌─────┬─────┬─────┐
       pfadd.ss  f5, f10, f12  │ 5+10│ 4+9 │ 3+8 │      f12  <────  9.
                               └─────┴─────┴─────┘
                               ┌─────┬─────┬─────┐
       pfadd.ss  f6, f11, f13  │ 6+11│ 5+10│ 4+9 │      f13  <────  11.
                               └─────┴─────┴─────┘
                               ┌─────┬─────┬─────┐
       pfadd.ss  f0, f0, f14   │  0  │ 6+11│ 5+10│      f14  <────  13.
                               └─────┴─────┴─────┘
                                                                       
                                                                     
           Рис.2. В сумматоре  содержится трехстадийный конвейер. Каж-
                  дая команда может начинать операцию сложения и  отп-
                  равлять результат предыдущего сложения.
                                         
                                         
           ПРОГРАММНОЕ ОБЕСПЕЧЕНИЕ ДЛЯ МИКРОПРОЦЕССОРА INTEL 80860


       ╔═══════╗  ┌──────┐  ╔═══════╗  ┌───────┐
       ║Фортран║  │Векто-│  ║Модиф. ║  │Фортран│                  ┌────────┐
       ║ источ-║─>│риза- │─>║ФОРТРАН║─>│компи- │                  │Модели- │
       ║ ник   ║  │тор   │  ║источн.║  │лятор  │               ┌─>│ровщик/ │
       ╚═══════╝  └──────┘  ╚═══════╝  └───────┘               │  │дебаггер│
                                        │                      │  └────────┘
                            ┌──────┐    │   ┌──────┐  ┌──────┐ │
       ╔════════╗           │ Си   │    └──>│ Ас-  │  │      │─┘
       ║ Си     ║──────────>│компи-│───────>│ сем- │─>│Линкер│
       ║источник║           │лятор │ ┌─────>│ блер │  │      │─┐
       ╚════════╝           └──────┘ │      └──────┘  └──────┘ │
                                     │                 ^ ^ ^   │  ┌───────┐
                                     │  ┌──────────┐   │ │ │   │  │ 80860 │
       ╔════════╗                    │  │Библиотека│   │ │ │   └─>│процес-│
       ║Ассем-  ║                    │  │векторных │───┘ │ │      │сор    │
       ║блерный ║────────────────────┘  │примитивов│     │ │      └───────┘
       ║источник║                       └──────────┘     │ │
       ╚════════╝                       ┌──────────┐     │ │
                                        │Математи- │     │ │
                                        │ческая    │─────┘ │
                                        │библиотека│       │
                                        └──────────┘       │
                                        ┌──────────┐       │
                                        │Библиотека│       │
                                        │трехмерной│───────┘
                                        │графики   │
                                        └──────────┘
                                                            
                                                            
           Рис.3. Научные программы  на  Фортране  имеют  преимущества
                  из-за  векторизуего препроцессора, который автомати-
                  чески подставляет обращение к библиотеке.  Программы
                  на Си также могут обращаться к библиотекам.
           
                

