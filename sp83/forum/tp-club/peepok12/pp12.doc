

                                PP.EXE
                                ──────

                         (Ver 1.2 - 29 Apr 91)


                     Copyright(c) and developed by

                             José Campione
      2415 SouthVale Cr. U-25, Ottawa, Ont. K1B 4T9 (613) 523-4345.

                                 and

                         C. Robert Parkinson
          5 Ramsgate, Ottawa, Ont. K1V 8M4, (613) 523-7299.


                     ... from the PUB SQUAD ...

                               *  *  *


 NOTICE
 ======

     This program and every file distributed with it are copyright (C)
 by the authors, who retain authorship both of the pre-compiled and 
 compiled codes.  Their use and distribution are unrestricted, as long
 as nobody gets any richer in the process.  Although these programs 
 were developed to the best of the authors abilities, no guarantees
 can be given as to their performance.  By using them, the user
 accepts all risks and the authors decline all liability. 


 DESCRIPTION
 ===========

     PP.EXE (PeekPoke) is a very simple program allowing the peeking
 and poking of addresses in the computer's memory. 

     Poking effectively changes bytes in memory and this may have 
 harmfull effects on the operation of your computer and software. 
 However, resetting the computer will usually restore things to
 normal.  As opposed to PORTS.EXE (the acommpanying program), PP does
 not harm hardware.

     PP.EXE can be most useful in determining, or changing, the value
 in an I/O port, the BIOS Data Area, a Disk Parameter Block, etc. 


 CAUTION
 =======

     WARNING!!!  This program can modify memory locations in your
     *******     computer and, unless used with great care, may well
                 crash the system.  You have been warned.


 SYNTAX
 ======

     To read the byte value ("peek"), use:

             "PP e segment:offset <!>"

     To write a byte value ("poke"), use:

             "PP o segment:offset byte_value <!>"

     Where:

           "segment:offset" is the desired memory location.  It can
                            be entered as hexadecimal numbers (they 
                            must be preceded by the "$" sign as in the
                            example below), as decimal numbers
                            (without the "$" sign), or a mixture of
                            both.  Both words have to separated by the
                            ":" punctuation, without any additional
                            spaces or characters.


           "byte_value" is the value of the byte that you wish
                        written to that memory location.  It may be
                        in decimal or hex format.  If hex, it must
                        be preceded by the "$" sign (e.g., $33).

           "!" is an optional parameter that causes the memory
               location, in segment:offset hex notation, and the byte
               value in both decimal, hex and binary form, to be
               displayed on the screen.  For a write operation, both
               the old and the new values will be displayed.
                

 ERRORLEVEL
 ==========

     In both read and write operations, the original ASCII decimal
 byte value is returned as an exit errorlevel, which can be tested
 from a batch file.


 EXAMPLE
 =======

     Hex address $0040:$0065 contains the BIOS byte with the video
 card configuration.  The following examples will all display the
 same byte:

         C:\>PP e $0040:$0065 !

         C:\>PP e $40:$65 !

         C:\>PP e $40:$0065 !
 
         C:\>PP e $0040:$65 !
 
         C:\>PP e 64:101 !

         C:\>PP e $40:101 !

         C:\>PP e 64:$0065 !
 
     The result of all these commands is always the same:

         mem[0040h:0065h] = 41d, 0029h, 00101001b.

     (although the actual value of the byte may change from system
      to system).


                                  *  *  *


