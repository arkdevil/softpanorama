Newsgroups: comp.lang.perl
From: imc@comlab.ox.ac.uk (Ian Collier)
Subject: Re: Equivalent of REXX's parse?
Message-ID: <5087.imc@uk.ac.ox.prg>
Organization: Oxford University Computing Laboratory
Date: Mon, 29 Aug 1994 12:24:47 GMT

In article <33j3jo$ake@inti.inf.utfsm.cl>, vparada@inf.utfsm.cl (Victor Parada G.) wrote:
>Is there an easy way to simulate REXX's parse instruction?

The following instructions seem to work, though I'm not a perl expert...

>  PARSE VAR in_string out1 out2 . out4 out_remain

$in_string =~ /^\s*(\S*)\s+(\S*)\s+(\S*)\s+(\S*)\s(.*)$/;
($out1,$out2,$out4,$out_remain) = ($1,$2,$4,$5);

where: \s* ignores leading blanks
       \S* picks up a sequence of nonblanks
       \s+ skips one or more blanks which separate the words
       \s  skips a single blank which separates the last word from the
           remainder of the string
       .*  picks up the remainder of the string.
The parentheses denote the sections of string which should be assigned
to the special variables $1, $2, etc.

>so if in_string=" word1  word2 word3     word4   word5   word6  ",
>out1="word1", out2="word2", "word3" is discarded, out4="word4"
>and out_remain="word5   word6  " (spaces are intentional).

Actually you have missed two spaces out of "out_remain".  The last variable
in a REXX parse instruction keeps all the spaces before and after the data
except for one space which was used to separate it from the previous one.

>PARSE VAR record "[" date "_" time "]" host request ":" data

$record =~ /^.*\[(.*)_(.*)\]\s+(\S*)\s(.*):(.*)$/;
($date,$time,$host,$request,$data) = ($1,$2,$3,$4,$5);

>I was a REXX programmer for many years in CMS machines.  Then, I moved
>to unix, and selected perl to write scripts.

(of course, you could have used Rexx on Unix too. :-) )

Ian Collier
Ian.Collier@comlab.ox.ac.uk | imc@ecs.ox.ac.uk
http://www.comlab.ox.ac.uk/oucl/users/ian.collier/index.html

