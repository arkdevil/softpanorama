'===================================================================== EXPR.DAT
' PERL Expressions for Norton Guides Database
' Kevin Grover, grover@isri.unlv.edu, 11 Jun 1992
'==============================================================================
!short: **      The exponentiation operator.

     **      The exponentiation operator.
!short: **=     The exponentiation assignment operator.

     **=     The exponentiation assignment operator.
!short: ()      The null list, used to initialize an array to null.

     ()      The null list, used to initialize an array to null.
!short: .       Concatenation of two strings.

     .       Concatenation of two strings.
!short: .=      The concatenation assignment operator.

     .=      The concatenation assignment operator.
!short: eq      Striing equiality (== is numeric equality)

     eq      String equality (== is  numeric  equality).   For  a
             mnemonic  just  think  of "eq" as a string.  (If you
             are used to the awk behavior of using == for  either
             string or numeric equality based on the current form
             of the comparands, beware!   You  must  be  explicit
             here.)
!short: ne      String inequality (!= is numeric inequality).

     ne      String inequality (!= is numeric inequality).
!short: lt      String less than.

     lt      String less than.
!short: gt      String greater than.

     gt      String greater than.
!short: le      String less than or equal.

     le      String less than or equal.
!short: ge      String greater than or equal.

     ge      String greater than or equal.
!short: cmp     String comparison, returning -1, 0, or 1.

     cmp     String comparison, returning -1, 0, or 1.
!short: <=>     Numeric comparison, returning -1, 0, or 1.

     <=>     Numeric comparison, returning -1, 0, or 1.
!short: =~      String modification

     =~      Certain operations search or modify the string  "$_"
             by default.  This operator makes that kind of opera-
             tion work on some other string.  The right  argument
             is  a  search pattern, substitution, or translation.
             The  left  argument  is  what  is  supposed  to   be
             searched,  substituted, or translated instead of the
             default "$_".  The return value indicates  the  suc-
             cess of the operation.  (If the right argument is an
             expression other than a  search  pattern,  substitu-
             tion,  or translation, it is interpreted as a search
             pattern at run time.  This is less efficient than an
             explicit  search, since the pattern must be compiled
             every time the expression is evaluated.)   The  pre-
             cedence  of  this operator is lower than unary minus
             and autoincrement/decrement, but higher than  every-
             thing else.
!short: !~      Just like =~ except the return value is negated.

     !~      Just like =~ except the return value is negated.
!short: x       String repetition

     x       The repetition operator.  Returns a string  consist-
             ing of the left operand repeated the number of times
             specified by the right operand.  In  an  array  con-
             text,  if  the  left operand is a list in parens, it
             repeats the list.

                  print '-' x 80;          # print row of dashes
                  print '-' x80;      # illegal, x80 is identifier

                  print "\t" x ($tab/8), ' ' x ($tab%8);  # tab over

                  @ones = (1) x 80;        # an array of 80 1's
                  @ones = (5) x @ones;          # set all elements to 5
!short: x=      String repetition assignment

     x=      The repetition assignment operator.  Only  works  on
             scalars.
!short: ..      Range operator (Array context=array,Scalar=boolean)

     ..      The range operator, which is  really  two  different
             operators  depending  on  the  context.  In an array
             context, returns an array  of  values  counting  (by
             ones)  from the left value to the right value.  This
             is useful for writing "for (1..10)"  loops  and  for
             doing slice operations on arrays.

             In a scalar context, ..  returns  a  boolean  value.
             The  operator  is bistable, like a flip-flop..  Each
             .. operator maintains its own boolean state.  It  is
             false  as  long  as its left operand is false.  Once
             the left operand is true, the range  operator  stays
             true  until  the  right operand is true, AFTER which
             the range operator becomes false again.  (It doesn't
             become  false  till the next time the range operator
             is evaluated.  It  can  become  false  on  the  same
             evaluation it became true, but it still returns true
             once.)  The right operand is not evaluated while the
             operator  is  in  the  "false"  state,  and the left
             operand is not evaluated while the  operator  is  in
             the  "true"  state.   The scalar .. operator is pri-
             marily intended for doing line number  ranges  after
             the fashion of sed or awk.  The precedence is a lit-
             tle lower than || and &&.   The  value  returned  is
             either  the  null  string  for  false, or a sequence
             number (beginning with 1) for  true.   The  sequence
             number  is  reset  for  each range encountered.  The
             final sequence number in a range has the string 'E0'
             appended  to  it,  which  doesn't affect its numeric
             value, but gives you something to search for if  you
             want  to  exclude the endpoint.  You can exclude the
             beginning point by waiting for the  sequence  number
             to  be  greater than 1.  If either operand of scalar
             .. is static, that operand is implicitly compared to
             the $. variable, the current line number.  Examples:

             As a scalar operator:
                 if (101 .. 200) { print; }       # print 2nd hundred lines

                 next line if (1 .. /^^$/);       # skip header lines

                 s/^^/> / if (/^^$/ .. eof());    # quote body

             As an array operator:
                 for (101 .. 200) { print; }      # print $_ 100 times

                 @foo = @foo[$[ .. $#foo]; # an expensive no-op
                 @foo = @foo[$#foo-4 .. $#foo]; # slice last 5 items
!short: -x      File test

     -x      A file test.  This unary operator  takes  one  argu-
             ment,  either  a filename or a filehandle, and tests
             the associated file to  see  if  something  is  true
             about  it.   If  the  argument is omitted, tests $_,
             except for -t, which tests STDIN.  It returns 1  for
             true and '' for false, or the undefined value if the
             file doesn't exist.  Precedence is higher than logi-
             cal  and relational operators, but lower than arith-
             metic operators.  The operator may be any of:

                  -r   File is readable by effective uid.
                  -w   File is writable by effective uid.
                  -x   File is executable by effective uid.
                  -o   File is owned by effective uid.
                  -R   File is readable by real uid.
                  -W   File is writable by real uid.
                  -X   File is executable by real uid.
                  -O   File is owned by real uid.
                  -e   File exists.
                  -z   File has zero size.
                  -s   File has non-zero size (returns size).
                  -f   File is a plain file.
                  -d   File is a directory.
                  -l   File is a symbolic link.
                  -p   File is a named pipe (FIFO).
                  -S   File is a socket.
                  -b   File is a block special file.
                  -c   File is a character special file.
                  -u   File has setuid bit set.
                  -g   File has setgid bit set.
                  -k   File has sticky bit set.
                  -t   Filehandle is opened to a tty.
                  -T   File is a text file.
                  -B   File is a binary file (opposite of -T).
                  -M   Age of file in days when script started.
                  -A   Same for access time.
                  -C   Same for inode change time.

             The interpretation of the file permission  operators
             -r,  -R,  -w,  -W,  -x and -X is based solely on the
             mode of the file and the uids and gids of the  user.
             There  may be other reasons you can't actually read,
             write or execute the file.  (Note that  serveral  of
             the above don't mean much under MS-DOS.)

             Example:

                  while (<>) {
                       chop;
                       next unless -f $_;  # ignore specials
                       ...
                  }

             Note that -s/a/b/ does not do  a  negated  substitu-
             tion.   Saying  -exp($foo)  still works as expected,
             however--only single letters following a  minus  are
             interpreted as file tests.

             The -T and -B switches work as follows.   The  first
             block  or so of the file is examined for odd charac-
             ters such as strange control  codes  or  metacharac-
             ters.   If too many odd characters (>10%) are found,
             it's a -B file, otherwise it's a -T file.  Also, any
             file  containing  null  in  the  first block is con-
             sidered a binary file.  If -T or -B  is  used  on  a
             filehandle,  the  current  stdio  buffer is examined
             rather than the first block.  Both -T and -B  return
             TRUE on a null file, or a file at EOF when testing a
             filehandle.

     If any of the file tests (or either stat operator) are given
     the  special  filehandle consisting of a solitary underline,
     then the stat structure of the previous file test  (or  stat
     operator) is used, saving a system call.  (This doesn't work
     with -t, and you need to remember that  lstat  and  -l  will
     leave  values  in  the stat structure for the symbolic link,
     not the real file.)  Example:

          print "Can do.\n" if -r $a || -w _ || -x _;

          stat($filename);
          print "Readable\n" if -r _;
          print "Writable\n" if -w _;
          print "Executable\n" if -x _;
          print "Setuid\n" if -u _;
          print "Setgid\n" if -g _;
          print "Sticky\n" if -k _;
          print "Text\n" if -T _;
          print "Binary\n" if -B _;
!short: What C has that perl doesn't

     Here is what C has that perl doesn't:

     unary &     Address-of operator.

     unary *     Dereference-address operator.

     (TYPE)      Type casting operator.
