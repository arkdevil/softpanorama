'================================================================== OPTIONS.DAT
'  PERL Command Line options for Norton Guides Database
'  Kevin Grover, 26 Dec 1991
'  11 Jun 1992 - Corrections
'==============================================================================
'
'--------------------------------------------------------------------------- -0
'
!short: Combining Options

     A single-character option may be combined with the following
     option, if any.  This is particularly useful when invoking a
     script using the #! construct which only  allows  one  argu-
     ment.  Example:

          #!/usr/bin/perl -spi.bak # same as -s -p -i.bak
          ...

!short: -0digits            Set record separator (octal number)

     -0digits
          specifies the record separator ($/) as an octal number.
          If  there  are  no  digits,  the  null character is the
          separator.  Other switches may precede  or  follow  the
          digits.   For  example,  if  you have a version of find
          which can print filenames terminated by the null  char-
          acter, you can say this:

              find . -name '*.bak' -print0 | perl -n0e unlink

          The special value 00 will cause Perl to slurp files  in
          paragraph  mode.   The  value  0777  will cause Perl to
          slurp files whole since there  is  no  legal  character
          with that value.

'
'--------------------------------------------------------------------------- -a
'
!short: -a                  Turn auto split mode on

     -a   turns on autosplit mode when used with a -n or -p.   An
          implicit  split  command to the @F array is done as the
          first thing inside the implicit while loop produced  by
          the -n or -p.

               perl -ane 'print pop(@F), "\n";'

          is equivalent to

               while (<>) {
                    @F = split(' ');
                    print pop(@F), "\n";
               }

!seealso: -n -p

'
'--------------------------------------------------------------------------- -c
'
!short: -c                  Check syntax of script, don't execute

     -c   causes perl to check the syntax of the script and  then
          exit without executing it.

'
'-------------------------------------------------------------------------- -d
'
!short: -d                  Run script under the PERL debugger

     -d   runs the script under the perl debugger.  See the  sec-
          tion on Debugging.


'
'-------------------------------------------------------------------------- -D
'
!short: -Dnumber            Set PERL debugging flags

     -Dnumber
          sets debugging flags.  To watch how  it  executes  your
          script,  use  -D14.   (This  only works if debugging is
          compiled  into  your  perl.)   Another  nice  value  is
          -D1024,  which  lists  your  compiled syntax tree.  And
          -D512 displays compiled regular expressions.

'
'-------------------------------------------------------------------------- -e
'
!short: -e commandline      Specify one-line script

     -e commandline
          may be used to enter one line of script.   Multiple  -e
          commands  may be given to build up a multi-line script.
          If -e is  given,  perl  will  not  look  for  a  script
          filename  in  the  argument  list.   On  MS-DOS, the -e
          switch will not work well unless perl is  run  from  an
          MKS tool, such as the Korn shell.  This is due to limi-
          tations in the standard method of MS-DOS argument pass-
          ing.


'
'-------------------------------------------------------------------------- -i
'
!short: -iextension         Use in place editing

     -iextension
          specifies that files processed by the <> construct  are
          to  be  edited  in-place.  It does this by renaming the
          input file, opening the output file by the  same  name,
          and selecting that output file as the default for print
          statements.  The extension, if supplied,  is  added  to
          the  name of the old file to make a backup copy.  If no
          extension is supplied, no backup is made.  Saying "perl
          -p  -i.bak  -e "s/foo/bar/;" ... " is the same as using
          the script:

               #!/usr/bin/perl -pi.bak
               s/foo/bar/;

          which is equivalent to

               #!/usr/bin/perl
               while (<>) {
                    if ($ARGV ne $oldargv) {
                         rename($ARGV, $ARGV . '.bak');
                         open(ARGVOUT, ">$ARGV");
                         select(ARGVOUT);
                         $oldargv = $ARGV;
                    }
                    s/foo/bar/;
               }
               continue {
                   print;     # this prints to original filename
               }
               select(STDOUT);

          except that the -i form doesn't need to  compare  $ARGV
          to  $oldargv to know when the filename has changed.  It
          does, however, use ARGVOUT for the selected filehandle.
          Note  that  STDOUT  is  restored  as the default output
          filehandle after the loop.

          You can use eof to locate the end of each  input  file,
          in  case you want to append to each file, or reset line
          numbering (see example under eof).

'
'-------------------------------------------------------------------------- -I
'
!short: -Idirectory         Include path for C preprocessor

     -Idirectory
          may be used in  conjunction  with  -P  to  tell  the  C
          preprocessor  where  to  look  for  include  files.  By
          default /usr/include and /usr/lib/perl are searched.

!seealso: -P
'
'-------------------------------------------------------------------------- -l
'

!short: -loctnum            Enable auto line-ending

     -loctnum
          enables automatic line-ending processing.  It  has  two
          effects:  first, it automatically chops the line termi-
          nator when used with -n or -p , and second, it  assigns
          $\ to have the value of octnum so that any print state-
          ments will have that line terminator added back on.  If
          octnum  is omitted, sets $\ to the current value of $/.
          For instance, to trim lines to 80 columns:

               perl -lpe 'substr($_, 80) = ""'

          Note that the assignment $\  =  $/  is  done  when  the
          switch  is processed, so the input record separator can
          be different than the output record separator if the -l
          switch is followed by a -0 switch:

               gnufind / -print0 | perl -ln0e 'print "found $_" if -p'

          This sets $\ to newline and then sets $/  to  the  null
          character.

'
'-------------------------------------------------------------------------- -n
'
!short: -n                  Assume wrapper to process argument files

     -n   causes perl to assume the following  loop  around  your
          script,  which makes it iterate over filename arguments
          somewhat like "sed -n" or awk:

               while (<>) {
                    ...       # your script goes here
               }

          Note that the lines are not printed by default.  See -p
          to  have  lines  printed.   Here is an efficient way to
          delete all files older than a week:

               find . -mtime +7 -print | perl -nle 'unlink;'

          This is faster than using  the  -exec  switch  of  find
          because  you  don't  have  to  start a process on every
          filename found.
!seealso: -a -p
'
'-------------------------------------------------------------------------- -p
'
!short: -p                  Assumes loop with continue to process command args

     -p   causes perl to assume the following  loop  around  your
          script,  which makes it iterate over filename arguments
          somewhat like sed:

               while (<>) {
                    ...       # your script goes here
               } continue {
                    print;
               }

          Note that the  lines  are  printed  automatically.   To
          suppress  printing use the -n switch.  A -p overrides a
          -n switch.

!seealso: -a
'
'-------------------------------------------------------------------------- -P
'
!short: -P                  runs C preprocessor on script before running it

     -P   causes your script to be run through the C preprocessor
          before  compilation  by perl.  (Since both comments and
          cpp directives begin with the # character,  you  should
          avoid  starting  comments  with any words recognized by
          the C preprocessor such as "if", "else" or "define".)

'
'-------------------------------------------------------------------------- -s
'
!short: -s                  Enable rudamentary command line switch processing

     -s   enables some rudimentary switch parsing for switches on
          the  command  line after the script name but before any
          filename arguments (or before a --).  Any switch  found
          there  is removed from @ARGV and sets the corresponding
          variable in the  perl  script.   The  following  script
          prints "true" if and only if the script is invoked with
          a -xyz switch.

               #!/usr/bin/perl -s
               if ($xyz) { print "true\n"; }


'
'-------------------------------------------------------------------------- -S
'
!short: -S                  Uses PATH environment variable to search for script

     -S   makes perl use the PATH environment variable to  search
          for  the  script  (unless the name of the script starts
          with a slash).  Typically this is used  to  emulate  #!
          startup  on machines that don't support #!, in the fol-
          lowing manner:

               #!/usr/bin/perl
               eval "exec /usr/bin/perl -S $0 $*"
                    if $running_under_some_shell;

          The system ignores the first line and feeds the  script
          to  /bin/sh,  which proceeds to try to execute the perl
          script as a  shell  script.   The  shell  executes  the
          second  line as a normal shell command, and thus starts
          up the perl interpreter.  On some  systems  $0  doesn't
          always  contain the full pathname, so the -S tells perl
          to search for the  script  if  necessary.   After  perl
          locates  the  script,  it  parses the lines and ignores
          them because the variable $running_under_some_shell  is
          never  true.   A  better  construct  than  $*  would be
          ${1+"$@"}, which handles embedded spaces  and  such  in
          the  filenames, but doesn't work if the script is being
          interpreted by csh.  In order to  start  up  sh  rather
          than  csh, some systems may have to replace the #! line
          with a line containing just a colon, which will be pol-
          itely  ignored  by  perl.   Other systems can't control
          that, and need a totally devious  construct  that  will
          work  under any of csh, sh or perl, such as the follow-
          ing:

               eval '(exit $?0)' && eval 'exec /usr/bin/perl -S $0 ${1+"$@"}'
               & eval 'exec /usr/bin/perl -S $0 $argv:q'
                    if 0;

'
'-------------------------------------------------------------------------- -u
'
!short: -u                  cause perl to dump core after compiling script

     -u   causes perl to dump core after compiling  your  script.
          This switch is not supported on MS-DOS.

'
'--------------------------------------------------------------------------- -U
'
!short: -U                  allows perl to do unsafe operations

     -U   allows perl to do  unsafe  operations.   Currently  the
          only "unsafe" operation is the unlinking of directories
          while running as superuser.

'
'---------------------------------------------------------------------------- -v
'
!short: -v                  prints the version and patchlevel

     -v   prints the version and patchlevel of your perl execut-
          able.

'
'---------------------------------------------------------------------------- -w
'
!short: -w                  Warns about identifiers mentioned only once

     -w   prints warnings about identifiers  that  are  mentioned
          only  once,  and  scalar variables that are used before
          being set.  Also warns about redefined subroutines, and
          references  to  undefined  filehandles  or  filehandles
          opened readonly that you are attempting  to  write  on.
          Also  warns you if you use == on values that don't look
          like numbers, and if your subroutines recurse more than
          100 deep.

'
'--------------------------------------------------------------------------- -x
'
!short: -xdirectory         Extracts PERL program from input stream

     -xdirectory

          tells perl that the script is embedded  in  a  message.
          Leading  garbage will be discarded until the first line
          that starts with #! and  contains  the  string  "perl".
          Any  meaningful  switches  on that line will be applied
          (but only one group of switches, as with normal #! pro-
          cessing).   If a directory name is specified, Perl will
          switch to that directory  before  running  the  script.
          The -x switch only controls the the disposal of leading
          garbage.  The script must be terminated with __END__ if
          there is trailing garbage to be ignored (the script can
          process any or all of the trailing garbage via the DATA
          filehandle if desired).

