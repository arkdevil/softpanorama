'================================================================= COMMANDS.DAT
'  PERL Commands Syntax for Norton Guides Database
'  Kevin Grover, 26 Dec 1991
'  11 Jun 1992 - Corrections:  Escaped all ^ chars using ^^
'  27 Feb 1993 - Additions, unix stuff at end
'==============================================================================
'
'-------------------------------------------------------------------- /PATTERN/
'
!short: /PATTERN/        Abbreviation for m/PATTERN/

        This is an abreviation for m/PATTERN/

!seealso: m/PATTERN/gio
'
'-------------------------------------------------------------------- ?PATTERN?
'
!short: ?PATTERN?        Similar to /PATTERN/, but matches only once

     ?PATTERN?

             This is just like the /pattern/ search, except  that
             it  matches  only  once  between  calls to the reset
             operator.  This is a useful  optimization  when  you
             only  want  to see the first occurrence of something
             in each file of a set of files, for instance.   Only
             ?? patterns local to the current package are reset.

!seealso: m/PATTERN/gio
'
'----------------------------------------------------------------------- accept
'
!short: accept           Same as C system call

     accept(NEWSOCKET,GENERICSOCKET)

             Does the same thing  that  the  accept  system  call
             does.  Sockets are not yet supported on MS-DOS.

!seealso: bind connect
'
'------------------------------------------------------------------------ alarm
'
!short: alarm            Not supported on DOS

     alarm(SECONDS)

     alarm SECONDS

             Not supported on MS-DOS.

'
'------------------------------------------------------------------------ atan2
'
!short: atan2            Returns arctangen of Y/X in range -PI to PI

     atan2(Y,X)

             Returns the arctangent of Y/X in the  range  -PI  to
             PI.

!seealso: cos sin
'
'------------------------------------------------------------------------- bind
'
!short: bind             Same as C system call

     bind(SOCKET,NAME)

             Does the same thing that the bind system call  does.
             Returns true if it succeeded, false otherwise.  NAME
             should be a packed address of the  proper  type  for
             the  socket.  See example in section on Interprocess
             Communication.

!seealso: accept connect
'
'---------------------------------------------------------------------- binmode
'
!short: binmode          Puts a file in BINARY mode

     binmode(FILEHANDLE)

     binmode FILEHANDLE

             Arranges for the file to be read in "binary" mode in
             operating  systems  that  distinguish between binary
             and text files.  Files that are not read  in  binary
             mode  have CR LF sequences translated to LF on input
             and LF translated to CR LF on output.   Binmode  has
             no   effect   under   Unix.   If  FILEHANDLE  is  an
             expression, the value is taken as the  name  of  the
             filehandle.

!seealso: open close seek tell
'
'----------------------------------------------------------------------- caller
'
!short: caller           Return context of current subroutine call

     caller(EXPR)

             Returns the context of the current subroutine call:

                  ($package,$filename,$line) = caller;

             With EXPR, returns some extra information  that  the
             debugger  uses to print a stack trace.  The value of
             EXPR indicates how  many  call  frames  to  go  back
             before the current one.


'
'------------------------------------------------------------------------ chdir
'
!short: chdir            Changes working directory

     chdir(EXPR)

     chdir EXPR

             Changes the working directory to EXPR, if  possible.
             If  EXPR  is  omitted,  changes  to  home directory.
             Returns 1 upon success, 0  otherwise.   See  example
             under die.

             On MS-DOS, the path  and/or  the  directory  can  be
             specified.

             chdir "c:/junk/subdir";
             chdir "e:";
             chdir "abc/xyz";

             The first of these changes  the  default  drive  and
             directory.  The second changes to the default direc-
             tory on drive E:.  The third changes  the  directory
             on  the  current drive.  As with all filenames, for-
             ward slashes are recommended inside perl.  (See  the
             section on MS-DOS.)

!seealso: chroot
'
'-------------------------------------------------------------------- chmod
'
!short: chmod            Change permissions on file(s)

     chmod(LIST)

     chmod LIST

             Changes the permissions of a  list  of  files.   The
             first  element  of  the  list  must be the numerical
             mode.  Returns  the  number  of  files  successfully
             changed.

                  $cnt = chmod 0755, 'foo', 'bar';
                  chmod 0755, @executables;

!seealso: chown
'
'-------------------------------------------------------------------- chop
'
!short: chop             Chop off last char of string and return that char

     chop(LIST)

     chop(VARIABLE)

     chop VARIABLE

             Chops off the last character of a string and returns
             the  character  chopped.   It's  used  primarily  to
             remove the newline from the end of an input  record,
             but  is  much  more efficient than s/\n// because it
             neither scans nor copies the string.  If VARIABLE is
             omitted, chops $_.  Example:

                  while (<>) {
                       chop;     # avoid \n on last field
                       @array = split(/:/);
                       ...
                  }

             You can actually chop  anything  that's  an  lvalue,
             including an assignment:

                  chop($cwd = `pwd`);
                  chop($answer = <STDIN>);

             If you chop a list, each element is  chopped.   Only
             the value of the last chop is returned.

!seealso: substr
'
'------------------------------------------------------------------------ chown
'
!short: chown            Change owner (and group) of a list of files

     chown(LIST)

     chown LIST

             Changes the owner (and group) of a  list  of  files.
             The  first  two  elements  of  the  list must be the
             NUMERICAL uid and gid, in that order.   Returns  the
             number of files successfully changed.

                  $cnt = chown $uid, $gid, 'foo', 'bar';
                  chown $uid, $gid, @filenames;

             Here's an example that looks up non-numeric uids  in
             the passwd file:

                  print "User: ";
                  $user = <STDIN>;
                  chop($user);
                  print "Files: "
                  $pattern = <STDIN>;
                  chop($pattern);
                  open(pass, '/etc/passwd')
                       || die "Can't open passwd: $!\n";
                  while (<pass>) {
                       ($login,$pass,$uid,$gid) = split(/:/);
                       $uid{$login} = $uid;
                       $gid{$login} = $gid;
                  }
                  @ary = <${pattern}>;     # get filenames
                  if ($uid{$user} eq '') {
                       die "$user not in passwd file";
                  }
                  else {
                       chown $uid{$user}, $gid{$user}, @ary;
                  }

!seealso: chmod
'
'----------------------------------------------------------------------- chroot
'
!short: chroot           Change root directory for process and children

     chroot(FILENAME)

     chroot FILENAME

             Not supported on MS-DOS.

!seealso: chdir
'
'------------------------------------------------------------------------ close
'
!short: close            Close a file or pipe

     close(FILEHANDLE)

     close FILEHANDLE

             Closes the file or pipe  associated  with  the  file
             handle.   You  don't have to close FILEHANDLE if you
             are immediately going to  do  another  open  on  it,
             since open will close it for you.  (See open.)  How-
             ever, an explicit close on an input file resets  the
             line  counter ($.), while the implicit close done by
             open does not.  Also, closing a pipe will  wait  for
             the  process  executing  on the pipe to complete, in
             case you want to look at  the  output  of  the  pipe
             afterwards.  Closing a pipe explicitly also puts the
             status value of the command into $?.  Example:

                  open(OUTPUT, '|sort >foo');   # pipe to sort
                  ...  # print stuff to output
                  close OUTPUT;       # wait for sort to finish
                  open(INPUT, 'foo'); # get sort's results

             FILEHANDLE may be an expression  whose  value  gives
             the real filehandle name.

!seealso: open dbmopen dbmclose
'
'--------------------------------------------------------------------- closedir
'
!short: closedir         Closes a directory

     closedir(DIRHANDLE)

     closedir DIRHANDLE

             Closes a directory opened by opendir().

!seealso: opendir
'
'---------------------------------------------------------------------- connect
'
!short: connect          As as C system call

     connect(SOCKET,NAME)
             Does the same thing that  the  connect  system  call
             does.  Sockets are not yet supported on MS-DOS.

!seealso: accept bind
'
'-------------------------------------------------------------------------- cos
'
!short: cos              Returns cosine expressed in radians

     cos(EXPR)

     cos EXPR

     cos
             Returns the cosine of EXPR (expressed  in  radians).
             If EXPR is omitted takes cosine of $_.

!seealso: sin atan2
'
'------------------------------------------------------------------------ crypt
'
!short: crypt            Encrypt a string (like similar func in C)

     crypt(PLAINTEXT,SALT)

             Encrypts a string exactly like the crypt()  function
             in  the C library.  Sockets are not yet supported on
             MS-DOS.

'
'--------------------------------------------------------------------- dbmclose
'
!short: dbmclose         Break binding beteen bdm file and associative array

     dbmclose(ASSOC_ARRAY)

     dbmclose ASSOC_ARRAY

             Breaks the binding between a dbm file and an associ-
             ative  array.   The values remaining in the associa-
             tive array are meaningless unless you happen to want
             to  know  what  was  in  the cache for the dbm file.
             This function is only useful if you have ndbm.

!seealso: dbmopen
'
'---------------------------------------------------------------------- dbmopen
'
!short: dbmopen          Bind dbm file to associative array

     dbmopen(ASSOC,DBNAME,MODE)

             This binds a dbm or  ndbm  file  to  an  associative
             array.   ASSOC is the name of the associative array.
             (Unlike normal open, the first  argument  is  NOT  a
             filehandle,  even though it looks like one).  DBNAME
             is the name of the database  (without  the  .dir  or
             .pag extension).  If the database does not exist, it
             is created with protection  specified  by  MODE  (as
             modified  by  the  umask).  If your system only sup-
             ports the older dbm functions, you may only have one
             dbmopen in your program.  If your system has neither
             dbm nor  ndbm,  calling  dbmopen  produces  a  fatal
             error.  (MS-DOS users: the MS-DOS port uses Gnu-dbm,
             which supports multiple files.)

             Values assigned to the associative  array  prior  to
             the  dbmopen  are  lost.  A certain number of values
             from the dbm file are cached in memory.  By  default
             this number is 64, but you can increase it by preal-
             locating that number of garbage entries in the asso-
             ciative array before the dbmopen.  You can flush the
             cache if necessary with the reset command.

             If you don't have write access to the dbm file,  you
             can  only  read associative array variables, not set
             them.  If you want to test whether  you  can  write,
             either  use  file tests or try setting a dummy array
             entry inside an eval, which will trap the error.

             Note that functions such as keys() and values()  may
             return  huge  array  values  when  used on large dbm
             files.  You may prefer to use the each() function to
             iterate over large dbm files.  Example:

                  # print out history file offsets
                  dbmopen(HIST,'/usr/lib/news/history',0666);
                  while (($key,$val) = each %HIST) {
                       print $key, ' = ', unpack('L',$val), "\n";
                  }
                  dbmclose(HIST);

!seealso: dbmclose
'
'---------------------------------------------------------------------- defined
'
!short: defined          Indicates if item has been defined or not

     defined(EXPR)

     defined EXPR

             Returns a boolean value saying  whether  the  lvalue
             EXPR  has  a  real  value  or  not.  Many operations
             return the undefined value under exceptional  condi-
             tions,  such as end of file, uninitialized variable,
             system error and such.  This function allows you  to
             distinguish  between  an undefined null string and a
             defined  null  string  with  operations  that  might
             return a real null string, in particular referencing
             elements of an array.  You may also check to see  if
             arrays  or  subroutines  exist.   Use  on predefined
             variables is not  guaranteed  to  produce  intuitive
             results.  Examples:

                  print if defined $switch{'D'};
                  print "$val\n" while defined($val = pop(@ary));
                  die "Can't readlink $sym: $!"
                       unless defined($value = readlink $sym);
                  eval '@foo = ()' if defined(@foo);
                  die "No XYZ package defined" unless defined %_XYZ;
                  sub foo { defined &bar ? &bar(@_) : die "No bar"; }

!seealso: undef
'
'----------------------------------------------------------------------- delete
'
!short: delete           Delete specified value from associate array

     delete $ASSOC{KEY}

             Deletes the specified value from the specified asso-
             ciative  array.   Returns  the deleted value, or the
             undefined value if nothing  was  deleted.   Deleting
             from $ENV{} modifies the environment.  Deleting from
             an array bound to a dbm file deletes the entry  from
             the dbm file.

             The following deletes all the values of an  associa-
             tive array:

                  foreach $key (keys %ARRAY) {
                       delete $ARRAY{$key};
                  }

             (But it would be faster to use  the  reset  command.
             Saying undef %ARRAY is faster yet.)

'
'-------------------------------------------------------------------------- die
'
!short: die              Print message to stderr and terminate

     die(LIST)

     die LIST

             Outside of an eval, prints  the  value  of  LIST  to
             STDERR  and  exits  with  the  current  value  of $!
             (errno).  If $! is 0, exits with the value of ($? >>
             8)  (`command`  status).   If  ($? >> 8) is 0, exits
             with 255.  Inside an  eval,  the  error  message  is
             stuffed  into $@ and the eval is terminated with the
             undefined value.

             Equivalent examples:

                  die "Can't cd to spool: $!\n"
                       unless chdir '/usr/spool/news';

                  chdir '/usr/spool/news' || die "Can't cd to spool: $!\n"


             If the value of EXPR does not end in a newline,  the
             current script line number and input line number (if
             any) are also printed, and a  newline  is  supplied.
             Hint:  sometimes  appending ", stopped" to your mes-
             sage will cause it to make  better  sense  when  the
             string  "at  foo line 123" is appended.  Suppose you
             are running script "canasta".

                  die "/etc/games is no good";
                  die "/etc/games is no good, stopped";

             produce, respectively

                  /etc/games is no good at canasta line 123.
                  /etc/games is no good, stopped at canasta line 123.

!seealso: exit warn
'
'--------------------------------------------------------------------------- do
'
!short: do               Do a block or subroutine, or execute file

     do BLOCK

             Returns  the  value  of  the  last  command  in  the
             sequence of commands indicated by BLOCK.  When modi-
             fied by a loop modifier,  executes  the  BLOCK  once
             before   testing  the  loop  condition.   (On  other
             statements the loop modifiers test  the  conditional
             first.)

     do SUBROUTINE (LIST)

             Executes a SUBROUTINE declared by a sub declaration,
             and   returns  the  value  of  the  last  expression
             evaluated in SUBROUTINE.  If there is no  subroutine
             by  that name, produces a fatal error.  (You may use
             the "defined" operator to determine if a  subroutine
             exists.)  If you pass arrays as part of LIST you may
             wish to pass the length of the  array  in  front  of
             each  array.   (See the section on subroutines later
             on.)  SUBROUTINE may be a scalar variable, in  which
             case  the  variable contains the name of the subrou-
             tine to execute.  The parentheses  are  required  to
             avoid confusion with the "do EXPR" form.

             As an alternate form, you may call a  subroutine  by
             prefixing  the  name with an ampersand: &foo(@args).
             If you aren't passing any arguments, you don't  have
             to use parentheses.  If you omit the parentheses, no
             @_ array is passed to the subroutine.  The & form is
             also  used to specify subroutines to the defined and
             undef operators.

     do EXPR Uses the value of EXPR as a  filename  and  executes
             the contents of the file as a perl script.  Its pri-
             mary use is to include subroutines from a perl  sub-
             routine library.

                  do 'stat.pl';

             is just like

                  eval `cat stat.pl`;

             except that it's more efficient, more concise, keeps
             track  of  the  current filename for error messages,
             and searches all the -I libraries if the file  isn't
             in the current directory (see also the @INC array in
             Predefined Names).  It's the same, however, in  that
             it  does reparse the file every time you call it, so
             if you are going to use the file inside a  loop  you
             might  prefer to use -P and #include, at the expense
             of a little more startup time.   (The  main  problem
             with #include is that cpp doesn't grok # comments--a
             workaround is to use ";#" for standalone  comments.)
             Note that the following are NOT equivalent:

                  do $foo;  # eval a file
                  do $foo();     # call a subroutine

             Note that inclusion of library  routines  is  better
             done with the "require" operator.

'
'------------------------------------------------------------------------- dump
'
!short: dump             Causes immediate core dump

     dump LABEL

             This causes an immediate core dump.   Not  supported
             on MS-DOS.

             Example:

                  #!/usr/bin/perl
                  require 'getopt.pl';
                  require 'stat.pl';
                  %days = (
                      'Sun',1,
                      'Mon',2,
                      'Tue',3,
                      'Wed',4,
                      'Thu',5,
                      'Fri',6,
                      'Sat',7);

                  dump QUICKSTART if $ARGV[0] eq '-d';

                 QUICKSTART:
                  do Getopt('f');

'
'------------------------------------------------------------------------- each
'
!short: each             Used to iterate of associative arrays

     each(ASSOC_ARRAY)

     each ASSOC_ARRAY

             Returns a 2 element array consisting of the key  and
             value for the next value of an associative array, so
             that you can iterate over it.  Entries are  returned
             in  an  apparently  random order.  When the array is
             entirely read, a null array is returned (which  when
             assigned produces a FALSE (0) value).  The next call
             to each() after that  will  start  iterating  again.
             The  iterator  can  be reset only by reading all the
             elements from the array.  You must  not  modify  the
             array  while  iterating  over it.  There is a single
             iterator for each associative array, shared  by  all
             each(),  keys()  and  values() function calls in the
             program.  The following prints out your  environment
             like  the  printenv  program,  only  in  a different
             order:

                  while (($key,$value) = each %ENV) {
                       print "$key=$value\n";
                  }

!seealso: keys values

'
'-------------------------------------------------------------------------- eof
'
!short: eof              Indicated file is at End-of-file

     eof(FILEHANDLE)

     eof()

     eof     Returns 1 if the next read on FILEHANDLE will return
             end of file, or if FILEHANDLE is not open.  FILEHAN-
             DLE may be an expression whose value gives the  real
             filehandle  name.  (Note that this function actually
             reads a character and then ungetc's it, so it is not
             very  useful  in  an  interactive  context.)  An eof
             without an argument returns the eof status  for  the
             last file read.  Empty parentheses () may be used to
             indicate the pseudo file formed of the files  listed
             on the command line, i.e. eof() is reasonable to use
             inside a while (<>) loop to detect the end  of  only
             the  last  file.   Use  eof(ARGV) or eof without the
             parentheses to test EACH file in a while (<>)  loop.
             Examples:

                  # insert dashes just before last line of last file
                  while (<>) {
                       if (eof()) {
                            print "--------------\n";
                       }
                       print;
                  }

                  # reset line numbering on each input file
                  while (<>) {
                       print "$.\t$_";
                       if (eof) {     # Not eof().
                            close(ARGV);
                       }
                  }

'
'------------------------------------------------------------------------- eval
'
!short: eval             Evaluate expressions as if it where a little program

     eval(EXPR)

     eval EXPR

             EXPR is parsed and executed as if it were  a  little
             perl  program.  It is executed in the context of the
             current perl program, so that any variable settings,
             subroutine  or format definitions remain afterwards.
             The value returned is the value of the last  expres-
             sion  evaluated, just as with subroutines.  If there
             is a syntax error or runtime error, or a die  state-
             ment  is executed, an undefined value is returned by
             eval, and $@ is set to the error message.  If  there
             was  no error, $@ is guaranteed to be a null string.
             If EXPR is omitted, evaluates $_.  The  final  semi-
             colon, if any, may be omitted from the expression.

             Note that, since eval traps otherwise-fatal  errors,
             it  is  useful  for determining whether a particular
             feature (such as dbmopen or symlink) is implemented.
             It  is  also  Perl's  exception  trapping mechanism,
             where the die operator is used to raise exceptions.

'
'------------------------------------------------------------------------- exec
'
!short: exec             Execute a shell script/command

     exec(LIST)

     exec LIST

             If there is more than one argument in  LIST,  or  if
             LIST  is  an  array  with more than one value, calls
             execvp() with the arguments in LIST.   If  there  is
             only  one  scalar  argument, the argument is checked
             for shell metacharacters.  If  there  are  any,  the
             entire  argument is passed to "/bin/sh -c" for pars-
             ing.  If there are none, the argument is split  into
             words and passed directly to execvp(), which is more
             efficient.  Note: exec (and  system)  do  not  flush
             your  output  buffer,  so  you may need to set $| to
             avoid lost output.  Examples:

                  exec '/bin/echo', 'Your arguments are: ', @ARGV;
                  exec "sort $outfile | uniq";


             If you don't really want to execute the first  argu-
             ment, but want to lie to the program you are execut-
             ing about its own name, you can specify the  program
             you  actually  want  to  run  by assigning that to a
             variable and putting the name  of  the  variable  in
             front  of  the  LIST  without a comma.  (This always
             forces interpretation of the LIST as a  multi-valued
             list,  even  if there is only a single scalar in the
             list.)  Example:

                  $shell = '/bin/csh';
                  exec $shell '-sh';       # pretend it's a login shell

             The MS-DOS  implementation  of  exec  has  problems.
             Unlike system and pipes it is not MKS toolkit compa-
             tible.  As of this writing (September 1991) it  will
             not  even allow for temporary file cleanup.  The use
             of exec on MS-DOS is strongly discouraged.

'
'------------------------------------------------------------------------- exit
'
!short: exit             Exit script with exit code

     exit(EXPR)

     exit EXPR

             Evaluates  EXPR  and  exits  immediately  with  that
             value.  Example:

                  $ans = <STDIN>;
                  exit 0 if $ans =~ /^^[Xx]/;

             If EXPR  is  omitted,  exits  with  0 status.

!seealso: die
'
'-------------------------------------------------------------------------- exp
'
!short: exp              Return e to a specified power
             
     exp(EXPR)

     exp EXPR

             Returns e to the power of EXPR.  If EXPR is omitted,
             gives exp($_).

'
'------------------------------------------------------------------------ fcntl
'
!short: fcntl            Not in DOS

     fcntl(FILEHANDLE,FUNCTION,SCALAR)

             Implements the fcntl(2) function.  Not  supported
             on MS-DOS.

'
'----------------------------------------------------------------------- fileno
'
!short: fileno           Returns a file descriptor for a file handle
             
     fileno(FILEHANDLE)

     fileno FILEHANDLE

             Returns the file descriptor for a filehandle.   Use-
             ful  for  constructing  bitmaps  for  select().   If
             FILEHANDLE is an expression, the value is  taken  as
             the name of the filehandle.

!seealso: select
'
'------------------------------------------------------------------------ flock
'
!short: flock            Call flock(2) on a filehandle

     flock(FILEHANDLE,OPERATION)

             Calls flock(2) on FILEHANDLE.  See manual  page  for
             flock(2)  for definition of OPERATION.  Returns true
             for success, false on failure.  Will produce a fatal
             error  if  used  on a machine that doesn't implement
             flock(2).  Here's a mailbox appender  for  BSD  sys-
             tems.

                  $LOCK_SH = 1;
                  $LOCK_EX = 2;
                  $LOCK_NB = 4;
                  $LOCK_UN = 8;

                  sub lock {
                      flock(MBOX,$LOCK_EX);
                      # and, in case someone appended
                      # while we were waiting...
                      seek(MBOX, 0, 2);
                  }

                  sub unlock {
                      flock(MBOX,$LOCK_UN);
                  }

                  open(MBOX, ">>/usr/spool/mail/$ENV{'USER'}")
                       || die "Can't open mailbox: $!";

                  do lock();
                  print MBOX $msg,"\n\n";
                  do unlock();

'
'------------------------------------------------------------------------- fork
'
!short: fork             Fork off a process (not on MS-DOS)

     fork    Does a fork() call.  Not supported on MS-DOS.

'
'------------------------------------------------------------------------- getc
'
!short: getc             Return next character from input stream

     getc(FILEHANDLE)

     getc FILEHANDLE

     getc

             Returns the  next  character  from  the  input  file
             attached to FILEHANDLE, or a null string at EOF.  If
             FILEHANDLE is omitted, reads from STDIN.

'
'--------------------------------------------------------------------- getlogin
'
!short: getlogin         Returns current login from /etc/utmp (not on MS-DOS)

     getlogin

             Returns the current login from  /etc/utmp,  if  any.
             (Not supported on MS-DOS.)

'
'------------------------------------------------------------------ getpeername
'
!short: getpeername      Return packed socket address of other end of socket
             
     getpeername(SOCKET)

             Returns the packed sockaddr address of other end  of
             the  SOCKET  connection.   (Sockets are not yet sup-
             ported on MS-DOS.)

!seealso: getsockname
'
'---------------------------------------------------------------------- getpgrp
'
!short: getpgrp          Return process group (not on MS-DOS)

     getpgrp(PID)

     getpgrp PID

             Returns the current process group for the  specified
             PID,  0  for  the current process.  Not supported on
             MS-DOS.

'
'---------------------------------------------------------------------- getppid
'
!short: getppid          Return id of the parent process (not on MS-DOS)

     getppid

             On Unix, returns the process id of the  parent  pro-
             cess.  Not supported on MS-DOS.

'
'------------------------------------------------------------------ getpriority
'
!short: getpriority      Return current process priority  (not on MS-DOS)

     getpriority(WHICH,WHO)

             Returns the current priority for a process,  a  pro-
             cess group, or a user.  Not supported on MS-DOS.

'
'------------------------------------------------------------------ getsockname
'
!short: getsockname      Return socket address for this side of socket

     getsockname(SOCKET)

             Returns the packed sockaddr address of this  end  of
             the SOCKET connection.
             Sockets are not yet supported on MS-DOS.

!seealso: getpeername

'
'------------------------------------------------------------------- getsockopt
'
!short: getsockopt       Return requested socket option (or NULL)

     getsockopt(SOCKET,LEVEL,OPTNAME)

             Returns the socket option requested, or undefined if
             there is an error.  Sockets are not yet supported on
             MS-DOS.

'
'----------------------------------------------------------------------- gmtime
'
!short: gmtime           Greenwich time

     gmtime(EXPR)

     gmtime EXPR

             Converts a time as returned by the time function  to
             a  9-element  array  with  the time analyzed for the
             Greenwich timezone.  Typically used as follows:

             ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) =
                                           gmtime(time);

             All array elements are numeric,  and  come  straight
             out  of  a struct tm.  In particular this means that
             $mon has the range 0..11 and  $wday  has  the  range
             0..6.  If EXPR is omitted, does gmtime(time).

!seealso: time
'
'------------------------------------------------------------------------- goto
'
!short: goto             Start executing at specified label

     goto LABEL

             Finds the statement labeled with LABEL  and  resumes
             execution  there.   Currently  you  may  only  go to
             statements in the main body of the program that  are
             not nested inside a do {} construct.  This statement
             is not implemented very  efficiently,  and  is  here
             only  to  make the sed-to-perl translator easier.  I
             may change its semantics  at  any  time,  consistent
             with  support for translated sed scripts.  Use it at
             your own risk.  Better yet, don't use it at all.

'
'------------------------------------------------------------------------- grep
'
!short: grep             Return matched lines of an array

     grep(EXPR,LIST)

             Evaluates EXPR for each  element  of  LIST  (locally
             setting  $_  to  each element) and returns the array
             value consisting of those  elements  for  which  the
             expression  evaluated to true.  In a scalar context,
             returns the number of times the expression was true.

                  @foo = grep(!/^^#/, @bar);    # weed out comments

             Note that, since $_ is a reference  into  the  array
             value,  it can be used to modify the elements of the
             array.  While this is useful and supported,  it  can
             cause  bizarre  results  if  the LIST is not a named
             array.

'
'-------------------------------------------------------------------------- hex
'
!short: hex              Return value of expression as hex string

     hex(EXPR)

     hex EXPR

             Returns the decimal value of EXPR interpreted as  an
             hex  string.  (To interpret strings that might start
             with 0 or 0x see oct().)  If EXPR is  omitted,  uses
             $_.

!seealso: oct
'
'------------------------------------------------------------------------ index
'
!short: index            Return position of first occurance of SUBSTR in STR

     index(STR,SUBSTR,POSITION)

     index(STR,SUBSTR)

             Returns the position  of  the  first  occurrence  of
             SUBSTR  in STR at or after POSITION.  If POSITION is
             omitted, starts searching from the beginning of  the
             string.  The return value is based at 0, or whatever
             you've set the $[ variable to.  If the substring  is
             not  found,  returns  one  less than the base, ordi-
             narily -1.

!seealso: rindex
'
'-------------------------------------------------------------------------- int
'
!short: int              Return integer portion of an expression

     int(EXPR)

     int EXPR

             Returns the integer portion of  EXPR.   If  EXPR  is
             omitted, uses $_.

'
'------------------------------------------------------------------------ ioctl
'
!short: ioctl            x

     ioctl(FILEHANDLE,FUNCTION,SCALAR)

             Implements the ioctl(2) function.   You'll  probably
             have to say

                  require "ioctl.ph"; # probably /usr/local/lib/perl/ioctl.ph

             first to get the correct function  definitions.   If
             ioctl.ph  doesn't  exist or doesn't have the correct
             definitions you'll have to roll your own,  based  on
             your  C  header files such as <sys/ioctl.h>.  (There
             is a perl script called h2ph  that  comes  with  the
             Unix  perl  kit which may help you in this.)  SCALAR
             will  be  read  and/or  written  depending  on   the
             FUNCTION--a  pointer  to  the string value of SCALAR
             will be passed as the third argument of  the  actual
             ioctl call.  (If SCALAR has no string value but does
             have a numeric value,  that  value  will  be  passed
             rather  than  a  pointer  to  the  string value.  To
             guarantee this to be true, add a  0  to  the  scalar
             before using it.)  The pack() and unpack() functions
             are useful for manipulating the values of structures
             used  by  ioctl().   The  following example sets the
             erase character to DEL.

                  require 'ioctl.ph';
                  $sgttyb_t = "ccccs";          # 4 chars and a short
                  if (ioctl(STDIN,$TIOCGETP,$sgttyb)) {
                       @ary = unpack($sgttyb_t,$sgttyb);
                       $ary[2] = 127;
                       $sgttyb = pack($sgttyb_t,@ary);
                       ioctl(STDIN,$TIOCSETP,$sgttyb)
                            || die "Can't ioctl: $!";
                  }

             The return value of ioctl (and fcntl) is as follows:

                  if OS returns:           perl returns:
                    -1                       undefined value
                    0                        string "0 but true"
                    anything else            that number

             Thus perl returns  true  on  success  and  false  on
             failure,  yet  you  can  still  easily determine the
             actual value returned by the operating system:

                  ($retval = ioctl(...)) || ($retval = -1);
                  printf "System returned %d\n", $retval;

'
'------------------------------------------------------------------------- join
'
!short: join             Join separate strings/arrays into single string/array

     join(EXPR,LIST)

     join(EXPR,ARRAY)

             Joins the separate strings of LIST or ARRAY  into  a
             single  string with fields separated by the value of
             EXPR, and returns the string.  Example:

             $_ = join(':',
                       $login,$passwd,$uid,$gid,$gcos,$home,$shell);

!seealso: split
'
'------------------------------------------------------------------------- keys
'
!short: keys             Return an array of keys for an associative array

     keys(ASSOC_ARRAY)

     keys ASSOC_ARRAY

             Returns a normal array consisting of all the keys of
             the  named associative array.  The keys are returned
             in an apparently random order, but it  is  the  same
             order as either the values() or each() function pro-
             duces (given that the associative array has not been
             modified).   Here  is  yet another way to print your
             environment:

                  @keys = keys %ENV;
                  @values = values %ENV;
                  while ($#keys >= 0) {
                       print pop(@keys), '=', pop(@values), "\n";
                  }

             or how about sorted by key:

                  foreach $key (sort(keys %ENV)) {
                       print $key, '=', $ENV{$key}, "\n";
                  }

'
'------------------------------------------------------------------------- kill
'
!short: kill             Terminate a list of processes/groups

     kill(LIST)

     kill LIST

             Sends a signal to a list of  processes.   The  first
             element  of  the  list  must  be the signal to send.
             Returns the number of  processes  successfully  sig-
             naled.

                  $cnt = kill 1, $child1, $child2;
                  kill 9, @goners;

             If the signal  is  negative,  kills  process  groups
             instead of processes.  (On System V, a negative pro-
             cess number  will  also  kill  process  groups,  but
             that's  not portable.)  You may use a signal name in
             quotes.

'
'------------------------------------------------------------------------- last
'
!short: last             Terminate a loop (like break in C)
             
     last LABEL

     last
             The last command is like the break  statement  in  C
             (as used in loops); it immediately exits the loop in
             question.  If the  LABEL  is  omitted,  the  command
             refers  to  the  innermost enclosing loop.  The con-
             tinue block, if any, is not executed:

                  line: while (<STDIN>) {
                       last line if /^^$/;  # exit when done with header
                       ...
                  }

!seealso: next
'
'----------------------------------------------------------------------- length
'
!short: length           Return the length of a string expression

     length(EXPR)

     length EXPR

             Returns the length in characters  of  the  value  of
             EXPR.  If EXPR is omitted, returns length of $_.

'
'------------------------------------------------------------------------- link
'
!short: link             Create a new file linked to an old file

     link(OLDFILE,NEWFILE)

             Creates a new filename linked to the  old  filename.
             Returns 1 for success, 0 otherwise.

'
'----------------------------------------------------------------------- listen
'
!short: listen           Same as listen system call

     listen(SOCKET,QUEUESIZE)

             Does the same thing  that  the  listen  system  call
             does.  Sockets are not yet supported on MS-DOS.

'
'------------------------------------------------------------------------ local
'
!short: local            Declare a list of variables to be local to a block

     local(LIST)

             Declares the listed variables to  be  local  to  the
             enclosing  block, subroutine, eval or "do".  All the
             listed elements must be legal lvalues.  This  opera-
             tor  works  by  saving  the  current values of those
             variables in LIST on a hidden  stack  and  restoring
             them  upon  exiting  the  block, subroutine or eval.

             This means that called subroutines can  also  refer-
             ence  the  local  variable,  but not the global one.
             The LIST may be assigned to if desired, which allows
             you to initialize your local variables.  (If no ini-
             tializer is given for a particular variable,  it  is
             created  with an undefined value.)  Commonly this is
             used to name the parameters to a subroutine.   Exam-
             ples:

                  sub RANGEVAL {
                       local($min, $max, $thunk) = @_;
                       local($result) = '';
                       local($i);

                       # Presumably $thunk makes reference to $i

                       for ($i = $min; $i < $max; $i++) {
                            $result .= eval $thunk;
                       }

                       $result;
                  }

                  if ($sw eq '-v') {
                      # init local array with global array
                      local(@ARGV) = @ARGV;
                      unshift(@ARGV,'echo');
                      system @ARGV;
                  }
                  # @ARGV restored

                  # temporarily add to digits associative array
                  if ($base12) {
                       # (NOTE: not claiming this is efficient!)
                       local(%digits) = (%digits,'t',10,'e',11);
                       do parse_num();
                  }

             Note that local() is a run-time command, and so gets
             executed  every  time  through a loop, using up more
             stack storage each time until it's all  released  at
             once when the loop is exited.

'
'-------------------------------------------------------------------- localtime
'
!short: localtime        Convert result of time to a 9-element array
             
     localtime(EXPR)

     localtime EXPR

             Converts a time as returned by the time function  to
             a  9-element  array  with  the time analyzed for the
             local timezone.  Typically used as follows:

             ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) =
                                           localtime(time);

             All array elements are numeric,  and  come  straight
             out  of  a struct tm.  In particular this means that
             $mon has the range 0..11 and  $wday  has  the  range
             0..6.  If EXPR is omitted, does localtime(time).
!seealso: time
'
'-------------------------------------------------------------------------- log
'
!short: log              Return the logarith (base e) of an expression

     log(EXPR)

     log EXPR

             Returns logarithm (base e)  of  EXPR.   If  EXPR  is
             omitted, returns log of $_.

'
'------------------------------------------------------------------------ lstat
'
!short: lstat            Call stat on symbolic links

     lstat(FILEHANDLE)

     lstat FILEHANDLE

     lstat(EXPR)

     lstat SCALARVARIABLE

             Used to stat symbolic links  on  Unix.   On  MS-DOS,
             same as stat.

!seealso: stat
'
'---------------------------------------------------------------- m/PATTERN/gio
'
!short: m/PATTERN/gio    Match a string agaist a pattern

     m/PATTERN/gio

     /PATTERN/gio

             Searches a string for a pattern match,  and  returns
             true  (1)  or false ('').  If no string is specified
             via  the  =~  or  !~  operator,  the  $_  string  is
             searched.  (The string specified with =~ need not be
             an lvalue--it may be the  result  of  an  expression
             evaluation,   but   remember  the  =~  binds  rather
             tightly.)  See also the section on  regular  expres-
             sions.

             If / is  the  delimiter  then  the  initial  'm'  is
             optional.   With  the  'm'  you  can use any pair of
             non-alphanumeric characters as delimiters.  This  is
             particularly  useful  for  matching  Unix path names
             that contain '/'.  If the final  delimiter  is  fol-
             lowed  by  the  optional letter 'i', the matching is
             done in a case-insensitive manner.  PATTERN may con-
             tain  references  to scalar variables, which will be
             interpolated (and the pattern recompiled) every time
             the  pattern search is evaluated.  (Note that $) and
             $| may not be interpolated because  they  look  like
             end-of-string tests.)  If you want such a pattern to
             be compiled only once, add an "o" after the trailing
             delimiter.   This avoids expensive run-time recompi-
             lations, and is useful when the value you are inter-
             polating  won't  change over the life of the script.

             If the PATTERN evaluates to a null string, the  most
             recent   successful   regular   expression  is  used
             instead.

             If used in a context that requires an array value, a
             pattern  match  returns  an  array consisting of the
             subexpressions matched by  the  parentheses  in  the
             pattern, i.e. ($1, $2, $3...).  It does NOT actually
             set $1, $2, etc. in this case, nor does it  set  $+,
             $`,  $&  or $'.  If the match fails, a null array is
             returned.  If the match succeeds, but there were  no
             parentheses, an array value of (1) is returned.

             Examples:

                 open(tty, '/dev/tty');
                 <tty> =~ /^^y/i && do foo();    # do foo if desired

                 if (/Version: *([0-9.]*)/) { $version = $1; }

                 next if m#^^/usr/spool/uucp#;

                 # poor man's grep
                 $arg = shift;
                 while (<>) {
                      print if /$arg/o;    # compile only once
                 }

                 if (($F1, $F2, $Etc) = ($foo =~ /^^(\S+)\s+(\S+)\s*(.*)/))

             This last example splits $foo  into  the  first  two
             words  and  the  remainder  of the line, and assigns
             those three fields to $F1, $F2 and $Etc.  The condi-
             tional  is true if any variables were assigned, i.e.
             if the pattern matched.

             The   "g"   modifier   specifies   global    pattern
             matching--that  is, matching as many times as possi-
             ble within the string.  How it  behaves  depends  on
             the context.  In an array context, it returns a list
             of all the substrings matched by all the parentheses
             in   the   regular  expression.   If  there  are  no
             parentheses, it returns a list of  all  the  matched
             strings,  as  if  there  were parentheses around the
             whole pattern.  In a  scalar  context,  it  iterates
             through  the  string,  returning  TRUE  each time it
             matches, and FALSE when it eventually  runs  out  of
             matches.   (In  other  words,  it remembers where it
             left off last time and restarts the search  at  that
             point.)   It presumes that you have not modified the
             string since the last match.  Modifying  the  string
             between  matches  may  result in undefined behavior.

             (You can actually get away with  in-place  modifica-
             tions  via substr() that do not change the length of
             the entire string.  In general, however, you  should
             be using s///g for such modifications.)  Examples:

                  # array context
                  ($one,$five,$fifteen) = (`uptime` =~ /(\d+\.\d+)/g);

                  # scalar context
                  $/ = 1; $* = 1;
                  while ($paragraph = <>) {
                      while ($paragraph =~ /[a-z]['")]*[.!?]+['")]*\s/g) {
                       $sentences++;
                      }
                  }
                  print "$sentences\n";

'
'------------------------------------------------------------------------ mkdir
'
!short: mkdir            Make a directory

     mkdir(FILENAME,MODE)

             Creates the directory specified  by  FILENAME,  with
             permissions   specified  by  MODE  (as  modified  by
             umask).  If it succeeds it returns 1,  otherwise  it
             returns 0 and sets $! (errno).

!seealso: rmdir
'
'------------------------------------------------------------------------- next
'
!short: next             Start the next iteration of a loop (like continue in C)
             
     next LABEL

     next    The next command is like the continue  statement  in
             C; it starts the next iteration of the loop:

                  line: while (<STDIN>) {
                       next line if /^^#/;  # discard comments
                       ...
                  }

             Note that if there were  a  continue  block  on  the
             above,  it  would  get  executed  even  on discarded
             lines.  If the LABEL is omitted, the command  refers
             to the innermost enclosing loop.

!seealso: last
'
'-------------------------------------------------------------------------- oct
'
!short: oct              Return expression as an octal string

     oct(EXPR)

     oct EXPR

             Returns the decimal value of EXPR interpreted as  an
             octal  string.   (If  EXPR happens to start off with
             0x, interprets it as a  hex  string  instead.)   The
             following  will handle decimal, octal and hex in the
             standard notation:

                  $val = oct($val) if $val =~ /^^0/;

             If EXPR is omitted, uses $_.

!seealso: hex
'
'------------------------------------------------------------------------- open
'
!short: open             Open a file for reading,writting, or appending

     open(FILEHANDLE,EXPR)

     open(FILEHANDLE)

     open FILEHANDLE

             Opens the file whose filename is given by EXPR,  and
             associates  it with FILEHANDLE.  If FILEHANDLE is an
             expression, its value is used as  the  name  of  the
             real  filehandle  wanted.   If  EXPR is omitted, the
             scalar variable of the same name as  the  FILEHANDLE
             contains  the filename.  If the filename begins with
             "<" or nothing, the file is opened  for  input.   If
             the filename begins with ">", the file is opened for
             output.  If the filename begins with ">>", the  file
             is  opened  for  appending.   (You  can put a '+' in
             front of the '>' or '<' to indicate  that  you  want
             both  read  and  write  access to the file.)  If the
             filename begins with "|",  the  filename  is  inter-
             preted  as a command to which output is to be piped,
             and if the filename ends with a "|", the filename is
             interpreted  as  command  which  pipes  input to us.
             (You may not have a command that pipes both  in  and
             out.)   Opening  '-'  opens  STDIN  and opening '>-'
             opens STDOUT.  Open returns non-zero  upon  success,
             the undefined value otherwise.  If the open involved
             a pipe, the return value happens to be  the  pid  of
             the subprocess.  Examples:

                  $article = 100;
                  open article || die "Can't find article $article: $!\n";
                  while (<article>) {...

                  open(LOG, '>>/usr/spool/news/twitlog');
                                      # (log is reserved)

                  open(article, "caesar <$article |");
                                      # decrypt article

                  open(extract, "|sort >/tmp/Tmp$$");
                                      # $$ is our process#

                  # process argument list of files along with any includes

                  foreach $file (@ARGV) {
                       do process($file, 'fh00');    # no pun intended
                  }

                  sub process {
                       local($filename, $input) = @_;
                       $input++;      # this is a string increment
                       unless (open($input, $filename)) {
                            print STDERR "Can't open $filename: $!\n";
                            return;
                       }
                       while (<$input>) {       # note use of indirection
                            if (/^^#include "(.*)"/) {
                                 do process($1, $input);
                                 next;
                            }
                            ...       # whatever
                       }
                  }

             You may also, in the Bourne shell tradition, specify
             an  EXPR beginning with ">&", in which case the rest
             of the string  is  interpreted  as  the  name  of  a
             filehandle (or file descriptor, if numeric) which is
             to be duped and opened.  You may use & after >,  >>,
             <,  +>,  +>>  and  +<.   The mode you specify should
             match the mode of the original filehandle.  Here  is
             a  script that saves, redirects, and restores STDOUT
             and STDERR:


                  #!/usr/bin/perl
                  open(SAVEOUT, ">&STDOUT");
                  open(SAVEERR, ">&STDERR");

                  open(STDOUT, ">foo.out") || die "Can't redirect stdout";
                  open(STDERR, ">&STDOUT") || die "Can't dup stdout";

                  select(STDERR); $| = 1;       # make unbuffered
                  select(STDOUT); $| = 1;       # make unbuffered

                  print STDOUT "stdout 1\n";    # this works for
                  print STDERR "stderr 1\n";    # subprocesses too

                  close(STDOUT);
                  close(STDERR);

                  open(STDOUT, ">&SAVEOUT");
                  open(STDERR, ">&SAVEERR");

                  print STDOUT "stdout 2\n";
                  print STDERR "stderr 2\n";

             Explicitly closing any piped filehandle  causes  the
             parent  process to wait for the child to finish, and
             returns the status value in $?.  Note: on any opera-
             tion  which  may do a fork, unflushed buffers remain
             unflushed in both processes,  which  means  you  may
             need to set $| to avoid duplicate output.

             On MS-DOS, "pipes" are actually files, and the  sub-
             process is run to completion.  For output pipes, the
             subprocess is run when perl exits or when  the  pipe
             is  explicitly closed.  For input pipes, the subpro-
             gram is run to completion when the open is  done.
             On MS-DOS, it is recommended that forward slashes be
             used to delimit path components in file names.  (See
             the section on MS-DOS.)

!seealso: close dbmopen dbmclose
'
'---------------------------------------------------------------------- opendir
'
!short: opendir          Open a directory

     opendir(DIRHANDLE,EXPR)
             Opens a directory named EXPR for processing by read-
             dir(),   telldir(),   seekdir(),   rewinddir()   and
             closedir().  Returns true if successful.  DIRHANDLEs
             have their own namespace separate from FILEHANDLEs.

!seealso: readdir telldir seekdir rewinddir closedir
'
'-------------------------------------------------------------------------- ord
'
!short: ord              Return ascii value of first character of EXPR

     ord(EXPR)

     ord EXPR

             Returns the numeric ascii value of the first charac-
             ter of EXPR.  If EXPR is omitted, uses $_.

'
'------------------------------------------------------------------------- pack
'
!short: pack             Pack values into a binary structure

     pack(TEMPLATE,LIST)

             Takes an array or list of values and packs it into a
             binary  structure,  returning  the string containing
             the structure.  The TEMPLATE is a sequence of  char-
             acters  that  give  the order and type of values, as
             follows:

                  A    An ascii string, will be space padded.
                  a    An ascii string, will be null padded.
                  c    A signed char value.
                  C    An unsigned char value.
                  s    A signed short value.
                  S    An unsigned short value.
                  i    A signed integer value.
                  I    An unsigned integer value.
                  l    A signed long value.
                  L    An unsigned long value.
                  n    A short in "network" order.
                  N    A long in "network" order.
                  f    A single-precision float in the native format.
                  d    A double-precision float in the native format.
                  p    A pointer to a string.
                  x    A null byte.
                  X    Back up a byte.
                  @    Null fill to absolute position.
                  u    A uuencoded string.
                  b    A bit string (ascending bit order, like vec()).
                  B    A bit string (descending bit order).
                  h    A hex string (low nybble first).
                  H    A hex string (high nybble first).

             Each letter may optionally be followed by  a  number
             which  gives  a repeat count.  With all types except
             "a", "A", "b", "B", "h" and "H", the  pack  function
             will  gobble up that many values from the LIST.  A *
             for the repeat count means to use however many items
             are  left.   The  "a"  and "A" types gobble just one
             value, but pack it as a string of length count, pad-
             ding  with  nulls  or  spaces  as  necessary.  (When
             unpacking, "A" strips trailing spaces and nulls, but
             "a"  does  not.)   Likewise,  the "b" and "B" fields
             pack a string that many bits long.  The "h" and  "H"
             fields  pack  a string that many nybbles long.  Real
             numbers (floats  and  doubles)  are  in  the  native
             machine  format  only;  due  to  the multiplicity of
             floating formats around, and the lack of a  standard
             "network"  representation,  no  facility  for inter-
             change has been made.  This means that packed float-
             ing  point  data  written  on one machine may not be
             readable on another - even if both use IEEE floating
             point  arithmetic  (as the endian-ness of the memory
             representation is not part of the IEEE spec).   Note
             that  perl  uses  doubles internally for all numeric
             calculation, and converting from double -> float  ->
             double   will   lose   precision  (i.e.  unpack("f",
             pack("f", $foo)) will not in general equal $foo).
             Examples:

                  $foo = pack("cccc",65,66,67,68);
                  # foo eq "ABCD"
                  $foo = pack("c4",65,66,67,68);
                  # same thing

                  $foo = pack("ccxxcc",65,66,67,68);
                  # foo eq "AB\0\0CD"

                  $foo = pack("s2",1,2);
                  # "\1\0\2\0" on little-endian
                  # "\0\1\0\2" on big-endian

                  $foo = pack("a4","abcd","x","y","z");
                  # "abcd"

                  $foo = pack("aaaa","abcd","x","y","z");
                  # "axyz"

                  $foo = pack("a14","abcdefg");
                  # "abcdefg\0\0\0\0\0\0\0"

                  $foo = pack("i9pl", gmtime);
                  # a real struct tm (on my system anyway)

                  sub bintodec {
                      unpack("N", pack("B32", substr("0" x 32 . shift, -32)));
                  }
             The same template may generally also be used in  the
             unpack function.

!seealso: unpack
'
'------------------------------------------------------------------------- pipe
'
!short: pipe             Open a pair of connected pipes

     pipe(READHANDLE,WRITEHANDLE)

             Opens a pair of connected pipes like the correspond-
             ing system call.  Not supported on MS-DOS.

'
'-------------------------------------------------------------------------- pop
'
!short: pop              Pops and return last value of an array

     pop(ARRAY)

     pop ARRAY

             Pops and returns the last value of the array,  shor-
             tening the array by 1.  Has the same effect as

                  $tmp = $ARRAY[$#ARRAY--];

             If there are no elements in the array,  returns  the
             undefined value.

!seealso: push
'
'------------------------------------------------------------------------ print
'
!short: print            Print a list of strings to an output file

     print(FILEHANDLE LIST)

     print(LIST)

     print FILEHANDLE LIST

     print LIST

     print   Prints  a  string  or  a  comma-separated  list   of
             strings.   Returns non-zero if successful.  FILEHAN-
             DLE may be a scalar variable name, in which case the
             variable  contains  the name of the filehandle, thus
             introducing one level  of  indirection.   (NOTE:  If
             FILEHANDLE  is  a  variable  and the next token is a
             term, it may be misinterpreted as an operator unless
             you  interpose  a  +  or put parens around the argu-
             ments.)  If FILEHANDLE is omitted, prints by default
             to  standard  output (or to the last selected output
             channel--see select()).  If LIST  is  also  omitted,
             prints  $_  to  STDOUT.   To  set the default output
             channel to  something  other  than  STDOUT  use  the
             select  operation.  Note that, because print takes a
             LIST, anything in the LIST is evaluated in an  array
             context,  and any subroutine that you call will have
             one or more of its expressions evaluated in an array
             context.   Also  be  careful not to follow the print
             keyword with a left parenthesis unless you want  the
             corresponding  right  parenthesis  to  terminate the
             arguments to the print--interpose a + or put  parens
             around all the arguments.

!seealso: printf
'
'----------------------------------------------------------------------- printf
'
!short: printf           Print a list of string with formatting to output file

     printf(FILEHANDLE LIST)

     printf(LIST)

     printf FILEHANDLE LIST

     printf LIST

             Equivalent to a "print FILEHANDLE sprintf(LIST)".


     The first string is the format string (as in C).  The format
     characters are the same as those of C.

!seealso: print
'
'------------------------------------------------------------------------- push
'
!short: push             Pushes an items as first element of an array

     push(ARRAY,LIST)

             Treats ARRAY (@ is optional) as a stack, and  pushes
             the  values  of  LIST  onto  the  end of ARRAY.  The
             length of ARRAY increases by  the  length  of  LIST.
             Has the same effect as

                 for $value (LIST) {
                      $ARRAY[++$#ARRAY] = $value;
                 }

             but is more efficient.

!seealso: pop
'
'-------------------------------------------------------------------- q/STRING/
'
!short: q/STRING/        Generalized quoting mechanism (too avoid many \)

     q/STRING/

     qq/STRING/

     qx/STRING/

             These are not really functions, but simply syntactic
             sugar  to let you avoid putting too many backslashes
             into quoted strings.  The q operator is  a  general-
             ized single quote, and the qq operator a generalized
             double quote.  The  qx  operator  is  a  generalized
             backquote.   Any  non-alphanumeric  delimiter can be
             used in place of /, including newline.  If the  del-
             imiter  is  an  opening  bracket or parenthesis, the
             final delimiter will be  the  corresponding  closing
             bracket  or  parenthesis.   (Embedded occurrences of
             the  closing  bracket  need  to  be  backslashed  as
             usual.)  Examples:

                  $foo = q!I said, "You said, 'She said it.'"!;
                  $bar = q('This is it.');
                  $today = qx{ date };
                  $_ .= qq
             *** The previous line contains the naughty word "$&".\n
                       if /(ibm|apple|awk)/;      # :-)

'
'------------------------------------------------------------------------- rand
'
!short: rand             Return random fraction between 0 and 1 (or specified)

     rand(EXPR)

     rand EXPR

     rand    Returns a random fractional number between 0 and the
             value  of EXPR.  (EXPR should be positive.)  If EXPR
             is omitted, returns a value between 0  and  1.   See
             also srand().

!seealso: srand
'
'------------------------------------------------------------------------- read
'
!short: read             Read a sequence a data from a file

     read(FILEHANDLE,SCALAR,LENGTH,OFFSET)

     read(FILEHANDLE,SCALAR,LENGTH)

             Attempts to read LENGTH bytes of data into  variable
             SCALAR  from  the specified FILEHANDLE.  Returns the
             number of bytes actually read, or undef if there was
             an  error.   SCALAR  will  be grown or shrunk to the
             length actually read.  An OFFSET may be specified to
             place  the  read  data  at some other place than the
             beginning of the  string.   This  call  is  actually
             implemented  in terms of stdio's fread call.  To get
             a true read system call, see sysread.

!seealso: open close seek
'
'---------------------------------------------------------------------- readdir
'
!short: readdir          Return next directory entry

     readdir(DIRHANDLE)

     readdir DIRHANDLE

             Returns the next directory  entry  for  a  directory
             opened  by  opendir().  If used in an array context,
             returns all the rest of the entries  in  the  direc-
             tory.   If  there  are  no  more entries, returns an
             undefined value in a scalar context or a  null  list
             in an array context.

!seealso: opendir closedir telldir seekdir rewinddir
'
'--------------------------------------------------------------------- readlink
'
!short: readlink         Return the value of a symbolic link

     readlink(EXPR)

     readlink EXPR

             Returns the value of a symbolic link.  Not supported
             on MS-DOS.

'
'------------------------------------------------------------------------- recv
'
!short: recv             Receive a message on a socket

     recv(SOCKET,SCALAR,LEN,FLAGS)

             Receives a message on a socket.

             SOCKET  filehandle.   Returns  the  address  of  the
             sender,  or the undefined value if there's an error.
             SCALAR will be grown or shrunk to the  length  actu-
             ally  read.  Takes the same flags as the system call
             of the same name. Sockets are not yet  supported  on
             MS-DOS.

'
'------------------------------------------------------------------------- redo
'
!short: redo             Restart a loop block without evaluating conditional

     redo LABEL

     redo    The redo command restarts  the  loop  block  without
             evaluating  the  conditional  again.   The  continue
             block, if any, is not executed.   If  the  LABEL  is
             omitted, the command refers to the innermost enclos-
             ing loop.  This command is normally used by programs
             that  want  to lie to themselves about what was just
             input:

                  # a simpleminded Pascal comment stripper
                  # (warning: assumes no { or } in strings)
                  line: while (<STDIN>) {
                       while (s|({.*}.*){.*}|$1 |) {}
                       s|{.*}| |;
                       if (s|{.*| |) {
                            $front = $_;
                            while (<STDIN>) {
                                 if (/}/) {     # end of comment?
                                      s|^^|$front{|;
                                      redo line;
                                 }
                            }
                       }
                       print;
                  }

'
'----------------------------------------------------------------------- rename
'
!short: rename           Change the name of a file

     rename(OLDNAME,NEWNAME)

             Changes the name of a file.  Returns 1 for  success,
             0  otherwise.  Will not work across filesystem boun-
             daries.

'
'---------------------------------------------------------------------- require
'
!short: require          Include a library file

     require(EXPR)

     require EXPR

     require

             Includes the library file specified by EXPR,  or  by
             $_  if  EXPR is not supplied.  Has semantics similar
             to the following subroutine:

                  sub require {
                      local($filename) = @_;
                      return 1 if $INC{$filename};
                      local($realfilename,$result);
                      ITER: {
                       foreach $prefix (@INC) {
                           $realfilename = "$prefix/$filename";
                           if (-f $realfilename) {
                            $result = do $realfilename;
                            last ITER;
                           }
                       }
                       die "Can't find $filename in \@INC";
                      }
                      die $@ if $@;
                      die "$filename did not return true value" unless $result;
                      $INC{$filename} = $realfilename;
                      $result;
                  }

             Note that the file will not be included twice  under
             the same specified name.

'
'------------------------------------------------------------------------ reset
'
!short: reset            Clear variables and searches

     reset(EXPR)

     reset EXPR

     reset
             Generally used in a continue block at the end  of  a
             loop  to  clear  variables  and reset ?? searches so
             that they work again.  The expression is interpreted
             as  a list of single characters (hyphens allowed for
             ranges).  All variables and  arrays  beginning  with
             one  of  those  letters  are reset to their pristine
             state.  If  the  expression  is  omitted,  one-match
             searches (?pattern?) are reset to match again.  Only
             resets variables or searches in the current package.
             Always returns 1.  Examples:

                 reset 'X';      # reset all X variables
                 reset 'a-z';    # reset lower case variables
                 reset;          # just reset ?? searches

             Note:  resetting  "A-Z"  is  not  recommended  since
             you'll wipe out your ARGV and ENV arrays.

             The use of reset on dbm associative arrays does  not
             change  the  dbm file.  (It does, however, flush any
             entries cached by perl, which may be useful  if  you
             are sharing the dbm file.  Then again, maybe not.)

'
'----------------------------------------------------------------------- return
'
!short: return           Return from a subroutine with given value(s)

     return LIST

             Returns from a subroutine with the value  specified.
             (Note that a subroutine can automatically return the
             value of the last expression evaluated.  That's  the
             preferred method--use of an explicit return is a bit
             slower.)

'
'---------------------------------------------------------------------- reverse
'
!short: reverse          Reverses order of elements of an array or string

     reverse(LIST)

     reverse LIST

             In an array context, returns an array value consist-
             ing  of  the elements of LIST in the opposite order.
             In a scalar context, returns a string value consist-
             ing of the bytes of the first element of LIST in the
             opposite order.

!seealso: sort
'
'-------------------------------------------------------------------- rewinddir
'
!short: rewinddir        Set position of directory to beginning

     rewinddir(DIRHANDLE)

     rewinddir DIRHANDLE

             Sets the current position to the  beginning  of  the
             directory for the readdir() routine on DIRHANDLE.

!seealso: opendir readdir telldir seekdir closedir
'
'----------------------------------------------------------------------- rindex
'
!short: rindex           Return position of last occurance of SUBSTR in STR

     rindex(STR,SUBSTR,POSITION)

     rindex(STR,SUBSTR)

             Works just like index except  that  it  returns  the
             position  of  the  LAST occurrence of SUBSTR in STR.
             If  POSITION  is   specified,   returns   the   last
             occurrence at or before that position.

!seealso: index
'
'------------------------------------------------------------------------ rmdir
'
!short: rmdir            Remove a directory

     rmdir(FILENAME)

     rmdir FILENAME

             Deletes the directory specified by FILENAME if it is
             empty.   If  it  succeeds it returns 1, otherwise it
             returns 0 and sets $! (errno).  If FILENAME is omit-
             ted, uses $_.

!seealso: mkdir
'
'------------------------------------------------------------- s/PATT/REPL/gieo
'
!short: s/PATT/REPL/gieo Does string subsitutions based on patterns

     s/PATTERN/REPLACEMENT/gieo

             Searches a string  for  a  pattern,  and  if  found,
             replaces  that pattern with the replacement text and
             returns the number of substitutions made.  Otherwise
             it  returns  false (0).  The "g" is optional, and if
             present,  indicates  that  all  occurrences  of  the
             pattern  are  to  be  replaced.   The  "i"  is  also
             optional, and if present, indicates that matching is
             to be done in a case-insensitive manner.  The "e" is
             likewise optional, and if  present,  indicates  that
             the  replacement  string  is  to  be evaluated as an
             expression  rather  than  just  as  a  double-quoted
             string.   Any non-alphanumeric delimiter may replace
             the slashes; if single quotes are used, no interpre-
             tation  is  done  on  the  replacement string (the e
             modifier overrides this, however); if backquotes are
             used, the replacement string is a command to execute
             whose output will be used as the actual  replacement
             text.   If  no  string is specified via the =~ or !~
             operator, the $_ string is  searched  and  modified.
             (The string specified with =~ must be a scalar vari-
             able, an array element, or an assignment to  one  of
             those, i.e. an lvalue.)  If the pattern contains a $
             that looks like a variable rather  than  an  end-of-
             string  test, the variable will be interpolated into
             the pattern at run-time.  If you only want the  pat-
             tern  compiled  once  the first time the variable is
             interpolated, add an "o" at the end.  If the PATTERN
             evaluates to a null string, the most recent success-
             ful regular expression is used  instead.   See  also
             the section on regular expressions.  Examples:

                 s/\bgreen\b/mauve/g;      # don't change wintergreen

                 $path =~ s|/usr/bin|/usr/local/bin|;

                 s/Login: $foo/Login: $bar/; # run-time pattern

                 ($foo = $bar) =~ s/bar/foo/;

                 $_ = 'abc123xyz';
                 s/\d+/$&*2/e;        # yields 'abc246xyz'
                 s/\d+/sprintf("%5d",$&)/e;     # yields 'abc  246xyz'
                 s/\w/$& x 2/eg;      # yields 'aabbcc  224466xxyyzz'

                 s/([^^ ]*) *([^^ ]*)/$2 $1/;     # reverse 1st two fields

             (Note the use of $ instead of \ in the last example.
             See section on regular expressions.)

'
'----------------------------------------------------------------------- scalar
'
!short: scalar           Interpret EXPR in a scalar context and return value

     scalar(EXPR)

             Forces EXPR to be interpreted in  a  scalar  context
             and returns the value of EXPR.

'
'------------------------------------------------------------------------- seek
'
!short: seek             Position file pointer to specified offset

     seek(FILEHANDLE,POSITION,WHENCE)

             Randomly positions the file pointer for  FILEHANDLE,
             just like the fseek() call of stdio.  FILEHANDLE may
             be an expression whose value gives the name  of  the
             filehandle.  Returns 1 upon success, 0 otherwise.

'
'---------------------------------------------------------------------- seekdir
'
!short: seekdir          Position file pointer for directories

     seekdir(DIRHANDLE,POS)

             Sets the current position for the readdir()  routine
             on  DIRHANDLE.   POS  must  be  a  value returned by
             telldir().  Has  the  same  caveats  about  possible
             directory  compaction  as  the  corresponding system
             library routine.

!seealso: closedir opendir readdir rewinddir telldir
'
'----------------------------------------------------------------------- select
'
!short: select           Return/Set file handle for output

     select(FILEHANDLE)

     select

             Returns the currently selected filehandle.  Sets the
             current default filehandle for output, if FILEHANDLE
             is supplied.  This has two effects: first,  a  write
             or a print without a filehandle will default to this
             FILEHANDLE.  Second, references to variables related
             to  output  will  refer to this output channel.  For
             example, if you have to set the top of  form  format
             for  more  than one output channel, you might do the
             following:

                  select(REPORT1);
                  $^^ = 'report1_top';
                  select(REPORT2);
                  $^^ = 'report2_top';

             FILEHANDLE may be an expression  whose  value  gives
             the name of the actual filehandle.  Thus:

                  $oldfh = select(STDERR); $| = 1; select($oldfh);

'
'------------------------------------------------------------------------ shift
'
!short: shift            Shift first element of array off and return it

     shift(ARRAY)

     shift ARRAY

     shift

             Shifts the first value of the array off and  returns
             it,  shortening the array by 1 and moving everything
             down.  If  there  are  no  elements  in  the  array,
             returns  the  undefined value.  If ARRAY is omitted,
             shifts the @ARGV array in the main program, and  the
             @_  array in subroutines.  (This is determined lexi-
             cally.)   See  also  unshift(),  push()  and  pop().
             Shift()  and unshift() do the same thing to the left
             end of an array that push()  and  pop()  do  to  the
             right end.

'
'-------------------------------------------------------------------------- sin
'
!short: sin              Return sine of EXPR in radians

     sin(EXPR)

     sin EXPR

             Returns the sine of EXPR (expressed in radians).  If
             EXPR is omitted, returns sine of $_.

!seealso: cos atan2
'
'------------------------------------------------------------------------ sleep
'
!short: sleep            Pause to specified number of seconds

     sleep(EXPR)

     sleep EXPR

     sleep   Causes the script to sleep for EXPR seconds, or for-
             ever  if no EXPR.  May be interrupted by sending the
             process a SIGALARM.  Pretty worthless on MS-DOS,  as
             it just wastes the number of seconds requested.

'
'----------------------------------------------------------------------- socket
'
!short: socket           Open a socket of the specified type

     socket(SOCKET,DOMAIN,TYPE,PROTOCOL)

             Opens a socket of the specified kind and attaches it
             to  filehandle  SOCKET.  call of the same name.  You
             may need to run h2ph  on  sys/socket.h  to  get  the
             proper  values handy in a perl library file.  Return
             true if successful.  See the example in the  section
             on  Interprocess  Communication. Sockets are not yet
             supported on MS-DOS.

'
'------------------------------------------------------------------- socketpair
'
!short: socketpair       Create an unnamed pair of sockets in specified domain

     socketpair(SOCKET1,SOCKET2,DOMAIN,TYPE,PROTOCOL)

             Creates an unnamed pair of sockets in the  specified
             domain,  of the specified type.  Sockets are not yet
             supported on MS-DOS.

'
'------------------------------------------------------------------------- sort
'
!short: sort             Sort a LIST and return the sorted array value

     sort(SUBROUTINE LIST)

     sort(LIST)

     sort SUBROUTINE LIST

     sort LIST

             Sorts the LIST and returns the sorted  array  value.
             Nonexistent  values  of arrays are stripped out.  If
             SUBROUTINE is omitted, sorts in standard string com-
             parison  order.   If  SUBROUTINE is specified, gives
             the name of a subroutine  that  returns  an  integer
             less than, equal to, or greater than 0, depending on
             how the elements of the array  are  to  be  ordered.
             (The  <=>  and cmp operators are extremely useful in
             such routines.)  In the interests of efficiency  the
             normal  calling  code  for  subroutines is bypassed,
             with the following effects: the subroutine  may  not
             be  a  recursive subroutine, and the two elements to
             be compared are passed into the subroutine  not  via
             @_  but  as $a and $b (see example below).  They are
             passed by reference so don't modify $a and $b.  SUB-
             ROUTINE may be a scalar variable name, in which case
             the value provides the name  of  the  subroutine  to
             use.  Examples:

                  sub byage {
                      $age{$a} <=> $age{$b};    # presuming integers
                  }
                  @sortedclass = sort byage @class;

                  sub reverse { $b cmp $a; }
                  @harry = ('dog','cat','x','Cain','Abel');
                  @george = ('gone','chased','yz','Punished','Axed');
                  print sort @harry;
                       # prints AbelCaincatdogx
                  print sort reverse @harry;
                       # prints xdogcatCainAbel
                  print sort @george, 'to', @harry;
                       # prints AbelAxedCainPunishedcatchaseddoggonetoxyz

!seealso: reverse
'
'----------------------------------------------------------------------- splice
'
!short: splice           Remove elements of array and replace with LIST

     splice(ARRAY,OFFSET,LENGTH,LIST)

     splice(ARRAY,OFFSET,LENGTH)

     splice(ARRAY,OFFSET)

             Removes the elements designated by OFFSET and LENGTH
             from  an  array, and replaces them with the elements
             of LIST, if any.  Returns the elements removed  from
             the array.  The array grows or shrinks as necessary.
             If LENGTH is omitted, removes everything from OFFSET
             onward.   The following equivalencies hold (assuming
             $[ == 0):

                  push(@a,$x,$y)                splice(@a,$#a+1,0,$x,$y)
                  pop(@a)                       splice(@a,-1)
                  shift(@a)                     splice(@a,0,1)
                  unshift(@a,$x,$y)             splice(@a,0,0,$x,$y)
                  $a[$x] = $y                   splice(@a,$x,1,$y);

             Example, assuming array lengths are passed before arrays:

                  sub aeq { # compare two array values
                       local(@a) = splice(@_,0,shift);
                       local(@b) = splice(@_,0,shift);
                       return 0 unless @a == @b;     # same len?
                       while (@a) {
                           return 0 if pop(@a) ne pop(@b);
                       }
                       return 1;
                  }
                  if (&aeq($len,@foo[1..$len],0+@bar,@bar)) { ... }

'
'------------------------------------------------------------------------ split
'
!short: split            Split a string into an array of strings

     split(/PATTERN/,EXPR,LIMIT)

     split(/PATTERN/,EXPR)

     split(/PATTERN/)

     split   Splits a  string  into  an  array  of  strings,  and
             returns  it.   (If  not in an array context, returns
             the number of fields found and splits  into  the  @_
             array.   (In  an  array  context,  you can force the
             split into @_ by using ?? as the pattern delimiters,
             but  it still returns the array value.))  If EXPR is
             omitted, splits the $_ string.  If PATTERN  is  also
             omitted,  splits  on  whitespace (/[ \t\n]+/).  Any-
             thing matching PATTERN is taken to  be  a  delimiter
             separating the fields.  (Note that the delimiter may
             be longer than one character.)  If LIMIT  is  speci-
             fied,  splits  into  no  more  than that many fields
             (though it may  split  into  fewer).   If  LIMIT  is
             unspecified,   trailing  null  fields  are  stripped
             (which potential users of pop()  would  do  well  to
             remember).   A pattern matching the null string (not
             to be confused with a null pattern //, which is just
             one  member  of  the set of patterns matching a null
             string) will split the value of EXPR  into  separate
             characters  at  each point it matches that way.  For
             example:

                  print join(':', split(/ */, 'hi there'));

             produces the output 'h:i:t:h:e:r:e'.

             The LIMIT parameter can be used to partially split a
             line

                  ($login, $passwd, $remainder) = split(/:/, $_, 3);

             (When assigning to a list, if LIMIT is omitted, perl
             supplies a LIMIT one larger than the number of vari-
             ables in the list, to avoid unnecessary  work.   For
             the  list  above LIMIT would have been 4 by default.
             In time critical applications it behooves you not to
             split into more fields than you really need.)

             If  the  PATTERN  contains  parentheses,  additional
             array  elements  are created from each matching sub-
             string in the delimiter.

                  split(/([,-])/,"1-10,20");

             produces the array value

                  (1,'-',10,',',20)

             The  pattern  /PATTERN/  may  be  replaced  with  an
             expression to specify patterns that vary at runtime.
             (To  do   runtime   compilation   only   once,   use
             /$variable/o.)   As  a  special  case,  specifying a
             space (' ') will split on white space just as  split
             with no arguments does, but leading white space does
             NOT produce a null first  field.   Thus,  split(' ')
             can  be  used  to  emulate  awk's  default behavior,
             whereas split(/ /) will give you as many  null  ini-
             tial fields as there are leading spaces.

             Example:

                  open(passwd, '/etc/passwd');
                  while (<passwd>) {
                       ($login, $passwd, $uid, $gid, $gcos, $home, $shell)
                            = split(/:/);
                       ...
                  }

             (Note that $shell above will still have a newline on
             it.  See chop().)  See also join.

'
'---------------------------------------------------------------------- sprintf
'
!short: sprintf          Formatted printing to a string

     sprintf(FORMAT,LIST)

             Returns a string formatted by the usual printf  con-
             ventions.  The * character is not supported.

!seealso: printf print
'
'------------------------------------------------------------------------- sqrt
'
!short: sqrt             Return square root of EXPR

     sqrt(EXPR)

     sqrt EXPR

             Return the square root of EXPR.  If EXPR is omitted,
             returns square root of $_.

'
'------------------------------------------------------------------------ srand
'
!short: srand            Set random number seed

     srand(EXPR)

     srand EXPR
             Sets the random number seed for the  rand  operator.
             If EXPR is omitted, does srand(time).

!seealso: rand
'
'------------------------------------------------------------------------- stat
'
!short: stat             Return statistics for a file

     stat(FILEHANDLE)

     stat FILEHANDLE

     stat(EXPR)

     stat SCALARVARIABLE

             Returns a 13-element array giving the statistics for
             a  file,  either  the file opened via FILEHANDLE, or
             named by EXPR.  Typically used as follows:

                 ($dev,$ino,$mode,$nlink,$uid,$gid,$rdev,$size,
                    $atime,$mtime,$ctime,$blksize,$blocks)
                        = stat($filename);

             If stat is passed the special filehandle  consisting
             of  an  underline,  no stat is done, but the current
             contents of the stat structure from the last stat or
             filetest are returned.  (Note that on MS-DOS several
             of these values are spurious.) Example:

                  if (-x $file && (($d) = stat(_)) && $d < 0) {
                       print "$file is executable NFS file\n";
                  }

             (This only works on machines for  which  the  device
             number is negative under NFS.)

!seealso: lstat
'
'------------------------------------------------------------------------ study
'
!short: study            Study SCALAR in antisipation of doing many matches

     study(SCALAR)

     study SCALAR

     study   Takes extra time to study SCALAR ($_ if unspecified)
             in anticipation of doing many pattern matches on the
             string before it is next modified.  This may or  may
             not save time, depending on the nature and number of
             patterns you are searching on, and on the  distribu-
             tion  of  character  frequencies in the string to be
             searched--you probably want to compare runtimes with
             and  without  it  to  see  which runs faster.  Those
             loops which scan for  many  short  constant  strings
             (including  the  constant parts of more complex pat-
             terns) will benefit most.  You  may  have  only  one
             study  active  at  a  time--if you study a different
             scalar the first is  "unstudied".   (The  way  study
             works  is  this: a linked list of every character in
             the string to be searched is made, so we  know,  for
             example,  where  all  the  'k' characters are.  From
             each  search  string,  the   rarest   character   is
             selected, based on some static frequency tables con-
             structed from some  C  programs  and  English  text.
             Only those places that contain this "rarest" charac-
             ter are examined.)

             For example, here is a loop which inserts index pro-
             ducing  entries before any line containing a certain
             pattern:

                  while (<>) {
                       study;
                       print ".IX foo\n" if /\bfoo\b/;
                       print ".IX bar\n" if /\bbar\b/;
                       print ".IX blurfl\n" if /\bblurfl\b/;
                       ...
                       print;
                  }

             In searching for /\bfoo\b/, only those locations  in
             $_  that  contain 'f' will be looked at, because 'f'
             is rarer than 'o'.  In general, this is  a  big  win
             except  in pathological cases.  The only question is
             whether it saves you more time than it took to build
             the linked list in the first place.

             Note that if you have to look for strings  that  you
             don't  know  till  runtime,  you can build an entire
             loop as a string and eval that to avoid  recompiling
             all  your  patterns  all  the  time.   Together with
             undefining $/ to input entire files as  one  record,
             this can be very fast, often faster than specialized
             programs like fgrep.  The following scans a list  of
             files  (@files)  for  a  list of words (@words), and
             prints out the names of those files that  contain  a
             match:

                  $search = 'while (<>) { study;';
                  foreach $word (@words) {
                      $search .= "++\$seen{\$ARGV} if /\b$word\b/;\n";
                  }
                  $search .= "}";
                  @ARGV = @files;
                  undef $/;
                  eval $search;       # this screams
                  $/ = "\n";          # put back to normal input delim
                  foreach $file (sort keys(%seen)) {
                      print $file, "\n";
                  }

'
'----------------------------------------------------------------------- substr
'
!short: substr           Extract substring of EXPR and return it

     substr(EXPR,OFFSET,LEN)

     substr(EXPR,OFFSET)

             Extracts a substring out of  EXPR  and  returns  it.
             First  character  is at offset 0, or whatever you've
             set $[ to.  If OFFSET is negative, starts  that  far
             from  the  end  of  the  string.  If LEN is omitted,
             returns everything to the end of  the  string.   You
             can use the substr() function as an lvalue, in which
             case EXPR must be an lvalue.  If  you  assign  some-
             thing  shorter than LEN, the string will shrink, and
             if you assign something longer than LEN, the  string
             will grow to accommodate it.  To keep the string the
             same length you may need to pad or chop  your  value
             using sprintf().

!seealso: chop
'
'---------------------------------------------------------------------- symlink
'
!short: symlink          Create new file symbolically linked to old file

     symlink(OLDFILE,NEWFILE)

             Creates a new filename symbolically  linked  to  the
             old  filename.   (Note  that MS-DOS does not support
             symbolic links.)

'
'---------------------------------------------------------------------- syscall
'
!short: syscall          Call a system function with arguments

     syscall(LIST)

     syscall LIST

             Calls the system call specified as the first element
             of the list, passing the remaining elements as argu-
             ments to the system call.   If  unimplemented,  pro-
             duces  a fatal error.  The arguments are interpreted
             as follows: if a  given  argument  is  numeric,  the
             argument  is  passed as an int.  If not, the pointer
             to the string value is passed.  You are  responsible
             to make sure a string is pre-extended long enough to
             receive any result that  might  be  written  into  a
             string.   If your integer arguments are not literals
             and have never been interpreted in  a  numeric  con-
             text, you may need to add 0 to them to force them to
             look like numbers.

                  require 'syscall.ph';         # may need to run h2ph
                  syscall(&SYS_write, fileno(STDOUT), "hi there\n", 9);

'
'---------------------------------------------------------------------- sysread
'
!short: sysread          Read data from file using system call 'read'

     sysread(FILEHANDLE,SCALAR,LENGTH,OFFSET)

     sysread(FILEHANDLE,SCALAR,LENGTH)

             Attempts to read LENGTH bytes of data into  variable
             SCALAR from the specified FILEHANDLE, using the sys-
             tem call read(2).  It bypasses stdio, so mixing this
             with  other  kinds  of  reads  may  cause confusion.
             Returns the number of bytes actually read, or  undef
             if  there  was  an  error.   SCALAR will be grown or
             shrunk to the length actually read.  An  OFFSET  may
             be  specified  to  place the read data at some other
             place than the beginning of the string.

'
'----------------------------------------------------------------------- system
'
!short: system           Send a command to the system to be executed

     system(LIST)

     system LIST

             Does exactly the same thing as  "exec  LIST"  except
             that  a  fork  is done first, and the parent process
             waits for the child process to complete.  Note  that
             argument  processing  varies depending on the number
             of arguments.  The return value is the  exit  status
             of  the  program as returned by the wait() call.  To
             get the actual exit value divide by 256.   See  also
             exec.

             On MS-DOS, this is implemented using the spawn  sys-
             tem call.

!seealso: exec
'
'--------------------------------------------------------------------- syswrite
'
!short: syswrite         Write data to file using system call 'write'

     syswrite(FILEHANDLE,SCALAR,LENGTH,OFFSET)

     syswrite(FILEHANDLE,SCALAR,LENGTH)

             Attempts to write LENGTH bytes of data from variable
             SCALAR to the specified FILEHANDLE, using the system
             call write(2).  It bypasses stdio,  so  mixing  this
             with prints may cause confusion.  Returns the number
             of bytes actually written, or undef if there was  an
             error.  An OFFSET may be specified to place the read
             data at some other place than the beginning  of  the
             string.

'
'------------------------------------------------------------------------- tell
'
!short: tell             Return current file position for FILEHANDLE

     tell(FILEHANDLE)

     tell FILEHANDLE

     tell    Returns the current file  position  for  FILEHANDLE.
             FILEHANDLE  may  be  an expression whose value gives
             the name of the actual filehandle.  If FILEHANDLE is
             omitted, assumes the file last read.

'
'---------------------------------------------------------------------- telldir
'
!short: telldir          Return current position of readdir() for DIRHANDLE

     telldir(DIRHANDLE)

     telldir DIRHANDLE

             Returns the current position of the  readdir()  rou-
             tines on DIRHANDLE.  Value may be given to seekdir()
             to access a particular location in a directory.  Has
             the same caveats about possible directory compaction
             as the corresponding system library routine.

!seealso: closedir opendir readdir rewinddir seekdir
'
'------------------------------------------------------------------------- time
'
!short: time             Return num. of non-leap sec. since 00:00:00 1 Jan 1970

     time    Returns  the  number  of  non-leap   seconds   since
             00:00:00 UTC, January 1, 1970.  Suitable for feeding
             to gmtime() and localtime().

'
'------------------------------------------------------------------------ times
'
!short: times            Return arrays with user and system times processes

     times   Returns a four-element array  giving  the  user  and
             system  times,  in seconds, for this process and the
             children of this process.  Not implmented on MS-DOS.

'
'------------------------------------------------------------- tr/SRCH/REPL/cds
'
!short: tr/SRCH/REPL/cds Translate characters from one set into another

     tr/SEARCHLIST/REPLACEMENTLIST/cds

     y/SEARCHLIST/REPLACEMENTLIST/cds

             Translates all occurrences of the  characters  found
             in  the search list with the corresponding character
             in the replacement list.  It returns the  number  of
             characters  replaced  or  deleted.   If no string is
             specified via the =~ or !~ operator, the  $_  string
             is  translated.   (The string specified with =~ must
             be a  scalar  variable,  an  array  element,  or  an
             assignment  to  one  of those, i.e. an lvalue.)  For
             sed devotees, y is provided as a synonym for tr.

             If the c modifier is specified, the SEARCHLIST char-
             acter  set  is  complemented.   If the d modifier is
             specified, any characters  specified  by  SEARCHLIST
             that  are  not found in REPLACEMENTLIST are deleted.
             (Note that this is slightly more flexible  than  the
             behavior  of some tr programs, which delete anything
             they find in the  SEARCHLIST,  period.)   If  the  s
             modifier  is specified, sequences of characters that
             were translated to the same character  are  squashed
             down to 1 instance of the character.

             If the d modifier was used, the  REPLACEMENTLIST  is
             always interpreted exactly as specified.  Otherwise,
             if the REPLACEMENTLIST is  shorter  than  the  SEAR-
             CHLIST, the final character is replicated till it is
             long enough.  If the REPLACEMENTLIST  is  null,  the
             SEARCHLIST is replicated.  This latter is useful for
             counting characters in a  class,  or  for  squashing
             character sequences in a class.

             Examples:

                 $ARGV[1] =~ y/A-Z/a-z/;   # canonicalize to lower case

                 $cnt = tr/*/*/;           # count the stars in $_

                 $cnt = tr/0-9//;          # count the digits in $_

                 tr/a-zA-Z//s;             # bookkeeper -> bokeper

                 ($HOST = $host) =~ tr/a-z/A-Z/;

                 y/a-zA-Z/ /cs;            # change non-alphas to single space

                 tr/\200-\377/\0-\177/;    # delete 8th bit

'
'--------------------------------------------------------------------- truncate
'
!short: truncate         Truncate an open file to specified length

     truncate(FILEHANDLE,LENGTH)

     truncate(EXPR,LENGTH)

             Truncates the file opened on FILEHANDLE, or named by
             EXPR,  to  the  specified  length.  Produces a fatal
             error if truncate isn't implemented on your system.

'
'------------------------------------------------------------------------ umask
'
!short: umask            Set the umask for the process and return old one

     umask(EXPR)

     umask EXPR

     umask   Sets the umask for the process and returns  the  old
             one.  Not supported on MS-DOS.

'
'------------------------------------------------------------------------ undef
'
!short: undef            Undefines a value

     undef(EXPR)

     undef EXPR

     undef   Undefines the  value  of  EXPR,  which  must  be  an
             lvalue.   Use  only  on  a  scalar  value, an entire
             array, or a subroutine name (using &).  (Undef  will
             probably  not  do what you expect on most predefined
             variables or dbm array values.)  Always returns  the
             undefined  value.   You  can omit the EXPR, in which
             case nothing is undefined,  but  you  still  get  an
             undefined value that you could, for instance, return
             from a subroutine.  Examples:

                  undef $foo;
                  undef $bar{'blurfl'};
                  undef @ary;
                  undef %assoc;
                  undef &mysub;
                  return (wantarray ? () : undef) if $they_blew_it;

'
'----------------------------------------------------------------------- unlink
'
!short: unlink           Deletes a list of files

     unlink(LIST)

     unlink LIST

             Deletes a list of  files.   Returns  the  number  of
             files  successfully  deleted.   (MS-DOS users should
             note that open files cannot be deleted.)

                  $cnt = unlink 'a', 'b', 'c';
                  unlink @goners;
                  unlink <*.bak>;

             Note: unlink will not delete directories unless  you
             are  superuser  and the -U flag is supplied to perl.
             Even if these conditions are  met,  be  warned  that
             unlinking  a  directory  can  inflict damage on your
             filesystem.  Use rmdir instead.

'
'----------------------------------------------------------------------- unpack
'
!short: unpack           Unpack binary results of pack

     unpack(TEMPLATE,EXPR)

             Unpack does the reverse of pack: it takes  a  string
             representing  a structure and expands it out into an
             array value,  returning  the  array  value.   (In  a
             scalar  context,  it  merely returns the first value
             produced.)  The TEMPLATE has the same format  as  in
             the  pack  function.   Here's a subroutine that does
             substring:

                  sub substr {
                       local($what,$where,$howmuch) = @_;
                       unpack("x$where a$howmuch", $what);
                  }

             and then there's

                  sub ord { unpack("c",$_[0]); }

             In addition, you may prefix a field with a %<number>
             to indicate that you want a <number>-bit checksum of
             the items instead of the items themselves.   Default
             is  a  16-bit  checksum.  For example, the following
             computes the same number as the System  V  sum  pro-
             gram:

                  while (<>) {
                      $checksum += unpack("%16C*", $_);
                  }
                  $checksum %= 65536;

!seealso: pack
'
'--------------------------------------------------------------------- unshifht
'
!short: unshift          Prepend a list to the front of an array

     unshift(ARRAY,LIST)

             Does the opposite of a shift.  Or the opposite of  a
             push,  depending  on  how  you look at it.  Prepends
             list to the front of  the  array,  and  returns  the
             number of elements in the new array.

                  unshift(ARGV, '-e') unless $ARGV[0] =~ /^^-/;

!seealso: push pop shift
'
'------------------------------------------------------------------------ utime
'
!short: utime            Change access and modification time of files

     utime(LIST)

     utime LIST
             Changes the access and modification  times  on  each
             file  of a list of files.  The first two elements of
             the list must be the NUMERICAL access and  modifica-
             tion  times,  in that order.  (On MS-DOS, the access
             time field is ignored.)  Returns the number of files
             successfully  changed.   The inode modification time
             of each file is set to the current time.  Example of
             a "touch" command:

                  #!/usr/bin/perl
                  $now = time;
                  utime $now, $now, @ARGV;

'
'----------------------------------------------------------------------- values
'
!short: values           Return an array of values of associative arrays

     values(ASSOC_ARRAY)

     values ASSOC_ARRAY

             Returns a normal array consisting of all the  values
             of  the  named  associative  array.   The values are
             returned in an apparently random order,  but  it  is
             the  same order as either the keys() or each() func-
             tion would produce on  the  same  array.   See  also
             keys() and each().

'
'-------------------------------------------------------------------------- vec
'
!short: vec              Get bits from an array of unsigned ints

     vec(EXPR,OFFSET,BITS)

             Treats a string as a vector  of  unsigned  integers,
             and  returns  the  value  of the bitfield specified.
             May also be assigned to.  BITS must be  a  power  of
             two from 1 to 32.

             Vectors created with vec() can also  be  manipulated
             with  the  logical  operators |, & and ^^, which will
             assume a bit vector operation is desired  when  both
             operands  are  strings.   This interpretation is not
             enabled unless there is at least one vec()  in  your
             program, to protect older programs.

             To transform a bit vector into a string or array  of
             0's and 1's, use these:

                  $bits = unpack("b*", $vector);
                  @bits = split(//, unpack("b*", $vector));

             If you know the exact length in bits, it can be used
             in place of the *.

'
'------------------------------------------------------------------------- wait
'
!short: wait             Wait for a child process to terminate

     wait
             Waits for a child process to terminate  and  returns
             the  pid of the deceased process, or -1 if there are
             no child processes.  The status is returned in $?.

'
'---------------------------------------------------------------------- waitpid
'
!short: waitpid          Wait for a particular child process to terminate

     waitpid(PID,FLAGS)

             Waits for a particular child  process  to  terminate
             and  returns  the pid of the deceased process, or -1
             if there is no such child process.  Not supported on
             MS-DOS.

'
'-------------------------------------------------------------------- wantarray
'
!short: wantarray        Return true of curr. subroutine is looking for array

     wantarray

             Returns true if the context of the currently execut-
             ing  subroutine  is  looking  for  an  array  value.
             Returns false  if  the  context  is  looking  for  a
             scalar.

                  return wantarray ? () : undef;

'
'------------------------------------------------------------------------- warn
'
!short: warn             Produce a message to STDERR

     warn(LIST)

     warn LIST

             Produces a message on STDERR just  like  "die",  but
             doesn't exit.

!seealso: die
'
'------------------------------------------------------------------------ write
'
!short: write            Write formatted record to file

     write(FILEHANDLE)

     write(EXPR)

     write

             Writes a formatted record (possibly  multi-line)  to
             the specified file, using the format associated with
             that file.  By default the format for a file is  the
             one  having the same name is the filehandle, but the
             format for the current output channel  (see  select)
             may  be  set explicitly by assigning the name of the
             format to the $~ variable.

             Top of form processing is handled automatically:  if
             there  is  insufficient room on the current page for
             the  formatted  record,  the  page  is  advanced  by
             writing a form feed, a special top-of-page format is
             used to format the new page  header,  and  then  the
             record  is written.  By default the top-of-page for-
             mat is "top", but it may be set  to  the  format  of
             your  choice  by  assigning the name to the $^^ vari-
             able.  The number of lines remaining on the  current
             page  is  in  variable  $-, which can be set to 0 to
             force a new page.

             If FILEHANDLE is unspecified,  output  goes  to  the
             current  default output channel, which starts out as
             STDOUT but may be changed by  the  select  operator.
             If the FILEHANDLE is an EXPR, then the expression is
             evaluated and the resulting string is used  to  look
             up the name of the FILEHANDLE at run time.  For more
             on formats, see the section on formats later on.

             Note that write is NOT the opposite of read.

!short: getpwnam                                                         ^BUNIX^b

     getpwnam(NAME)

!short: getgrnam                                                         ^BUNIX^b

     getgrnam(NAME)

!short: gethostbyname                                                    ^BUNIX^b

     gethostbyname(NAME)

!short: getnetbyname                                                     ^BUNIX^b

     getnetbyname(NAME)

!short: getprotobyname                                                   ^BUNIX^b

     getprotobyname(NAME)

!short: getpwuid                                                         ^BUNIX^b

     getpwuid(UID)

!short: getgrgid                                                         ^BUNIX^b

     getgrgid(GID)

!short: getservbyname                                                    ^BUNIX^b

     getservbyname(NAME,PROTO)

!short: gethostbyaddr                                                    ^BUNIX^b

     gethostbyaddr(ADDR,ADDRTYPE)

!short: getnetbyaddr                                                     ^BUNIX^b

     getnetbyaddr(ADDR,ADDRTYPE)

!short: getprotobynumber                                                 ^BUNIX^b

     getprotobynumber(NUMBER)

!short: getservbyport                                                    ^BUNIX^b

     getservbyport(PORT,PROTO)

!short: getpwent                                                         ^BUNIX^b

     getpwent

!short: getgrent                                                         ^BUNIX^b

     getgrent

!short: gethostent                                                       ^BUNIX^b

     gethostent

!short: getnetent                                                        ^BUNIX^b

     getnetent

!short: getprotoent                                                      ^BUNIX^b

     getprotoent

!short: getservent                                                       ^BUNIX^b

     getservent

!short: setpwent                                                         ^BUNIX^b

     setpwent

!short: setgrent                                                         ^BUNIX^b

     setgrent

!short: sethostent                                                       ^BUNIX^b

     sethostent(STAYOPEN)

!short: setnetent                                                        ^BUNIX^b

     setnetent(STAYOPEN)

!short: setprotoent                                                      ^BUNIX^b

     setprotoent(STAYOPEN)

!short: setservent                                                       ^BUNIX^b

     setservent(STAYOPEN)

!short: endpwent                                                         ^BUNIX^b

     endpwent

!short: endgrent                                                         ^BUNIX^b

     endgrent

!short: endhostent                                                       ^BUNIX^b

     endhostent

!short: endnetent                                                        ^BUNIX^b

     endnetent

!short: endprotoent                                                      ^BUNIX^b

     endprotoent

!short: endservent                                                       ^BUNIX^b

     endservent

             These routines perform the same functions  as  their
             counterparts  in  the system library.  None are sup-
             ported on MS-DOS.

!short: msgctl                                                           ^BUNIX^b

     msgctl(ID,CMD,ARG)

!short: msgget                                                           ^BUNIX^b

     msgget(KEY,FLAGS)

!short: msgsnd                                                           ^BUNIX^b

     msgsnd(ID,MSG,FLAGS)

!short: msgrcv                                                           ^BUNIX^b

     msgrcv(ID,VAR,SIZE,TYPE,FLAGS)

             These System V  inter-process  communications  func-
             tions are not available on MS-DOS.

!short: semctl                                                           ^BUNIX^b

     semctl(ID,SEMNUM,CMD,ARG)

!short: semget                                                           ^BUNIX^b

     semget(KEY,NSEMS,SIZE,FLAGS)

!short: semop                                                            ^BUNIX^b

     semop(KEY,OPSTRING)

             These System V  inter-process  communications  func-
             tions are not available on MS-DOS.

!short: setpgrp                                                          ^BUNIX^b

     setpgrp(PID,PGRP)

             Sets the current process  group  for  the  specified
             PID,  0  for  the current process.  Not supported on
             MS-DOS.

!short: setpriority                                                      ^BUNIX^b

     setpriority(WHICH,WHO,PRIORITY)

             Sets the current priority for a process,  a  process
             group, or a user.  Not supported on MS-DOS.

!short: setsockopt                                                       ^BUNIX^b

     setsockopt(SOCKET,LEVEL,OPTNAME,OPTVAL)

             Sets the socket option requested.  Sockets  are  not
             yet supported on MS-DOS.

!short: select                                                           ^BUNIX^b

     select(RBITS,WBITS,EBITS,TIMEOUT)

             This calls the Unix select system call, which is not
             implemented on MS-DOS.

             The select system call is not implemented on MS-DOS.

!short: shmctl                                                           ^BUNIX^b

     shmctl(ID,CMD,ARG)

!short: shmget                                                           ^BUNIX^b

     shmget(KEY,SIZE,FLAGS)

!short: shmread                                                          ^BUNIX^b

     shmread(ID,VAR,POS,SIZE)

!short: shmwrite                                                         ^BUNIX^b

     shmwrite(ID,STRING,POS,SIZE)

             These System V  inter-process  communications  func-
             tions are not available on MS-DOS.

