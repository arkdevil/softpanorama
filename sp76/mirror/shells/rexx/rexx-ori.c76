 
This chapter introduces "The REXX Handbook" (Goldberg and
Smith, 1992, ISBN 0-07-023682-8), published by McGraw-Hill
and reproduced by permission.
 
Copyright (c) McGraw-Hill Inc, 1992.  All rights reserved.
------------------------------------------------------------
 
REXX ORIGINS, by Mike Cowlishaw
===============================
 
In  this  chapter you'll find a little of the history of the
REXX programming language, how and why it was  written,  and
its main advantages (and disadvantages).
 
 
SOME HISTORY
------------
During the 1970s and 1980s, the VM/370 (Virtual Machine/370)
operating  system  and  its derivatives were the interactive
development environment of choice for most of IBM  and  many
of  its  customers.   This operating system borrowed many of
its features from earlier systems, including the concept  of
controlling the system by commands (character strings, typed
by  the  user, which control and direct the operating system
and its applications).  VM's command language, especially in
the CMS (Conversational Monitor System) component, is one of
the simplest and most readable ever devised.
 
Like other command-driven operating  systems,  CMS  provided
the  ability to "wrap up" commands with a little programming
logic; these simple programs  were  written  in  a  language
called  EXEC.  This allowed enhancements and new commands to
be written rapidly and much more easily than in  the  native
assembler language used for writing low-level commands.
 
In  the  1970s, C. J. Stephenson and others at the IBM T. J.
Watson Research Center realized that,  if  applied  consist-
ently,  this  concept  of a command programming language was
extraordinarily powerful: a single  language  could  provide
the  extension  language  - or "macro" language - for a wide
variety of applications.  They took the  EXEC  language  and
generalized  and improved it for this enhanced role; the new
language was called EXEC 2.
 
EXEC 2 proved the concept of a general macro language.    It
was used mostly for writing system commands and macros for a
wide  variety of editors.  Its interpreter was, and probably
still  is,  the  finest  example  of  efficient  and  robust
System/370 assembler code.
 
However,  EXEC 2  (like its predecessor and most other macro
languages of the 1970s and even early  1980s)  assumed  that
macro  programs  would  be  mostly commands, with relatively
little "glue" of logic and variables.   Accordingly, it  was
designed  to allow commands (literal strings, usually in up-
per case) to be written plainly, whereas  language  keywords
and  variables  were identified by a prefix of an ampersand.
A command, followed by a test of its result, might look like
this:
 
  COPYFILE &FNAME &FTYPE &FMODE = BACKUP =
  &IF &RC GT 0 &TYPE Copy failed with return code &RC
 
This  style, while adequate for simple commands, proved cum-
bersome for the large and complex programs and  macros  that
were  soon  being  written in EXEC 2.  It became clear to me
that a new language was needed, one based on the more  clas-
sical  syntax  and semantics used by languages in the tradi-
tion of Algol, Pascal, and PL/I, yet including  the  command
and  string programming facilities that EXEC 2 had proven to
be so effective and powerful.
 
This new language, initially called REX  (because  the  name
sounded  nice)  was  very  much driven by the desire to make
programming easy.   It borrows most  of  its  features  from
other  languages, especially PL/I and EXEC 2, but these fea-
tures are modified or expressed in ways that make them  easy
to  use  (and not necessarily easy to implement!).  The code
fragment shown above would  look  quite  different;  literal
strings are quoted, but language keywords and variable names
are not obfuscated by special characters:
 
  'COPYFILE' fname ftype fmode '= BACKUP ='
  if rc>0 then say 'Copy failed with return code' rc
 
This  difference  between  the  two  languages  becomes more
striking as the complexity of the program increases.
 
The first specification for the language is dated  29  March
1979.    This was written before any implementation was even
designed, and it was circulated to a number  of  people  for
comment:  this  began  the tradition of documentation before
implementation that characterized the development  of  REXX.
This  first  specification  included  three  sample programs
written in REXX to show how the language would  look;  those
programs  would  seem  familiar to today's REXX programmers,
although some details have changed.
 
My first implementation of REXX was  made  freely  available
over  IBM's internal network in late 1979 and rapidly became
popular.  The electronic mail network made it easy for  peo-
ple to exchange ideas and make suggestions for improvements.
Also, because the language was limited to one (large) organ-
ization,  it  was possible to make some rather large changes
in response to these suggestions.
 
As a result of this direct feedback,  the  language  quickly
evolved  to  meet the needs of its users through a number of
releases over the next few years.  By 1982 it had become es-
sentially the language known today; its name gained  an  "X"
to  avoid  any confusion with other products, with a rarely-
used expansion to match - "REstructured eXtended  eXecutor".
REXX  was  included  in the third release of IBM's VM/System
Product, shipped in 1983.
 
It was soon discovered that IBM's customers liked  the  lan-
guage  just  as  much as did the "internal" users.  Only two
years  later,  the  first  non-IBM  implementation  (by  the
Mansfield  Software Group, for PC-DOS) became available, and
in 1987 IBM announced that REXX was  to  be  the  Procedures
Language  for  its  Systems  Application Architecture (SAA).
This was followed by implementations for a number of operat-
ing systems.  The first REXX compiler was developed at IBM's
Vienna Laboratory, following research by the IBM Haifa  Sci-
entific  Center, and was delivered to customers in 1989.  By
1990 there was sufficient interest in the language  to  jus-
tify  the  first international REXX Symposium for Developers
and Users, organized by the Stanford Linear Accelerator Cen-
ter in California.
 
1991 sees the beginning of a new phase in REXX's history, as
work starts on preparing an ANSI standard for the language.
 
 
ADVANTAGES
----------
REXX is a programming language which was developed  for  its
users  rather than for the convenience of its implementers -
those who implement its compilers and interpreters.  For ex-
ample, it hides the underlying mechanisms of  hardware  from
the  programmer, except where it is absolutely necessary and
appropriate to expose them.
 
Further, in the first five years of its life the core of the
language was defined and  implemented  by  a  single  person
(based  on  feedback  from  hundreds of early users) and was
constrained by an explicit design philosophy.  This has  led
to a language which is coherent and does what its users want
it to do, and which has a sound base for future evolution.
 
This  design  approach  gives  REXX  several advantages over
older languages:
 
o   REXX programs can be made very readable, since there  is
    a minimum of required punctuation or special characters.
 
o   REXX has only one data type, the character string, so no
    declarations are needed.  This makes writing programs in
    the language both attractive and productive, as the pro-
    grammer  doesn't have to worry about underlying hardware
    representations.  REXX operators are optimized for  com-
    mon  string  operations  such  as concatenation, and are
    supported by powerful parsing and word instructions  and
    functions.
 
o   REXX  arithmetic  is defined as decimal arithmetic, with
    precision selected by the programmer rather than by  the
    underlying  hardware.  Exponential notation is supported
    in both scientific form  and  in  the  multiple-of-three
    form  usual  in  engineering  or financial applications.
    Results of arithmetic operations therefore match  users'
    expectations  far  better  than  results from the binary
    arithmetic used by most other languages.
 
o   REXX puts no inherent limits on the size of strings (in-
    cluding those that represent numbers).  Again, this  re-
    moves   many   of   the   headaches  that  often  plague
    programmers.
 
o   REXX is a small language.   This makes  it  approachable
    and easy to learn.
 
o   REXX  was  specifically designed to be a general-purpose
    extension ("macro" or "glue") language.    That  is,  it
    lets  users  easily tailor and enhance advanced software
    systems.   Like most human written  languages,  REXX  is
    based  on simple character strings.  It also has special
    mechanisms for rapid environment  switching  and  simple
    error handling that are especially suited to this use.
 
o   REXX has no reserved words.  This allows robust programs
    to be written that will not be invalidated by future ad-
    ditions  to  the set of language instructions.  Not only
    does this mean that programmers do not need to learn the
    keywords that they do not use, but this is also extraor-
    dinarily important when using the language for  applica-
    tion extension.
 
    Software  vendors  can distribute macros written in REXX
    which, even though they are processed  in  source  form,
    can remain almost immune to changes in the REXX language
    itself.   This benefits the user, since installing a new
    level of REXX (which is usually part of  the  underlying
    operating  system)  is unlikely to break the macros pro-
    vided with an application or written by the  user.    It
    also benefits the software vendor, since much less main-
    tenance and fewer updates will be needed.
 
o   REXX  is very system-independent.  This gives it the ad-
    vantages of portability  and  wide  application.    This
    means  that  people need to learn fewer programming lan-
    guages; there is no longer the need for  a  new  command
    programming language for every application and operating
    system.
 
o   Finally,  REXX has a number of unusual features, such as
    associative arrays and dynamic  variable  scoping,  that
    make  many  algorithms  much easier to design and imple-
    ment.
 
These advantages have led to the rapid acceptance of REXX as
a  language for procedure automation, application extension,
and scripting.  Its users cover the whole spectrum  of  pro-
grammers,  from  secretaries  or  workstation users who just
wish to  customize  their  environment  in  a  flexible  way
through  to  professional programmers writing or prototyping
whole subsystems of software in REXX.
 
 
DISADVANTAGES
-------------
Designs that provide for human variability  and  preferences
inevitably  are more costly to implement than those that ig-
nore human nature.  The most obvious cost is in performance;
for example, REXX's decimal arithmetic will be  slower  than
binary  arithmetic until manufacturers start providing hard-
ware support for user-friendly arithmetic.   REXX's  dynamic
nature means that, even with advanced compilers, programs in
REXX are usually slower than those written in languages that
move  most  of the burden of data conversion and typing onto
the programmer.
 
Even so, as hardware speeds increase exponentially, REXX be-
comes useful for more and more applications; for example, it
has already been used  successfully  for  prototyping  image
processing  algorithms  and  for  extensive mathematical re-
search.
 
The second disadvantage of REXX is  that  it  is  relatively
hard  to  implement.   This, however, is a task that is done
infrequently; the investment rapidly pays  off  in  improved
user programs and productivity.
 
Finally, REXX's data type, the string, is not well supported
by many other languages, so there can be extra cost involved
in data conversions when REXX invokes or uses programs writ-
ten  in these "lower-level" languages.  This cost can be im-
portant when small programs with little function are called,
but if significant processing is to be done then  data  con-
version on entry and return is relatively inexpensive.
 
 
THE FUTURE
----------
Programming  languages  are among the most enduring features
of computer science and the computer industry; they  take  a
decade  or  more to become established, and can then survive
for generations of programmers and operating systems.   REXX
is  now widely recognized as the leading extension and macro
language.  It has broken new ground, and, I hope, will  con-
tinue  to  break  new  ground  while holding to its original
principles.  One can expect it to change to meet the  chang-
ing  needs of its users, and that is the most important fea-
ture of any tool.
 
- - - - -
