    FreeStyLISP processor                    А.А.Титов
           LISP-процессор                    г.Кировоград Украина
    ---------------------                    (052-2)24-57-63
    Приложение для работы со спрайтами

                            0. Содержание

    Тема                      |              Контекст поиска
    --------------------------------------------------------------
    Зачем он нужен            |              KnowHow
                              |
    Структура программы       |              Progst
                              |
    Язык описания сценариев   |              FilmLan
                              |
    Архитектура данных        |              Internal
                              |
    Как писать свои функции   |              OwnFunct
                              |
    Ограничения               |              Limits
    --------------------------------------------------------------

    KnowHow                  1. Зачем он нужен


                                            Ах Самара городок,
                                            Беспокойная я,
                                            Беспокойная я,
                                            Успокойте меня !
                                                      (Эпиграф)

    Было много (правильных) научных разговоров, но  для нас важны
    два главных свойства этого языка:

                -ОН МАКСИМАЛЬНО ПРОСТ СИНТАКСИЧЕСКИ.
                -ОН МОЖЕТ ВСЕ, ЧТО И ЛЮБОЙ ПРИВЫЧНЫЙ ЯЗЫК,
                 ХОТЯ, К СОЖАЛЕНИЮ, НЕ ВСЕГДА ПРИВЫЧНЫМ ОБРАЗОМ.

    Из этого следует, что и интерпретатор тоже максимально прост
    при сохранений всех традиционных возможностей (циклы, вызов под-
    программ, условия и т.п.)
    Не всегда привычный образ - это вот что:

       Обычно:     x=y;
       В LISPe:    (SET X Y)

       Обычно:     x=y+z;
       В LISPe:    (SET X (ADD Y Z))

       Обычно:     x=y+z*h;
       В LISPe:    (SET X (ADD Y (MUL Z H)))

       Обычно:     for i=1 to 5 step 2 {  ... };
       В LISPe:    (REPEAT I 1 5 2 ( ... ))

       Обычно:     function F(X,Y) {.....}
       В LISPe:    (DEFINE F (LAMBDA X Y ( операторы,содерж X и Y )))

    Последнее уже трудно воспринимается. Из сказанного, кроме крайней
    простоты интерпретатора, следует также определенная трудновоспринимаемость
    текстов на LISPе ДЛЯ ЧЕЛОВЕКА.

    Следовательно, если Вам позарез нужно слепить язык описания чего-то
    содержательно сложного, но ооочень быстро и дешево, причем язык этот
    будет интерпретироваться не человеком, а машиной, то LISP - это то,
    что Вам надо. Такие языки обычно называются метафайлами, например,
    графические метафайлы, всем знакомый AutoLISP, какие-либо описания
    сценариев, траектории инструментов и т.п.
    Данная поставка содержит набор функций для визуализации спрайтов.

    ЗАПУСК ПРИМЕРА:
                    RUN BOX

    Вы должны увидеть вверху посреди экрана прямоугольник из точек,
    а потом слева направо над ним побежит прямоугольник из рожиц.
    Это и есть простейший фильм. Обьясним, откуда произошла эта задача.
    Интерпретатор фильмов нужно было построить для специальной аппара-
    туры связи с телевизионным трактом. При этом функция view передавала
    набор спрайтов на эту аппаратуру, а не через BIOS на экран,  как в
    просмотренном Вами фильме. Функция (sprite НомерСпрайта) определяла,
    какой спрайт из ПЗУ аппаратуры показывать в данном месте телевизионного
    экрана. Спрайт в ПЗУ - это целая картинка, рассматриваемая в данной
    системе как неделимая единица изображения. Таким образом, программа

            (CLEARS)
            (LOC 2 5 4 (SPRITE 67))
            (VIEW)

     после чистки экрана размещает на телевизоре в спрайтовых (а не растровых)
     позициях x=2 y=5 z=(глубина)4 картиночку из ПЗУ аппаратуры сопряжения
     с номером 67, а на дисплее PC - в текстовых координатах 2,5 символ с
     кодом ASCII 67.
     Заказать аппаратуру связи можно в научно-производственном предприятии
     КОМЭКС (г.Кировоград,(052-2)555-1-28 ). А мы больше не будем говорить
     о телевизорах и рассмотрим сам язык FreeStyLISP и то, как им овладевает
     программист-разработчик метафайла.


Progst                       2. Структура программы

                                                        Мозги промыть,
                                                        отварить,
                                                        откинуть на дуршлаг
                                                        и подавать с горошком
                                                              Книга о вкусной
                                                              и здоровой пище

     Программа на LISPе представляет собой минимальный в записях, свойственных
     нашим культурам, способ воспроизведения структурированной информации.
     Если отвлечься от интерпретации, то запись

                       (ADD (ADD X Y) Z)

    определяет всего-навсего МНОЖЕСТВО из элементов ADD, (ADD X Y) и Z,
    причем оно содержит множество (ADD X Y) в качестве элемента.
    (Да простят мне математики, хотя здесь я как раз стараюсь быть и не free)
    Вряд ли можно придумать что-либо еще короче и проще для записи множеств.
    Именно в этом смысле синтаксис LISP  МИНИМАЛЕН для записи программ.
    Значит, и более дешевый интерпретатор невозможен. Кстати, этот разра-
    батывался примерно день, если считать время работы за экраном.

    Семантика вносится только набором функций, и тогда получается

                       z+(x+y)

    Итак, СКОБКИ служат для обьединения в множества
    В скобках могут стоять:

          ЧИСЛА - например, 1   1.2     -5   +3  .7   8.
          СТРОКИ            "v"  "ggggg'llll"    'ggggg"jhjj' 'kkk' "jjj"
          ИДЕНТИФИКАТОРЫ различных обьектов
          #ИДЕНТИФИКАТОРЫ для ссылки на include-файлы : #x означает X.FSL
          и, конечно, скобочные конструкции

   Согласно определенной традиции, программа имеет РЕЗУЛЬТАТ,
   который распечатывается в конце выполнения на Системный Вывод.

   Результатом FSL-программы (ADD 3 4) будет 7
                             (2)       --"-- 2

   При некоторых условиях ПЕРВЫЙ ЭЛЕМЕНТ СКОБОЧНОЙ СТУКТУРЫ ИМЕЕТ ОСОБЫЙ СМЫСЛ.
   Если он - имя известной системе функции, то она вызывается, а все остальные
   элементы рассматриваются как ее параметры. Например:

            (ADD X Y)  вычисляется как ADD(X,Y)

   Функция должна сама контролировать число и тип аргументов, а также вообще
   разбираться со своим внутрискобочным хозяйством, хотя и может предоставить
   делать это функции интерпретации FRAME.

   Рассмотрим функцию FRAME (в rigorous реализациях она называется PROGRAM,
   да простят мне rigorouсты, здесь и далее я уже free)

            (FRAME 2 (ADD 3 4) (SUB 3 5))

   Функция FRAME вычисляет по порядку значения всех своих аргументов:
                   2     7         8
   и результатом программы будет 8.

   Рассмотрим еще пример:

                     (ADD 3 (4 5))

   Как понимать (4 5)? Если ADD контролирует тип параметров, то

   1.либо ругайся - список недопустим
   2.либо понимай как-нибудь список
   3.либо вызывай (FRAME (4 5)) - FreeStyLISP вернет 4 и в результате будет 7

   FreeStyLISP исповедует веру 3, но Вы можете в своих функциях поступать
   и по-другому.
   Таким образом, первый элемент имеет выделенный смысл (функция),
   когда он подлежит интерпретации FRAME.

   Результатом функции может быть функция:

               (ADD (BYNAME #D) 2)

               D.FSL:   (SUB 7 3)

               и получится 6

   Программа в ходе выполнения может строить фрагменты программы и выполнять
   их, хотя для этого надо иметь еще ряд функций, описанных в литературе
   по LISP.  Но я Вам сейчас не рекомендую этим заниматься, а писать свои
   функции да и все. В след главе детально рассмотрим пример набора таких
   функций, а в следующей за ней - как писать сами отработчики функций.


FilmLan              3. Язык описания фильмов
                                                        Развивайте национальные
                                                        языки программирования!
                                                                  Софтпанорама

    Неявно предполагается, что в начале программы стоит "(FRAME" а в конце ")"
    Операторы:

    (CLEARS)     - функция без аргументов чистки экрана

    (DELAY n)    - задержка на n тиков. n вычисляется и понимается как целое.

    (VIEW)       - показ тех фрагментов экрана, которые были изменены
                   по сравнению с предыдущим view. Таким образом, по связям
                   с оборудованием пересылаются ТОЛЬКО ИЗМЕНЕННЫЕ спрайты.
                   Экономится время воспроизведения. Пересылаются координаты
                   и номера спрайтов. В этой версии просто вывод через BIOS.

    (LOC X Y Z f) - размещение фрагмента f в координатах X Y Z относительно
                    обьемлющего оператора LOC. Пример:

                    (LOC 1 2 0
                         (FRAME
                             (LOC 1 1 0 (SPRITE 0))
                             (LOC 2 3 4 (SPRITE 1))
                         )
                    )
                    Здесь спрайт 0 размещен по абс коорд 2,3,0
                                 1                       3,5,4
                    Естественно, f - атом или список.

    (SPRITE n)   - Размещение спрайта. n-любая конструкция,
                   результат вычисления которой понимается как целый
                   номер спрайта:
                   (SPRITE "x")
                   (SPRITE 2)
                   (SPRITE (ADD 2 (BYNAME S)))

    (NAMEDEF ident object) - Определение имени. ident отныне указывает
                   (по адресу) на object, который может быть атомом
                   или списком.

    (BYNAME ident) - При выполнении происходит выполение (интерпретация)
                     object, который подставляется по адресу.

    (REPEAT from to step ...) - Повторение. Результаты from,to,step
                     понимаются как целые числа. "..." вычисляется последо-
                     вательно как (FRAME ...)

    Описание работы со слоями:
             Последовательные кадры мультфильма разделяются операторами
             (VIEW). Если что-либо вносится в кадре в какой-то Z-слой,
             предыдущее (из предыдущего кадра) содержимое этого слоя
             стирается. Слои с меньшими номерами расположены ближе.

    Рекомендуем Вам еще раз посмотреть на BOX.FSL и запустить его: RUN BOX


Internal             4. Архитектура данных
                                                      Стоит статуя
                                                      В лучах заката.
                                                      Рука поднята,
                                                      В руке граната

    Есть ПРОГРАММА и ОБЬЕКТЫ

    ПРОГРАММА - это виноградная гроздь списков, полученная в результате
                трансляции исходного текста. rootelement показывает на
                первый элемент списка, представляющего программу.

    ОБЬЕКТЫ   - это цепочка дескрипторов обьектов, в каждом дескрипторе
                есть поле NEXT->след. дескриптор. Обьектом может быть
                и список.


                          *-------------------------*
    ЭЛЕМЕНТ СПИСКА:       |   CAR      |   CDR --------------------->
                          *----|--------------------*   CDR=адрес следующего
                               |                            элемента
                               |                            (пары CAR CDR)
                               V
                           CAR=адрес дескриптора
                               содержимого элемента списка.

                CAR и CDR - это исторические названия (1963 г), их
                придется уважать.

     Просмотрите теперь фрагмент файла L.H:

#define objtype enum d3
typedef objtype {listT,stringT,intT,floatT,functT,extrnT,varT};

#define object struct d6      Дескриптор обьекта (содержимого
object                        элемента списка)
{
 char *string;          Имя его если есть
 objtype typ;           Тип его (см выше objtype)
 union
  {
    void    *first;     Либо это список - тогда здесь адрес 1-го эл-та
    char    *string;    Либо это строка
    int     *intv;      Либо целое
    float   *floatv;    Либо веществ
    fsubr functv;       Либо встроенная функция
    void    *voidv;     Либо что-то еще
  } contents;
 object *next;          Адрес след обьекта
};
                              Все обьекты (как определенные в тексте
                              программы, так и вновь создаваемые в ходе
                              выполнения) помещаются в эту цепочку.
                              Программу FreeStyLISP в нее не помещает,
                              хотя Вы можете это сделать.


#define element struct d0     Это соответсвует красивой картинке CAR-CDR
element                       приведенной выше
{
  object *car;
  element *cdr;
};

  Как видите, все очень просто и прозрачно. Вот как выглядит фрагмент

              (ADD X Y)

  во внутреннем представлении:

  Listart
     |
     *------> CAR CDR ---> CAR CDR ----> CAR CDR=NULL
               |            |             |
               |            |             |
               V            V             V
               typ=functT   Описатель X   Описатель Y
               functv по-
               казывает на
               встроенную
               void функцию. Listart является ее первым параметром.

   Еще немного и все! Не теряйте внимания, ибо далее о том,

OwnFunct               5. Как писать свои встроенные функции

                                                     И стали они
                                                     жить-поживать.


Функция (REPEAT index from to step операторы):

  Listart
     |
     *------> CAR CDR ---> CAR CDR->CAR CDR->CAR CDR->CAR CDR->CAR CDR ...
               |            |          |        |        |        |
               |            |          |        |        |        |
               V            V          V        V        V        V
               typ=functT   index      from     to       step     первый
               functv по-                                         оператор
               казывает на
               встроенную
               void функцию. Listart является ее первым параметром.
               Вот эта функция:

void repeat(listart,result)
/* (repeat index from to step program) */
element *listart;
object* *result;   /* Каждая функция имеет возвращаемый таким вот способом  */
{                  /* результат  result - ссылка на результир обьект или NULL */
 object *indexref;
 object *fromref;
 object *toref;
 object *stepref;
 object *val();
 void frame();
 object *res;
 int index,from,to,step;

 /* listart->car  - это дескриптор самой функции REPEAT */
 indexref=val(listart->cdr);
 fromref=val(listart->cdr->cdr);
 toref=val(listart->cdr->cdr->cdr);
 stepref=val(listart->cdr->cdr->cdr->cdr);

 from =*(( fromref->contents).intv);
 to   =*((   toref->contents).intv);
 step =*(( stepref->contents).intv);

 index=from;
 *result=NULL;
 while (index<=to)
 {
        *((indexref->contents).intv)=(int)index;
        frame(listart->cdr->cdr->cdr->cdr,&res);
        index+=step;
 };
 *result=res;
};


Надо просто написать такую функцию (заметьте, что результат возвращается
вторым параметром), а также включить среди других аналогичных операторов
оператор
         finstall("repeat",functT,repeat);

Можно инсталлировать функцию и под несколькими именами.
После этого нужно перетранслировать L.C
Оператор finstall вносит в цепочку обьектов предопределенный обьект.
В данном случае это имя обьекта repeat, тип функция, третий параметр-
ссылка на обьект.

Limits            6. Ограничения

                                 Сейчас не просто вводится пост для одного
                                 человека - сейчас закладываются основы
                                 нового государственного мышления
                                        По материалам народных депутатов


    Все списочные структуры хранятся в основной памяти. Никакого
    механизма виртуальной памяти, своппинга и т.д. не предусматри-
    вается, работа ведется с указателями(.,->) в языке C.
    Для предлагаемых приложений LISPа данное ограничение несущественно.
    Канонические функции (VAL,EVAL,CONS,CAR и т.д.) могут быть
    очень легко дописаны, если кому нужны.

    С уважением Титов Александр Алексеевич (052-2)24-57-63
