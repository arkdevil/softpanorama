

      РЕГУЛЯРНАЯ АРХИТЕKТУРА ОПЕРАЦИОННыХ СИСТЕМ


                     В.Г. Антонов



                      Аннотация

    В статье описана объектно-ориентированная опе-
    рационная  система с регулярной архитектурой и
    минимальным функционально-полным набором  при-
    митивов.   Рассмотрена возможность эффективной
    реализации системы  с  такой  архитектурой  на
    фон-Неймановских машинах.



1.  Введение

     В последнее время уже ни у кого не вызвает сомне-
ний тот факт, что система Unix[1] стала стандартом  de
facto  современной универсальной операционной системы.
Тем не менее различные версии Unix сильно несовместимы
одна  с  другой.   Попытки  стандартизовать систему не
имеют особого успеха.  Главная причина несовместимости
разных  версий  Unix по видимому не в нежелании разра-
ботчиков  версий  системы  придерживаться  какого-либо
стандарта,  а, скорее, в том, что использование только
"стандартной" системы Unix версии 7 (которая как подм-
ножество входит во все версии Unix) делает практически
невозможным простую  и  эффективную  реализацию  таких
программ,  как полиэкранные интерфейсы, сетевые файло-
вые системы, системы ведения версий программ и т.п.

     Все вышеперечисленные применения требуют  наличия
развитых  средств  межпроцессной коммуникации, которые
отсутствуют в Unix версии 7.  Как следствие, для реше-
ния  конкретных  задач  в  систему  добавлялись  такие
средства, но при этом каждый из таких механизмов взаи-
модействия процессов (мультиплексные файлы, псевдотер-
миналы, System V IPC, ядро TCP/IP версии  Unix BSD[2])
предназначен  только  для  решения своего круга задач.
____________________
   [1] Unix - торговая марка AT&T Technologies.
   [2] Unix BSD - версия системы University  of  Cali-
fornia, Berkeley.


                        - 1 -




                       Введение


Поэтому современные версии Unix,  поддерживающие  сов-
местимость  как  с  Unix  System V,  так и с Unix BSD,
содержат десяток различных несовместимых  между  собой
механизмов  межпроцессного  взаимодействия  и по слож-
ности приближаются к OS/370 фирмы IBM.

     Разные механизмы взаимодействия  процессов  плохо
сочетаются друг с другом, часто имеют непрозрачную для
сетей семантику и нерегулярную структуру,  что  значи-
тельно  усложняет  прикладные  программы, использующие
их.

     Можно с уверенностью утверждать,  что  требование
простоты системы (если иметь в виду реальную, развива-
ющуюся систему, а не абстракцию из учебника программи-
рования)  влечет  за  собой  требование функциональной
полноты набора системных вызовов.  Очевидно, что набор
системных вызовов, обладающий полнотой, не потребуется
изменять в процессе эволюции системы  (в  том  смысле,
что  любая новая версия набора системных вызовов будет
семантически эквивалентна старой, т.е.  старую  версию
можно  будет реализовать в виде крайне простой библио-
теки, обеспечивающей обратную совместимость.

     Естественно,  обеспечить  полноту  таких  функций
ядра    "классической"    системы   как   терминальный
ввод/вывод  не  представляется  возможным.  Поэтому  в
предлагаемой  архитектуре  ядро  системы  обеспечивает
только взаимодействие объектов и реализует минимальную
среду, необходимую для существования объектов.  После-
довательное использование объектного подхода к  конст-
руированию операционной системы позволило получить ряд
неожиданных свойств системы D3[3], таких  как  возмож-
ность работы с нецифровой информацией или  использова-
ния  D3  как  альтернативы системам виртуальных машин.
Кроме того, архитектура D3 разрабатывалась  специально
как архитектура распределенной системы.

     Весьма  немаловажным   обстоятельством   является
также то, что D3 может быть эффективно реализована как
на обычных серийных компьютерах, так и на многих маши-
нах нетрадиционной архитектуры, включая транспьютеры и
цифро-аналоговые машины.


____________________
   [3] Название намеренно  ассоциируется  с  известным
"феноменом  Системы II", это отражает эволюцию проекта
D3 от супер-Unix до крайне простой (но  более  мощной)
системы.


                        - 2 -




                       Введение


2.  Определения

     Основными понятиями, используемыми в описании D3,
являются  понятия  объекта,  функционирования объекта,
доступа, протокола работы с объектом и  понятие  тран-
закции.   Везде далее эти термины будут использоваться
только в определенном узком смысле.

2.1.  Объекты

     D3 содержит два класса объектов - P-объекты и  S-
объекты.

P-объекты  представляют собой аппаратные или программ-
           ные  автоматы с жестко заданной (непрограм-
           мируемой)  логикой   функционирования.   P-
           объект  может использовать внешнюю информа-
           цию для модификации логики своего  функцио-
           нирования (т.е. использовать внешнюю инфор-
           мацию как программу).  Кроме того, P-объект
           может содержать внутреннюю память.  Измене-
           ние состояния P-объекта во времени и  внеш-
           ние эффекты этого изменения состояния далее
           будут   называться   функционированием   P-
           объекта.

           P-объект может быть активен или  находиться
           в состоянии ожидания.  Находящийся в состо-
           янии ожидания P-объект не  должен  изменять
           какую-либо внешнюю информацию и, вообще, не
           должен проявлять активность внутри системы,
           но вне самого P-объекта[4].  Все  P-объекты
           внутри  D3  функционируют  параллельно (или
           квазипараллельно - в зависимости от  реали-
           зации).

           Каждый P-объект имеет свой  системный  кон-
           текст,   содержащий  текущее  состояние  P-
           объекта и информацию о связях  P-объекта  с
           другими   объектами   системы.    P-объекты
           непосредственно не  адресуются;  невозможно
           выполнение   каких-либо   операций  над  P-
____________________
   [4] Это не означает  прекращения  или  приостановки
функционирования P-объекта, так P-объект может продол-
жать  изменение  своего  внутреннего   состояния   или
каким-либо образом взаимодействовать со внешней по от-
ношению к системе средой; важно только, чтобы  находя-
щийся  в состоянии ожидания P-объект не функционировал
с точки зрения остальных объектов системы.


                        - 3 -




                       Объекты


           объектами. Способ  создания  и  уничтожения
           P-объектов  определяется  реализацией  сис-
           темы;  в  частности  конкретная  реализация
           может  вообще не содержать способа порожде-
           ния  новых  P-объектов  (см.  также  раздел
           "Управление P-объектами").

S-объекты  являются  адресуемыми  пунктами  связи   P-
           объектов.   S-объект  не  содержит  никакой
           внутренней информации, кроме  информации  о
           своем  существовании, информации о допусти-
           мых операциях над этим S-объектом и (недос-
           тупной P-объектам) ссылки на P-объект, фак-
           тически выполняющий операции, применяемые к
           этому S-объекту.  (В дальнейшем будем гово-
           рить что S-объект принадлежит P-объекту, на
           который  указывает  эта ссылка, и для этого
           P-объекта такой S-объект является собствен-
           ным).

           Р-объект  может  выполнить   операцию   над
           несобственным  S-объектом; при этом состоя-
           ние P-объекта,  которому  принадлежит  этот
           S-объект,  изменится  -  в  частности,  при
           определенных условиях этот  P-объект  может
           перейти  из  состояния  ожидания в активное
           состояние. Выполнение операции над несобст-
           венным  S-объектом может перевести P-объект
           в состояние ожидания.

     Таким образом, P-объекты являются активными  эле-
ментами  системы,  в то время как S-объекты предназна-
чены  исключительно  для  обеспечения   взаимодействия
между P-объектами.

2.2.  Доступы и защита

     К каждому S-объекту могут  применяться  несколько
разных  видов  операций.   Для выполнения операции над
S-объектом P-объекту нужно иметь соответствующего вида
доступ  на  S-объект.  P-объект может уничтожить имею-
щийся у  него  доступ  или  передать  его  другому  P-
объекту,  но  создать  доступ на S-объект можно только
при создании этого S-объекта.

     P-объект  может  содержать   несколько   доступов
одного или разных видов на один и тот же S-объект.

     Реализация D3 должна  обеспечивать  невозможность
выполнения  операции  над  S-объектом при отсутствии у
P-объекта, выполняющего операцию, нужного доступа.

                        - 4 -




                   Доступы и защита


     Таким образом,  полномочия  P-объекта  в  системе
полностью опредеделяются набором имеющихся у него дос-
тупов на S-объекты. Суммирование полномочий  осуществ-
ляется просто добавлением новых доступов[5].

     Кроме того, в  качестве  средства  аутентификации
P-объектов можно использовать т.н.  ключи.  В качестве
ключей  используются  S-объекты,  подлинность  которых
проверяется  при помощи специального примитива сравне-
ния двух доступов ("являются ли эти доступы  доступами
на  один  S-объект?"  или  "являются  ли S-объекты, на
которые ссылаются эти доступы собственными S-объектами
одного P-объекта?").

     P-объект, которому принадлежит  S-объект,  должен
иметь  набор  доступов  на  этот S-объект; для каждого
вида операций, допустимых над этим S-объектом,  должен
существовать  ровно один активный доступ, используемый
для идентификации  объекта,  над  которым  выполняется
операция[6].   Уничтожение  активного  доступа  на  S-
объект  запрещает выполнение запросов соответствующего
вида к этому объекту.

     Активный доступ нельзя передать другому P-объекту
и  при  его копировании получается обычный (пассивный)
доступ на этот S-объект.

2.3.  Адресация

     В D3 не существует глобального  адресного  прост-
ранства  объектов.   У  каждого P-объекта имеется свое
пространство  локальных  адресов  S-объектов.   Каждый
локальный  адрес содержит группу доступов разных видов
на один S-объект.   (Вообще  говоря,  локальный  адрес
может не содержать ни одного доступа на S-объект; но и
в  этом  случае  он  будет  связан  с  конкретным   S-
объектом).   Разные локальные адреса в одном P-объекте
____________________
   [5] Возможность суммирования полномочий весьма  су-
щественна  для организации корректной и надежной схемы
защиты системы; так, например, отсутствие  возможности
суммирования  полномочий процессов в системе Unix при-
водит к необходимости частого использования  установки
эффективного  идентификатора  суперпользователя, что в
большинстве случаев не позволяет локализовать  наруше-
ния защиты.
   [6] Вместе  с  активным  P-объект  может иметь нес-
колько обычных (пассивных) доступов того  же  вида  на
тот  же  S-объект, однако выставлять запросы собствен-
ному S-объекту нельзя.


                        - 5 -




                      Адресация


могут содержать доступы одного вида на один и  тот  же
S-объект.   Совпадающие по значению локальные адреса у
разных P-объектов могут указывать на разные S-объекты.

     Для  осуществления  преобразования  внешних  имен
каких-либо объектов в локальные адреса можно использо-
вать определенные заранее S-объекты, принадлежащие  P-
объектам, которые имеют (или могут создать) доступы на
нужные объекты. Такие  P-объекты  в  дальнейшем  будем
называть  адресующими  подсистемами.   В частности, от
одной адресующей подсистемы можно получить  доступ  на
S-объект  -  вход  другой (или даже той же) адресующей
подсистемы[7].

     Принцип локальности адресации объектов  позволяет
строить  произвольные адресные пространства без каких-
либо ограничений со стороны системы.

     P-объекты  непосредственно  не   адресуемы.   Для
управления функционированием P-объектов (включая также
создание и уничтожение  P-объектов)  можно,  например,
создавать  соответствущие  им S-объекты, принадлежащие
P-объекту, который косвенным путем управляет  функцио-
нированим  других P-объектов.  Возможны различные реа-
лизации управления P-объектами, в зависимости от конк-
ретной  аппаратуры  или назначения конкретной вычисли-
тельной системы.

2.4.  Запросы и протоколы

     К каждому S-объекту  может  быть  применено  нес-
колько различных операций; это производится путем выс-
тавления  P-объектом  соотвествующих  запросов  к   S-
объекту.   Для этого требуется указать локальный адрес
S-объекта, вид запроса и список аргументов.

     Виды запросов, применимых к  S-объекту,  задаются
при его создании.  (Далее будем говорить, что S-объект
допускает запросы заданных видов).

     Вид запроса может быть или просто целым числом (в
этом случае предполагается, что все операции над конк-
ретным S-объектом  пронумерованы  несовпадающими  чис-
лами)   или  парой  <локальный  адрес  типизующего  S-
объекта, целое число>.

____________________
   [7] Это позволяет (при разумном планировании)  ком-
бинировать  пространства  имен  с совершенно различной
структурой.


                        - 6 -




                 Запросы и протоколы


     В первом  случае  предполагается,  что  P-объект,
выставляющий запросы, точно уверен в том, что S-объект
имеет нужное соответствие номеров запросов выполняемым
операциям.

     Во втором  случае  для  выставления  запросов  P-
объекту  нужно иметь еще и локальный адрес типизующего
S-объекта, что позволяет динамически проверять тип  S-
объекта (система должна отвергать любые попытки выпол-
нить операцию над объектом, не допускающим такого зап-
роса с данным типом)[8].  Кроме того, можно  создавать
S-объекты, допускающие запросы разных типов, но с сов-
падающими кодами; это аналогично множественному насле-
дованию   типов  (multiple  inheritance)  в  некоторых
объектно-ориентированных  языках.    В   качестве   S-
объекта-тэга  типа  можно использовать, например, вход
адресующей подсистемы, возвращающей ссылки на объекты,
допускающие запросы данного типа.

     С каждым запросом ассоциируется (возможно пустой)
список  аргументов, которые могут служить для передачи
доступов  от  P-объекта,  выставившего  запрос,  к  P-
объекту, его обрабатывающему, или наоборот.

     Набор допустимых видов  доступов  и  связанных  с
каждым  из  видов набором возможных списков аргументов
(т.е. направлений передачи доступов и  протоколов  для
каждого  аргумента)  будем называть протоколом взаимо-
действия с объектом.  (Особо надо отметить рекурсивную
природу понятия протокола; так, протокол может опреде-
ляться через себя).

     Протоколы, определяющиеся через себя или содержа-
щие только запросы без аргументов далее будем называть
базовыми протоколами.

     Важной особенностью D3 является то, что запрос не
подразумевает  передачи  информации, а передает только
доступы на объекты.  Обмен информацией является побоч-
ным  эффектом  обслуживания  P-объектом запросов к его
собственному S-объекту.  От реализации системы  требу-
ется  только  поддержка соответствия защиты физических
каналов передачи информации и  распределения  доступов
____________________
   [8] В отличие  от  других  объектно-ориентированных
систем,  при использовании объекта как тэга типа можно
не заботиться об уникальности кодов запросов к  объек-
там;  кроме того это позволяет внутри подсистемы неви-
димо для других подсистем использовать новые типы зап-
росов.


                        - 7 -




                 Запросы и протоколы


на объекты внутри системы.

     Архитектура D3 не накладывает ограничений на спо-
собы обмена информацией между P-объектами[9].  Исполь-
зование  базового протокола предполагает наличие неко-
торого физического способа передачи  информации,  свя-
занного  с этим протоколом.  Небазовые протоколы могут
не  иметь  ассоцированного  с  ними  способа  передачи
информации, а использовать для этого протоколы нижнего
уровня.  Так, например, протокол обмена  с  файлами  в
качестве  протокола  нижнего уровня может использовать
протокол оперативной памяти.

2.5.  Транзакции и синхронизация

2.5.1.  Схема client-master

     По отношению к каждому запросу есть две  стороны:
P-объект,  выставивший  запрос, (далее его будем назы-
вать client или  CP-объект)  и  P-объект,  исполняюший
этот  запрос, (далее master или MP-объект).  CP-объект
при этом должен  иметь  доступ  на  принадлежащий  MP-
объекту  S-объект (к которому, собственно, и выставля-
ется запрос).

     При  выставлении  запроса  CP-объектом  состояние
MP-объекта  изменяется  таким  образом,  что MP-объект
может определить наличие ждущего  выполнения  запроса.
После  выполнения  связанных  с  запросом действий MP-
объект должен сообщить системе об окончании выполнения
запроса.    CP-объект  может  проверить,  окончено  ли
выполнение запроса  МP-объектом,  или  задержать  свое
функционирование до окончания выполнения запроса.

     Ожидание окончания  выполнения  запроса  является
единственным  внутрисистемным  способом  синхронизации
функциониования P-объектов[10].

2.5.2.  Мультиожидание и прерывания

     Основным примитивом синхронизации в  D3  является
мультиожидание[11], т.е. задержка функционирования  P-
____________________
   [9] Возможно использование передачи  информации  не
только в цифровой, но и в аналоговой форме.
   [10] Могут  существовать  и  другие  (внесистемные)
способы,  вроде  обмена  по  линиям  связи, аппаратной
синхронизации и т.п.
   [11] Аналог  системного  вызова  select  в Unix BSD
(University of California, Berkeley).


                        - 8 -




             Мультиожидание и прерывания


объекта до одного события из указанного списка возмож-
ных событий.  Событием в D3 может быть:

1)   выставление запроса CP-объектом;

2)   завершение выполнения запроса MP-объектом;

3)   снятие запроса CP-объектом;

4)   аппаратное событие (эти события  оформляются  как
     завершения запросов к специальным объектам).

     Разновидность ожидаемого события определяется  по
тому,  чем  является  элемент списка возможных событий
(этими  элементами  могут  быть  локальные  адреса  S-
объектов  или  транзакций  (см. далее); так, локальный
адрес C-транзакции используется для  ожидания  событий
второго   и   четвертого   вида,  локальный  адрес  M-
транзакции - для  третьего  вида,  а  локальный  адрес
собственного  S-объекта  для  ожидания событий первого
вида).

     Использование мультиожидания позволяет во  многих
случаях   отказаться  от  использования  традиционного
механизма прерываний или сигналов; однако для имитации
этого механизма в D3 добавлен специальный аппарат пре-
рываний, который в момент  возникновения  события  (из
указанного  списка  событий) прерывает функциониование
P-объекта и передает управление подпрограмме обработки
прерывания.  Механизм прерываний также включает в себя
средства для временного запрещения прерываний.

     Вообще   говоря,   использование   мультиожидания
вместо  прерываний  позволяет создавать более надежные
программы с прозрачной логикой и простой структурой.

2.5.3.  Транзакции и очереди транзакций

     С момента выставления запроса  CP-объектом  и  до
получения CP-объектом информации о завершении выполне-
ния запроса в системе существует связанная с этим зап-
росом транзакция.

     Транзакция содержит в себе информацию о виде зап-
роса  и  аргументах  этого  запроса. Каждая транзакция
может иметь два локальных адреса,  один  у  CP-объекта
(далее   он  будет  называться  локальным  адресом  C-
транзакции) и один - у MP-объекта (который будем назы-
вать   локальным   адресом  M-транзакции).   Локальные
адреса транзакций находятся в том же  адресном  прост-
ранстве,  что  и  адреса  объектов,  но  не могут быть
использованы в контексте локальных адресов S-объектов.
                        - 9 -




           Транзакции и очереди транзакций


     Адрес C-транзакции возвращается CP-объекту  сразу
же  после выставления запроса к S-объекту и может быть
использован для  ожидания  завершения  транзакции  или
снятия  запроса (т.е. отказа от выполнения запрошенной
операции).  Адрес M-транзакции возвращается MP-объекту
после   выполнения  примитива  выборки  транзакции  по
локальному адресу собственного S-объекта.

     Во время своего существования,  транзакция  может
находиться в одном из четырех состояний:

1)   ожидает  выборки  MP-объектом  (CP-объект   имеет
     адрес этой транзакции, а MP-объект - нет);

2)   выбрана  MP-объектом  (CP-  и  MP-объекты   имеют
     адреса);

3)   завершена, существует до тех пор, пока  CP-объект
     не  уничтожит  локальный  адрес этой C-транзакции
     (MP-объект не имеет адреса);

4)   снята  CP-объектом  (MP-объект  имеет   локальный
     адрес  этой транзакции, и может использовать дос-
     тупы из сегментов этой транзакции, но может также
     определить  то,  что запрос уже снят и прекратить
     его обработку; CP-объект адреса уже не имеет).

У каждого P-объекта, имеющего  собственные  S-объекты,
есть  очередь  транзакций,  ожидающих  выборки. Обычно
транзакции помещаются в конец очереди,  но  существует
способ  при  создании  S-объекта указать для некоторых
видов запросов то, что транзакции будут  помещаться  в
начало очереди (out-of-band запросы).

     С каждой транзакцией связаны  аргументы  запроса,
т.е.  передаваемые  доступы на объекты (в D3 использу-
ются только позиционные аргументы).  Аргументы  запро-
сов,  хранящиеся  в транзакции, будем называть сегмен-
тами транзакции.

     Сегменты транзакций могут  содержать  (в  зависи-
мости  от  состояния  транзакции) набор доступов на S-
объект, передаваемый от CP-объекта  MP-объекту,  набор
доступов,  передаваемый  от MP-объекта CP-объекту, или
вообще ничего не содержать.

2.5.4.  Временные доступы

     Обычно доступы на S-объект, передаваемые  от  CP-
объекта  MP-объекту  нужны  только на время исполнения
запроса, т.е. как аргументы "вызова процедуры" (remote
procedure  call).  D3 позволяет передавать доступы MP-
                        - 10 -




                  Временные доступы


объекту так, чтобы использование  этих  доступов  было
возможно  только пока существует транзакция, в сегмен-
тах которой были переданы эти доступы.  Такие  доступы
далее  будем называть временными доступами, связанными
с данной транзакцией.

     Если P-объект, имеющий временый доступ,  передает
его  другому  P-объекту, то, независимо от способа его
передачи (как временного или как постоянного доступа),
второй  P-объект будет иметь временный доступ, связан-
ный с той же транзакцией, что и исходный.

     Таким образом, если CP-объект  передал  временный
доступ, он может быть уверен, что после завершения или
снятия запроса этим доступом  никто  более  не  сможет
воспользоваться  независимо  от того, передавал ли MP-
объект этот доступ другим  P-объектам  или  нет;  т.е.
механизм  временных доступов необходим для обеспечения
независимости внешних проявлений обслуживающих подсис-
тем от их внутренней структуры (например от того, сос-
тоят они из одного или из нескольких взаимодействующих
P-объектов)[12].

3.  Реализация

     В данном разделе кратко описан вариант реализации
D3  на машинах с традиционой фон-Неймановской архитек-
турой.

3.1.  функции ядра

     Ядро D3 обеспечивает разделение времени ЦП, пере-
дачу  доступов  на  S-объекты  и защиту, синхронизацию
процессов, управление памятью  и  содержит  реализацию
протоколов  памяти  и  управления P-объектами; т.е.  в
ядре реализуются примитивы D3 (далее они  будут  назы-
ваться  системными  вызовами)  и  алгоритмы  работы  с
памятью и процессами как с объектами.

     Как правило, драйверы внешних устройств  реализо-
ваны как отдельные P-объекты и по сути являются преоб-
разователями протоколов, транслирующими операции внут-
рисистемных  протоколов  в  наборы операций физических
устройств.   По  соображениям  эффективности  драйверы
некоторых  устройств  или обработчики прерываний могут
быть реализованы в ядре системы.
____________________
   [12] Это свойство архитектуры D3 позволяет  строить
строго модульные системы, обеспечивая максимальную за-
щиту одних модулей от других.


                        - 11 -




                     функции ядра


3.2.  Системные вызовы

     Для описания системных вызовов далее используется
синтаксическая  форма  вызовов  процедур  в  языке  C.
Интерфейсы системных вызовов  в  других  языках  могут
быть построены аналогично.

3.2.1.  Диапазоны локальных адресов

     Локальные адреса в D3 представляются  четырехбай-
товыми  положительными  целыми  числами  (хранимыми  в
переменных типа sdesc).  Значение 0l используется  как
признак  конца  списка  аргументов  запроса или списка
событий. Отрицательные значения используются как приз-
наки ошибки.

     Поле локальных адресов разбито на 4 диапазона:

1)   локальные адреса S-объектов;

2)   локальные адреса C- и M-транзакций;

3)   локальные адреса групп (о группах см. далее);

4)   локальные адреса сегментов C- и M-транзакций.

     Локальный адрес сегмента транзакции  используется
для  обращения к аргументу транзакции и вычисляется из
локального  адреса  транзакции  и   номера   сегмента.
Локальный   адрес  сегмента  M-транзакции  может  быть
использован в любом месте, где может быть  использован
локальный  адрес  несобственного  S-объекта.  Сегменты
C-транзакций могут быть использованы для копирования в
них  доступов  системными  вызовами dup и rdup или для
объявления их как сегментов для приема  доступов  сис-
темным вызовом receive.

     Локальный адрес сегмента транзакции  можно  полу-
чить при помощи конструкции

    tseg(tsd, segno)

где tsd - локальный адрес транзакции, а segno -  номер
сегмента этой транзакции.

3.2.2.  Создание и уничтожение S-объектов

     S-объект создается системным вызовом

    sd = create(code1, ..., 0l)
или
    sd = createv(codelist)
                        - 12 -




          Создание и уничтожение S-объектов


где sd - локальный адрес нового S-объекта, а  code1...
- коды всех допустимых для нового объекта видов запро-
сов.  (В createv codelist указывает  на  массив  видов
запросов,  заканчивающийся  0l).   Коды видов запросов
могут быть:

1)   константой type(SELF,код) - для  видов  запросов,
     специфичных  для  самого объекта (код - это целое
     число от 0 до MAXREQ);

2)   для видов  запросов,  типизованных  S-объектом  -
     конструкцией type(tysd,код), где tysd - локальный
     адрес типизующего S-объекта, а код - целое  число
     от 0 до MAXREQ;

3)   если в качестве кода  вида  запроса  использована
     конструкция

         URGENT | type(...,...),

     то запросы этого вида будут выполняться в  режиме
     out-of-band,  т.е.  транзакции будут помещаться в
     начало, а не в конец очереди.

Максимальное число допустимых видов запросов к  одному
S-объекту определяется константой SYS_NREQ.

     В качестве результата create возвращает локальный
адрес с набором активных доступов на новый S-объект.

     Набор доступов, связанных с локальным адресом sd,
можно уничтожить при помощи системного вызова

    close(sd).

close уничтожает доступы  на  S-объект  и  освобождает
указанный  локальный адрес; S-объект уничтожается сис-
темой автоматически после уничтожения последнего  дос-
тупа на этот объект.

3.2.3.  Локальные адреса

     Системный вызов

    sd = sdalloc()

находит свободный локальный адрес sd (в  поле  адресов
S-объектов)  и  помечает его как занятый, не смотря на
то, что он не связан  с  S-объектом.   Этот  локальный
адрес  может быть использован только для копирования в
него доступов.

                        - 13 -




                   Локальные адреса


     Скопировать набор доступов из  локального  адреса
sd  в  локальный адрес tsd можно при помощи системного
вызова

    newsd = dup(tsd, sd, code1, ..., 0l)
или
    newsd = dupv(tsd, sd, codelist)

В случае успешного завершения dup возвращает локальный
адрес  tsd.   Если  локальный  адрес tsd был занят, то
перед копированием этот локальный адрес будет освобож-
ден (см. close).

     Системный  вызов  dup  (dupv)  копирует   доступы
только  тех  видов,  коды которых перечислены в списке
code1... (в массиве codelist).  Для копирования досту-
пов,  виды которых не указаны в списке можно использо-
вать системный вызов

    newsd = rdup(tsd, sd, code1, ..., 0l)
или
    newsd = rdupv(tsd, sd, codelist).


     При копировании системными вызовами  dup  и  rdup
активных доступов получаются пассивные доступы (а в sd
остаются активные). Для того, чтобы скопировать актив-
ные  доступы  из sd в tsd, вместо sd надо использовать
конструкцию

    ACTIVE | sd.

Активные доступы нельзя передавать из одного P-объекта
в другой.

     При копировании доступа  в  сегмент  C-транзакции
получается временный доступ, связанный с этой транзак-
цией. Для того, чтобы передать постоянный  доступ  MP-
объекту вместо sd надо использовать[13]

    STABLE | sd.


     Для объединения двух наборов доступов на  один  и
тот  же S-объект (эти доступы одновременно должны быть
постоянными или временными, ассоциироваными с одной  и
той же транзакцией) используется системный вызов
____________________
   [13] Константы ACTIVE и STABLE имеют одно и  то  же
числовое значение; смысл его опредляется по контексту.


                        - 14 -




                   Локальные адреса


    newsd = sumacc(tsd, ssd),

где tsd - локальный адрес, в который  нужно  поместить
объединенный  набор  доступов  из  tsd и ssd; в случае
успешного завершения он же возвращается в newsd.

     При помощи системного вызова

    res = access(sd, code1, ..., 0l)
или
    res = accessv(sd, codelist)

можно  определить  наличие  нужных  видов  доступов  у
локального  адреса  sd.  access возвращает истину если
есть  все  перечисленные  доступы.   Указав  в  списке
code1...  локальный  адрес  с  ACTIVE  можно проверить
наличие активного доступа.

     Системный вызов

    status = sdstat(sd)

возвращает состояние локального адреса  S-объекта  sd:
это  может  быть:  SD_FREE - локальный адрес свободен,
SD_REC - локальный  адрес  зарезервирован  для  приема
доступов  (см.  receive),  SD_TEMP  -  локальный адрес
содержит временные доступы, или  SD_STAB  -  локальный
адрес содержит постоянные доступы.

3.2.4.  Запросы и передача доступов

     Запрос к S-объекту выставляется при помощи следу-
ющей последовательности действий:

1)   системным вызовом request создается C-транзакция;

2)   при помощи dup и  rdup  в  сегменты  C-транзакции
     копируются  доступы  на  аргументы  запроса  и  с
     помощью  системного  вызова  receive  объявляются
     сегменты  C-транзакции для приема доступов от MP-
     объекта;

3)   после этого CP-объект может дождаться  завершения
     транзакции  и  получить код завершения при помощи
     системного вызова waitreply.

     Системный вызов

    ctsd = request(sd, code, nsegs)

создает транзакцию, связанную с S-объектом, на который
указывает  локальный  адрес sd, с кодом запроса code и
                        - 15 -




             Запросы и передача доступов


числом сегментов nsegs. request  возвращает  локальный
адрес новой C-транзакции.

     Для передачи  доступа  от  CP-объекта  MP-объекту
надо  скопировать  этот  доступ в сегмент C-транзакции
системным вызовом dup или rdup, а для  приема  доступа
от  MP-объекта  с  сегментом C-транзакции segsd должен
быть связан выделенный заранее локальный адрес  sd  (в
поле адресов CP-объекта) при помощи системного вызова

    rsd = receive(segsd, sd).

receive в случае успешного завершения возвращает  зна-
чение  sd;  и  до  выполнения  waitreply или до снятия
транзакции этот  локальный  адрес  будет  заблокирован
(т.е. любое обращение к нему приведет к ошибке).  Если
до выполнения receive локальный адрес sd содержал дос-
тупы  на  какой-либо S-объект, он предварительно осво-
бождается (см.  close).

     Системный вызов

    retcode = waitreply(ctsd)

активирует C-транзакцию с локальным адресом ctsd (если
она  еще  не активирована системным вызовом activate),
ждет ее выполнения MP-объектом, освобождает  локальный
адрес  транзакции  и  возвращает  код  завершения этой
транзакции.

3.2.5.  Асинхронные запросы и мультиожидание

     CP-объект может и не ждать  завершения  обработки
запроса  MP-объектом,  а  сразу  продолжить выполнение
после выставления запроса. Для этого он должен активи-
ровать транзакцию системным вызовом

    activate(ctsd)

(ctsd - локальный адрес C-транзакции).

     После активирования C-транзакции доступ к ее сег-
ментам  невозможен.   Дождаться  завершения выполнения
транзакции и освободить ее локальный адрес  можно  при
помощи системного вызова waitreply.

     Если CP-объекту не нужна информация о  завершении
обработки  транзакции  MP-объектом,  он  может  просто
освободить ее локальный адрес системным вызовом close.

     CP-объект может снять запрос (не дожидаясь завер-
шения  его  выполнения MP-объектом) выполнив системный
                        - 16 -




         Асинхронные запросы и мультиожидание


вызов

    cancel(ctsd)

где ctsd - локальный адрес  C-транзакции.   cancel  не
прекращает  обработки  транзакции (если она уже начала
обрабатываться), а только сообщает MP-объекту  о  том,
что  транзакция снята.  Если же транзакция еще не была
выбрана MP-объектом, cancel удалит транзакцию из  оче-
реди.

     После снятия запроса  CP-объект  может  подождать
окончания  ее  обработки  вызовом waitreply или просто
освободить локальный адрес C-транзакции вызовом close.

     Примитив waitreply позволяет  ожидать  завершения
одной  конкретной  транзакции;  если  же  нужно  ждать
завершения одной из множества  активных  C-транзакций,
то нужно использовать системный вызов

    extern sdesc selsd;

    nev = sel(sd1, ..., 0l)
или
    nev = selv(sdlist)

где sd1... - локальные адреса (в данном  случае  -  C-
транзакций)  или  (для selv) sdlist - массив локальных
адресов, заканчивающийся 0.

     sel ожидает, пока не возникнет событие (в  данном
случае  -  пока  не  завершится одна из транзакций), а
затем  возвращает  порядковый  номер  элемента  списка
локальных  адресов  (начиная с 1), с которым было свя-
зано событие.  Во внешнюю переменную  selsd  при  этом
записывается  локальный адрес транзакции (или объекта,
см. далее), с которым было связано событие.

     Просто проверить наличие события  (без  ожидания)
можно при помощи системного вызова

    nev = asel(sd1, ..., 0l)
или
    nev = aselv(sdlist).

В отличие от системного вызова sel, в случае,  если  в
момент  выполнения  asel  еще  не  произошло ни одного
события (не завершена ни одна  из  указанных  транзак-
ций),  asel  немедленно  возвращает  нулевое значение.
Если не было событий,  то  asel  записывает  локальный
адрес 0 в переменную selsd.

                        - 17 -




         Асинхронные запросы и мультиожидание


     Иногда нужно прерывать функционирование P-объекта
в  момент  возникновения какого-либо события и переда-
вать управление на подпрограмму обработки этого  собы-
тия.  Установить  "ловушку"  для  прерывания можно при
помощи системного вызова

    trap(handler, sd1, ..., 0l)
или
    trapv(handler, sdlist).

Аргументы trap аналогичны аргументам sel кроме handler
-  адреса  процедуры  обработки прерывания. В качестве
первого аргумента процедуре handler будет передаваться
порядковый  номер  элемента  списка, с которым связано
прерывание, а в качестве  второго  -  локальный  адрес
(аналогично  использованию  переменной  selsd в вызове
sel).

     У  каждого  P-объекта  может  быть  только   одна
ловушка  для  прерываний, повторное использование сис-
темного вызова trap отменяет ранее установленную реак-
цию на прерывание.

     На время выполнения критических  секций  программ
прерывания можно запрещать (а потом разрешать) систем-
ным вызовом

    oldflag = enbint(flag)

где flag должен быть равен  0,  если  нужно  запретить
прерывания, и 1 - если нужно разрешить. enbint возвра-
щает старое значение флага разрешения обработки преры-
ваний.

3.2.6.  Выборка транзакций MP-объектом

     Если в списке аргументов  системного  вызова  sel
указан  локальный адрес, содержащий активный доступ на
S-объект, sel будет прекращать ожидание по выставлению
запроса  к этому S-объекту по одному из видов активных
доступов.  Аналогично  можно  использовать   системный
вызов asel.

     Для  того,  чтобы  получить  локальный  адрес  M-
транзакции MP-объекту нужно выполнить системный вызов

    mtsd = accept(sd, &reqcode).

Вызову accept нужно указать sd -  локальный  адрес  S-
объекта,  содержащего  активный  доступ, или локальный
адрес группы (см. далее).  Если к этому S-объекту (или
к  одному из S-объектов в группе) еще не было запросов
                        - 18 -




            Выборка транзакций MP-объектом


подходящего вида, accept будет ждать, пока не появится
такой запрос.  После выборки запроса accept возвращает
локальный адрес M-транзакции, а в  reqcode  записывает
номер  запроса (номер элемента списка кодов запросов в
системном вызове create, которым был  создан  этот  S-
объект).

     После выполнения запроса MP-объект  должен  сооб-
щить  CP-объекту код завершения транзакции[14] систем-
ным вызовом

    reply(mtsd, retcode).

reply освобождает локальный адрес M-транзакции mtsd  и
передает в качестве кода ее завершения retcode.

     Для ожидания  (или  проверки)  снятия  какой-либо
транзакции  можно  использовать  системный  вызов  sel
(asel); для этого в  списке  ожидаемых  событий  нужно
указать  локальный  адрес  M-транзакции.   Это событие
будет выбираться вызовом sel до тех  пор,  пока  обра-
ботка этой M-транзакции не будет завершена.

     MP-объект может получить некоторую  информацию  о
транзакции при помощи вызова trstat.

/* типы сегментов транзакции (возвращается segty) */
#define RF_NULL 0       /* пустой сегмент */
#define RF_REC  1       /* CP --> MP */
#define RF_SEND 2       /* CP <-- MP */

/* макро для разборки поля формата транзакции */
#define segty(fmt, segno)  (((fmt)>>(2*(segno)))&3)

/* структура для записи инфорации о транзакции */
struct trstat {
    sdesc  tf_sd /* лок. адрес активного доступа */
    short  tf_code /* номер запроса (см. accept) */
    short  tf_nseg /* число сегментов */
    short  tf_fmt/* формат транзакции */
} status_info;

Системный вызов

    trstat(mtsd, &status_info)

записывает   информацию   о   M-транзакции,   заданной
____________________
   [14] Код завершения должен быть четырехбайтовым це-
лым числом.


                        - 19 -




            Выборка транзакций MP-объектом


локальным адресом mtsd в  память,  заданую  аргументом
status_info.   формат транзакции - это набор двухбито-
вых полей, каждое из  которых  соответствует  сегменту
транзакции. Тип сегмента транзакции может быть RF_SEND
(в сегмент C-транзакции был скопирован доступ  систем-
ным  вызовом  dup),  RF_REC  (сегмент C-транзакции был
зарезервирован для приема доступа от  MP-объекта  сис-
темным  вызовом receive) или RF_NULL.  Если транзакция
снята CP-объектом, то в поле tr_code записывается зна-
чение

    CANCELED | код запроса.


     Если локальный адрес  содержит  активные  доступы
некоторых видов и другой P-объект уничтожает последний
пассивный доступ из этих видов на  этот  объект,  ядро
системы  создает  специальную транзакцию (без аргумен-
тов) с кодом REQ_CLOSE и связывает ее с этим локальным
адресом.   После  выборки и закрытия M-транзакции сис-
темным вызовом reply эта транзакция  просто  уничтожа-
ется.

3.2.7.  Группы

     Группы не являются  базовым  понятием  системы  и
предназначены исключительно для удобства использования
системноых вызовов sel, asel и accept.  Группа  предс-
тавляет  собой множество локальных адресов собственных
S-объектов, C- или M-транзакций (т.е. адресов, с кото-
рыми  могут  быть  связаны  события).  Если  в  списке
локальных адресов sel или asel будет  указана  группа,
эти  системные  вызовы будут задерживать выполнение до
появления события, связанного  с  одним  из  локальных
адресов  в  этой  группе.   Если  вызову  accept задан
локальный адрес группы, то он выберет M-транзакцию  от
одного  из  локальных  адресов  собственых S-объектов,
входящих в эту группу.

     При возникновении события, связанного с одним  из
локальных адресов, входящих в группу, системные вызовы
sel и asel запишут  в  переменную  selsd  именно  этот
локальный адрес, а не локальный адрес группы.

     Новую группу можно создать системным вызовом

    grpsd = newgroup(),

который возвращает локальный адрес группы.

     Добавление локальных адресов в группу и  удаление
из нее производится системными вызовами
                        - 20 -




                        Группы


    insgrp(grpsd, sd1, ..., 0l)
    insgrpv(grpsd, sdlist)
и
    delgrp(grpsd, sd1, ..., 0l)
    delgrpv(grpsd, sdlist),

где grpsd -  локальный  адрес  группы,  а  sd1...  или
sdlist  -  список  локальных  адресов  собственных  S-
объектов и C-транзакций. Если в списке указан  локаль-
ный адрес группы, то будет произведена операция сложе-
ния или вычитания множеств локальных адресов.

     Группа уничтожается при помощи системного  вызова
close;  и  не  может  быть передана другому P-объекту.
Если локальный адрес, входящий в  одну  или  несколько
групп, освобождается, он будет автоматически удален из
всех групп.

3.2.8.  Проверка ключей

     Для аутентификации P-объектов - авторов  запросов
можно  передавать  неподделываемые ключи вместе с дру-
гими аргументами запросов.  В  качестве  таких  ключей
используются S-объекты, а для проверки истинности клю-
чей можно использовать системные вызовы

    fair = eqobj(sd1, sd2)
и
    fair = eqowner(sd1, sd2).

eqobj возвращает истину если оба локальных адреса  sd1
и  sd2 укаывают на один и тот же S-объект, а eqowner -
если они принадлежат одному P-объекту.

     Для  использования  ключа  не  требуется  наличия
каких-либо  доступов  на  этот S-объект; однако обычно
S-объекты,  используемые  в  качестве  ключей,   могут
выполнять  запросы  вроде  "выдать  имя  пользователя"
и.т.п.

3.3.  Некоторые стандартные протоколы

     Стандартные протоколы делятся на две категории  -
базовые  стандартные протоколы (реализованные апаратно
или в ядре системы) и другие.  Набор базовых  протоко-
лов  может изменяться в зависимости от реализации сис-
темы или аппаратной среды. На  машинах  с  класической
фон-Неймановской  архитектурой есть два базовых прото-
кола:  протокол  памяти  и  протокол   управления   P-
объектами. (Это, по сути, отражает архитектуру машины,
содержащей отдельно процессор (на котором  реализуются
P-объекты, которыми можно управлять) и память (которая
                        - 21 -




           Некоторые стандартные протоколы


рассматривается как P-объект, которому принадлежат  S-
объекты с протоколом памяти)).

3.3.1.  Протокол памяти

     Протокол памяти включает в себя следующие запросы
(далее  S-объект,  имеющий протокол памяти, к которому
выставляются   запросы   будет   именоваться    просто
памятью):

MEM_READ
        - копирование содержимого памяти  в  указанный
          объект с протоколом памяти;

MEM_WRITE
        - копирование из указанного объекта в память;

MEM_SUB - создание  нового  S-объекта   с   протоколом
          памяти, являющегося частью памяти;

MEM_EXPAND
        - изменение границ адресов доступной памяти;

MEM_INFO
        - выдача информации о памяти (начальный  адрес
          и длина);

MEM_NEW - создание нового участка памяти (этот запрос,
          собственно,  не  входит  в протокол памяти и
          применяется к  объекту  -  входу  подсистемы
          управления памятью).

     Поскольку доступ от процессора к памяти  реализо-
ван  аппаратно, необходима возможность выделять подоб-
ласти прямо доступной процессору памяти  для  передачи
аргументов  запросов  с  протоколом  памяти. Это можно
сделать с помощью примитивов

    newsd = m_read(sd, addr, len)
    newsd = m_write(sd, addr, len)
    newsd = m_update(sd, addr, len),

которые создают доступ на часть прямо  доступной  про-
цессору  памяти  и записывают его в локальный адрес sd
(sd также возвращается в newsd), при этом подразумева-
ется сегмент памяти длиной len байтов, расположенный с
адреса addr математической памяти  P-объекта.  m_read,
m_write  и  m_update создают S-объекты с доступами для
чтения, записи и чтения/записи памяти соответственно.

     Эти вызовы не входят в набор общесистемных прими-
тивов, однако их реализация при помощи этих примитивов
                        - 22 -




                   Протокол памяти


требует  имитации  работы  аппаратуры,   преобразующей
математические  адреса  памяти  в  физические, а также
обращения к таблице сегментов памяти, прямо  доступных
данному P-объекту, что может быть неэффективным и дос-
таточно сложным.   Таким  образом,  эти  вызовы  можно
рассматривать  как  программную реализацию недостающей
функции протокола аппаратного обмена  процессор-память
на машинах с фон-Неймановской архитектурой.

3.3.2.  Управление P-объектами

     Протокол управления  P-объектами  также  является
базовым протоколом, т.е. требует или аппаратной реали-
зации или программной поддержки в ядре системы.  Набор
операций протокола управления P-объектами можно разде-
лить на три группы:

1)   Создание P-объектов.  В конкретной вычислительной
     среде может вообще не быть способа создания новых
     P-объектов (например,  это  не  нужно  в  системе
     управления  автоматическим манипулятором). Созда-
     ние P-объекта на машине традиционной  архитектуры
     происходит в несколько стадий: сначала собственно
     создается  P-объект,  функционирование   которого
     приостановлено; затем ядро системы передает унас-
     ледованные от старого  P-объекта  доступы;  после
     этого создаются S-объекты с протоколом памяти и в
     них копируются команды  и  начальные  данные  для
     работы  процесса; эти S-объекты объявляются прямо
     доступными новому P-объекту и (наконец)  разреша-
     ется функционирование этого P-объекта.

2)   Управление  функционированием  P-объектов.    Эта
     группа  операций  должна  содержать такие функции
     как: приостановка и продолжение  функционирования
     P-объекта,   объявление  S-объекта  с  протоколом
     памяти как прямо доступной памяти  P-объекта  (на
     фон-Неймановских  машинах),  изменение  и  чтение
     атрибутов P-объекта  (приоритета,  идентификатора
     пользователя и т.д.), уничтожение P-объекта.

3)   Трассировка, эмуляция системных  вызовов,  вирту-
     альные  машины.   Отдельная группа операций пред-
     назначена для имитации аппаратной  или  системной
     среды  для  программы,  выполняющейся P-объектом.
     Сюда могут входить перехват программных  прерыва-
     ний,   пошаговое   выполнение,   перехват  команд
     ввода/вывода.

     Использование перехвата специальных команд внутри
     объект-ориентированой  системы  фактически позво-
     ляет реализовать  независимые  (и  несовместимые)
                        - 23 -




                Управление P-объектами


     операционные среды без значительной потери эффек-
     тивности, свойственой системам виртуальных машин.
     Кроме  того,  такие среды не оказываются изолиро-
     ванными одна от другой, т.е. возможно  комбиниро-
     вание  разнородных програмных средств, работающих
     в разных операционных средах.

     Протокол управления P-объектами может  существено
изменяться в зависимости от назначения конкретной сис-
темы и архитектуры вычислительной установки; в настоя-
щее  время такой протокол разработан только для цифро-
вых машин с последовательным выполнением команд.

3.3.3.  Протокол файлов

     Протокол  файлов  является  надпротоколом  памяти
(т.е.  возможно  использование  файлов  как адресуемой
памяти) и кроме операций из протокола памяти  содержит
установку указателя чтения/записи и установку и чтение
атрибутов файла (владельца, кодов доступа и т.п.).

     Операция установки указателя чтения/записи  может
быть  модифицирована с тем, чтобы устанавливать указа-
тель не по номеру байта, а  по  ключу,  что  позволяет
естественным образом организовать встроенную базу дан-
ных.

     Собственно, файл на диске  не  является  объектом
D3,  т.к.  он  находится "внутри" файловой системы; S-
объектом является открытый (активный) файл.

3.3.4.  Протокол каталогов

     Каталоги в D3 (в отличие от Unix) недоступны  для
прямого  чтения, что позволяет сделать компоненты сис-
темы независимыми  от  структуры  конкретной  файловой
системы. В набор операций протокола каталогов входят:

1)   чтение каталога;

2)   выборка объекта по имени или по позиции из  ката-
     лога, эта операция должна вернуть доступ на новый
     S-объект, соответствующий открытому файлу;

3)   быстрая проверка существования объекта с заданным
     именем в каталоге;

4)   создание нового файла указанного типа;

5)   уничтожение входа каталога;


                        - 24 -




                  Протокол каталогов


6)   связывание входа каталога с открытым файлом;

7)   установка и чтение атрибутов каталога.

     Протокол каталогов может использоваться не только
для  работы  с файловыми системами на дисках. Возможно
использование протокола  каталогов  для  представления
любого  глобального адресного пространства (это облег-
чается тем, что  имя  входа  каталога  не  обязательно
является текстом; имена задаются просто последователь-
ностью байтов и длиной этой последовательности).

     В функции протокола каталогов  обычно  не  входит
разбор  компонентов  составного  имени в иерархических
файловых системах. Это может быть сделано  при  помощи
применения  протокола  каталогов  к стандартным входам
подсистемы разбора имен файлов.  Еще одно  использова-
ние протокола каталогов - создание "псевдокаталогов" с
результатом расширения (globbing) шаблонов  имен  фай-
лов.

3.4.  Реализация ядра на фон-Неймановских машинах

     В функции ядра на  машинах  с  традиционной  фон-
Неймановской  архитектурой кроме интерпретации систем-
ных вызовов входит также реализация базовых протоколов
памяти  и  управления  P-объектами.   Кроме того, ядро
должно предоставлять драйверам интерфейс к  аппаратным
регистрам  внешних  устройств  и  системе  прерываний.
Возможна также имитация аппаратной среды, более подхо-
дящей  к архитектуре системы, чем имеющаяся (так, нап-
ример, было сделано  при  переносе  системы  ДЕМОС 1.3
(аналог   системы   Unix)   на   советскую   супер-ЭВМ
Эльбрус-Б).

     Обычно   использование   объектно-ориентированной
архитектуры   подразумевает  выполнение  ассоциативных
поисков в глобальном пространстве имен.  Использование
исключительно  локальной  адресации  позволяет  вообще
обойтись без длинных циклов в ядре системы, т.е.   все
части ядра системы могут работать при полностью закры-
тых прерываниях  (кроме,  конечно,  особых  случаев  с
аппаратурой,  требующей очень маленького времени реак-
ции).  Таким образом, ядро D3 может быть не  реентера-
бельным,  а просто состоять из обработчиков прерываний
от системных вызовов и устройств, что значительно  его
упрощает.  (Кстати,  это  также  значительно облегчает
реализацию ядра для многопроцессорных машин.)

     Значительная часть времени процессора в системной
фазе  уходит на перепланирование процессора и переклю-
чение контекстов,  поэтому  в  макетной  реализции  D3
                        - 25 -




     Реализация ядра на фон-Неймановских машинах


использован  алгоритм  планировщика  с несколькими (по
числу приоритетов) кольцевыми списками.

     Реализация S-объектов с протоколом  памяти  также
требует  повышенного внимания с точки зрения эффектив-
ности.  Целесообразно  вместо  передачи  доступов   на
небольшие участки памяти (до нескольких десятков слов)
просто их  копировать.  (Это  может  быть  реализовано
внутри  ядра системы без изменения внешних интерфейсов
ядра).

4.  Распределенные системы

     Существуют два основных типа распределенных  сис-
тем: тесно связаные и слабо связанные.

     Применительно к D3 тесно связанные распределенные
системы  отличаются тем, что все процесоры в этой сис-
теме имеют  общее  однородное  пространство  объектов;
т.е.  любой P-объект потенциально может взаимодейство-
вать с любым другим  без  каких-либо  ограничений.   С
точки  зрения каждого P-объекта такая система ничем не
отличается от системы, работающей на  однопроцессорной
машине.    Алгоритмы,   обеспечивающие  взаимодействие
физических устройств в такой системе, должны быть реа-
лизованы  в  ядре.  Надо  отметить,  что, в отличие от
Unix, это не представляет собой проблемы, т.к. ядро D3
может  быть  реализовано  как  нереентерабельное  (см.
выше). Кроме того, в архитектуре D3  нет  нет  никаких
генераторов  уникальных чисел (вроде номеров процессов
и т.п.).

     Для  реализации  слабо  связанных  распределенных
систем   может  быть  использована  техника  объектов-
"теней". Для каждой связи между  системами  существует
объектов:  собственно  S-объект, выполняющий запросы и
его "тень" на удаленой  машине.   Поскольку  D3  имеет
мультиожидание,  не  требуется  создавать  для каждого
участвующего в сетевом  траффике  P-объекта  создавать
"затычки"  (stubs)  на удаленных машинах, т.к. сетевая
подсистема может имитировать любые протоколы.



    (CP-объект) ----> (S) ----> (сетевая подсистема)
                     тень               ||
  машина A                              ||
- - - - - -          - - - - - -        ||    - - - - - -
  машина B                              ||
                                        ||
    (MP-объект) <---- (S) <---- (сетевая подсистема)

                        - 26 -




                Распределенные системы


     Кроме создания и  обслуживания  теней  процессов,
сетевая подсистема должна выполнять функции согласова-
ния протоколов, т.е. замены типизующих S-объектов уда-
ленной  машины  на  соответствующие  им  типизующие S-
объекты локальной машины, и функции согласования  клю-
чей, т.е. замены ключей с одновременной проверкой пол-
номочий для удаленного доступа.

     Естественно, возможны гибридные  схемы  работы  в
сетях. Так, например, подсистема спулинга печати может
не пересылать запросы на вывод на  АЦПУ  на  удаленную
машину,  а просто собрать весь вывод в файл и передать
его.  Другой вариант: ограничить взаимодействие систем
только  протоколами  файлов  и каталогов, т.е. уровнем
сетевой файловой системы.

5.  Сравнение регулярной  архитектуры  с  традициоными
архитектурами

     Несомненным достоинством  регулярной  архитектуры
D3 является ее простота[15].  Простота набора примити-
вов системы позволяет формально доказать полноту этого
набора с точки зрения  возможности  реализации  произ-
вольных  схем защиты системы, любой организации адрес-
ных пространств и любой схемы синхронизации процессов;
однако  проведение  такого исчерпывающего математичес-
кого доказательства не входило в цели авторов проекта.

     Абстрагирование  базовых  концепций  системы   от
конкретных  способов  обработки  и передачи информации
значительно расширяет класс аппаратных средств, допус-
кающих использование реализации D3; основной проблемой
остается возможность достаточно эффективной реализации
такой  системы.   При  проектировании системы основное
внимание уделялось возможности эффективной  реализации
на  машинах с классической фон-Неймановской архитекту-
рой и на транспьютерах[16].

     Главной  трудностью  реализации  пользовательской
среды  в D3 представляется необходимость четкого выде-
ления функций в отдельные модули, что требует тщатель-
ного  планирования  всего  программного  комплекса;  с
____________________
   [15] Malek's Law: "Any simple idea will  be  worded
in the most complicated way" [SIC].
   [16] Впрочем, одним из "тестовых" примеров аппарат-
ной  среды была вычислительная машина, в которой новый
процесс порождается физическим добавлением нового про-
цессора (при помощи чего-либо вроде управляемого мани-
пулятора).


                        - 27 -



Сравнение регулярной архитектуры с традициоными архитектурами


другой стороны, архитектура D3 позволяет  одновременно
эксплуатировать на одной вычислительной установке раз-
ные версии  программных  комплексов  (в  том  числе  и
таких, как сетевые службы, драйверы устройств и файло-
вые системы), что должно облегчить  переход  на  новые
версии программ.

     Системы  с  регулярной  архитектурой  могут  быть
использованы  не  только на вычислительных комплексах,
но и в автоматических контроллерах, системах  аналого-
цифровой  обработки информации (например, для управле-
ния обработкой  и  передачей  телевизионных  программ,
управления телефонными станциями и т.п.).

     функциональная полнота схемы защиты D3  позволяет
организовать    эффективную   систему   предотвращения
несанкционированных доступов и  локализации  нарущений
защиты.    Жесткая  модульность  системы  также  очень
полезна для создания управляющих комплексов повышенной
надежности.

6.  Состояние работ и дальнейшее развитие

     Работы по проектированию D3 ведутся около четырех
лет, за это время были проверены на макетах пять вари-
антов системы, что позволило заметить многие подводные
камни еще на этапе проектирования архитектуры системы.
Кроме того, был проведен теоретический анализ  полноты
системы  и выработаны критерии для проектирования сис-
темы.

     В настоящее время реализован макет шестой  версии
ядра  D3,  работающий под управлением операционой сис-
темы ДЕМОС 2.2 (советский аналог Unix,  совместимый  с
BSD и System V) на PDP-11.  Макет ядра системы написан
на C, объем исходного текста - 4000 строк.

     На стадии  рабочего  проекта  находится  файловая
система  и  подсистема  терминального  ввода-вывода. В
первую очередь в D3 будет  реализован  полномасштабный
имитатор системы Unix.

     К сожалению, работы ведутся отнюдь не так быстро,
как это было бы возможно; это связано в первую очередь
с тем, что основная деятельность авторов D3 состоит  в
разработке,  развитии и маркетинге операционных систем
семейства   ДЕМОС[17]   для   аппаратуры    советского
____________________
   [17] ДЕМОС - торговая  марка  кооператива  demos/*,
СССР.


                        - 28 -




        Состояние работ и дальнейшее развитие


производства; кроме того, разработка промышленной опе-
рационной  систеы  требует  больших вложений со значи-
тельным риском.

     Кроме конструирования операционных систем, анало-
гичный  подход  может  быть использован для построения
объектно-ориентированных языков, сейчас ведутся работы
по конструированию такого языка.

Благодарности

     Многие идеи, легшие в основу проекта D3,  принад-
лежат Л.А. Егошину; без его участия эта работа была бы
невозможна.  Очень много дало мне  обсуждение  идей  и
концепций      с      Д.В. Бурковым,     В.В Бардиным,
Д.В. Володиным,    С.А. Аншуковым,    А.А. Левочкиным,
А.П. Рудневым  и  М.И. Давидовым.   Я также благодарен
всем своим друзьям и коллегам по  кооперативу  demos/*
за всестороннюю поддержку этой работы.
