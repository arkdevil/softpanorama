From csoft!L-usenet%cs.kiev.ua Sat Oct 17 16:14:25 UKR 1992
Received:  by softp.kiev.ua (UUPC/@ Release 3.00/fossil/28Oct91);
           Sat, 17 Oct 1992 16:14:25 UKR
X-Class: Slow
To: netters
Sender: L-usenet@cs.kiev.ua
Newsgroups: comp.software-eng
From: lum@leland.stanford.edu (Benjamin Lai)
Subject: [NEWS] Writing Computer Programs by Direct Manipulation of Data Structures
Message-ID: <1992Oct12.054820.8801@leland.Stanford.EDU>
Organization: DSO, Stanford University
Date: Mon, 12 Oct 92 05:48:20 GMT
Status: R

Keywords: visual programming programming-by-example novel user interface


Help!

My name is Ben Lai.  I'm a second-year Master's student in computer
science at Stanford University.  I have some ideas for a research
project to do for this year -- a program I'd like to write -- but,
since I'm a Masters student, AND I'd like to work on MY idea
SPECIFICALLY, AND I missed the deadlines for various fellowships,
I'll be hard put to find any funding for these ideas.  Plus, I
don't really know how valuable they are, or how practical, so I'd
like a lot of feedback from many people.  Can you help me out
somehow?  It could be suggestions on who to talk to, papers to
read, angles to think around the problem, code to donate, or ideas
for funding. And, of course, responses to my ideas.

So if anybody has insomnia or some other reason for killing some
time, you can take a look at my proposal (below), and mull it over
a little bit.  My idea is pretty much to:

_______\    Create a user interface for manipulating data   /_____
       /   structures as a way to write computer programs.  \

If you're interested, you can read the elaboration below.  Thanks!

-Ben

                                                Benjamin Lai
                                                MSCS
                                                Stanford University
                                                September 29, 1992


        A User Interface for Writing Computer Programs

Before the advent of WYSIWIG word processors, people hadn't
realized that the work they were doing to format their documents
could have been done by a computer;  moreover, perhaps people did
not believe that a standardized, visually appealing *simulation of
paper* would give them as much freedom and power as an extensible
text formatting language.  People may not have realized how much
better a computer would have been for the housekeeping chores
required in text formatting.

I feel that computer programming is in the same relation to the
next programming environment as TeX is to MacWrite.  I believe that
similar housekeeping chores occur in computer programming as in
text formatting; perhaps there are even more chores in programming.

I'd like to write a USER INTERFACE FOR COMPUTER PROGRAMMING.  What
does that mean?  It means a user interface for common data
structures in computer programs, such as lists, stacks, trees,
graphs, tables, graphics objects, database objects, user interface
objects, and the basic operations performed on each of these types
of objects.  To my knowledge, no such thing as yet exists on the
market or off;  there are very fancy debuggers that will interpret
C code and show variable values, there are nice demo programs for
"visualizing algorithms", and there are many many different visual
languages in research labs trying to capture the essence of
computer programs in icons. But there does not exist a system which
allows computer programmers to manipulate lists as typists
manipulate paragraphs;  to map and transform vectors as accountants
manipulate spreadsheets;  to draw and arrange trees as architects
draw and arrange blueprint layouts in AutoCad.  Or, at least, there
is no one system which does all of the above, together, AND is
integrated into a full programming environment.  (Is there?)

Some very common functions for various data types, such as sorting,
searching, and mapping lists, tables, and trees, will be in the
menus of this user interface.  The data structures themselves may
be represented as tables, graphs, or dialog boxes in a window.  The
functions that the programmer writes might also be dialog boxes
with multiple fields, or buttons, dials, or switches.  The idea is
to let programmers manipulate data DIRECTLY, and demonstrate to the
computer how to perform a certain function, by his or her actions.
This may involve some primitive forms of inferencing and/or
programming-by-example.

Such a programming user interface would not only allow much easier
debugging and data structure management, but would also free people
from having to keep much abstraction in their heads and allow them
to see their algorithms better. Having a visual component as well
as a text component to programs appeals to more of one's mental
faculties.  Some non-programmers may be attracted by the clarity
and intrinsically didactic nature of the user interface, and their
subsequent programming will also be easier.  This user interface
may lead to more end-user programming.

Along such lines, I would like to write a PROGRAM PLAYBACK SYSTEM
integrated with the programming user interface, in the VCR
paradigm, which will allow the programmer to execute code and watch
what it does, how it works, why it's necessary.  Since all data
structures are visible entities in this system, every single line
of code does something;  no functionality is hidden.  As a former
computer programmer for a small start-up software company, I
realized that code is read far, far more than it is written.
Documentation is of utmost importance, and yet, code is often, if
not almost always, rewritten because someone does not wish to spend
the long hard hours understanding someone else's code.  This may be
the single most unproductive feature of modern computer
programming, for the excellent work of good programmers is done
thousands of times over -- every year!  I, for one, do not believe
that that is an intrinsic property of software engineering.

The problem is the abstract nature of text.  People are not willing to
share each other's code, no matter how well-written, because there
are enormous comprehension barriers in reading code -- perhaps
greater than in writing it.  This is also part of the motivation
for a better way to "see" code.

There are other aspects I would LIKE to include in such an
interface, including a semi-intelligent "inference engine" which
can deduce what a programmer would like to do based on one or two
examples;  this is similar to Brad Myers' Peridot paradigm (1), but
it would operate not only on user interface objects but on all data
structures.  For example, if you want to decrement every number in
a linked list of numbers by 1, you simply decrement the first
number in the list, then the second, and then the computer
recognizes a pattern in your actions and asks if you would like to
do the entire list.

Another useful idea to marry to the main one is the idea of a
readily modifiable user interface, one that can be demonstrated as
in Peridot, which would allow programmers AND USERS to modify user
interface independent of the program's function.  Modify, meaning
invent, create, change, destroy, make prettier, faster, more
intuitive.  Allowing users to see the scaffolding behind the
objects may empower them even more.  User interface objects have
the potential of controlling as much information at a time as
people are inventive; machines, cartoon characters and other wild
ideas have been barely touched upon for their potential to
manipulate information.  If user interface design were taken to the
users themselves, a whole new world can be opened up.

Any thoughts on these ideas, any wild angles, or the names of any
programs (or people) that already do all this would be welcomed
tremendously!

Please send email to lum@leland.stanford.edu.

References:

1. __Creating_User_Interfaces_by_Demonstration__, by Brad A. Myers.
   Academic Press, Boston, 1988.

