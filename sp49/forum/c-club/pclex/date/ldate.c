#define YY_DEFAULT_ACTION ECHO;
#define FLEX_USE_ECS
#define FLEX_USE_MECS
/* A lexical scanner generated by flex */

#include "flexsdef.h"

# line 1 "ldate.l"
#define INITIAL 0
/*
     ABRAXAS SOFTWARE, PCLEX example

     ldate.l - lexical analyzer for date program

     this example program is from July 1978, Bell System Tech. Journal
     "Language develoment tools", pp.2155 by Johnson and Lesk.
     We believe this is an excellent example of the "marriage" 
     between PCYACC and PCLEX.
*/
# line 15 "ldate.l"

#include "ydate.h" /* from pcyacc (-D), token types + YYSTYPE */

#define MON(x) { yylval.in = x; return( MONTH ); }

# line 22 "ldate.l"
#define YY_JAM 75
#define YY_JAM_BASE 97
#define YY_TEMPLATE 76
static char l[76] =
    {   0,
       -2,   -2,   16,   14,   15,   13,   16,   16,   16,   16,
       16,   16,   16,   16,   14,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    4,    8,   12,    2,    1,
        7,    6,    3,    5,   11,   10,    9,    4,    0,    8,
        0,   12,    0,    2,    0,    1,    0,    7,    6,    3,
        0,   11,    0,   10,    0,    9,    9,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0
    } ;

static char e[128] =
    {   0,
        1,    1,    1,    1,    1,    1,    1,    1,    2,    3,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    2,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    4,    1,    5,    5,    5,
        5,    5,    5,    5,    5,    5,    5,    1,    1,    1,
        1,    1,    1,    1,    6,    1,    1,    7,    1,    8,
        1,    1,    1,    9,    1,    1,   10,   11,   12,    1,
        1,    1,   13,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,   14,   15,   16,    1,

       17,    1,   18,   19,   20,    1,    1,   21,   22,   23,
       24,   25,    1,   26,   27,   28,   29,   30,    1,    1,
       31,    1,    1,    1,    1,    1,    1
    } ;

static char m[32] =
    {   0,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1
    } ;

static short int b[77] =
    {   0,
        0,   12,   97,   95,   97,   97,    1,   79,   78,    2,
       80,   69,   76,   74,   88,   63,   70,   71,   71,   62,
        6,    2,   54,   55,   57,   28,   30,   32,   31,   33,
       34,   35,   37,   97,   38,   39,   36,   97,   60,   97,
       53,   97,   57,   97,   64,   97,   63,   97,   97,   97,
       57,   97,   53,   97,   59,   97,   40,   45,   57,   45,
       44,   54,   51,   45,   49,   30,   27,   39,   28,   36,
       24,   21,   29,   19,   97,    0
    } ;

static short int d[77] =
    {   0,
       76,   76,   75,   75,   75,   75,   75,   75,   75,   75,
       75,   75,   75,   75,   75,   75,   75,   75,   75,   75,
       75,   75,   75,   75,   75,   75,   75,   75,   75,   75,
       75,   75,   75,   75,   75,   75,   75,   75,   75,   75,
       75,   75,   75,   75,   75,   75,   75,   75,   75,   75,
       75,   75,   75,   75,   75,   75,   75,   75,   75,   75,
       75,   75,   75,   75,   75,   75,   75,   75,   75,   75,
       75,   75,   75,   75,-32767,   75
    } ;

static short int n[129] =
    {   0,
        3,    4,    5,   75,    6,    7,    8,    9,   10,   11,
       12,   13,   14,    4,    5,   20,    6,    7,    8,    9,
       10,   11,   12,   13,   14,   16,   31,   33,   32,   17,
       21,   38,   34,   40,   44,   42,   46,   48,   49,   56,
       50,   52,   54,   56,   56,   74,   52,   39,   43,   42,
       73,   49,   51,   54,   53,   72,   64,   46,   41,   45,
       44,   47,   55,   57,   48,   71,   70,   69,   68,   67,
       66,   65,   40,   63,   62,   50,   61,   60,   59,   58,
       38,   37,   36,   35,   30,   29,   28,   27,   26,   15,
       25,   24,   23,   22,   19,   18,   15,   75,   75,   75,

       75,   75,   75,   75,   75,   75,   75,   75,   75,   75,
       75,   75,   75,   75,   75,   75,   75,   75,   75,   75,
       75,   75,   75,   75,   75,   75,   75,   75
    } ;

static short int c[129] =
    {   0,
       76,    1,    1,    0,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    2,    2,   10,    2,    2,    2,    2,
        2,    2,    2,    2,    2,    7,   21,   22,   21,    7,
       10,   26,   22,   27,   29,   28,   30,   31,   32,   37,
       33,   35,   36,   57,   74,   73,   72,   26,   28,   71,
       70,   32,   33,   69,   35,   68,   57,   67,   27,   29,
       66,   30,   36,   37,   31,   65,   64,   63,   62,   61,
       60,   59,   58,   55,   53,   51,   47,   45,   43,   41,
       39,   25,   24,   23,   20,   19,   18,   17,   16,   15,
       14,   13,   12,   11,    9,    8,    4,   75,   75,   75,

       75,   75,   75,   75,   75,   75,   75,   75,   75,   75,
       75,   75,   75,   75,   75,   75,   75,   75,   75,   75,
       75,   75,   75,   75,   75,   75,   75,   75
    } ;


/* these declarations have to come after the section 1 code or lint gets
 * confused about whether the variables are used
 */
FILE *yyin = stdin, *yyout = stdout;

/* these variables are all declared out here so that section 3 code can
 * manipulate them
 */
static int yy_start, yy_b_buf_p, yy_c_buf_p, yy_e_buf_p;
static int yy_saw_eof, yy_init = 1;

/* yy_ch_buf has to be 1 character longer than YY_BUF_SIZE, since when
 * setting up yytext we can try to put a '\0' just past the end of the
 * matched text
 */
static char yy_ch_buf[YY_BUF_SIZE + 1];
static int yy_st_buf[YY_BUF_SIZE];
static char yy_hold_char;
char *yytext;
static int yyleng;

YY_DECL
    {
    int yy_n_chars, yy_lp, yy_iii, yy_buf_pos, yy_act;

#ifdef FLEX_REJECT_ENABLED
    int yy_full_match;
#endif




    if ( yy_init )
	{
	YY_INIT;
	yy_start = 1;
	yy_init = 0;
	}

    goto get_next_token;

do_action:

#ifdef FLEX_REJECT_ENABLED
    /* remember matched text in case we back up due to trailing context */
    yy_full_match = yy_c_buf_p;
#endif

    for ( ; ; )
	{
	YY_DO_BEFORE_ACTION

#ifdef FLEX_DEBUG
	fprintf( stderr, "--accepting rule #%d\n", yy_act );
#endif
	switch ( yy_act )
	    {
case 1:
# line 24 "ldate.l"
MON(1);
	YY_BREAK
case 2:
# line 25 "ldate.l"
MON(2);
	YY_BREAK
case 3:
# line 26 "ldate.l"
MON(3);
	YY_BREAK
case 4:
# line 27 "ldate.l"
MON(4);
	YY_BREAK
case 5:
# line 28 "ldate.l"
MON(5);
	YY_BREAK
case 6:
# line 29 "ldate.l"
MON(6);
	YY_BREAK
case 7:
# line 30 "ldate.l"
MON(7);
	YY_BREAK
case 8:
# line 31 "ldate.l"
MON(8);
	YY_BREAK
case 9:
# line 32 "ldate.l"
MON(9);
	YY_BREAK
case 10:
# line 33 "ldate.l"
MON(10);
	YY_BREAK
case 11:
# line 34 "ldate.l"
MON(11);
	YY_BREAK
case 12:
# line 35 "ldate.l"
MON(12);
	YY_BREAK
case 13:
# line 37 "ldate.l"
{
                yylval.in = yytext[0] - '0';

                return( DIGIT );
        }
	YY_BREAK
case 14:
# line 43 "ldate.l"
{       ;                        /* delete blanks */

        }
	YY_BREAK
case 15:
# line 48 "ldate.l"
case 16:
# line 49 "ldate.l"
{
                return( yytext[0] );    /* return single characters */
        }
	YY_BREAK
case 17:
# line 52 "ldate.l"
YY_DEFAULT_ACTION;
	YY_BREAK

case YY_NEW_FILE:
break; /* begin reading from new file */

case YY_END_TOK:
return ( YY_END_TOK );

default:
YY_FATAL_ERROR( "fatal flex scanner internal error" );
	    }

get_next_token:
	{
	register int yy_curst;
	register char yy_sym;

	YY_DO_BEFORE_SCAN

	/* set up to begin running DFA */

	yy_curst = yy_start;

	if ( yy_ch_buf[yy_c_buf_p] == '\n' )
	    ++yy_curst;

	/* yy_b_buf_p points to the position in yy_ch_buf
	 * of the start of the current run.
	 */

	yy_b_buf_p = yy_c_buf_p + 1;

	do /* until the machine jams */
	    {
	    if ( yy_c_buf_p == yy_e_buf_p )
		{ /* need more input */
		if ( yy_e_buf_p >= YY_BUF_LIM )
		    { /* not enough room to do another read */
		    /* see if we can make some room for more chars */

		    yy_n_chars = yy_e_buf_p - yy_b_buf_p;

		    if ( yy_n_chars >= 0 )
			/* shift down buffer to make room */
			for ( yy_iii = 0; yy_iii <= yy_n_chars; ++yy_iii )
			    {
			    yy_buf_pos = yy_b_buf_p + yy_iii;
			    yy_ch_buf[yy_iii] = yy_ch_buf[yy_buf_pos];
			    yy_st_buf[yy_iii] = yy_st_buf[yy_buf_pos];
			    }

		    yy_b_buf_p = 0;
		    yy_e_buf_p = yy_n_chars;

		    if ( yy_e_buf_p >= YY_BUF_LIM )
			YY_FATAL_ERROR( "flex input buffer overflowed" );

		    yy_c_buf_p = yy_e_buf_p;
		    }

		else if ( yy_saw_eof )
		    {
saweof:		    if ( yy_b_buf_p > yy_e_buf_p )
			{
			if ( yywrap() )
			    {
			    yy_act = YY_END_TOK;
			    goto do_action;
			    }
			
			else
			    {
			    YY_INIT;
			    yy_act = YY_NEW_FILE;
			    goto do_action;
			    }
			}

		    else /* do a jam to eat up more input */
			{
#ifndef FLEX_INTERACTIVE_SCANNER
			/* we're going to decrement yy_c_buf_p upon doing
			 * the jam.  In this case, that's wrong, since
			 * it points to the last non-jam character.  So
			 * we increment it now to counter the decrement.
			 */
			++yy_c_buf_p;
#endif
			break;
			}
		    }

		YY_INPUT( (yy_ch_buf + yy_c_buf_p + 1), yy_n_chars,
			  YY_MAX_LINE );

		if ( yy_n_chars == YY_NULL )
		    {
		    if ( yy_saw_eof )
	YY_FATAL_ERROR( "flex scanner saw EOF twice - shouldn't happen" );
		    yy_saw_eof = 1;
		    goto saweof;
		    }

		yy_e_buf_p += yy_n_chars;
		}

	    ++yy_c_buf_p;

#ifdef FLEX_USE_ECS
	    yy_sym = e[yy_ch_buf[yy_c_buf_p]];
#else
	    yy_sym = yy_ch_buf[yy_c_buf_p];
#endif

#ifdef FLEX_FULL_TABLE
	    yy_curst = n[yy_curst][yy_sym];

#else /* get next state from compressed table */

	    while ( c[b[yy_curst] + yy_sym] != yy_curst )
		{
		yy_curst = d[yy_curst];

#ifdef FLEX_USE_MECS
		/* we've arrange it so that templates are never chained
		 * to one another.  This means we can afford make a
		 * very simple test to see if we need to convert to
		 * yy_sym's meta-equivalence class without worrying
		 * about erroneously looking up the meta-equivalence
		 * class twice
		 */

		if ( yy_curst >= YY_TEMPLATE )
		    yy_sym = m[yy_sym];
#endif
		}

	    yy_curst = n[b[yy_curst] + yy_sym];

#endif

	    yy_st_buf[yy_c_buf_p] = yy_curst;

	    }
#ifdef FLEX_INTERACTIVE_SCANNER
	while ( b[yy_curst] != YY_JAM_BASE );
#else
	while ( yy_curst != YY_JAM );
	--yy_c_buf_p; /* put back character we jammed on */

#endif

	if ( yy_c_buf_p >= yy_b_buf_p )
	    { /* we matched some text */
	    yy_curst = yy_st_buf[yy_c_buf_p];
	    yy_lp = l[yy_curst];

#ifdef FLEX_REJECT_ENABLED
find_rule: /* we branch to this label when doing a REJECT */
#endif

	    for ( ; ; ) /* until we find what rule we matched */
		{
#ifdef FLEX_REJECT_ENABLED
		if ( yy_lp && yy_lp < l[yy_curst + 1] )
		    {
		    yy_act = a[yy_lp];
		    goto do_action; /* "continue 2" */
		    }
#else
		if ( yy_lp )
		    {
		    yy_act = yy_lp;
		    goto do_action; /* "continue 2" */
		    }
#endif

		if ( --yy_c_buf_p < yy_b_buf_p )
		    break;

		yy_curst = yy_st_buf[yy_c_buf_p];
		yy_lp = l[yy_curst];
		}
	    }

	/* if we got this far, then we didn't find any accepting
	 * states
	 */

	/* so that the default applies to the first char read */
	++yy_c_buf_p;

	yy_act = YY_DO_DEFAULT;
	}
	}

    /*NOTREACHED*/
    }


static int unput( c )
char c;

    {
    YY_DO_BEFORE_SCAN; /* undo effects of setting up yytext */

    if ( yy_c_buf_p == 0 )
	{
	register int i;
	register int yy_buf_pos = YY_BUF_MAX;

	for ( i = yy_e_buf_p; i >= yy_c_buf_p; --i )
	    {
	    yy_ch_buf[yy_buf_pos] = yy_ch_buf[i];
	    yy_st_buf[yy_buf_pos] = yy_st_buf[i];
	    --yy_buf_pos;
	    }

	yy_c_buf_p = YY_BUF_MAX - yy_e_buf_p;
	yy_e_buf_p = YY_BUF_MAX;
	}

    if ( yy_c_buf_p <= 0 )
	YY_FATAL_ERROR( "flex scanner push-back overflow" );

    if ( yy_c_buf_p >= yy_b_buf_p && yy_ch_buf[yy_c_buf_p] == '\n' )
	yy_ch_buf[yy_c_buf_p - 1] = '\n';

    yy_ch_buf[yy_c_buf_p--] = c;

    YY_DO_BEFORE_ACTION; /* set up yytext again */
    }


static int input()

    {
    int c;

    YY_DO_BEFORE_SCAN

    if ( yy_c_buf_p == yy_e_buf_p )
	{ /* need more input */
	int yy_n_chars;

	/* we can throw away the entire current buffer */
	if ( yy_saw_eof )
	    {
	    if ( yywrap() )
		return ( EOF );

	    YY_INIT;
	    }

	yy_b_buf_p = 0;
	YY_INPUT( yy_ch_buf, yy_n_chars, YY_MAX_LINE );

	if ( yy_n_chars == YY_NULL )
	    {
	    yy_saw_eof = 1;

	    if ( yywrap() )
		return ( EOF );

	    YY_INIT;

	    return ( input() );
	    }

	yy_c_buf_p = -1;
	yy_e_buf_p = yy_n_chars - 1;
	}

    c = yy_ch_buf[++yy_c_buf_p];

    YY_DO_BEFORE_ACTION;

    return ( c );
    }
# line 52 "ldate.l"

