────────────────────────────────────────────────────────────────────────















                              S P A

               Структурный препроцессор для ассемблера.





                      Предприятие  "ЭКСПЕРТ"























                            1992
────────────────────────────────────────────────────────────────────────

────────────────────────────────────────────────────────────────────────

      Содержание


        ВВЕДЕНИЕ

        ПРЕДТЕЧИ

        ОГРАНИЧЕНИЯ

        ВЫПОЛНЕНИЕ

        СТРУКТУРЫ

        ОПЕРАТОРЫ

        ЗАКЛЮЧЕНИЕ






























────────────────────────────────────────────────────────────────────────

────────────────────────────────────────────────────────────────────────

        ВВЕДЕНИЕ

      Данная программа предназначена для облегчения программирования  на
ассемблере. Облегчение, главным образом,  должно  наступить  посредством
избавления от большей части меток в программе. Метки,  а  также  команды
сравнения  и  перехода,  должны  в  основном  замениться  на  операторы,
обрабатываемые   препроцессором.   Операторы   поддерживают     основные
конструкции   структурного   программирования,   поэтому    препроцессор
структурный. В результате использования препроцессора должно  облегчится
и убыстрится написание программ, уменьшится обьем исходного кода, а  сам
код  станет более доступным  для  понимания.


        ПРЕДТЕЧИ

      На момент создания сей программы автору  были  известны  лишь  две
попытки  решения  подобной  задачи,  и  обе  по   электронному   журналу
"СофтПанорама".  Одно   решение   реализовано   Юрием   Константиновичем
Козловским из г. Измаила в виде библиотеки макрокоманд для  структурного
программирования. Набор макроопределений достаточно полон  и  сравним  с
набором операторов, предлагаемых SPA, но использование  их  по  причинам
синтаксиса  ассемблера  представляется  иногда  весьма  затруднительным.
Например, составное условие в  макрокоманде  состоит  из  списка  "левых
переменных",  разделенных  запятыми,  затем,   после   запятой,   список
буквенных отношений с запятыми, а после него и очередной запятой  список
"правых переменных" (конечно, через запятую).  В  операторах  SPA  можно
использовать условия в привычно - нормальном виде со знаками =, <,  >  и
другими. Из этой библиотеки автор  подчерпнул  параметр  L  или  Long  -
генерировать длинный переход.
      Вторая  реализация  -  это  Block   Structure   Processor   (BSP).
Процессор воспринимает две конструкции: IF ... THEN ... ENDIF и  DO  ...
ENDDO и позволяет (по BSP!.DOC) "удалить 80% меток в Ваших  программах".
В операторе IF условие задается в виде  набора  флагов,  а  в  DOC-файле
ничего не сказано об обработке директивы ассемблера  INCLUDE.  Вероятно,
перед автором BSP задача обработки этой директивы не стояла.
      Ввиду вышеизложенного автор и решил несколько облегчить  написание
программ на ассемблере для себя  и  всех желающих.









────────────────────────────────────────────────────────────────────────

────────────────────────────────────────────────────────────────────────

        ОГРАНИЧЕНИЯ

      Предлагаемая программа имеет следующие нижеприводимые ограничения.
      Обьем  свободной   оперативной   памяти   -   нужен   всего   один
полноразмерный сегмент, другими словами, 64K.
      Общее число структур в программе - не более 65535.
      Вложенность директив INCLUDE - не более 10.
      Вложенность структур - не более 20.
      Вложенность CASE-структур - не более 5.
      Длина генерируемой строки ассемблера - не более 132 символов.
      Длина  имени  переменной  (то  бишь  ячейки  памяти)  в  операторе
DO_CASE - не более 32 символов.
      Генерируемые  препроцессором  метки  начинаются  с  символов   $_,
поэтому, если в Вашей программе все  же  есть  метки,  лучше,  если  они
будут начинаться с других символов.
      В строке, содержащий оператор, можно указывать только параметры  и
и нельзя писать комментарии, за исключением того случая,  когда  указаны
все возможные параметры, тогда после последнего параметра через  пробелы
или табуляцию  можно  заносить  любой текст,  но  он  не будет выведен в
результирующий файл.


        ВЫПОЛНЕНИЕ

      Формат командной строки для запуска препроцессора:

      SPA  имя_исходного_файла  [имя_результирующего_файла]

      Для обработки может быть указано только имя  исходного  файла  без
расширения. Если явно не указано, то подразумевается, что исходный  файл
имеет расширение .spa, а результирующий файл  то  же  имя  и  расширение
.asm.   Файлы,   указанные   в   директиве   INCLUDE,     препроцессором
обрабатываются  и  включаются  в  выходной   файл.   О   каждой   ошибке
препроцессор выводит на  экран  сообщение  с  указанием  имени  файла  и
номера строки в нем. В конце работы проверяется закрытие  всех  структур
и выдаются сообщения о неоконченных структурах. По завершению  обработки
выводится  сообщение  об  общем  количестве  ошибок  или  об  отсутствии
таковых. Код возврата равен нулю при безошибочной обработке, девяти  при
наличии ошибок и изменяется от 1 до 7 при фатальной ошибке, т.е.  ошибке
ввода - вывода.






────────────────────────────────────────────────────────────────────────

────────────────────────────────────────────────────────────────────────

        СТРУКТУРЫ

      Препроцессор поддерживает следующие структуры:

      If_  условие [Long]
        ...
        Else_  [Long]
        ...
      End_If

      Do_While условие [Long]
        ...
        Continue [Long]
        ...
        Exit [Long]
        ...
      EndWhile [Long]

      Repeat
        ...
        Continue [Long]
        ...
        Exit [Long]
        ...
      Until условие [Long]

      Do_Case переменная
        ...
        Case переменная или значение [Long] [Long]
        ...
        Other [Long]
        ...
      EndCase [Long]

      For переменная = значение To значение [Step значение] [Long]
        ...
        Continue [Long]
        ...
        Exit [Long]
        ...
      EndFor [Long]





────────────────────────────────────────────────────────────────────────

────────────────────────────────────────────────────────────────────────

      Looping значение [pp]
        ...
        Continue [Long]
        ...
        Exit [Long]
        ...
      EndLoop [[z или nz] или [Long]]

      Последняя структура опирается на ассемблерную команду  Loop,  т.е.
это цикл с загрузкой регистра CX, значение которого на  каждой  итерации
цикла декрементируется и этот цикл  выполняется,  пока  значение  CX  не
станет равно 0.


        ОПЕРАТОРЫ

      Некоторые синтаксические замечания: оператор  может  начинаться  с
любой позиции в строке исходного файла, написан целиком или  частью  как
прописными, так и строчными буквами и должен  отделяться  от  параметров
пробелами или  знаками  табуляции.  Это  же  относится  и  к  параметрам
операторов.
      Оператор Continue (продолжить) передает  управление  на  ближайший
оператор цикла, где проверяется условие, т.е. на  Do_While,  Until,  For
или EndLoop.
      Оператор  Exit  (выход,  в  данном  случае,  из  цикла)   передает
управление  на  первую  команду,  следующую  за   ближайшим   оператором
завершения цикла, т.е. за  EndWhile,  Until, EndFor  или  EndLoop.
      В операторе Case можно указывать параметр  Long  дважды.  Одиножды
Long  указывает  препроцессору  генерировать  длинный  JMP  на  оператор
EndCase, двойной Long - что, кроме этого, генерируется длинный JMP и  на
следующий оператор Case (или, в конце структуры, на Other или  EndCase).
Исключение из этого правила - первый  Сase  в  структуре.  Для  него  не
генерируется переход на EndCase и, соответственно,  параметр  Long (если
он нужен) следует указывать один раз.
      В операторе For необязательно указывать  значение  шага  итерации,
если  оно  не  указано,  то  шаг  берется  равным  1.  Можно   указывать
отрицательное значение шага (т.е. ставить  перед  значением  знак  "-"),
при  этом  счетчик  будет  уменьшаться  на   величину   шага,   а   цикл
выполняться, пока счетчик меньше или равен граничному значению.  Замечу,
что если величина шага  равна  1  или  -1,  то  препроцессор  генерирует
короткие команды DEC или INC.
      В операторе Looping необходимо  указать  значение,  которое  будет
загружено в регистр CX (т.е. операнд команды MOV CX,  ).  Необязательный
параметр PP означает Push-Pop CX,  т.е.  сохранение  счетника  в  начале
цикла и его восстановление перед проверкой.

────────────────────────────────────────────────────────────────────────

────────────────────────────────────────────────────────────────────────

      Оператор  EndLoop  имеет  необязательные,   но   взаимоисключающие
параметры. Если не указан параметр Long, то генерируется команда Loop  и
можно  указать  постфикс  условия   z   или   nz   (т.е.   тогда   будет
генерироваться команда Loopz или Loopnz). Если параметр Long указан,  то
конец цикла организовывается при помощи команд DEC CX, JCXZ и JMP.
      Параметр Long может использоваться  в  сокращенной  форме  в  виде
буквы L. Он  служит  для  указанию  препроцессору  генерировать  длинные
переходы.
      В условии допустимы следующие знаки: ! (отрицание),  <,  >,  =,  &
(AND), и | (OR). Возможно прямое задание  флагов  условия  в  обрамлении
точек, например .NC. Важное ограничение - в  каждом  конкретном  условии
может может задаваться логическая связка только одного  типа  -  или  &,
или |. Можно в одном или нескольких отношениях условия указывать  только
флаги, например вполне  правильно  условие  .C.  &  AX<>Read_Size.  Знак
отрицания в отношении (если он есть) должен идти первым.  Знаки  <  и  >
интерпретируются   препроцессором   как   "менее"   и   "более",    т.е.
генерируются команды перехода по беззнаковому условию.
      В качестве значений в параметрах операторов или в  условиях  можно
указывать и ячейки памяти, важно лишь помнить, что  в  ассемблере  80х86
режим адресации команд  CMP, ADD,  SUB  и  пр.  не  позволяет  указывать
сразу в  качестве  обоих  операндов  команды  ячейки  памяти.  В  случае
наличия таких команд  компилятор  ассемблера  сообщит  Вам  о  серьезных
ошибках.
      В генерируемой строке команда начинается с позиции на два  пробела
правее  позиции  исходного оператора. Метки начинаются с первой позиции.


        ЗАКЛЮЧЕНИЕ

      В заключение еще одна поддерживаемая  препроцессором  возможность.
В исходном  тексте  можно  в  одной  строке  записать  несколько  команд
ассемблера. Команды должны отделяться одна от другой  знаком  \,  причем
препроцессор  игнорирует  этот  знак  внутри  символьных   строк,   т.е.
ограниченных  кавычками  или  апострофами.  Генерируется  препроцессором
столько строк, сколько частей в исходной строке.  Команды  во  вторую  и
следующую  строки  выводятся  с  той  же  позиции,  с  какой  начинается
текст в исходной строке.









────────────────────────────────────────────────────────────────────────

────────────────────────────────────────────────────────────────────────








      Автор будет рад получить замечания и пожелания по адресу:

      460026, г.Оренбург, а/я 1364, Петрову Максиму

      Наш телефон  35 41 61,

      или, если звонить из-за рубежей Оренбурга - (353 00) 5 41 61.
































────────────────────────────────────────────────────────────────────────
