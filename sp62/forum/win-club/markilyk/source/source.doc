     Данный каталог содержит исходные тексты и ресурсы для ASSOC,
ASSOCSRV и их stub-ов, а также PRJ и MAK файлы для создания EXE.
MAK получен из PRJ при помощи PRJ2MAK и дополнен вручную. Разобрать-
ся в работе программы, по-моему, довольно просто - я старался писать
комментарии так подробно, как только сумел. Далее следует некоторые
замечания о том, почему что-либо сделано так, а не иначе, которые не
попали в комментарии.


                       Комментарии.

     Я долго думал, в какой кодировке писать комментарии. Остановился 
все-таки на DOSовской. Среда для DOS мне больше нравится, во-первых,
а потом - всегда можно просмотреть комментарии и в среде для Windows,
установив шрифт Fixedsys. 


                       Windows 3.1 API.  

     Хотя утилита писана для Windows 3.1, из всех новшеств API использу-
ется только диалог File Open и несколько макросов из windowsx.h (об этих 
макросах - ниже). Не используются DDEML, message crackers & forwarders и 
прочие новшества. Связано это с тем, что большая часть писалась еще для 
Windows 3.0, и я решил не менять то, что проверено. 


                    Распределение памяти.
     ASSOCSRV распределяет память из глобального heap'a и локирует ее до 
окончания своей работы. Вот для этого и применяются те несколько макросов 
из windowsx.h. Честно говоря, я так до конца и не разобрался до конца с 
GlobalLock. MS Windows SDK Reference настаивает на том, что Lock нужно де-
лать только непосредственно перед обращением к памяти и сразу после этого 
делать Unlock, иначе Windows не сможет перемещать выделенный участок. В 
Programming Windows Петцольд посвятил целый раздел тому, как это надо де-
лать и как это важно, а затем в последнем абзаце пишет "...впрочем, если 
Windows работает в стандартном или расширенном режиме, она может переме-
щать и локированные участки...". И все. Больше нигде по этому поводу ниче-
го я не встречал. Поэтому, решив, что от пары килобайт Windows не обеднеет, 
пошел по самому простому пути - локирую память сразу после распределения, 
а отпускаю перед самым возвратом.


                       Переменная bDummy.

     При трансляции вы получите несколько сообщений о том, что bDummy assign-
ed value that is never used. Дело в том, что для GlobalFreePtr lvalue 
required и все тут ! Это самое lvalue и есть bDummy.


               Зачем нужны 2 класса окон в ASSOCSRV   

     Дело в том, что если окно свернуто в иконку, оно не может иметь фокус
ввода, т.е. не может отрабатвать нажатия клавиш. Но в этом случае не может 
иметь фокус ввода и меню, которое создает это окно. В нашем случае это 
значит, что выбор из pop-up меню возможен только мышью, hot keys не сраба-
тывают. Поэтому пришлось идти как всем нормальным героям - в обход. Сначала 
окно класса AssocSrvWin (главное окно ASSOCSRV) создает окно класса 
MenuWindow, которое, в свою очередь создает pop-up меню и обрабатывает со-
общения от него. Можно было бы, в принципе, обойтись и одним классом, но в
этом случае функция окна получилась бы, как на мой вкус, слишком громоздкой.


             Немодальный диалог как главное окно программы - 
                           вариации на тему.

     В процессе работы у меня сложилось впечатление, что Петцольд преуве-
личивает крутизну использования немодального диалога как главного окна 
программы. Этот метод хорошо работает в HexCalc'e, но, по-моему, не может
считаться эталоном для создания программ, визуальная часть которых состо-
ит из одного диалога. Все хорошо, все работает, пока вы не начнете цеплять
к этому интерфейс с клавиатурой. Window subclassing в этом случае тоже не
спасает. Т.е., вы можете дописать  куски по установке фокуса ввода на тот
или иной control, и даже полностью имитировать работу стандартного модаль-
ного диалога. Дело только в том, сколько уйдет времени на написание всего
этого, а нервов - на отладку.

     В ASSOCSRV это решение несколько иное, хотя оно, вообще-то, производит
впечатление попытки почесать правое ухо левой пяткой. Главное окно программы
может быть только iconic. Попытка раскрыть его приводит к созданию и выводу
модального диалога конфигурации. Во время запуска ASSOCSRV анализирует пара-
метр nShow. Если он не равен SW_SHOWMINIMIZED, т.е. попытка заставить окно
раскрыться при запуске программы, ему (nShow) все равно присваивается зна-
чение SW_SHOWMINIMIZED и выставляется флаг признака необходимости вывода
диалога bNeedConfigure.

     Cледующий вопрос - при обработке какого сообщения создавать и выво-
дить этот диалог. Первое, что мне пришло в голову - конечно, WM_CREATE.
Ан нет. Дело в том, что WM_CREATE посылается функции окна до того, как
будет завершено создание окна. Так что функция уже работает, а окна еще
нет. Послать самому себе сообщение - тоже не получится. Нет окна - нет и
очереди сообщений. Остановился на WM_ACTIVATE. Хотя тут тоже есть кое-какие
капканы. Так, это сообщение не посылается окну, если оно создано как mini-
mized, до тех пор, пока не click его кто-нибудь mouse'ом. Чтобы разобрать-
ся с этим и введена bNeedConfigure.


---------------------------------------------------------------------------
     Данная программа и исходные тексты принадлежат к классу FREEWARE.
Вы можете свободно ими пользоваться и распространять.

     Условия:
          - При распространении вы не можете изменять содержимое архива
            либо какого-то отдельного файла

          - Запрещено коммерческое использование программы без согласования
            с автором
----------------------------------------------------------------------------

Тел.:  (052-72)37-110 (рабочий)
Адрес: 323000, Днепропетровская обл., г. Павлоград, ул. Днепровская, 424-50,
       Маркилюк Александр

