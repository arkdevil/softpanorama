                                                         Boling, Douglas

                     REXX - IBM's command language for OS/2 

Abstract:  IBM's REXX command language is a powerful, easy-to-use command
           language that is much more sophisticated than the DOS batch
           language.  Basic aspects of REXX programming are discussed;
           the classic 'Hello World' example program is shown.  Comment
           statements are enclosed within delimiters and can span
           multiple lines.  The first line of a REXX program must be a
           comment in order to indicate that a .CMD file is written in
           REXX instead of the DOS-like command language provided with
           OS/2.  Variables are set by simply using the equals sign.  The
           SAY statement can display strings or numbers.  REXX is an
           interpreted language; each line is processed in sequence until
           there are no more.  The PULL statement returns a string from a
           standard input queue.  REXX supports standard branching and
           looping statements and can call subroutines.  It has a
           sophisticated queue interface and can execute system commands
           within its programs.

The limitations of Microsoft's DOS batch file language have frustrated
users since DOS 2.0.  Finally--in OS/2 2.0-- IBM has done something about
it.  Although OS/2 2.0's CMD.EXE continues built-in support for a
DOS-like batch language, integrated into the new operating system is
IBM's REXX command language interpreter.  REXX is more than a simple
batch language: It is a powerful, easy-to-use, high-level language.

REXX, which stands for Restructured Extended Executor, was developed for
IBM's VM mainframe operating system by IBM guru Mike Cowlishaw, in
Hursley, England.  The popularity of REXX soon spread throughout the
various IBM mainframe operating systems, and it has now become the
standard command language for IBM's Systems Application Architecture.
Support for REXX was built into OS/2 1.3, the best of the ill-fated
16-bit versions of OS/2.

Command languages have a more restricted purpose than that of other
computer languages.  In languages such as Pascal or Modula 2, the
enforcement of strict rules helps the programmer not only to limit his
mistakes, but also to achieve the best program design.  When writing a
command or batch file, however, the goal is not elegance, but simply
getting the job done.  The appeal of REXX is that it lets you accomplish
your task without presuming that you want to write a "perfect" program.

In this Lab Notes, I'll discuss the basic aspects of REXX programming.
In addition to explaining the standard branching, looping, and calling
statements, I'll touch briefly on the other parts of REXX you'll need to
write fully functional programs.  While a language as powerful as REXX
cannot be completely covered in one article, when you're done reading you
should be able to write some fairly complex REXX programs.

Since REXX has maintained backward compatibility with its earlier
versions, it often permits the same result to be achieved in any of
several ways.  In what follows I'll generally discuss only one way, but
this should not be taken to imply that the examples I use are the only
ways to get a particular job done.

PROGRAMMING IN REXX

As with most computer languages, REXX is best learned by example.  A good
example with which to start is the classic "Hello World" program.  The
REXX version of this program goes as follows:

/* My first REXX program */

SAY Hello World

You should use an ASCII text editor to type in these two lines and save
the file with the extension .CMD.  Then, when you enter its name at the
OS/2 command line, the program will execute, displaying the string, HELLO
WORLD.  Note that although I have capitalized the SAY statement for
readability, it is not necessary to do so.  (I'll continue to put REXX
keywords in uppercase throughout the remainder of this article, however.)

This simple program demonstrates some key proprieties of a REXX program.
The first line of the program is a comment enclosed by the delimiters /*
and */.  REXX ignores anything enclosed inside these delimiters.  REXX
comments may span multiple lines and may even be nested within another
comment.

It is not just for the sake of good programming practice that this brief
program has a comment as its first line.  The first line of a REXX
program must be a comment, since this is what tells OS/2 that the .CMD
file is written in REXX instead of in the standard, DOS-like OS/2 command
language.  The first line comment requirement is also consistent with the
mainframe versions of REXX, in which the comment also tells the operating
system to use the REXX interpreter instead of its own mainframe command
language.

The SAY statement does what the ECHO statement does in a DOS .BAT file,
and more.  In this program, SAY simply displays the string HELLO WORLD.
If the program were instead written as

/* My second REXX program */

World = Doug

SAY Hello World

the output would be HELLO DOUG, for here the variable World has been
assigned the value DOUG.  Unlike the arcane DOS batch language, you don't
have to use the environment for storing variables, so you don't need to
use the SET statement and enclose variables in percent signs.  Variables
are set in REXX simply by using the equal sign, and they're used by
placing the variable name where you want the value of that variable.

Notice that the output of the programs above is printed in uppercase.
REXX translates every literal string that is not enclosed in quotes into
uppercase.  This irritating characteristic can be avoided by the liberal
use of quotes.  To make the output of the immediately previous program
more user-friendly, you could write it thus:

/* A friendlier 2nd REXX program */

World = 'Doug'

SAY 'Hello' World

This will produce the output, Hello Doug.  The conversion to uppercase
also makes variable names case-insensitive; the variable World is the
same as WORLD.

The SAY statement displays numbers as easily as it does strings.  The
statement SAY 2 + 3 will display the number 5.  Variables, numbers, and
strings can all be combined in one SAY statement, as shown in the
following example:

/* SAY statement versatility */ answer = 5 + 3

SAY 'Five plus three is ' answer but

five plus four is 5 + 4

Running this program will display the line

Five plus three is 8 BUT FIVE PLUS

FOUR is 9

The first string is enclosed in quotes in this example, so it is not
capitalized.  The variable answer is replaced with the value 8, since the
previous statement assigned it the result of 5 + 3.  Since the second
string, but five plus four, is not enclosed in quotes, REXX capitalizes
it.  Finally, SAY evaluates the expression

5 + 4 to the number 9 and prints it.

REXX processes each line in sequence until there are no more lines to
process.  If you want to stop the REXX interpreter from executing any
more lines beyond a certain point in a program, you use the EXIT
statement.  In the next example, I have added an EXIT statement to insure
the program terminates after the first SAY statement but before the
second SAY.

/* Using the EXIT statement */

World = 'Doug'

SAY 'Hello' World

EXIT

SAY 'This line will not be

executed!'

In this example, the EXIT statement serves only to prevent the second SAY
instruction from being executed.  In the more complex examples below, the
main program will be followed by subroutines and functions.  Without the
EXIT command at the end of the main program, the interpreter would
attempt to execute subroutine lines listed after the program itself had
finished.

Asking the user for input is easy, though the name of the command is
strange. The PULL statement returns a string from what REXX-speak calls
the standard input queue--usually the keyboard.  I'll discuss the whole
queue concept later, but for now just think of the PULL statement as an
oddly named INPUT statement.  You can now make the original example a bit
friendlier:

/* A personalized REXX program */

SAY 'What is your name?'

PULL name

SAY 'Hello' name

The PULL statement can handle more than just one variable.  Each variable
after the PULL instruction, with the exception of the last, is assigned a
single word from the line entered by the user.  The last variable is
assigned the remainder of the line.  For example, suppose the PULL
statement were

PULL dog cat mouse

and the user entered the line,

'Now is the time for all good men'

The variable DOG would be assigned the word Now, CAT would be assigned
is, and MOUSE would be assigned the time for all good men, which is the
remainder of the line.

If the user enters fewer words than there are variables, the remaining
variables are set to a string with no characters, that is, a null string.
 If the user entered 'Not Now' in response to the PULL statement above,
DOG would be assigned Not, CAT would become now, and MOUSE would be a
null string.

BRANCHING AND LOOPING

As with any high-level language, REXX supports the standard branching and
looping statements.  The IF statement allows users to branch on a
condition as, for example, in this code fragment

/* Using the IF statement */

IF hour > 6

THEN

SAY 'Good Evening'

As would be expected, this program will print the line Good Evening if
hour is greater than 6.  An ELSE statement can be included and will be
executed if the condition tests false.  In the following example, Good
afternoon is displayed if hour is before or equal to 6.

/* An example of IF-THEN-ELSE */

IF hour > 6

THEN

SAY 'Good Evening'

ELSE

SAY 'Good Afternoon'

REXX allows you a fair amount of flexibility in positioning its
statements.  For example, the previous IF statement could have been
written as

IF hour > 6 THEN SAY Good Evening'

ELSE SAY 'Good Afternoon'

On the other hand, if the statement were written

IF hour > 6 THEN SAY 'Good Evening'

ELSE SAY 'Good Afternoon'

and hour = 7, the output would be

Good Evening ELSE SAY 'Good

Afternoon'

This odd result comes about because, unlike the THEN clause, the ELSE
must be placed on a separate line.  In this case, therefore, the REXX
interpreter assumed anything past the SAY statement should simply be
printed to the screen.

Fortunately, for the legion of C hackers who absolutely live to compress
complex programs into as few lines as possible, there is a solution.
REXX statements can be placed on the same line if they are separated by a
semicolon.  To restore the previous statement to its proper
functionality, it can be written as a single line thus:

IF hour > Say 'Good Evening';

ELSE Say 'Good Afternoon'

The ELSE statement binds itself with the most immediate IF statement that
does not already have an ELSE statement.  To insure that ELSE statements
bind correctly, you can use the NOP (No OPeration) statement as a
placeholder to fill in dummy ELSE statements, as needed.  Note that
simply using a semicolon on the line--as is often done in C
programs--will not work in REXX.  The following example shows how to nest
the IF statements properly:

/* Nested IF statements */

IF month = 12

THEN

IF date = 25

THEN

SAY Merry Christmas'

ELSE

NOP

ELSE

SAY 'It is not December yet'

Without the NOP statement, the last ELSE statement would be bound with
the second IF statement.

When used alone, the THEN or ELSE statements can only execute a single
line.  If you want to apply them to more than one line, you must enclose
the lines in a DO END block, as shown in the following example:

IF hour > 6

THEN DO

SAY 'Good Evening'

SAY 'Don't work too late!'

END

Looping is as simple as branching in REXX.  In the following example the
program will continue to loop while the variable answer is not equal to
5.

/* A persistent program */ answer = 0

DO WHILE answer <> 5

SAY 'What is 2 + 3 ?'

PULL answer

END

The WHILE loop tests the condition and, if it is true, proceeds to
execute the body of the loop.  In this program, the loop will continue
until the value 5 is returned.

The DO UNTIL statement can be used when the testing of the condition is
to be performed after the body of the loop has been executed.  The
previous program could have been written as:

/* A persistent program, Take 2 */

DO UNTIL answer = 5

SAY 'What is 2 + 3 ?'

PULL answer

END

Notice that the initial ANSWER = 0 line can now be removed, since the
body of the loop will be executed and the variable answer will be
assigned a value before the condition is tested.

The LEAVE statement can be used to depart from a loop in midstride.
Modifying the previous example to use the LEAVE statement makes the
program a bit less stubborn.

/* A persistent program, Take 3 */

DO UNTIL answer = 5

SAY 'What is 2 + 3 ?'

PULL answer

IF answer = QUIT

THEN LEAVE

END

Note that the LEAVE statement can be used with any of the looping
statements in REXX.

Repetitive looping can be performed by replacing the WHILE/UNTIL
condition with a number.  In the following example, the loop will execute
1,000 times.

/* Ask for forgiveness */

DO 1000

SAY 'Pardon'

END

If you need to know the iteration count for the loop, the syntax can be
expanded to look more like the FOR statements found in other high-level
languages.  The following loop prints the numbers 1 though 5 on the
screen.

/* Count to 5 */

DO i = 1 TO 5

SAY i

END

To modify the amount by which the loop variable is changed for each
iteration, the BY keyword can be used as in the following loop:

/* Countdown */

DO i = 10 TO 0 BY -1

SAY i

END

SAY 'Blastoff!'

This short program will print the numbers 10 through 0 in decreasing
order and will then print the string Blastoff!.

SUBROUTINES

As would be expected of a high-level language, REXX can call subroutines.
 To call a routine, the keyword CALL is used, and equally appropriately,
the keyword RETURN is used to return to the statement following the
original CALL.  In the following example, the forgiveness routine is
called using the CALL statement.

/* Example using a subroutine */

CALL forgiveness

SAY 'Am I now forgiven?'

/* other code */

EXIT forgiveness:

DO 1000

SAY 'Pardon'

END

RETURN

As illustrated here, placing the forgiveness routine in a subroutine
allows it to be executed with a single CALL statement.  To return from
the subroutine, the RETURN statement is used.  When REXX encounters a
RETURN, it returns to the line following the most recent CALL
statement--in this case, to the SAY statement following the CALL.

This example also uses the EXIT statement, which terminates the REXX
program. The EXIT is needed because without it REXX would continue to
execute lines sequentially until it fell into the forgiveness routine.

Arguments can be passed to a subroutine by including them on the same
line as the CALL statement.  Multiple arguments to be passed are
separated by commas. In the following example, the forgiveness routine
has been changed so that the caller can modify the number of times
forgiveness is requested as well as for whom forgiveness is asked.  The
subroutine accesses the passed parameters by using the ARG() function.

/* A subroutine with parameters */

CALL forgiveness 10, 'me'

/* other code */

EXIT forgiveness:

i = ARG(1)

DO i

SAY 'Pardon' ARG(2)

END

RETURN

ARG() is a built-in function that returns the parameter specified in the
argument to the function.  ARG(1) returns the first parameter, ARG(2) the
second, and so on.  If ARG() is called without any parameters, it returns
the number of parameters passed to the subroutine.  In the preceding
example, a call to ARG() with no parameters would return 2, since two
parameters were passed to the forgiveness subroutine.  If a subroutine is
called with fewer parameters than the number passed to the ARG()
function, ARG() returns a null.

The following example checks for the existence of a parameter before
using it.

/* Parameter-checking subroutine */

CALL forgiveness 10, 'me'

/* other code */

EXIT forgiveness:

IF (ARG() < 2)

THEN

RETURN

DO i

SAY 'Pardon' ARG(2)

END

RETURN

Like the parameters in subroutines, the command line parameters of a REXX
program can be returned by using the ARG() function.  If ARG() is called
in the main body of the program (outside any subroutines), the parameters
returned are taken from the command line.  Just as %1 returns the first
command line parameter in a DOS batch file, ARG(1) will return the first
command line parameter of a REXX program.  Called without any parameters
in the main body of the program, ARG() returns the number of parameters
on the command line.

FUNCTIONS

REXX also supports user-defined functions.  Although generally similar to
subroutines, functions have a number of different properties: Calling a
function does not require a CALL statement, parameters passed to the
function must be enclosed in parentheses, and the function must return a
value on the RETURN statement.

In the next example, the function DOUBLE returns the value passed,
multiplied by 2.  Although this is a trivial function, DOUBLE
demonstrates the necessary properties of a REXX function.

/* Demonstration of a function */ say DOUBLE(6)

EXIT double: i = ARG(1) * 2

RETURN i

Notice here that although the parameters are passed inside parentheses,
they are still retrieved with the ARG() function.  The RETURN statement
is followed by the value to be returned.  In addition to user-defined
functions, REXX also has over 50 built-in functions, though their
treatment must be deferred to another occasion.

One of the quirks of REXX is that function names must be immediately
followed by the opening parenthesis; no intervening space is permitted.
For example, when using the DOUBLE function, REXX interprets the lines
DOUBLE(1) and DOUBLE (1) differently.  In the first case, REXX treats the
word as a call to the function DOUBLE and returns the result of the
function.  However, in the second case, DOUBLE (1), REXX parses the
DOUBLE as a variable name and separately parses the (1) as the value 1.

No discussion of subroutines and functions would be complete without
discussing scope.  Scope is the part of the program for which a variable
is defined.  In DOS batch files, all environment variables are global in
scope, since they can be set and used anywhere in the batch file.  REXX
variables, too, are generally global, that is, retained throughout the
program.  In the program shown in Figure 1(a), for example, the variable
PT1ABCPT2 is modified in the subroutine, but it retains its new value
after the return.  The variable DEF is assigned in the subroutine, and it
also retains its new value after the subroutine returns.

The PROCEDURE statement can be used to make variables private to a
specific routine.  In such a case, the PROCEDURE statement acts like a
brick wall, separating the variables defined within the PROCEDURE
statement from those defined outside it.  Variables that are defined
within the PROCEDURE statement are unrecognized beyond the point at which
the next RETURN statement is executed.  Thus, as shown in Figure 1(b),
adding a PROCEDURE statement to the previous example localizes the
variable.  In this case, the PROCEDURE statement has been added at the
start of the changevar routine.  The variables in the routine will now be
completely independent from the other parts of the program.

The variable-localizing effect of the PROCEDURE statement can be modified
by using the EXPOSE keyword, as shown in Figure 1(c).  As its name
suggests, the EXPOSE instruction allows one or more listed variables to
be "exposed" to the code outside the PROCEDURE instruction.  In Figure
1(c), then, by adding the EXPOSE instruction to the previous example, the
variable ABC is exposed in the routine changevar.  The PROCEDURE
statement now has an effect on ABC but still protects DEF.

THE QUEUE INTERFACE

One of the more confusing parts of REXX is its handling of user input.
As mentioned above, the statement used for asking users for input from
their keyboards is PULL.  While this seems a strange name for something
that should be called ASK or INPUT, the LBLname PULL does have some
relation to reality, for REXX is designed so that programs can read data
from an input queue.

Generically, the PULL command attempts to remove an item from the
currently active REXX input queue.  This is normally attached to the
standard input device--the keyboard--so if nothing is in the queue, PULL
waits for the user to enter data at the keyboard.  By using PULL with its
companion PUSH and QUEUE commands, however, the queue can be attached
instead to an OS/2 interprocess data queue.  This redirection is much
more powerful than the old DOS redirection mechanism: REXX queues enable
communication between two programs running at the same time.

The PUSH statement allows a REXX program to shove data into the queue in
such a way that the pushed data will be returned at the next PULL
statement.  Data PUSHed into the queue is organized in a
Last-In-First-Out (LIFO) manner.  That is, the last thing pushed into the
queue is the first thing pulled out.

In the next example, three PUSH instructions are used to place three
strings in the input queue.  The data is then removed by three successive
PULL statements.  Notice that the data is removed in reverse order due to
the LIFO ordering of the PUSH statement.

/* Using PUSH and PULL */

PUSH 1

PUSH 2

PUSH 3

PULL first

PULL second

PULL third

SAY first second third 'Blastoff!'

Running this example will print the line, 3 2 1 Blastoff!, since the
numbers were removed in the reverse order from the way they were placed
in the queue. Note that because there was already data in the input
queue, the PULL instructions did not wait for user input.  Inclusion of a
fourth PULL instruction would have caused the program to pause and wait
for user keyboard input, since only three items were in the queue.

The QUEUE instruction also places data in the input queue, but in a
First-In-First-Out order.  In a FIFO system, the first item placed in the
queue is the first item removed.  If the above example had used the QUEUE
instead of the PUSH instruction, the SAY statement would print 1 2 3
Blastoff!.

PUSH and QUEUE have a number of uses, two of which are illustrated in
Figure 2.  The example in Figure 2(a) also introduces the REXX built-in
TIME() function, which returns the current system time.  In this
instance, the PUSH instruction is used to save the time at which a
process starts, and PULL is then used to remove that stored time and
compare it to the current time.

In Figure 2(b), the answer to the confirmation question is PUSHed into
the input queue to provide a predefined answer to a question.  When data
has been pushed into the input queue in response to the first question,
the second PULL statement does not wait on input from the user.  Thus, if
the user does not want to confirm the operation, the program will still
display the confirmation question, and (after completion of the DO block)
it will automatically answer YES.  Note that in both the previous
examples, the QUEUE instruction could have been used in place of the PUSH
since only one item was placed in the queue.

USING OS/2 COMMANDS

A command language would not be of much use if it could not execute
system commands within its programs.  As with DOS and the standard OS/2
batch languages, REXX will execute any internal command, batch program,
REXX program, or external program that is inserted as a line in the
program.  For example, the following REXX program copies a file.

/*Trivial backup program */

copy program.asm program.bak

The only caution you must observe here is to be careful that REXX does
not try to process any of the many special symbols that are used both in
REXX and in OS/2 commands.  For example, in REXX the asterisk (PT1*PT2)
is used to indicate multiplication, while both DOS and OS/2 use the
asterisk as a wildcard character in filenames.  To avoid having REXX
process any such special characters, just enclose the command in quotes
as shown in the following lines.

/* A better backup program */

"copy *.asm *.bak"

In this Lab Notes I have only touched the surface of the power of REXX.
If you would like to learn more, just give it a try! You'll be amazed by
the power it puts at your fingertips.  Indeed, while people can still
argue over the merits of OS/2, there is no doubt that one of its big
pluses is REXX.

DOUGLAS BOLING IS A CONTRIBUTING EDITOR TO PC MAGAZINE.

[TABULAR DATA OMITTED]


                    Journal:    PC Magazine  May 11 1993 v12 n9 p325(6)
                  * Full Text COPYRIGHT Ziff-Davis Publishing Company 1993.
