     Вашему вниманию предлагаются утилиты для трансляторов с форта (СП 5.5),
реализующие в ларионовском форте задержку в миллисекундах и  переопределение
функций >, < и EXPECT в духе Черезова, в черезовском  -  увеличение  размера
арифметического стека и в обоих - арифметику с плавающей точкой.
     Файл VSPOMO.FRL создан описанным ж документации к  ларионовскому  форту
способом (см.комментарии ж VSPOMO.ASM).
     Утилита DELAY реализована стандартным образом. Обрашение  к  ней  имеет
вид
 use vspomo.frl
 use music.frl \ из авторскй поставки
 : nota ( freq -> ) sound 500 delay nosound ;
 : akkord 500 nota 600 nota 750 nota 1000 nota ;
 akkord
. Идея реализации (а с незначительными изменениями - и  сам  код)  взята  из
дизассемблята  программ,  оттранслированных   транслятором   фирмы   Борланд
(турбо-паскаль).
     Что касается функций >, < и EXPECT, то легко убедиться, что  транслятор
Ларионова  считает,  что  -20000>20000  (т.к.  разность  воспринимается  как
отрицательное число) и что при переназначении ввода по типу  fs.com<prog.frt
каждая строка сопровождается еще одной пустой строкой (т.к.  и  0Dh,  и  0Аh
воспринимаются  как  признак  конца  строки).  У  Черезова  функции  >  и  <
анализирует флаг переноса после вычитания, а EXPECT игнорирует симжолы  0Aх.
В наборе vspomo.* дано переопределение этих функций: код функций '>'  и  '<'
почти без изменений взят у Черезова, а код функции EXPECT -  ларионовский  с
изменением пункта  назначения  перехода  после  cmp al,0Ah  (этого  было  бы
достсточно   и   потребовало   бы   изменения    единственного    байта    в
оттранслированном коде) и незначительным изменением порядка фрагментов.
     Чно касается арифметики с плавающей  точкой,  то  вначале  автор  хотел
реализовать ее аналогичным образом.  (Сама  ее  необходимость  у  автора  не
вызывает сомнений: действительно, для бухгалтерского учета от нее нет особой
пользы, но есть задачи, где действительные числа входят в саму  формулировку
- например, образовать  из  фундаментальных  констант  (х=6.626Е-27тэрг*сек,
ц=2.998Е10тсм/сек, ...) величину с заданной размерностью. Аналгично у автора
не  вызывает  сомнения   желательность   использования   именно   6-байтного
представления действительных чисел - вероятно, тем, кто работал на  машинах,
где были только 4- и 8-байтное представление, это обосновывать  не  надо,  а
остальным  -  долго).  Однако  выяснилось,  что  реализация  даже   сложения
действительных  чисел  в  турбо-паскале  неожиданно  громоздка.   С   учетом
желательности использования всего ассортимента функций (арктангенс  и  т.п.)
стало ясно, что жыгоднее посадить написанный на паскале резидент,  обрашения
к которому осушествлялсь  бы  через  прерывания  и  который  бы  и  выполнял
требуемые операции. (Конечно,  дубово,  по-советски,  зато  работает.  Кроме
того,  этот  подход  обеспечивает  работу  сразу  с   обоими   трансляторами
(документированного способа введения автокодных функций в  черезовский  форт
нет, а описанный ниже  неудобен  -  поэтому  DELAY  реализована  только  для
ларионовского   форта).   Для   черезовского    транслятора    дополнительно
потребовалось увеличить размер арифметического стека - см.ниже).
     Было выяснено, что паскалевский резидент независимо от числа  указанных
параметров заносит в стек содержимое регистров (AX...BP); FG, CS  и  IP  при
этом  уже  занесены  туда  командой  прерывания.   В   конце   резидент   их
восстанавливает. Идентификация параметров - только по смешению  относительно
указателя стека, т.е.последний  параметр  (типа  word,  иначе  бессмысленно)
отождествляется с регистром BP и т.д. - независимо от имен параметров. Т.о.,
если регистров не хватает, можно передать резиденту дополнительные параметры
через стек, необходимо только учесть, что слово intr  у  Черезова  вносит  в
стек три, а у Ларионова - две собственных  переменных  типа  word,  так  что
заголовок резидента должен иметь примерно такой вид:
 procedure larionov(
  p1,p2:pointer;
  f1,f2:word; {два фиктивн.параметра; для Черезова их должно быть три}
  fg,cs,ip,ax,bx,cx,dx,si,di,ds,es,bp:word
 ); interrupt;
     Следует также учесть, что  внутренние  переменные  процедуры  обработки
прерывания размещаются в стеке и, т.о., не сохраняются от раза к разу - если
необходимо, чтобы они сохранялись, их надо описать в головной программе.
     Турбо-паскаль сам использует  прерывания  (например,  с  номером  3Fh),
поэтому при необходимости изменить номер перехваченного  прерывания  (сейчас
это 51h) необходимо проверить, не  нарушает  ли  ето  работоспособность.  (С
демонстрационными целями перехватывается также прерывание 52h).
     Демонстрации работы: заносим в рабочий каталог минимальный  необходимый
для трансляции набор файлов турбо-паскаля (я использовал версию 5.5),  обоих
форт-трансляторов  и выполняем команды:
 tpc arifmyet
 rem рекоменд.ключи /$N- или аналог., см.ARIFMYET.PAS
 arifmyet
 fs<arifdemo.frt
 forthall<arifdemo.f
(fs.com  -  диалоговая  версия;  если   ее   нет,   ее   надо   создать:
forth fs.frt).
     Программа для черезовского форта  демонстрирует  только  сложение  двух
чисел - основные усилия  сосредоточены  на  переносе  стека.  Программа  для
ларионовского форта содержит практически полный набор функций для  работы  с
действительными числами (обратите внимание на легкость чтения интерфейса  со
стороны  форта  !)  и  демонстрирует  также  нахождение   отношений   частот
равномерно темперированного строя (2^(i/12)) и  разложение  числа  в  цепную
дробь (здесь - чистая демонстрация, но вообще это метод нахождения наилучших
приближений действительных чисел рациональными).
     Набор арифметических утилит может показаться неоптимальным. Это связано
с тем, что, в соответствии с  пожеланиями,  если  не  ошибаюсь,  А.Шеховцова
(прошу прощения, если ошибся), я  предлагаю  не  программу  как  таковую  (у
которой неизбежны недостатки - наверняка кому-нибудь не понравится, что  код
операции - в DX, а не в AХ или что сделано на паскале, а не на си), а запись
алгоритма в пригодном для демонстрации  работоспособности  и  модификации  в
соответствии с вкусами пользователя виде (к  тому  же  такая  модификация  в
простейших случаях смехотворно проста).
     Обращения к  резиденту  из  системы  Черезова  вначале  вели  к  потере
управления   (типичная   симптоматика    -    зависания,    самопроизвольные
перезагрузки, реже - видеоэффекты и т.п. - невоспроизводимо от раза к разу).
Удалось выяснить, что слово,  из  которого  вызвано  слово  интр,  нормально
выполняется до конца  (вставив  в  него  dump,  можно  убедиться,  что  свою
основную работу резидент выполнил правильно), но на стадии выхода  на  слово
более высокого уровня управление теряется. Вставив занесение известных чисел
в стек возвратов с их  последующим  считыванием,  можно  увидеть,  что  стек
возвратов портится.
     Обратите внимание на  различие  синтаксиса  слова  интр  у  Черезова  и
Ларионова: вместо
 registers regs
 0 regs ax ! 16 regs intr
у Ларионова у Черезоова надо писать
 0 ax ! 16 intr
(у Черезова AX,  BX  и  т.п  -  это  переменные,  а  у  Ларионова  -  слова,
быполняющие индексацию в  массиве-заготовке  регистров).  В  ARIFMYET.PAS  с
демонстрационными целями оставлен также обработчик прерывания 52х, шлепающий
символ в видеопамять - он нормально работает и у Ларионова, и у Черезова.
     Эксперимент (см.ниже) показал, что стек возвратов  портится  налезающим
на него арифметическим стеком. Попытки исправить в трансляторе 1-е обращение
к регистру BP (счетчик стека возвратов),  чтобы  разместить  его  дальше  от
арифметического стека, не дали желаемых результатов  -  очевидно,  BP  потом
определяется повторно. Поэтому было решено передвинуть  его  в  ходе  работы
программы пользователя.  Это  оказалосьвозможным  следующим  образом.  Пишем
фиктивное слово достаточной длины (в арифдемо.ф это ZSUV). Пишем на автокоде
нужный  кусок  (для  черезовского  транслятора  он  должен  оканчиваться  на
lodsw/jmp ax, для ларионовского - на jmp word ptr  ds:[105h],  ассемблируем,
записываем в 16-м виде и пишем на форте еще одно слово,  которое  по  '!'  и
'c!' заносит полученную программу в первое из этих  слов  в  16-ичном  виде,
начиная с поля кода (в обоих трансляторах  поле  кода  имеет  вид  Е8XXXX  -
внутрисегментный CALL).  У  Ларионова  рекомендуется  также  исправить  байт
признаков (см. документацию к ларионовскому форту), но  критично  ли  это  -
автор не проверял. Если вносится слово, а не  байт  -  помните,  что  "более
поздний" байт является старшим байтом слова и пишется  впереди  -  например,
xor ax,ax= 33 C0 запишется C033 ! На время отладки  рекомендуется  следующий
прием. В отлаживаемый код вставляем  команду  FB  (разрешить  прерывания)  и
команды EBFE (короткий переход на саму себя)  в  критичных  участках.  Перед
запуском отлаживаемой  программы  запускаем  программу  PEPORES  (Peek  Poke
Resident, автор - Graeme  Scott).  Когда  отлаживаемая  программа  зависает,
активизируем  PEPORES:  если  все  нормально,  CS:IP  указывает   на   EBFE.
Просмотрев регистры и заменив EBFE на 9090 ( 2 команды  nop),  идем  дальше.
Если  требуется  повторный   останов   в   том   же   месте,   рекомендуется
последовательность EBFE9090 <-> 9090EBFE. (Может оказаться необходимым также
резидентный дизассемблер -UTIL Е.Касперского).  После  отладки  эти  команды
убираем. (Фактически идея занесения чисел в стек возвратов и  их  извлечения
после обращения к прерыванию для демонстрации порчи стека возвратов возникла
после  того,  как  с  помощью  этого  приема  было   выяснено   расположение
арифметического стека  и  стека  возвратов  и  получены  свидетелства  порчи
последнего разросшимся арифметическим стеком. Кстати,  у  Ларионова  сегмент
стека не совпадает с сегментом кода и данных, арифметический стек расположен
под  стеком  возвратов  (изображаем  младшие  адреса   внизу,   тогда   стек
разрастается вниз), и подобное  затирание  практически  невероятно).  Запуск
2-го слова подготавливает 1-е, а запуск 1-го сдвигает стек, после чего можно
продолжать работу.
     Конечно, рассмотреная реализация арифметики противоречит идее языка для
создания  особо  быстродействующих   программ,   зато   позволяет   рядовому
пользователю использовать могущество конструкций форта. Пожалуй, возможность
переопределить  команды  арифметических  действий,  чтобы  они  при   угрозе
переполнения рылись в стеке возвратов и выдавали диагностику,  для  рядового
пользователя менее впечатляюща, чем следующий  пример.  Пусть  надо  создать
таблицу с варьируемым от запуска  к  запуску  числом  и  порядком  элементов
разной длины (например, заготовки букв в самодельном  векторном  шрифте  или
наборы точек и тире в программе обучения азбуке Морзе). На паскале  пришлось
бы писать по типу
 v('a','.-'); v('b','-...');
(вариант  вынесения  рассматриваемой  информации  в  отдельный  файл  данных
намного  хуже  -  родственная  информация  оказывается  разбросана  по  двум
файлам). На форте же, используя слово WORD (и/или EXPECT), можно записать по
типу
 v a .- b -...
 v m -- n -.
 - без повторения идентификатора  процедуры  занесения  в  таблицу,  скобок,
точек с запятыми и апострофов. Что же касается постфиксной записи, то к  ней
быстро привыкаешь - это  аналогично  разному  порядку  слов  в  естественных
языках.  Например,  на  русском  говорится  "к  А  прибавить  В"  -  вначале
называется 1-й  аргумент,  затем  операция,  затем  2-й  аргумент  -  как  в
математической записи: А+В, А-В. Но на японском: "А-ни В-о куваэру", "А-кара
В-о хику" - как в форте: А В + или А В - (!!!). В свете этой аналогии  легко
записать и прочесть: a b =  c d =  and . Интересно, что в английском -  "add
В to А", "substract  В  from  А"  -  порядок  не  имеет  аналогов  в  языках
программирования: даже в лиспе, хоть символ операции - на 1-м месте, но  все
же 1-й аргумент - перед 2-м: (PLUS А В), (MINUS А Б).
     В заключение автор благодарит обоих авторов  трансляторов  с  форта  за
привлечение внимания к этому языку и за работу по написанию трансляторов.
     И.С. 1994,1,17.

