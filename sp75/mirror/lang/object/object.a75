From: Bob Hathaway <rjh@geodesic.com>
Newsgroups: comp.object,comp.answers,news.answers
Subject: Comp.Object FAQ Version 1.0.7 (10-27) Announcement
Date: 29 Oct 1994 11:42:03 GMT
Organization: Geodesic Systems, Inc.
Message-ID: <object-faq/announce_783430818@rtfm.mit.edu>
  anonymous@zaphod.uchicago.edu:/pub/CompObj7.faq(.Z)     (128.135.72.61)
  anonymous@zaphod.uchicago.edu:/pub/CompObj7.faq(.Z)     (128.135.72.61)
  anonymous@rtfm.mit.edu:/pub/usenet/comp.object/*_Part_* (18.181.0.24 Tmp)
  http://iamwww.unibe.ch/~scg/OOinfo/FAQ/index.html       (new IAM location)

Mail Server:  (See also section 1.24)
  mail mail-server@rtfm.mit.edu
  Subject:
  send usenet/comp.object/*

Zaphod is preferred over rtfm for anonymous ftp retrieval, as it provides a
single file.  Rtfm contains the FAQ as posted.

To use the hypertext system, see APPENDIX E, entries 27.

Again, a short period of time may be required to retrieve the latest version
from anonymous ftp, allowing the posted version to propagate and get out as
quickly as possible.

Thank you to the many people who have contributed their time and effort to
help this document spread the word about object-oriented technology and
available systems!  It is hoped it will be most useful in that endeavor.

Best Regards!
bob

From ankh.iia.org!babbage.ece.uc.edu!news.kei.com!bloom-beacon.mit.edu!senator-bedfellow.mit.edu!faqserv Wed Nov 23 21:57:33 1994
Path: ankh.iia.org!babbage.ece.uc.edu!news.kei.com!bloom-beacon.mit.edu!senator-bedfellow.mit.edu!faqserv
From: Bob Hathaway <rjh@geodesic.com>
Newsgroups: comp.object,comp.answers,news.answers
Subject: Comp.Object FAQ Version 1.0.7 (10-27) Part 1/10
Supersedes: <object-faq/part1_782395740@rtfm.mit.edu>
Followup-To: comp.object
Date: 29 Oct 1994 11:42:06 GMT
Organization: Geodesic Systems
Lines: 1160
Approved: news-answers-request@MIT.Edu
Distribution: world
Expires: 12 Dec 1994 11:40:18 GMT
Message-ID: <object-faq/part1_783430818@rtfm.mit.edu>
References: <object-faq/announce_783430818@rtfm.mit.edu>
NNTP-Posting-Host: bloom-picayune.mit.edu
Summary: Frequently Asked Questions (FAQ) List and Available Systems For Object-Oriented Technology
X-Last-Updated: 1994/10/28
Originator: faqserv@bloom-picayune.MIT.EDU
Xref: ankh.iia.org comp.object:7426 comp.answers:4416 news.answers:13674

Archive-name: object-faq/part1
Last-Modified: 10/27/94
Version: 1.0.7


COMP.OBJECT FAQ
Version: 1.0.7
Date:    10/27/1994


Author:
  Bob Hathaway
  Geodesic Systems, Inc.
  Cyberdyne Systems Corporation
  rjh@geodesic.com


Anonymous FTP Sites and Hypertext Server:
  anonymous@zaphod.uchicago.edu:/pub/CompObj7.faq(.Z)     (128.135.72.61)
  anonymous@rtfm.mit.edu:/pub/usenet/comp.object/*_Part_* (18.181.0.24 Tmp)
  http://iamwww.unibe.ch/~scg/OOinfo/FAQ/index.html       (new IAM location)

Mail Server:  (See also section 1.24)
  mail mail-server@rtfm.mit.edu
  Subject:
  send usenet/comp.object/*

Zaphod is preferred over rtfm for anonymous ftp retrieval, as it provides a
single file.  Rtfm contains the FAQ as posted.

To use the hypertext system, see APPENDIX E, entries 27.
There is currently no comp.object archive.

Copyright 1992-1994  Bob Hathaway
All rights reserved.

Permission is granted to freely copy and distribute this document but only
with this full header attached and at no cost to others with the exception
of a nominal distribution fee, if any.  No sale, resale or reprinting is
granted without the explicit written permission of the author.

Contributors:  Per Abrahamsen, Edwardo Casais, Stewart Clamen, Dennis De
  Champeaux, Mike DeVaney, Eric Dujardin, Piercarlo Grandi, Brian Henderson-
  Sellers, Urs Hoelzle, Paul Johnson, Bill Kinnersley, Oscar Nierstrasz,
  James Odell, Eoin Woods, and many others whose contributions have helped this
  document to fulfull its objective of bringing object-oriented concepts and
  systems to everyone.

  Special thanks to Object Systems, Geodesic Systems and Cyberdyne Systems for
  providing the support and resources needed to make this effort possible.

Objective:
  In the spirit of other FAQs, to provide a simple document to answer the most
  frequently asked and recurring questions and to allow new users to understand
  frequently discussed topics and terms used in comp.object.   This should
  bring new comp.object readers and/or writers to at least an introductory
  level of comprehension as soon as possible.  Other goals (hopes) are to
  provide a quick and current reference on available systems such as object-
  oriented languages, CASE, OODB and etc. and to provide good references to
  current and relevant OO systems, groups, texts and literature.

Disclaimer:
  This document does not necessarily reflect the opinions of the author's or
  any contributor's companies.  There are no explicit or implicit guarantees
  implied by this document.

While object systems are a constantly changing and moving target with a broad
diversity of often conflicting methodologies, constructs, terminologies,
approaches, languages, implementations and etc. and comp.object has a wide
diversity of readers and writers ranging from students, professors and
researchers in academia to beginners, professionals, top-notch experts and
leaders in industry with a broad range of experience and backgrounds ranging
across many paradigms, this FAQ can certainly not aspire to satisfy all of them
completely but instead attempts to provide the most well-rounded treatment of
object-oriented concepts and realizations primarily from the mainstream and
popular authors and systems and further to provide a collection of available
systems and tools in the appendices.

Several improvements are planned for future FAQs, including a glossary.


SECTION 1:  BASICS
  1.1)  What Is An Object?
  1.2)  What Is Object Encapsulation (Or Protection)?
  1.3)  What Is A Class?
  1.4)  What Is A Meta-Class?
  1.5)  What Is The Infinite Regress Of Objects And Classes?
  1.6)  What are MOPs and Reflection?
  1.7)  What Is Inheritance?
  1.8)  What Is Multiple Inheritance?
  1.9)  Does Multiple Inheritance Pose Any Additional Difficulties?
  1.10) What Is Dynamic Inheritance?
  1.11) What Is Shared (Repeated) Inheritance?
  1.12) Why Use Inheritance?
  1.13) Why Don't Some People Like Inheritance?
  1.14) What Is Specialization/Generalization/Overriding?
  1.15) What Is The Difference Between Object-Based And Object-Oriented?
  1.16) Is A Class An Object?
  1.17) Is An Object A Class?
  1.18) What Is A Method? (And Receiver And Message)
  1.19) What Are Multi-Methods And Multiple-Polymorphism?
  1.20) What Is OOP?
  1.21) What Is OOA/OOD (And Where Can I Get What I Need On It)?
  1.22) Where Did Object-Orientation Come From?
  1.23) What Are The Benefits Of Object-Orientation?
  1.24) What Other FAQs Are available?

SECTION 2:  TYPING
  2.1)  What Is Polymorphism?
  2.2)  What Does Polymorphism Boil Down To In OO Programming Languages?
  2.3)  What Is Dynamic Binding?
  2.4)  Is There A Difference Between Being A Member Or Instance Of A Class?
  2.5)  What Is This I Read About ML And Functional Programming Languages?
  2.6)  What Is the Difference Between Static And Dynamic Typing?
  2.7)  What Is A Separation Between Type And Class (Representation)?
  2.8)  What Are Generics And Templates?

SECTION 3:  GENERAL
  3.1)  What Is The "Classical" Object-Oriented Paradigm?
  3.2)  What Is The "Delegation/Prototyping" Object-Oriented Paradigm?
  3.3)  Are There Any Other Object-Oriented Paradigms?
  3.4)  What Are The Major Object-Oriented Programming Languages Today?
  3.5)  What Are Object-Oriented Databases And Persistence?
  3.6)  What Are Object-Oriented Operating Systems?
  3.7)  What Are The Current Object-Oriented Methodologies?
  3.8)  What Is The OMG/OMA/ORB/CORBA?
  3.9)  Why Is Garbage Collection A Good Thing?
  3.10) What Can I Do To Teach OO To The Kids?
  3.11) What Is Available On Object-Oriented Testing?
  3.12) What Distributed Systems Are Available?
  3.13) What Is The MVC Framework?
  3.14) What Is Real-Time?
  3.15) What Is Available on OO Metrics?

SECTION 4:  COMMONLY ASKED LANGUAGE SPECIFIC QUESTIONS
  4.1)  What Is Downcasting?
  4.2)  What Are Virtual Functions?
  4.3)  Can I Use Multiple-Polymorphism Or Multi-Methods In C++?
  4.4)  Can I Use Dynamic Inheritance In C++?

ANNOTATED BIBLIOGRAPHY

APPENDIXES
  APPENDIX A  VIPS
  APPENDIX B  OBJECT-ORIENTED DATABASES AND VENDORS
  APPENDIX C  OBJECT-ORIENTED LANGUAGES AND VENDORS
  APPENDIX D  OBJECT-ORIENTED CASE (OOA/D/P TOOLS) AND VENDORS
  APPENDIX E  ANONYMOUS FTP SITES
  APPENDIX F  MAGAZINES, JOURNALS AND NEWSLETTERS

[Another appendix on miscellaneous commercial object-oriented systems should
 be added soon for completeness]


SECTION 1:  BASICS
==================

Suggested Readings:
  [Booch 91, 94]
  Others to be added...


1.1) What Is An Object?
-----------------------

There are many definitions of an object, such as found in [Booch 91, p77]:
"An object has state, behavior, and identity; the structure and behavior of
similar objects are defined in their common class; the terms instance and
object are interchangeable".  This is a "classical languages" definition, as
defined in [Coplien 92, p280], where "classes play a central role in the
object model", since they do not in prototyping/delegation languages.
"The term object was first formally applied in the Simula language, and
objects typically existed in Simula programs to simulate some aspect of
reality" [Booch 91, p77].  Other definitions referenced by Booch include
Smith and Tockey: "an object represents an individual, identifiable item,
unit, or entity, either real or abstract, with a well-defined role in the
problem domain." and [Cox 91]: "anything with a crisply defined boundary"
(in context, this is "outside the computer domain".  A more conventional
definition appears on pg 54).  Booch goes on to describe these definitions
in depth.  [Martin 92, p 241] defines: "An "object" is anything to which a
concept applies", and "A concept is an idea or notion we share that applies
to certain objects in our awareness".  [Rumbaugh 91] defines: "We define an
object as a concept, abstraction or thing with crisp boundaries and meaning for
the problem at hand." [Shlaer 88, p 14] defines: "An object is an abstraction
of a set of real-world things such that:
  * all of the real-world things in the set - the instances - have the same
    characteristics
  * all instances are subject to and conform to the same rules"
and on identifying objects: "What are the *things* in this problem?  Most of
the things are likely to fall into the following five categories: Tangible
things, Roles, Incidents, Interactions, and Specifications."  [Booch 91, 4.3]
covers "Identifying Key Abstractions" for objects and classes based on an
understanding of the problem domain and [Jacobson 92] provides a novel approach
to identifying objects through use-cases, leading to a use-case driven design.
Jacobson also classifies objects into interface objects (e.g. GUI), entity
objects (corresponding to real-world objects), and control objects (introduced
in design).

The implementation of objects could roughly be categorized into descriptor-
based, capability-based, and simple static-based approaches.  Descriptor-
based approaches (e.g. Smalltalk handles) allow powerful dynamic typing, as
do the capability-based approaches which are typically found in object-
oriented databases and operating systems (object id's).  A "proxy" based
approach with an added layer of indirection to Smalltalk's handles is found
in Distributed Smalltalk which allows transparent, distributed, and migrating
objects [Kim 89, ch 19 and Yaoqing 93].  Simple static approaches are found in
languages such as C++, although the new RTTI facility will supply simple
dynamic typing similar to those introduced by Eiffel in 1989 through the
notion of assignment attempt.

Descriptor-based approaches can have pointer semantics and can be
statically typeless (or just "typeless", as in Smalltalk) where
references (variables) have no type, but the objects (values) they point
to always do. An untyped pointer (such as void* in C++) and an embedded
dynamic typing scheme are used in more conventional languages to fully
emulate this style of dynamically typed programming (see sections 2.3,
4.3, and [Coplien 92]).

Below is a simple example to show a most trivial case of OO implementation.
It is primarily intended to introduce new terms.  See [Cardelli 85] for
another semantic definition of OO using functions for methods and for
a view of types as sets of values.

Simple statically-typed objects (static and auto vars and temps in C++ and
expanded types in Eiffel) can be viewed as instances of a record type,
whose record fields are called instance variables (Smalltalk) or member data
(C++).  The record (class) may also contain operations which are called
methods (Smalltalk) or member functions (C++) which are equivalent to a
function taking an object of the record type, called the receiver, as the
first parameter.  The receiver is called self (Smalltalk) or this (C++).
Members will denote both instance variables and methods.  Inheritance is
roughly equivalent to a loosely coupled variant record, with derived classes
as variant parts and with multiple-inheritance concatenating several records
to serve as a base.

A virtual member in statically typed languages is a base class member
that can be set or respecified by a derived class. This is roughly
equivalent to a pointer or function pointer in the base class being set
by the derived class. [Stroustrup 90] covers the implementation details
of virtual member functions in C++, which also involve an offset for the
receiver to handle multiple-inheritance. This is an example of dynamic
binding, which replaces a switch statement on variant parts with a
single call, reducing code size and program complexity (fewer nested
programming constructs) and allowing variants to be added without
modifying client code (which causes higher defect injection rates during
maintanance and debugging).

Virtual members in dynamically typed languages are more flexible because
static typechecking requirements are dropped.  See section 2.5.

The terms method/member function, instance variable/member data, subclass/
derived class, parent class/base class, and etc. will be used interchangeably.
As pointed out in [Stroustrup 90, p197], the base/derived class terminology
may be preferable to the sub/super-class terminology, and is preferred in
this document also.

Delegation/prototyping languages [Kim 89, ch3; Ungar 87, Sciore 89] have a more
flexible kind of object which can play the role of classes in classical OO
languages.  Since there is no separate class construct in these languages, and
only objects, they are referred to as single-hierarchy, or 1 Level systems.
Objects contain fields, methods and delegates (pseudo parents), whereas
classical object-oriented languages associate method, field and parent
definitions with classes (and only associate state and class with objects,
although vtables of function pointers for dynamic binding is an exception).
However, one-level objects often play the role of classes to take advantage of
sharing and often instances will simply delegate to parents to access methods
or shared state, otherwise idiosyncratic objects, a powerful and natural
concept, will result.  Typical 1 Level objects can contain any number of
fields, methods and parents and any object can be used as a template/exemplar,
thus performing the classical role of a class.  In typical prototyping systems,
parents (as any other member) can be added or changed dynamically, providing
dynamic multiple inheritance (or more typically simple delegation).  Here, the
term "Prototype" usually refers to prototype theory, a recent theory of
classification where any object can be inherited from or cloned to serve as a
prototype for newly created instances.  [The Author also uses the term for
languages providing high quality support for rapid prototyping, although this
usage is atypical]  See [Booch 94, pp 154-155] for a brief discussion of
prototype theory in the context of OOA and OOD.

It is common in such systems for an object to "become" another kind of object
by changing its parent.  A good example is a window becoming an icon, since
window and icon objects display different behavior (although cognitive
differences are significant too:-)  Delegation refers to delegating the
search for an attribute to a delegate, and is therefore more of a pure
message passing mechanism (as with dynamic scoping) than inheritance, which
also typically specifies non-shared state when used for representation.

Chambers has proposed an interesting variation called "Predicate Classes"
[Chambers 93] as a part of his Cecil language.  These classes will only be
parents when certain predicates are true.  This can support a types/classes
as collections of objects view, which is the same as the types as sets of
values view taken by [Cardelli 85].  [Martin 92] provides some examples of
this view applied during OOA.

1 level systems therefore provide the most flexible and powerful capabilities.
Self is a good example of a delegation-based single hierarchy language [Ungar
87].


1.2)  What Is Object Encapsulation (Or Protection)?
---------------------------------------------------

[Booch 91, p. 45] defines: "Encapsulation is the process of hiding all of the
details of an object that do not contribute to its essential characteristics."

[Coad 91, 1.1.2] defines: "Encapsulation (Information Hiding).  A principle,
used when developing an overall program structure, that each component of a
program should encapsulate or hide a single design decision...  The interface
to each module is defined in such a way as to reveal as little as possible
about its inner workings.  [Oxford, 1986]"

Some languages permit arbitrary access to objects and allow methods to be
defined outside of a class as in conventional programming.  Simula and
Object Pascal provide no protection for objects, meaning instance variables
may be accessed wherever visible.  CLOS and Ada allow methods to be defined
outside of a class, providing functions and procedures.  While both CLOS
and Ada have packages for encapsulation, CLOS's are optional while Ada's
methodology clearly specifies class-like encapsulation (Adts).

However most object-oriented languages provide a well defined interface to
their objects thru classes.  C++ has a very general encapsulation/protection
mechanism with public, private and protected members.  Public members (member
data and member functions) may be accessed from anywhere.  A Stack's Push and
Pop methods will be public.  Private members are only accessible from within
a class.  A Stack's representation, such as a list or array, will usually be
private.  Protected members are accessible from within a class and also from
within subclasses (also called derived classes).  A Stack's representation
could be declared protected allowing subclass access.  C++ also allows a
class to specify friends (other (sub)classes and functions), that can access
all members (its representation).  Eiffel 3.0 allows exporting access to
specific classes.

For another example, Smalltalk's class instance variables are not accessible
from outside of their class (they are not only private, but invisible).
Smalltalk's methods are all public (can be invoked from anywhere), but a
private specifier indicates methods should not be used from outside of the
class.  All Smalltalk instance variables can be accessed by subclasses,
helping with abstract classes and overriding.

Another issue is per-object or per-class protection.  Per-class protection
is most common (e.g. Ada, C++, Eiffel), where class methods can access any
object of that class and not just the receiver.  Methods can only access the
receiver in per-object protection.  This supports a subtyping model, as any
object other than the receiver is only satisfying an abstract type interface,
whereby no method or object structure can be inferred in the general case.


1.3  What Is A Class?
--------------------

A class is a general term denoting classification and also has a new meaning
in object-oriented methods.  Within the OO context, a class is a specification
of structure (instance variables), behavior (methods), and inheritance
(parents, or recursive structure and behavior) for objects.  As pointed out
above, classes can also specify access permissions for clients and derived
classes, visibility and member lookup resolution.  This is a feature-based or
intensional definition, emphasizing a class as a descriptor/constructor of
objects (as opposed to a collection of objects, as with the more classical
extensional view, which may begin the analysis process).

Original Aristotlean classification defines a "class" as a generalization of
objects:
[Booch 91, p93]
  "a group, set, or kind marked by common attributes or a common attribute; a
   group division, distinction, or rating based on quality, degree of
   competence, or condition".

[Booch's definition in the context of OOD]
  "A class is a set of objects that share a common structure and a common
  behavior."  "A single object is simply an instance of a class."

The intension of a class is its semantics and its extension is its instances
[Martin 92].

[Booch 94, 4.2] proposes 3 views of classification as useful in OO analysis and
design: classical categorization (common properties), conceptual clustering
(conceptual descriptions), and prototype theory (resemblance to an exemplar).
He advocates starting with the former approach, turning to the second approach
upon unsatisfactory results, and finally the latter if the first two approaches
fail to suffice.


1.4)  What Is A Meta-Class?
---------------------------

[See also section 1.6]

A Meta-Class is a class' class.  If a class is an object, then that object
must have a class (in classical OO anyway).  Compilers provide an easy way to
picture Meta-Classes.  Classes must be implemented in some way; perhaps with
dictionaries for methods, instances, and parents and methods to perform all
the work of being a class.  This can be declared in a class named "Meta-Class".
The Meta-Class can also provide services to application programs, such as
returning a set of all methods, instances or parents for review (or even
modification).  [Booch 91, p 119] provides another example in Smalltalk with
timers.  In Smalltalk, the situation is more complex.  To make this easy, refer
to the following listing, which is based on the number of levels of distinct
instantiations:

1 Level System
  All objects can be viewed as classes and all classes can be viewed as
  objects (as in Self).  There is no need for Meta-Classes because objects
  describe themselves.  Also called "single-hierarchy" systems.
  There is only 1 kind of object.
2 Level System
  All Objects are instances of a Class but Classes are not accessible to
  programs (no Meta-Class except for in the compiler and perhaps for type-safe
  linkage, as in C++).
  There are 2 kinds of distinct objects: objects and classes.
3 Level System
  All objects are instances of a class and all classes are instances of
  Meta-Class.  The Meta-Class is a class and is therefore an instance of
  itself (really making this a 3 1/2 Level System).  This allows classes to
  be first class objects and therefore classes are available to programs.
  There are 2 kinds of distinct objects (objects and classes), with a
  distinguished class, the metaclass.
5 Level System
  What Smalltalk provides.  Like a 3 Level System, but there is an extra level
  of specialized Meta-Classes for classes.  There is still a Meta-Class as in
  a 3 Level System, but as a class it also has a specialized Meta-Class, the
  "Meta-Class class" and this results in a 5 Level System:
    object
    class
    class class (Smalltalk's Meta-Classes)
    Meta-Class
    Meta-Class class

  The "class class"es handle messages to classes, such as constructors and
  "new", and also "class variables" (a term from Smalltalk), which are
  variables shared between all instances of a class (static member data in
  C++).  There are 3 distinct kinds of objects (objects, classes, and
  metaclasses).


1.5)  What Is The Infinite Regress Of Objects And Classes?
----------------------------------------------------------

In the authors opinion, a myth.  The story goes an object is an instance of a
class (Meta-Object), a class is an instance of a Meta-Class, which must also
be an instance of a Meta-Meta-Class, which must also be an instance of a Meta-
Meta-Meta-Class, ...  Closure can be achieved with an instance-of loop, as with
a Meta-Class being an instance of itself or with a "Meta-Class - Meta-Class
class" instance-of loop (as in Smalltalk).


1.6)  What Are MOPs And Reflection?
-----------------------------------

MOP is an acronym for Meta-Object Protocol.  This is a system with
Meta-Classes accessible to users [Kiczales 92, Paepcke 93].  In CLOS
terminology, an introspective protocol provides a read only capability (e.g.
what is this object's class, give info on this class, etc.) and an
intercessory protocol provides a write capability which allows system
modification (e.g. add the following method or instance to this class,
perform inheritance this way, etc.).  Because inheritance can be used to
perform differential changes, intercessory protocols allow users to not
only define new frameworks but to specialize existing system frameworks
differentially without affecting them and their extant objects.  Thus, many
frameworks can interoperate together simultaneously.  This is a good example
of object-oriented reuse, since the compiler itself is reused thru
specialization to provide new frameworks.

"Reflective" systems are systems with MOPs (not to be confused with reflexive
systems, which often refer to systems implemented in terms of themselves, or
bootstrapped).  Reflective systems are inevitably reflexive (as are most
quality compilers), providing a direct program interface to the system.


1.7)  What Is Inheritance?
--------------------------

Inheritance provides a natural classification for kinds of objects and allows
for the commonality of objects to be explicitly taken advantage of in modeling
and constructing object systems.  Natural means we use concepts,
classification, and generalization to understand and deal with the complexities
of the real world.  See the example below using computers.

Inheritance is a relationship between classes where one class is the parent
(base/superclass/ancestor/etc.) class of another.  Inheritance provides
programming by extension (as opposed to programming by reinvention
[LaLonde 90]) and can be used as an is-a-kind-of (or is-a) relationship or
for differential programming.  Inheritance can also double for assignment
compatibility (see section 2.7).

In delegation languages, such as Self, inheritance is delegation where objects
refer to other objects to respond to messages (environment) and do not
respecify state by default.

Inherited parents can specify various flavors of state.  Delegation languages
don't specify new state by default (to do so requires cloning), C-based (C++,
Objective-C, etc.), lisp-based (CLOS, Flavors, Scheme, etc.), and Pascal-based
(Ada-9x, Modula-3, Object Pascal, etc.) OO languages do, but with multiple-
inheritance can also share parents within a class lattice (CLOS and Eiffel
provide this as a default at the level of slots and features, respectively).

Inheritance also provides for member lookup, or internal environment.  Various
schemes exist, for example C++ finds the closest match within a scope but
causes an ambiguity error iff more than one parent has match, CLOS creates
a linear precedence list, Self provides parent priorities, and Eiffel forces
renaming for any parent member conflicts.

Defining inheritance (with a thorough description or denotational semantic
definition, or both) can avoid confusion about which inheritance scheme is
being used (especially in OOD), because inheritance has many variations and
combinations of state and environment (sometimes with complex rules).
Inheritance can also be used for typing, where a type or class can be used to
specify required attributes of a matching object (see sections 2.1, 2.7 and
[Cardelli 85]).  It would be more judicious to have discussions on how
inheritance should be defined instead of over what it is, since it has many
existing uses and semantics.

An example of the is-a-kind-of relationship is shown below.  Is-a is often
used synonymously, but can be used to show the "object is-a class"
instantiation relationship.  In classical OO, inheritance is a relationship
between classes only.  In one-level systems, is-a (object instantiation) and
is-a-kind-of (inheritance) are merged into one [Ungar 87, Madsen 93, Sciore
89].

                               Computer
                              /    |     \
                       Mainframe  Mini    Personal
                        /    \    ...       /   \
                  Data Proc  Scientific   PC    Workstation

Class hierarchies are subjective [Booch 91, 4.2; Lakoff 87] and usually drawn
with the parent class on top, but more demanding graphs (as is often the case
in [Rumbaugh 91]) allow any topology, with the head of an arrow indicating the
base class and the tail indicating the derived class.

Differential programming is the use of inheritance to reuse existing classes
by making a small change to a class.  Creating a subclass to alter a method
or to add a method to a parent class is an example.


1.8)  What Is Multiple Inheritance?
-----------------------------------

Multiple Inheritance occurs when a class inherits from more than one parent.
For example, a person is a mammal and an intellectual_entity, and a document
may be an editable_item and a kind of literature.

Mixin's is a style of MI (from flavors) where a class is created to provide
additional attributes or properties to other classes.  They are intended to be
inherited by any class requiring them.  Method combination, or calling
sequences of before, after, and around methods or even several primary methods
[Kim 89, ch 4], make good use of mixins by invoking their methods without
explicitly calling them, allowing client class code to remain unchanged [Booch
91, p 113].


1.9)  Does Multiple Inheritance Pose Any Additional Difficulties?
-----------------------------------------------------------------

Yes, it does.  Any name can be simply resolved to a class member with single
inheritance by simply accessing the first name encountered for data members
and by accessing the first signature match (or ambiguity) encountered for
methods (at least one way, C++ hides some member functions).  Since several
distinct parents can declare a member within a multiple inheritance hierarchy,
which to choose becomes an issue.  Eiffel forces derived classes to rename
parent members that conflict.  Self prioritizes parents.  CLOS merges member
"slots" (instance variables) with the same name into a single slot, as did
the earlier flavors.  C++ declares an error iff a conflict arises, but a
class qualifier can be used to explicitly disambiguate.  Smalltalk renders
same names for instance variables of subclasses illegal.

On the other hand, multiple-inheritance can be seen as required for basic
object-oriented programming, because many objects in the real world belong to
several classes.  In classical systems without MI, a class which should inherit
from more than one class must textually include all but one of those classes in
its interface, causing code duplication (and a messy interface).


1.10)  What Is Dynamic Inheritance?
-----------------------------------

Dynamic inheritance allows objects to change and evolve over time.  Since base
classes provide properties and attributes for objects, changing base classes
changes the properties and attributes of a class.  A previous example was a
window changing into an icon and then back again, which involves changing a
base class between a window and icon class.

More specifically, dynamic inheritance refers to the ability to add, delete,
or change parents from objects (or classes) at run-time.  Actors, CLOS, and
Smalltalk provide dynamic inheritance in some form or other.  Single hierarchy
systems, such as Self, provide dynamic inheritance in the form of delegation
[Ungar 87].

See also [Kim 89, chs 1, 3] for a discussion and [Coplien 92] for some
implementation discussion in C++.


1.11)  What Is Shared (Repeated) Inheritance?
---------------------------------------------

Multiple Inheritance brings up the possibility for a class to appear as a
parent more than once in a class graph (repeated inheritance), and there is
then a potential to share that class.  Only one instance of the class will
then appear in the graph (as is always the case in CLOS, because all *members*
with the same name will be shared (receive a single slot) with the greatest
common subtype as its type).  C++ provides an alternative, where only parents
specified as virtual (virtual bases) are shared within the same class lattice,
allowing both shared and non-shared occurrences of a parent to coexist.  All
"features" in Eiffel (C++ members) of a repeated parent that are not to be
shared must be renamed "along an inheritance path", else they are shared by
default.  This allows a finer granularity of control and consistent name
resolution but requires more work for parents with many features.


1.12)  Why Use Inheritance?
---------------------------

Inheritance is a natural way to model the world or a domain of discourse,
and so provides a natural model for OOA and OOD (and even OOP).  This is
common in the AI domain, where semantic nets use inheritance to understand
the world by using classes and concepts for generalization and categorization,
by reducing the real-world's inherent complexity.

Inheritance also provides for code and structural reuse.  In the above Computer
class diagram, all routines and structure available in class Computer are
available to all subclasses throughout the diagram.  All attributes available
in Personal computers are also available to all of its subclasses.  This kind
of reuse takes advantage of the is-a-kind-of relationship.  Class libraries
also allow reuse between applications, potentially allowing order-of-magnitude
increases in productivity and reductions in defect rates (program errors),
as library classes have already been tested and further use provides further
testing providing even greater reliability.

With differential programming, a class does not have to be modified if it is
close to what's required; a derived class can be created to specialize it.
This avoids code redundancy, since code would have to be copied and modified
otherwise.  See [Raj 89] for an alternative approach as found in Jade.

Polymorphism is often explicitly available in many OO languages (such as C++,
CLOS, Eiffel, etc.) based on inheritance when type and class are bound together
(typing based on subclassing, or subclass polymorphism), since only an object
which is a member of (inherits from) a class is polymorphically assignment
compatible with (can be used in place of) instances or references of that
class.  Such assignment can result in the loss of an object's dynamic type in
favor of a static type (or even loss of an object's representation to that of
the static class, as in C++ slicing).  Maintaining the dynamic type of objects
can be provided (and preferred); however, C++ provides both sliced and non-
sliced replacement in a statically typed environment (see section 2.1).


1.13)  Why Don't Some People Like Inheritance?
----------------------------------------------

Some people complain that inheritance is hierarchical (which is what most
object-oriented languages provide).  They would also like to see more
operations available (set operations are quite common in specialized systems).
The former is a kind of language dependent feature commonly found in object-
oriented languages which are then associated with the term "inheritance"
(although they don't need to be.  For example, delegation languages allow graph
inheritance stuctures).  Some don't like the coupling of classes (as in Jade),
but in the author's opinion many of their complaints are easily answered.  In
systems that provide inheritance, inheritance provides a simple and elegant way
to reuse code and to model the real world in a meaningful way.

Others complain multiple inheritance is too complicated because it brings up
the issues of shared bases and member conflict resolution.  But most modern
systems support Multiple Inheritance by employing semantic resolution
strategies or renaming, and most consider MI to be highly desirable.  See the
latter part of section 1.9 for an example of why MI is important.

Some prefer association to MI, claiming "roles" (as defined in [Rumbaugh 91])
should be associations and inheritance should be reserved for a single
hierarchy "creation" mechanism, however this loses polymorphism and loses the
use of inheritance for typical classification.  Representation "roles" can be
supported by dynamic multiple inheritance (DMI) in many situations.


1.14)  What Is Specialization/Generalization/Overriding?
--------------------------------------------------------

To create a subclass is specialization, to factor out common parts of
derived classes into a common base (or parent) is generalization [Booch 91,
p56].  Overriding is the term used in Smalltalk and C++ for redefining a
(virtual in Simula and C++) method in a derived class, thus providing
specialized behavior.  All routines in Smalltalk are overridable and non-
"frozen" features in Eiffel can be "redefined" in a derived class.  Whenever
a method is invoked on an object of the base class, the derived class method
is executed overriding the base class method, if any.  Overriding in Simula
is a combination of overloading and multiple-polymorphism because parameters do
not have to be declared.  Eiffel and BETA are examples of languages allowing
any member to be redefined and not just methods, as is typical.


1.15)  What Is The Difference Between Object-Based And Object-Oriented?
-----------------------------------------------------------------------

Object-Based Programming usually refers to objects without inheritance
[Cardelli 85] and hence without polymorphism, as in '83 Ada and Modula-2.
These languages support abstract data types (Adts) and not classes, which
provide inheritance and polymorphism.  Ada-9x and Modula-3; however, support
both inheritance and polymorphism and are object-oriented.  [Cardelli 85, p481]
state "that a language is object-oriented if and only if it satisfies the
following requirements:

  - It supports objects that are data abstractions with an interface of named
    operations and a hidden local state.
  - Objects have an associated type.
  - Types may inherit attributes from supertypes.

  object-oriented = data abstractions + object types + type inheritance

These definitions are also found in [Booch 91, Ch2 and Wegner 87].

[Coad 91] provides another model:

  Object-Oriented = Classes and Objects
                    + Inheritance
                    + Communication with messages

Stroustrup's first edition of [Stroustrup 91, '86 p. 37] defines object based
as: "... storing type identification in each object, brings us to a style of
programming often referred to as "object based"", which is quite different
from C+W's.

A more modern definition of "object-oriented" includes single-hierarchy
languages and perhaps object id's for unique objects.  Object id's support the
modern notion of relocatable, persistent and distributed objects that can
even migrate across machines.  Distributed Smalltalk's proxy objects [Kim 89,
ch 19 and Yaoqing 93] provide another example of a distributable and migratable
object facility.  Separate type system support is another extension.

[Booch 94, 2.2] proposes 7 "Elements of the Object Model"; 4 major and 3 minor:
  Major:
    Abstraction
    Encapsulation
    Modularity
    Hierarchy  (Inheritance)
  Minor:
    Typing
    Concurrency
    Persistence


1.16)  Is A Class An Object?
----------------------------

In C++ no, because C++ classes are not instances of an accessible class (a
Meta-Class) and because C++ classes are not accessible to programs.  Classes
are objects in 3 Level Systems and above because classes are instances of
meta-classes.  But classes play a dual role, because objects can only be
declared to be instances of a class (and class objects instances of a
meta-class).  In 1 Level (single-hierarchy) systems, all classes are objects.


1.17)  Is An Object A Class?
----------------------------

In a Level 3 System and above yes, but only instances of a Meta-Class are
Classes.  Instances of a Class (ordinary objects) are not classes (excluding
hybrid systems).  However, all objects may be classes in single hierarchy
systems, since any object may act as a class (provide object instantiation or
act as a shared parent).


1.18)  What Is A Method? (And Receiver And Message)
---------------------------------------------------

A method implements behavior, which is defined by [Booch 91, p80]:

  Behavior is how an object acts and reacts, in terms of its state changes
  and message passing.

A method is a function or procedure which is defined in a class and typically
can access the internal state of an object of that class to perform some
operation.  It can be thought of as a procedure with the first parameter as
the object to work on.  This object is called the receiver, which is the object
the method operates on.  An exception exists with C++'s static member functions
which do not have a receiver, or "this" pointer.  The following are some common
notations for invoking a method, and this invocation can be called a message
(or message passing, see below):

  receiver.message_name(a1, a2, a3)
  receiver message_name: a1 parm1: a2 parm3: a3

Selector would be another good choice for message_name in the above examples,
although keywords (or formal parameter names, like named parameters) are
considered part of the selector in Smalltalk (and hence Objective-C).

If done statically, this can be referred to as invocation, and message passing
if done dynamically (true dynamic binding).  Statically typed dynamic binding
(e.g. C++ and Eiffel) is really in between (checked function pointers).

See also section 1.19 below for a discussion on the functional (prefix) verses
message based (receiver based) notation.


1.19)  What Are Multi-Methods And Multiple-Polymorphism?
--------------------------------------------------------

Multi-methods involve two primary concepts, multiple-polymorphism and lack of
encapsulation.  These issues are orthogonal.  Multiple-polymorphism implies
more than one parameter can be used in the selection of a method.  Lack of
encapsulation implies all arguments can be accessed by a multi-method (although
packages can be used to restrict access, as in CLOS).  Multi-methods can also
imply a functional prefix notation, although the CLOS designers (who coined the
term "multi-method") consider the functional and receiver based forms
(messages) equivalent.  Functional syntax was chosen "in order to minimize the
number of new mechanisms added to COMMON LISP" [Kim ch 4, p70 (D. Moon)].
[Chambers 93] discusses multi-methods in his new OO language, Cecil.

Multiple-polymorphism allows specialized functions or methods to be defined to
handle various cases:

  +(int, int)
  +(int, float)
  +(int, complex)
  +(int, real)
  +(float, complex)
  +(float, real)
  +(float, float)

The above functions are specialized to each of the cases required allowing
single, highly cohesive and loosely coupled functions to be defined.  This is
also the true essence of object-oriented polymorphism, which allows objects to
define methods for each specific case desired.  In addition to better coupling
and cohesion, multiple-polymorphism reduces program complexity by avoiding
coding logic (switch statements) and because small methods further reduce
complexity, as code complexity doesn't grow linearly with lines of code per
method, but perhaps exponentially.  This should be distinguished from double
dispatch, a fancy name for single dispatch after a call, which only provides
switching on a single argument per call (but for 2 levels), consistently
ignoring the inherent type of parameters in messaging.  Double dispatch is
used in languages with static typing for simplicity and efficiency
considerations.

If all of the above types are Numbers, code can be written without concern for
the actual classes of objects present:

  fn(one, two: Number): Number
    return one + two;

The addition expression above will invoke the correct "+" function based on the
inherent (true, actual, or dynamic) types of one and two.  Only the inherent
type of "one" would be used with double dispatch!  In the author's opinion,
this is a serious shortcoming.  Further, double dispatch would only allow
switching to the "fn" function based on the type of "one" also.  This could
lead to the use of switch statements based on type or complex coding in many
real-world programming situations, unnecessarily.  In the author's opinion,
this should only be used as necessary, e.g. if the implementation language
doesn't support multiple-polymorphism and either efficiency considerations
dominate and double dispatch can be suffered, or an embedded dynamic typing
scheme is used.

Why do multi-methods allow open access to parameters?  It allows efficient
handling, like C++ friends, usually by allowing representation details of more
than one object to be exposed.  See [Kim ch 4, pp70-71 (D. Moon)] for an
alternative explanation.  While open access can be useful in some cases, it
typically isn't recommended as a general OO practice (see section 1.15, C+W's
requirement 1 for OO languages and Section 1.2 on Encapsulation) and also
violates subtype polymorphism, because only subclass polymorphism is based on
representation and not type.

Polymorphic languages can be statically typed to provide strong type checking,
efficiency, and to support a static programming idiom, but require restrictions
in many cases, such as requiring overriding methods to have identical
signatures with the methods they substitute (as in C++) or allowing covariant
parameters but limiting base class usage (as in Eiffel).  If these restrictions
are dropped, multiple-polymorphism results.  Thus a single overridable function
declared in a base class may have several functions overriding it in a derived
class differentiated only by their formal argument types.  This therefore
requires both static and dynamic typing, because no formal argument
differentiation is possible without static types, as in Smalltalk, and no
actual argument differentiation is possible without dynamic types (as in C++
and Eiffel).  See section 2.3 for another example of multiple-polymorphism.

There is some concern about the efficiency of run-time method selection as
can occur with multiple-polymorphism (or even dynamic message passing).
However, static analysis optimizations are commonly available in the
literature, potentially providing a single static selection in many cases
[See Agrawal 91, Chambers 92, Mugridge 91, and etc.].

But coupling the two cases of selector variables (as found in CLOS,
Objective-C, and etc.) and several possible known selectors together with the
general undecidability of dynamic types at compile-time renders dynamic typing
and run-time selection (or checking) as unavoidable in the general case [a
point often mistaken in comp.object.  E.g. simple statically/strongly typed
multi-methods still require dynamic types!]

See [Booch 91], multiple-polymorphism, for a good CLOS example.


1.20)  What Is OOP?
-------------------

OOP stands for Object-Oriented Programming, the usual programming/hacking and
etc. most programmers think of.  Modern software engineering methodologies;
however, consider OOP as the implementation/evolution of an OOD.


1.21)  What Is OOA/OOD (And Where Can I Get What I Need On It)?
---------------------------------------------------------------

  See also section 3.7, the Annotated Bibliography, and APPENDIX D.  The
  classified bibliography in [Booch 94] also contains entries on OOA(B), OOD(F)
  and OOP(G).

[Booch 91]
  "In OOA, we seek to model the world by identifying the classes and objects
  that form the vocabulary of the problem domain, and in OOD, we invent the
  abstractions and mechanisms that provide the behavior that this model
  requires."

[Coad 91]
  "OOA is the challenge of understanding the problem domain, and then the
  system's responsibilities in that light".
  "To us, analysis is the study of a problem domain, leading to a specification
  of externally observable behavior; a complete, consistent, and feasible
  statement of what is needed; a coverage of both functional and quantified
  operational characteristics (e.g. reliability, availability, performance)".
  "Design.  The practise of taking a specification of externally available
  behavior and adding details needed for actual computer system implementation,
  including human interaction, task management, and data management details."

And on Domain Analysis:

  "Whereas OOA typically focuses upon one specific problem at a time, domain
   analysis seeks to identify the classes and objects that are common to all
   applications within a given domain, [...]".  - [Booch 91]

  [The following quotes on domain analysis are from [Berard 93]]

  "An investigation of a specific application area that seeks to identify the
   operations, objects, and structures that commonly occur in software systems
   within this area.  - Dan McNicholl

  "Systems analysis states what is done for a specific problem in a domain
   while domain analysis states what can be done in a range of problems in a
   domain.  ...A domain analysis is only useful in many similar systems are to
   be built so that the cost of the domain analysis can be amortized over the
   cost of all the systems.

   The key to reusable software is captured in domain analysis in that it
   stresses the reusability of analysis and design, not code. - Jim Neighbors

  "The process of identifying, collecting, organizing, and representing the
  relevant information in a domain based on the study of existing systems and
  their development histories, knowledge captured from domain experts,
  underlying theory, and emerging technology within the domain."  - Kang et al.

  Object-oriented domain analysis (OODA) seeks to identify reusable items
  localized around objects, e.g., classes, instances, systems of interacting
  objects, and kits [frameworks]. OORA analysts and OOD designers will
  interact on a fairly frequent basis with the domain analysis effort.


OOA and OOD stand for Object-Oriented Analysis and Object-Oriented Design,
respectively.  OOA strives to understand and model, in terms of object-oriented
concepts (objects and classes), a particular problem within a problem domain
(from its requirements, domain and environment) from a user-oriented or domain
expert's perspective and with an emphasis on modeling the real-world (the
system and its context/(user-)environment).  The product, or resultant model,
of OOA specifies a complete system and a complete set of requirements and
external interface of the system to be built, often obtained from a domain
model (e.g. FUSION), scenarios (Rumbaugh), or use-cases (Jacobson).

[Shlaer 88] is often credited as the first book on OOA, although their method
adds OO techniques to the traditional structured analysis principles of Yourdon
and Constantine. Their complete approach ([Shlaer 88, 92]) consists of
information modeling and recursive design, or OOA/RD and represents a recent
addition to the structured analysis family (as does Martin and Odell).
[Yourdon 92] provides a critique, although may only refer to their earlier
work.  Many other methodologies including Rumbaugh's OMT, Martin and Odell's
OOA/D, and many others, also share common ground with SA and other existing
analysis methodologies with such constructs as associations (E-R), functional
models, and even DFD's.  Booch, Jacobson, and Wirfs-Brock are examples of OO
methodologies representing a greater departure from the conventional
"structured" techniques, with greater emphasis on objects.  OOram [Reenskaug
91] provides support and emphasis on types and roles as guiding principles,
which is quite powerful.  [Booch 94] presents a methodology which is an
evolutionary step beyond the first edition by incorporating a collection of the
best features from several of the major OO methodologies, as does HP's new
FUSION methodology.

The usual progression is from OOA to OOD to OOP (implementation) and this
Universal Process Model roughly corresponds to the Waterfall Model [Royce 70].
See [Humphrey 89] and [Yourdon 92] for a few of many discussions on software
life-cycle models and their use.  Humphrey also details Worldy and Atomic
Process Models for finer grained analysis and design in the Defined Process
(see below) and discusses other alternatives to the task oriented models.  He
also provides the following critisisms on the Waterfall Model which had led to
Boehm's seminal work on the Spiral Model:

  * It does not adequately address changes
  * It assumes a relatively uniform and orderly sequence of development steps
  * It does not provide for such methods as rapid prototyping or advanced
    languages

Modern OO methodologies directly address these points and emphasize the
incremental, iterative, evolutionary, concurrent and situational nature of
software development.  [Boehm 86] presents a seminal spiral life-cycle model
with a risk-driven incremental prototyping approach.  [Booch 91, 6.1]
proposes a "round-trip gestalt" design with analyze-design iterations and
an overall system perspective and [Berard 93] proposes an (incremental)
"parallel-recursive design" with analyze-design-implement-test iterations.
[Coad 91b] presents the following development cycle breakdown:

  Waterfall-
    Analysis
    Design
    Programming

  Spiral-
    Analysis, prototyping, risk management
    Design, prototyping, risk management
    Programming, prototyping, risk management
    [Boehm, 1988]

  Incremental-
    A little analysis
    A little design
    A little programming
    Repeat
    [Gilb, 1988]

[Author's note: The spiral model is often incremental and may waterfall if
 called for.]

Since classes and objects are used in all phases of the OO software life-cycle,
the process is often referred to as seamless, meaning there is no conceptual
gap between the phases as is often the case in other software development
methodologies, such as the analysis (DFD's) to design (structure charts) to
programming gaps found in traditional structured analysis and design.
Seamlessness together with naturalness is a big advantage for consistency.

A problem domain has many realizations, or differing OOAs.  An OOA has many
realizations, or differing OODs, but a similar notation is often used for
the two.  An OOD also has many realizations, or differing OOPs, but allows a
selection from among various languages for implementation (choosing the best
language to implement the design).  But some, such as Bjarne Stroustrup, don't
like OOA and OOD getting too far from OOP (implementation independent), for
fear that great discrepancies could occur between OOD and OOP by losing sight
of the implementation language, which in some cases is predetermined.  See also
[Stroustrup 91].

From a greater perspective, the SEI has developed the Capability Maturity Model
(CMM), a process-based TQM model for assessing the level of an organization's
software development and which is often required of government contractors
in the US [Humphrey 89].  The CMM also serves as a 5 level improvement process
by specifying steps for organizations to progress to the next level, ultimately
leading to statistical (process) control and sustained improvement.  Watts S.
Humphrey is now working on the Personal Software Process (PSP), a scaled down
version of the CMM for individuals to use (references are forthcoming).  Next
should follow a team-based software process (TSP?).  Other CMM's in the works
at the SEI include a personnel management CMM (PM-CMM).

 Level 1: Initial:    Every project is handled differently; ad hoc and chaotic.
 Level 2: Repeatable: Every project is handled similarly.
 Level 3: Defined:    Standard processes are defined and used for all projects.
 Level 4: Managed:    A measurable basis for all improvements to the process.
 Level 5: Optimizing: Emphasis on defect prevention and optimizing/continually
                      improving the process.

See also:
Kitson, D.H. and Masters, S. "An Analysis of SEI Software Process Assessment
Results 1987-1991", CMU/SEI-92-TR-24

Humphrey, W., Snyder, T. and Willis, R. "Software Process Improvement at
Hughes Aircraft", IEEE Software, July 1991

Dion, R., "Elements of a Process Improvement Program," IEEE Software, July
1992.

"Concepts on Measuring the Benefits of Software Process Improvement,"
CMU/SEI-93-TR-9.

See also [Yourdon 92], [Wilkie 93], and [Booch 94] for discussions on this
often cited model.  There is also an ISO 9000 (9001,9003) standard on software
quality and ami working group in Europe creating the SPICE standard (among
other work), which is similar in scope to the CMM.  To join the ami mailing
list email to:
  ami-request@aut.alcatel.at
with the following message:
  subscribe firstname, lastname, e-mail address.

Object-oriented analysis now includes "Enterprise Modeling" [Martin 92], also
found in [Jacobson 92], and along with recent business "reengineering" efforts
places information systems within an organizational perspective by modeling
entire organizations or a large part of them, with the information processing
system and software products development as integrated components.  [Yourdon
92] even calls for "global modeling"!


1.22)  Where Did Object-Orientation Come From?
----------------------------------------------

Simula was the first object-oriented language providing objects, classes,
inheritance, and dynamic typing in 1967 (in addition to its Algol-60 subset).
It was intended as a conveyance of object-oriented design.  Simula 1 was a
simulation language, and the later general-purpose language Simula 67 is now
referred to as simply Simula.  Smalltalk was the next major contributor
including classes, inheritance, a high-powered graphical environment and a
powerful dynamic typing mechanism (although these existed to some extent in
Simula).  Self is somewhat of a Smalltalk-based next generation language, as is
BETA a followup to Simula (by its original designers).

[Meyer 88] contains a brief summary and history of Simula and Smalltalk, among
other OO languages.


1.23)  What Are The Benefits Of Object-Orientation?
---------------------------------------------------

Reuse, quality, an emphasis on modeling the real world (or a "stronger
equivalence" with the RW than other methodologies), a consistent and seamless
OOA/OOD/OOP package, naturalness (our "object concept"), resistance to change,
encapsulation and abstraction (higher cohesion/lower coupling), and etc.

On resistance to change, system objects change infrequently while processes
and procedures (top-down) are fequently changed, providing object-oriented
systems with more resilient system organization.

[Harmon 93]:
  Faster development
  Increased Quality
  Easier maintenance
  Enhanced modifiability

[Booch 94]:
  Exploit power of OOPs
  Reuse of software and designs, frameworks
  Systems more change resilient, evolvable
  Reduced development risks for complex systems, integration spread out
  Appeals to human cognition, naturalness


1.24)  What Other FAQs Are Available?
-------------------------------------

FAQ's are cross-posted to news.answers and are archived on anonymous ftp from:

  rtfm.mit.edu:/pub/usenet		(also usenet-by-hierarchy, etc.)

rtfm archives several FAQs pertinent to OO (alternative/original sites are listed).

  comp.lang.ada         ajpo.sei.cmu.edu:public/comp-lang-ada/cla-faq[12]
  comp.lang.beta        daimi.aau.dk:pub/beta/beta-language-faq.txt
  comp.lang.c++         sun.soe.clarkson.edu:pub/C++/FAQ [128.153.12.3]
  comp.lang.clos
  comp.lang.eiffel      ftp.cm.cf.ac.uk:/pub/eiffel/eiffel-faq
  comp.lang.modula3
  comp.lang.oberon
  comp.lang.objective-c
  comp.lang.sather      ftp.ICSI.Berkeley.EDU:pub/sather [not on rtfm]
  comp.lang.scheme      ftp.think.com:/public/think/lisp/scheme-faq.text
  comp.lang.smalltalk   xcf.Berkeley.EDU:misc/smalltalk/FAQ/SmalltalkFAQ.entire
  comp.object           zaphod.uchicago.edu:/pub/CompObj6.faq(.Z)
  comp.object.logic     ftp.cs.cmu.edu:(2)prg_1.faq,prg_2.faq  [128.2.206.173]
  comp.software-eng

Notes:
  1) xcf.Berkeley.EDU is 128.32.138.1
  2) /afs/cs.cmu.edu/project/ai-repository/ai/pubs/faqs/prolog/
  3) Beta FAQ www: http://www.daimi.aau.dk/~beta/beta-language-faq.html
     most current.  Email: info@mjolner.dk with body: send BETA beta-faq
  4) Modula-3: ftp.vlsi.polymtl.ca:pub/m3/m3-faq.ps.
               http://froh.vlsi.polymtl.ca/m3/m3-faq.html.
     Archives: gatekeeper.dec.com:pub/DEC/Modula-3/comp.lang.modula3
     Newsgroup relay mailing list; message to m3-request@src.dec.com

From ankh.iia.org!babbage.ece.uc.edu!news.kei.com!bloom-beacon.mit.edu!senator-bedfellow.mit.edu!faqserv Wed Nov 23 21:57:34 1994
Path: ankh.iia.org!babbage.ece.uc.edu!news.kei.com!bloom-beacon.mit.edu!senator-bedfellow.mit.edu!faqserv
From: Bob Hathaway <rjh@geodesic.com>
Newsgroups: comp.object,comp.answers,news.answers
Subject: Comp.Object FAQ Version 1.0.7 (10-27) Part 2/10
Supersedes: <object-faq/part2_782395740@rtfm.mit.edu>
Followup-To: comp.object
Date: 29 Oct 1994 11:42:11 GMT
Organization: Geodesic Systems
Lines: 1297
Approved: news-answers-request@MIT.Edu
Distribution: world
Expires: 12 Dec 1994 11:40:18 GMT
Message-ID: <object-faq/part2_783430818@rtfm.mit.edu>
References: <object-faq/part1_783430818@rtfm.mit.edu>
NNTP-Posting-Host: bloom-picayune.mit.edu
Summary: Frequently Asked Questions (FAQ) List and Available Systems For Object-Oriented Technology
X-Last-Updated: 1994/10/28
Originator: faqserv@bloom-picayune.MIT.EDU
Xref: ankh.iia.org comp.object:7427 comp.answers:4417 news.answers:13676

Archive-name: object-faq/part2
Last-Modified: 10/27/94
Version: 1.0.7

See APPENDIX E:60 for a CDROM with Internet FAQs.

A new C++ libraries FAQ is posted monthly to comp.lang.c++ and should be on
rtfm soon.  Contact cpplibs@trmphrst.demon.co.uk.  It contains anonymous ftp
sites and commercial libraries and may be merged with this FAQ soon.

Many FAQs are also available from mail-servers, however most can be accessed by
the rtfm mail-server.  Mail to mail-server@rtfm.mit.edu with help and index in
the body with no leading spaces and on separate lines for more information.

Example Unix Command (will retrieve this FAQ in about 26 pieces (and growing)):
  mail mail-server@rtfm.mit.edu
  Subject:
  send usenet/comp.object/*

There is also a great ftp site for sci.virtual-worlds on:
  stein.u.washington.edu (140.142.56.1)
          - home of sci.virtual-worlds, huge faq w/ great info!
          - if unable to use try ftp.u.washington.edu
          /public/virtual-worlds

[While VR may not be directly related to comp.object, it is most interesting!
   - The Author]


SECTION 2:  TYPING
==================

There are many definitions of type (and class and related concepts).  Many
authors define the terms as applied by their particular approach or language,
however we shall proceed in the face of this diversity.

  References
    [Blair 89]          Some Typing Topics.
    [Booch 91]          Small Section on Typing.
    [Cardelli 85]       Discussion on Object-Oriented Typing.
    [Gunter 94]         Theoretical Aspects of Object-Oriented Programming.
    [Kim 89, ch1]       Discussion on Some Research Topics.


2.1)  What Is Polymorphism?
---------------------------

Polymorphism is a ubiquitous concept in object-oriented programming and is
defined in many ways, so many definitions are presented from: Websters',
Author, Strachey, Cardelli and Wegner, Booch, Meyer, Stroustrup, and Rumbaugh.
Polymorphism is often considered the most powerful facility of an OOPL.

> Webster's New World Dictionary:

Polymorphism 1. State or condition of being polymorphous.  2. Cryall.
  crystallization into 2 or more chemically identical but
  crystallographically distinct forms.  3.  Zool., Bot. existence of an
  animal or plant in several forms or color varieties.

polymorphous adj. having, assuming, or passing through many or various forms,
  stages, or the like.  Also, polymorphic. [<Gk polymorphous multiform]


> Author's Definition:

Polymorphism is the ability of an object (or reference) to assume (be
replaced by) or become many different forms of object. Inheritance (or
delegation) specifies slightly different or additional structure or
behavior for an object, and these more specific or additional attributes
of an object of a base class (or type) when assuming or becoming an
object of a derived class characterizes object-oriented polymorphism.
This is a special case of parametric polymorphism, which allows an
object (or reference) to assume or become any object (possibly
satisfying some implicit or explicit type constraints (parametric type),
or a common structure), with this common structure being provided by
base classes or types (subclass and subtype polymorphism, respectively).

"Poly" means "many" and "morph" means "form".  The homograph polymorphism has
many uses in the sciences, all referring to objects that can take on or assume
many different forms.  Computer Science refers to Strachey's original
definitions of polymorphism, as divided into two major forms, parametric and
ad-hoc.  Cardelli and Wegner followup with another classification scheme,
adding inclusion polymorphism for subtyping and inheritance.


> Strachey's Original Definition [Strachey 67]:

"Parametric polymorphism is obtained when a function works uniformly on
a range of types; these types normally exhibit some common structure.
Ad-hoc polymorphism is obtained when a function works, or appears to
work, on several different types (which may not exhibit a common
structure) and may behave in unrelated ways for each type."

Parametric polymorphism is also referred to as "true" polymorphism, whereas
ad-hoc polymorphism isn't (apparent polymorphism).


> Cardelli and Wegner's Definition [Cardelli 85]:

C+W refine Strachey's definition by adding "inclusion polymorphism" to model
subtypes and subclasses (inheritance).  Strachey's parametric polymorphism is
divided into parametric and inclusion polymorphism, which are closely related,
but separated to draw a clear distinction between the two forms, which are then
joined as specializations of the new "Universal" polymorphism.

                                 |-- parametric
                 |-- universal --|
                 |               |-- inclusion
  polymorphism --|
                 |               |-- overloading
                 |-- ad hoc    --|
                                 |-- coercion

Polymorphic Languages: some values and variables may have more than one type.

Polymorphic Functions: functions whose operands (actual parameters) can
  have more than one type.  [...] If we consider a generic function to be
  a value, it has many functional types and is therefore polymorphic.

Polymorphic Types: types whose operations are applicable to operands of more
  than one type.

Parametric Polymorphism: a polymorphic function has an implicit or explicit
  type parameter which determines the type of the argument for each
  application of that function.

Inclusion Polymorphism: an object can be viewed as belonging to many different
  classes that need not be disjoint; that is, there may be inclusion of
  classes.

The two forms of "Universal Polymorphism", parametric and inclusion are closely
related, but are distinct enough in implementation to justify separate
classifications.

Parametric polymorphism is referred to as generics.  Generics can be syntactic,
where each instantiation creates a specialized version of the code allowing
fast running execution, but in a "true polymorphic system", only a single
implementation is used.

On inheritance is subtype polymorphism:
"Subtyping on record types corresponds to the concept of inheritance
(subclass) in languages, especially if records are allowed to have functional
components."

Author's Notes:
Implicit parametric polymorphism can be implemented with type inferencing
schemes [Aho 85].  ML is prototypical in providing this facility.

Inclusion polymorphism is common and is found in languages such as Simula,
Ada-9x, C++, CLOS, Eiffel and etc. (subclass polymorphism).  Smalltalk also
uses inclusion polymorphism; its used in declaring classes, and subclass
polymorphism is used in practice but not enforced.  For inheritance, inclusion
polymorphism specifies an instance of a subclass can appear wherever an
instance of a superclass is required.  For subtyping (subtype polymorphism),
the same applies because all operations required by the supertype are present
in the subtype (subtype is subset of supertype).  Cardelli and Wegner view
classes as sets of objects (resulting in subtype objects are a subset of
supertype objects, or an extensional view), as contrasted with a feature based
(intensional) approach (where subtypes are supersets of (contain) supertypes).
MI provides an interesting example here, as it is set intersection with an
extensional view and set union with an intensional view.  Details are left as
an exercise for the reader.

Ada generics and C++ templates provide explicit syntactic generics.  While
Ada may infer some actual generic parameters (operations) and C++ doesn't
require explicit instantiation of its template functions, formal generic
parameters must still be declared and many bodies are generated.

Inclusion polymorphism can refer to subtyping, or having at least as much or
more than required.  Since derived classes can inherit structure and behavior
from base classes, such inheritance is an example of inclusion polymorphism
with respect to representation (subclassing).  An example of inclusion
polymorphism with respect to assignment (and initialization, or replacement if
viewed in an almost symbolic way) occurs when object types may be specified and
assignment is based on actual object membership in that type (often of the CLOS
is-a-member-of form in OO).  Emerald provides another example of an object-
oriented language using inclusion polymorphism with respect to replacement;
however, inclusion is with respect to subtyping only with abstract types
("bounded quantification" by C+W.  C+W's parameters are subtype polymorphic
but lose the inherent type).  Any object possessing all required operations is
acceptable and no inheritance relation is required (subtype polymorphism).
They refer to this as "best-fitting" types [Black 86].  The original Trellis/
Owl also had such a facility but with two separate inheritance hierarchies,
although it was abandoned in favor of a single class-based approach for
simplicity.  See also section 2.7.

[As inclusion polymorphism covers both subtype and subclass polymorphism,
 perhaps IP could be further divided in C+W's above classification.]


> Booch's Definition [Booch 91, p. 517]:

polymorphism  A concept in type theory, according to which a name (such as a
variable declaration) may denote objects of many different classes that are
related by some common superclass; thus, any object denoted by this name is
able to respond to some common set of operations in different ways.

Booch also has several sections devoted to polymorphism.

[The author notes Booch's definition above is clearly in the context of
 conventional, classical OO and subclass polymorphism.]


> Meyer's Definition [Meyer 88, sect. 10.1.5 Polymorphism]:

"Polymorphism" means the ability to take several forms.  In object-oriented
programming, this refers to the ability of an entity to refer at run-time to
instances of various classes.  In a typed environment such as Eiffel, this is
constrained by inheritance: ...

[The Author notes Meyer has a following section 10.1.7 on Static Type,
 dynamic type, which is relevant, but claims "... there is no way the type
 of an object can ever change.  Only a reference can be polymorphic: ...".
 Meyer is clear between the concept and the Eiffel realization in his
 polymorphism definition above, but here neglects the "becomes" facility
 as found in several dynamically typed OO languages such as Actors, CLOS,
 Self and Smalltalk, which allows an object (and not just a reference) to
 change its class.]


> Stroustrup's Definition [Stroustrup 90, p. 209]:

The use of derived classes and virtual functions is often called "object-
oriented programming".  Furthermore, the ability to call a variety of
functions using exactly the same interface - as is provided by virtual
functions - is sometimes called "polymorphism".

[The Author notes this is a functional view of polymorphism (as provided in
C++).  [Stroustrup 91, p. 136] has an example of polymorphism with void *'s,
but a newer template function is incomparably preferable, as implied in
[Stroustrup 90, ch 14]]


Rumbaugh's Definition [Rumbaugh 91, p. 2]:

"Polymorphism" means that the same operation may behave differently on
different classes.


2.2)  What Does Polymorphism Boil Down To In OO Programming Languages?
----------------------------------------------------------------------

In C++, virtual functions provide polymorphism. This is because a
polymorphic object (pointer or reference (or such parameter)) is
assignment compatible with any object of a derived class. Is this
polymorphism in itself? Objects can take on objects of different forms
(the derived classes), but of what use is it? To make any difference,
the differing forms must have some effect. In dynamically typed
languages, polymorphic objects are passed messages and will respond in
whatever way the object has defined (usually starting from its most
derived class and working its way up). But for static objects, a virtual
function is invoked. This is the stored method from the derived class
that overrode the virtual method from its base class, providing
specialized behavior for the polymorphic object; and hence,
polymorphism. This common pure statically typed example is, of course,
an example of inclusion polymorphism, subclass polymorphism to be more
specific (see section 2.1). Pure statically typed subtype polymorphism,
as provided in Emerald, can be implemented similarly [Black 86].


2.3)  What Is Dynamic Binding?
------------------------------

Dynamic binding has two forms, static and dynamic. Statically-typed
dynamic binding is found in languages such as C++ (virtual functions)
and Eiffel (redefinition). It is not known which function will be called
for a virtual function at run-time because a derived class may override
the function, in which case the overriding function must be called.
Statically determining all possibilities of usage is undecidable. When
the complete program is compiled, all such functions are resolved
(statically) for actual objects. Formal object usage must have a
consistent way of accessing these functions, as achieved thru vtables of
function pointers in the actual objects (C++) or equivalent, providing
statically-typed dynamic binding (this is really just defining simple
function pointers with static typechecking in the base class, and
filling them in in the derived class, along with offsets to reset the
receiver).

The run-time selection of methods is another case of dynamic binding,
meaning lookup is performed (bound) at run-time (dynamically). This is
often desired and even required in many applications including
databases, distributed programming and user interaction (e.g. GUIs).
Examples can be found in [Garfinkel 93, p80] and [Cox 91, pp 64-67]. To
extend Garfinkels example with multiple-polymorphism, a cut operation in
an Edit submenu may pass the cut operation (along with parameters) to
any object on the desktop, each of which handles the message in its own
way (OO). If an (application) object can cut many kinds of objects such
as text and graphical objects, multiple-polymorphism comes into play, as
many overloaded cut methods, one per type of object to be cut, are
available in the receiving object, the particular method being selected
based on the actual type of object being cut (which in the GUI case is
not available until run-time).

Again, various optimizations exist for dynamic lookup to increase
efficiency (such as found in [Agrawal 91] and [Chambers 92]).

Dynamic binding allows new objects and code to be interfaced with or
added to a system without affecting existing code and eliminates switch
statements. This removes the spread of knowledge of specific classes
throughout a system, as each object knows what operation to support. It
also allows a reduction in program complexity by replacing a nested
construct (switch statement) with a simple call. It also allows small
packages of behavior, improving coherence and loose coupling. Another
benefit is that code complexity increases not linearly but exponentially
with lines of code, so that packaging code into methods reduces program
complexity considerably, even further that removing the nested switch
statement! [Martin 92] covers some of these issues.


2.4)  Is There A Difference Between Being A Member Or Instance Of A Class?
--------------------------------------------------------------------------

Yes (but be careful of context). To use C++ terminology, an object (not
a reference) is defined to be an instance of exactly one class (in
classical OO), called its most derived class. An object not directly
contained in any other is called the complete object [Stroustrup 90]. An
object is a member of several classes, including all of the classes its
declared (or most derived) class inherits from. With static typing and
inclusion polymorphism based on class, if a polymorphic object (or
reference) is made to refer to an object, that object must be a member
of the polymorphic object's class.

This also provides a good example of differing definitions among
object-oriented languages, since a member is defined as above in CLOS,
but a member of a class is one of its instance variables in C++.


2.5)  What Is The Difference Between Static And Dynamic Typing?
---------------------------------------------------------------

Static typing refers to types declared in a program at compile-time, so
no type information is available on objects at run-time. Dynamic typing
uses the inherent types of polymorphic objects, keeping track of the
types of objects at run-time. Statically typed dynamic binding is a
compromise (usually implemented with tables of function pointers and
offsets), and is how statically-typed OO languages provide polymorphism.
Some approaches provide both static and dynamic typing, sometimes with
static typing providing type-safe programs and dynamic typing providing
multiple-polymorphism [Agrawal 91] [Mugridge 91]. See also section 2.3.

Static typing is more efficient and reliable, but loses power. Typical
restrictions include only allowing a common set of base class functions
(or any common functions for the more general subtyping or parametric
polymorphic cases) to be available on formal objects and a lack of
multiple-polymorphism (see section 1.19), both of which are overcome
with dynamic typing.

Many languages provide dynamic typing: Smalltalk, Self, Objective-C, and
etc. A limited dynamic typing scheme, called RTTI (Run Time Type
Identification), is even being considered for the C++ standard. A
similar facility to safe downcasting (historically known as type
narrowing), the thrust of RTTI, can also be found in recent versions of
Eiffel.

See section 3.4 for a categorization of common OO languages by type system.


2.6)  What Is This I Hear About ML And Functional Programming Languages?
------------------------------------------------------------------------

ML, Metalanguage, is a functional programming language with a strongly typed
polymorphic type system [Wikstrom 87].  Russell (see Appendix E) is a more
recent functional language and Haskell [Hudak 92] provides a more modern and
"pure" example.  Section 2.5 discusses why static typing has less power/
flexibility than dynamic typing and the same applies to ML (although see the
appendixes for an experimental dynamic extension to ML, Alcool-90 and [Cardelli
85] for a proper placement of ML's type system).  ML doesn't use inheritance
for polymorphism; unlike OO languages, but provides the prototypical example of
parametric polymorphism, so no inheritance is required.  This is "true" or
"pure" statically (or strongly) checked parametric polymorphism, by Strachey's
(and Cardelli and Wegner's) definitions.

Smalltalk is an example of a dynamically-typed language which does not check
types during assignment (and hence for parameters) and therefore provides
parametric polymorphism without static constraints (by Strachey's definition).
However, Smalltalk's style uses inclusion polymorphism in practise and
inheritance for subclassing (representation).


2.7)  What Is A Separation Between Type And Class (Representation)?
-------------------------------------------------------------------

For a short answer:
  Subtype Polymorphism, as opposed to Subclass Polymorphism, is the best answer
  in OO.  Parametric polymorphism is a related concept where this is also true,
  but is of a different flavor (and usually requires object attributes by use.
  See also section 2.1).

A type can be considered a set of values and a set of operations on those
values.  This can insure type-safe programming.  However, the representation of
types (classes in OO) can be separated from the notion of type allowing many
representations per type while still maintaining reasonable type-safety.

In many languages, a type has a single representation insuring all operations
performed on that type are well defined (statically bound) and providing for
efficiency by taking advantage of that representation wherever used.  In many
OO languages, subclassing and dynamic binding provides for greater flexibility
by providing object specialization.  However, in many OO languages classes are
used for assignment compatibility forcing an assigned object to inherit
(transitively) from any polymorphic object's class (inclusion polymorphism
based on class, or subclass polymorphism).  This insures all operations to be
performed on any polymorphic object are satisfied by any replacing objects.
This also insures all types share a common representation, or at least a
common base interface specification.

By separating type from class, or representation (or perhaps separating class
from type, by the aforementioned definition of type), a replacing object must
satisfy the operations or type constraints of a polymorphic object (subtype
polymorphism) but are not required to do to do so by an inheritance relation
(subclass polymorphism), as is typical in most OOPLs.  Dropping this
restriction is somewhat less type-safe, because accidental matches of method
signatures can occur, calling for greater care in use.  [Black 86] discusses
this issue in Emerald.  The same issue arises in parametric polymorphism
(generics/templates), as any method matching a required signature is accepted,
calling for careful matching of actual and formal generic parameters.  The
difference between static and dynamic binding in OO and dynamic binding and
subtyping seems similar.  A possible loss of semantic integrity/similarity is
contrasted with greater power.

It is possible to specify desired abstract properties of type specifications
with mechanisms similar to Eiffel's pre-, post-, and invariant conditions.
This helps to insure the semantic integrity of replacing objects and their
behavior.  [Liskov 93] provides a recent exposition.

Abstract classes ([Stroustrup 91] and [Meyer 88]) in typing provide a facility
similar to subtype polymorphism; however, ACs require type compatible classes
to inherit from them, providing a subclass polymorphism facility, and ACs can
also specify representation.  Subtyping is therefore most useful to avoid
spreading knowledge of classes throughout a system, which is a high priority
for loosely coupled modules and in distributed programming [Black 87].

The formal type system found in [Cardelli 85], Emerald/Jade [Black 86] and
[Raj 89], original trellis/Owl, an experimental C++ extension (See Appendix E,
Signatures), Sather (originally Eiffel-based), and an Eiffel superset
[Jones 92] are all examples of OO systems providing subtype polymorphism.
Functional languages such as ML, Russell, and Haskell provide a separation with
pure parametric polymorphism (as is also commonly found in OO languages in
addition to inclusion polymorphism).

See also [Cook 90], "Inheritance Is Not Subtyping", for a formal approach.


2.8)  What Are Generics And Templates?
--------------------------------------

Short Answer: Parametric Polymorphism (although various implementations
              provide various subsets).

Generics (or Templates in C++) refer to the ability to parameterize types
and functions with types.  This is useful for parameterized classes and
polymorphic functions as found in languages such as Ada, C++, Eiffel, and
etc., although these are "syntactic" or restricted forms [Cardelli 85].
Generics are orthogonal to inheritance, since types (and classes)
may be generically parameterized.  Generics provide for reusability in
programming languages.  An example is a Stack with a generically
parameterized base type.  This allows a single Stack class to provide
many instantiations such as a Stack of ints, a Stack of any fundamental
or user defined type, or even a Stack of Stacks of ...  Another example is
a polymorphic sort function taking a base type with a comparison operator.
The function can be called with any type (containing a comparison operator).
See [Booch 87b] for several examples in Ada and [Stroustrup xx] and [Murray
93] for examples in C++.

While generics have many advantages, typical limitations include a static
nature, which is an advantage for strong typechecking but a potential
disadvantage when causing dynamic compilation (leading to a time/space
efficiency tradeoff), and sources can cause inlining and create source code
dependencies and expand code size (unlike a single-body or "true"
parametrically polymorphic implementation.  Generics can also be viewed as a
special case of type variables.

Functions are typically generic in statically-typed parametrically-polymorphic
languages.  One such popular functional language is ML, in which all functions
are generic.  Russell and Haskel are more modern variants (references are
forthcoming, however see APPENDIX E).


SECTION 3:  GENERAL
===================

  References:   (many more are to come)
    [Coplien 92]    Covers C++, symbolic, exemplar (single-hierarchy), etc.
    [Kim 89]        Covers many OO systems.


3.1)  What Is The "Classical" Object-Oriented Paradigm?
-------------------------------------------------------

This refers to the usual class and object model.  Its any 2+ level system
as described in section 1.4.  See also [Coplien 92].


3.2)  What Is The "Delegation/Prototyping" Object-Oriented Paradigm?
--------------------------------------------------------------------

See [Kim 89, ch 1,3].

This is the 1 Level System as Described under Meta-Classes.  Delegation refers
to the delegating of responsibility and can be applied to inheritance.  When a
derived class does not have a desired attribute, it "delegates" responsibility
to one of its base classes.  In delegation systems, each object has a delegate
list instead of a parent list. Thus, delegation's primary emphasis is
on message passing where an object could delegate responsibility of a message
it couldn't handle to objects that potentially could (its delegates).  Any
object can be added to the delegate list, giving dynamic inheritance (of a
sort).  Typically, delegation and prototyping languages also have "part
inheritance" in which fields and methods can be added and deleted from objects.
This makes for easy "prototyping", which allows for objects to be constructed
piece by piece at run-time, although the term "prototyping" in the context of
delegation languages usually refers to objects serving as prototypes for
object instantiation, or exemplars.

Next's NextStep OS provides delegation using Objective-C, providing an example
of delegation in a class-based language [Garfinkel 93].


3.3)  Are There Any Other Object-Oriented Paradigms?
----------------------------------------------------

There are many alternatives in OO.  Emerald/Jade ([Black 86] and [Raj 89])
provides one, where inheritance is replaced with a roughly equivalent form
where reuse occurs at a finer degree of granularity - method and instance
variables - with subtype polymorphism making up the difference.

CLOS [Kim 89, ch 4] has a looser coupling of methods to classes and doesn't
distinguish a receiver, but packages can help make up the difference.

Object Specialization [Sciore 89] is an example of a hybrid approach between
delegation and classical systems, where parent classes have an extra level
of indirection and inheritance hierarchies are specified on a per object/class
basis.


3.4)  What Are The Major Object-Oriented Programming Languages Today?
---------------------------------------------------------------------

Statically-Typed:
  Add 1 To Cobol giving Cobol with Objects.
  C++
  Classic-Ada
  Dragoon
  Emerald/Jade
  Object Pascal
  Trellis/Owl

Dynamically-Typed:
  Actors Languages
  C+@
  Flavors
  Self
  Smalltalk

Both:
  Actor
  Ada-9x
  BETA
  C++ (With RTTI)
  Cecil
  CLOS
  Eiffel
  Modula-3
  Objective-C
  Sather


3.5)  What Are Object-Oriented Databases And Persistence?
---------------------------------------------------------

See also Appendices B and E and the comp.database.object newsgroup.
Refs to be included in future FAQs.

Object-Oriented Databases are databases that support objects and
classes. They are different from the more traditional relational
databases because they allow structured subobjects, each object has its
own identity, or object-id (as opposed to a purely value-oriented
approach) and because of support for methods and inheritance. It is also
possible to provide relational operations on an object-oriented
database. OODBs allow all the benefits of object-orientation, as well as
the ability to have a strong equivalence with object-oriented programs,
an equivalence that would be lost if an alternative were chosen, as with
a purely relational database.

Another way of looking at Object-Oriented Databases is as a persistent
object store with a DBMS.

Persistence is often defined as objects (and their classes in the case
of OODBs) that outlive the programs that create them. Object lifetimes
can be viewed as a hierarchy, with locals/automatics having the shortest
default lifetime and objects stored indefinitely in an OODB (which are
persistent) having the longest. Persistent object stores do not support
query or interactive user interface facilities, as found in a fully
supported OODBMS.

Appendix B also contains references for object-oriented interfaces to
relational databases and see APPENDIX E, Papers, Persistent Operating
Systems.

From the net:
From: dbmsfacts@aol.com (DBMSfacts)
Subject: ODMG Gopher and Web Addresses
Date: 24 Oct 1994 13:10:02 -0400

The Object Database Management Group (ODMG) has set up Gopher and Web
Servers at the following addresses:

  Gopher:  gopher.odmg.org, port 2073
  WWW:  http://www.odmg.org:3083

These are still under construction.  What you can find right now are
addresses and contact information for ODBMS vendors, ODMG membership
information, updates to Release 1.1 of The Object Database Standard:
ODMG-93 along with ODL lex and yacc files.  In the future, we will be
adding more links to related sites, bibliographies, and a FAQ for ODBMSs.

If you cannot access these servers, but would like information on the
ODMG, send an email message to info@odmg.org and you will receive an
automated reply.

Doug Barry
ODMG Executive Director


3.6)  What Are Object-Oriented Operating Systems?
-------------------------------------------------

Refs to be included in future FAQs.  See also Appendix E.

Object-Oriented Operating Systems provide resources through objects,
sometimes all the way down to to the machine (OO architectures are found
at the bottom). They are almost always distributed systems (DOS or
DPOS), allowing objects to be passed freely between machines. They are
typically capability-based since objects, and hence system resources,
can only be accessed if a capability to them is available to programs.

Here are some abstracts taken from several postings to the net. This
list is by no means exhaustive.

Apertos (Meta-Object-based Mikro-Kernel.  See Appendix E, Papers:28)
Chorus Micro-kernel (written in C++, COOL, See Appendix E, Papers:63)
Choices (research OS, UofI, C++, supports SVR4, See Appendix E, Papers)
GEOS    (GeoWorks', written in Object Assembler, OO superset of 8086)
Mach    (CMU, supports BSD 4.3, really message-based)
NachOS  (written in C++, OS teaching/learning OS)
Ouverture Project (ESPRIT funded OMG IDL defines inter-module interfaces)
Peace    (OO family-based parallel OS, See Appendix E, General)
SOS
Spring      (Sun, written in C++)
PenPoint OS (Go, written in C++)

For the Spring Papers (free), Contact:
  Sun Microsystems Laboratories, Inc.
  M/S 29-01
  2550 Garcia Avenue
  Mountain View, CA USA  94043

See also APPENDIX E, PAPERS, Persistent Operating Systems entry.

From: whitney@oberon.Meakins.McGill.CA ()

Insight ETHOS: On Object-Orientation in Operating Systems
ISBN 3 72811948 2

This thesis covers the design of an extensible object-oriented operating
systems. The language used was Oberon-2. It includes a generalization of
the Rider/Carrier principle, Object Directories as well as basic OS
issues such as memory, file, tasking management. It covers extensible
objected-oriented programming from hardware up. It reviews other designs
such as Clouds and Choices which where written It reviews other designs
such as Clouds and Choices which where written on C++. [[ The lack of
type-tests in C++ was a problem in other designs.]] ETHOS was
implemented as an operating system for the Ceres computers at the ETH.


3.7)  What Are The Current Object-Oriented Methodologies?
---------------------------------------------------------

Here is a list of OOSE Methodologies:

  Berard                        [Berard 93]
  BON                           [Nerson 92]
  Booch                         [Booch 94]
  Coad/Yourdon                  [Coad 91]
  Colbert                       [Colbert 89]
  de Champeaux                  [de Champeaux 93]
  Embley                        [Embley 92]
  EVB                           [Jurik 92]
  FUSION                        [Coleman 94]
  HOOD                          [HOOD 89]
  IBM                           [IBM 90,91]
  Jacobson                      [Jacobson 92]
  Martin/Odell                  [Martin 92]
  Reenskaug (OOram, was OORASS) [Reenskaug 91]
  ROOM                          [Selic 94]
  Rumbaugh et al.               [Rumbaugh 91]
  Shlaer and Mellor             [Shlaer 88 and 92]
  Wasserman                     [Wasserman 90]
  Winter Partners (OSMOSYS)     [Winter Partners]
  Wirfs-Brock et al.            [Wirfs-Brock 90]

Further Ideas And Techniques:
  Meyer                         [Meyer 88]
  Stroustrup                    [Stroustrup 91]

See APPENDIX D for CASE systems supporting these methodologies (several from
the originators themselves).

See also section 1.21 for a discussion on OOA/OOD and etc.

Summaries and comparisons will be provided in future FAQs.  Suggestions for
inclusion of other major or new methodologies should be sent to the FAQ author.

Here are some comparison studies posted to the net:

Arnold, P., Bodoff, S., Coleman, D., Gilchrist, H., Hayes, F., An
Evolution of Five Object Oriented Development Methods, Research report,
HP Laboratories, June 1991

de Champeaux, Dennis and Faure, Penelope. A comparative study of
object-oriented analysis methods. Journal of Object Oriented Programming
(JOOP), pp 21-32. Vol.5, No. 1, 3/4-92

Fichman R.G. & Kemerer C.F.  OO and Conventional Analysis and Design
Methodologies.  Computer, Oct 1992, Vol 25, No. 10, p 22-40

Fichman, Robert and Kemerer, Chris. Object-Oriented and Conventional
Analysis and Design Methods - Comparison and Critique. IEEE-Comp, Oct,
1992, pp 22-39. OOA, OOD, conventional analysis, conventional design,
DeMarco SA, Yourdon SA, Bailin OO requirements specification,
Coad-Yourdon OOA, Shlaer-Mellor OOA, Yourdon-Constantine SD, Martin
information engineering design, Wasserman OOSD, Booch OOD, Wirfs-Brock
responsibility-driven design.

Hong, S., van den Goor, G., and Brinkkemper, S. A Comparison of
Object-oriented Analysis and Design Methods. Working paper, Computer
Information Systems Department, Georgia State University, Atlanta USA,
1992, 12 pages. To appear in the Proceedings of the 26th Hawaiian
international conference on System Sciences, IEEE Computer Science
Press.

Hong, S., van den Goor, G., Brinkkemper, S. A Formal Approach to the
Comparison of Object-Oriented Analysis and Design Methodologies, Hawaii
International Conference on System Sciences (HICSS) (IEEE Computer
Society Press, Hawaii) 1993, Vol. IV, pp. 689-698. Summary of [van den
Goor et.al., 1992] below.

  Order procedure:
  Available from the authors at cisssh@gsusgi2.gsu.edu or sjbr@cs.utwente.nl.
  The authors, regretfully, cannot supply ftp, postscript, TEX, or
  whatsoever.

Monarchi, David and Puhr, Gretchen I. A Research Typology for
Object-Oriented Analysis and Design. CACM/September 1992/Vol.35, No.9,
pp35.

[Wilkie 93] summarizes, compares, and provides examples of Booch,
Wirfs-Brock, Hood, Coad and Yourdon, Winter Partners, Shlaer and Mellor,
Jacobson, Wasserman et al, Rumbaugh, Reenskaug et al, and Colbert.

Wirfs-Brock, R.J. and Johnson, R.E., "Surveying Current Research in
Object-Oriented Design," The Communications of ACM, (33, 9) Sept. 1990,
pp. 104-1124.

UNICOM. Approaches to Object-Oriented Analysis and Design. tel: l 44 895
256 484. Ask the TOC and have a look at it.


Also commercially available:

An Evaluation of Object-Oriented Analysis and Design Methodologies (9)
J. Cribbs, C Roe, S. Moon SIGS Books (212) 274-0640 $149.

Object-Oriented Methodology Comparison Study (10 methodologies) Berard,
Booch, Coad/Yourdon, Colbert, Embley, IBM, Martin/Odell, Rumbaugh,
Shlaer/Mellor, Wirfs-Brock. Also contains refs to several previous
studies. Berard Software Engineering 101 Lakeforest Blvd., Suite 360,
Gaithersburg, MD 20877 Contact Person: Jim Youlio Phone: 301-417-9884
Fax: 301-417-0021 email: info@bse.com

[van den Goor et.al., 1992] G. van den Goor, S. Hong and S. Brinkkemper,
A Comparison of Six Object-oriented Analysis and Design Methods. Report
Center of Telematics and Information Technology, University of Twente,
the Netherlands, and Computer Information Systems Department, Georgia
State University, Atlanta, USA, 1992, 163 pages, US$ 70.

This report gives an in-depth analysis of six generally accepted O-O
methods, that are available in textbooks. The background, steps,
concepts, notations, and specification techniques of the methods are
extensively compared.

The six methods are:
-  Object Oriented Analysis & Object Oriented Design (OOA/OOD) of Coad &
      Yourdon (1991)
-  Designing Object Oriented Software (DOOS) of Wirfs-Brock et.al. (1990)
-  Object Modelling Technique (OMT) of Rumbaugh et.al. (1991)
-  Object Oriented Systems Analysis (OOSA) of Shlaer & Mellor (1988)
-  Object Oriented Design with Applications (OODA) of Booch (1991)
-  Object Oriented Analysis and Design (OOAD) of Martin & Odell (1992).

The comparison is performed by meta-modelling, resulting into detailed
information on the concepts of the methods (in EER notation) and on the
steps of the procedure of the methods (in Task Diagrams). Extensive
comparison tables of steps, concepts, techniques are included. Mappings
of the methodical concepts to the constructs of programming languages
(C++, Objective-C, Smalltalk-80, Object Pascal en CLOS) are given. A
small test case illustrates the application of the methods.

Order procedure:
Those who want to order the complete report (163 pp.) can order one by
specifying their postal address in an e-mail (sjbr@cs.utwente.nl) or fax
(+31.53.33.9605) attn. Sjaak Brinkkemper. The report will be send within
two weeks with an invoice for US$ 70. (seventy dollar; including
shipping, excl VAT).


3.8)  What Is the OMG/OMA/ORB/CORBA?
------------------------------------

Contents:
  (3.8.1)  Contact Information
  (3.8.2)  OMG Summary
  (3.8.3)  Mail Server Access
  (3.8.4)  OMG Publications
             - First Class (Bi-Monthly Newsletter)
             - Object Management Architecture Guide (OMA)
             - The Common Object Request Broker: Arch. and Spec. (Corba)
             - Pricing
  (3.8.5)  Implementations (Brief)
  (3.8.6)  Implementation Descriptions
  (3.8.7)  Books, Articles, And Literature


3.8.1  Contact Information
__________________________

Contact Person: Richard Soley (technical director) soley@omg.com

FTP Sites:
  omg.org:pub/*
  omg.org:pub/NEC_DII/93-1-2.tar...            *CORBA (DII) (corba.ps.Z)
  omg.org:pub/OMG_IDL_CFE_1.2/bin*              idl.SunOS4.x, idl.Solaris2.x
  claude.ifi.unizh.ch:under pub/standards/spec  CORBA Spec

Headquarters:                            Marketing Office:
  492 Old Connecticut Path                 3823 Birchwood Drive
  Framingham, MA 01701                     Boulder, CO  80304
  Tel: 508-820-4300                        Tel: 303-444-8129
  Fax: 508-820-4303                        Fax: 303-444-8172


3.8.2  OMG Summary
__________________

From: soley@emerald.omg.ORG (Richard Mark Soley)
Subject: OMG

In answer to your general question about the OMG, here's a brief overview.
Feel free to call, fax or email for more information.

        -- Richard Soley
           Vice President & Technical Director
           Object Management Group, Inc.
           and coincidentally, MIT '82, SM '85, PhD '89 (EECS)

The Object Management Group (OMG) is an international software industry
consortium with two primary aims:

(*) promotion of the object-oriented approach to software engineering
    in general, and

(*) development of command models and a common interface for the development
    and use of large-scale distributed applications (open distributed
    processing) using object-oriented methodology.

In late 1990 the OMG published its Object Management Architecture
(OMA) Guide document. This document outlines a single terminology for
object-oriented languages, systems, databases and application
frameworks; an abstract framework for object-oriented systems; a set
of both technical and architectural goals; and an architecture
(reference model) for distributed applications using object-oriented
techniques.  To fill out this reference model, four areas of
standardization have been identified:

1) the Object Request Broker, or key communications element, for
   handling distribution of messages between application objects in
   a highly interoperable manner;

2) the Object Model, or single design-portability abstract model for
   communicating with OMG-conforming object-oriented systems;

3) the Object Services, which will provide the main functions for
   realising basic object functionality using the Object Request Broker -
   the logical modeling and physical storage of objects; and

4) the Common Facilities will comprise facilities which are useful in
many application domains and which will be made available through OMA
compliant class interfaces.

The OMG adoption cycle includes Requests for Information and
Proposals, requesting detailed technical and commercial availability
information from OMG members about existing products to fill
particular parts of the reference model architecture.  After passage
by Technical and Business committees to review these responses, the
OMG Board of Directors makes a final determination for technology adoption.
Adopted specifications are available on a fee-free basis to members and
non-members alike.

In late 1991 OMG adopted its first interface technology, for the Object
Request Broker portion of the reference model.  This technology, adopted
from a joint proposal (named "CORBA") of Hewlett-Packard, NCR Corp.,
HyperDesk Corp., Digital Equipment Corp., Sun Microsystems and Object
Design Inc. includes both static and dynamic interfaces to an inter-
application request handling software "bus."

Unlike other organizations, the OMG itself does not and will not
develop nor sell software of any kind.  Instead, it selects and promulgates
software interfaces; products which offer these interfaces continue to be
developed and offered by commercial companies.

In order to serve OMG membership interested in other object-oriented systems
arenas besides the distributed system problem, the Group supports Special
Interest Groups for discussion of possible standards in other areas.  These
groups at present are:

        1) Object Oriented Databases;
        2) OO Languages;
        3) End-User Requirements;
        4) Parallel Processing;
        5) Analysis & Design Methodologies;
        6) Smalltalk; and
        7) Class Libraries.

Any company, university/research institution or individual, whether
end-user or vendor, can become a member of this body.  Administrative
details are given at the end of this paper.


3.8.3  Mail Server Access
_________________________

Information via Mail Server:
  Send the following commands in a letter to the mail server.

mail omg_server@omg.org
help                             (how to use file server)
index                            (return a list of all available files)
get <file>                       (get files returned by  index)
log <info>                       (logs info on server)
address <e-mail address)         (use this address instead of sender)
list <directory> [match]         (index a directory, pattern 'match' files)
size <segment size>              (max file size to send)

list mail
list docs
get docs/doclist.txt
get docs/91-12-1.ps               CORBA spec [although it looks a little old]


Recommended (from the net):

mail omg_server@omg.org
Subject:
help
index
list
list mail
list docs
get docs/doclist.txt


3.8.4  OMG Publications
_______________________

Below is from omg.org:pub/CORBA


> First Class (Bi-Monthly Newsletter)

First Class is OMG's non-commercial bi-monthly 28-page
newsletter. First Class provides current information on Object
Technology developments, both technically and commercially. First
Class offers an open editorial forum on numerous Object
Technology topics and issues.  This publication features
commentaries from software industry leaders, informative user
case histories, OT training information and the latest object-
oriented product announcements.  All OMG activities and the
ongoing development of the Object Management Architecture are
regularly reported.


> Object Management Architecture Guide (OMA)

The members of the OMG have a shared goal of developing and using
integrated software systems.  These systems should be built using
a methodology that supports modular production of software;
encourages reuse of code; allows useful integration across lines
of developers, operating systems and hardware; and enhance long-
range maintenance of that code.  As an organization, OMG believes
that the object-oriented approach to software construction best
supports their goals.  The OMA publication outlines the
groundwork for technology response to Request for Proposals (RFP)
and the adoption of specifications.


> The Common Object Request Broker: Arch. and Spec. (Corba)

The CORBA, as defined by the OMG's Object Request Broker (ORB),
provides the mechanisms by which objects transparently make
requests and receive responses. The ORB provides interoperability
between applications on different machines in heterogeneous
distributed environments and seamlessly interconnects multiple
object systems. The Common Object Request Broker Architecture and
Specification described in this published document is a self-
contained response to the Request for Proposals (RFP) issued by
the ORB Task Force of the OMG.

> Pricing

[Here's why you don't see the specifications posted to the net or available via
 ftp!  These are from the list of literature and periodicals listed in
 omg.org:pub/CORBA]

o I would like a one year subscription to First Class
    ______ for $40 U.S.,  ______ for $50 outside U.S.

o I would like to order  ______ copy(s) of the Object Management
  Architecture (OMA) Guide for $50 each.

o I would like to order  ______ copy(s) of the CORBA for $50 each.

o [Combinations]

Contact documents@omg.org or omg_documents@omg.org for more of the same...


3.8.5  Implementations (Brief)
______________________________

> DEC ObjectBroker Version 2.5  (Version 2.1 was ACA)
  Full implementation of OMG CORBA 1.1.  Digital's ObjectBroker is a 100 %
  compliant implementation of CORBA and is available on these  platforms:
  IBM AIX, IBM MVS(port in progress), HP-UX, Macintosh, MS-Windows 3.1, NT,
  OSF/1, SunOS, ULTRIX, Digital  VAX/VMS, Digital OpenVMS
Contact:
  Andrew Comas
  comas@nyo.dec.com  (212) 856-2507
  Digital Equipment Corporation.
  ObjectBroker
  110 Spit Brook Road
  Nashua, New Hampshire  03062-2698

> HP ORB Plus and HP Distributed Smalltalk
   Full implementation of the OMG CORBA 1.1 Object Request Broker. Also DOMF.
   Hewlett-Packard
   Distributed Computing Group
   19447 Pruneridge Avenue
   Cupertino, CA 95014-9974 (USA)
   Ian Fuller ian@cup.hp.com (408) 447-4722

> HyperDesk (Westborough MA) HD-DOMS, joe_cordo@hyperdesk.com
   Runs on SPARC, HP/UX, IBM RS-6000, Data General Aviion, MS-Windows (client
   API only), NetWare (planned, Novell owns part of HyperDesk).

> IBM SOM (System Object Model)
   Available on AIX and OS/2.  See Distributed Computing Monitor, March 93 for
   a detailed review.

> ILU (free, see APPENDIX E entry 59)
   Object RPC compatible with OMG CORBA 1.2 spec (will compile OMG IDL and
   generate OMG compliant code for OMG-specified languages).
   parcftp.parc.xerox.com:/pub/ilu/ilu.html

> IONA Technologies, Dublin Orbix, info@iona.ie
  First full and complete implementation of OMG's CORBA.

> NCR 'Cooperative Frameworks' -- a Distributed Object Foundation
  (1) C++ ORB toolkit consisting of over 300 C++ classes and runtime libraries
  (2) CORBA 1.1 toolkit

> ORBELINE - The SMART Object Request Broker - PostModern Computing
  Complete implementation of CORBA.  Free academic; com. eval licence avail.
  SunOS 4.x, Solaris 2.3, and OSF/1 versions of ORBeline available; will
  consider making other platforms available if enough interest. See Appendix E.

> ROLSCH CONSULTING (RC-ORB)
  Implements ORB spec, DOS/Windows 3.1, 12 user license: $99.
  Ref: Datamation, LOOK AHEAD Section, August 1.  German Company.

> SuiteSoftware (Anaheim CA) SuiteDOME
    runs on VAX/VMS, Unix, PC

> Sun DOE

> Tivoli

> CS Dept. University of Zurich, Switzerland.  maffeis@ifi.unizh.ch
    The ELECTRA Toolkit (not finished)


3.8.6  Implementation Descriptions
___________________________________

The OMG also has a (Corporate) Membership list and "known CORBA supporters"
list with their info package.


> The ELECTRA Toolkit

CS Dept. University of Zurich, Switzerland.  maffeis@ifi.unizh.ch
The ELECTRA Toolkit

Subject: ORB Implementations
Date: Tue, 4 May 1993 13:12:36 +0200 (MET DST)
From: Silvano Maffeis <maffeis@ifi.unizh.ch>

  something like an Object Broker, but it is *not* CORBA compatible (yet).
  Electra is a research project and not available yet.

  Its a toolkit for building failure resilient, distributed applications
  in C++. It supports object-groups, virtual synchrony, multithreading
  etc. Electra is based on the HORUS toolkit (which is "the new ISIS
  implementation" developed at Cornell, Ithaca NY.)
  An overview paper to electra is available from:
  ftp.ifi.unizh.ch: pub/techreports/electra.ps.Z


> HD_DOMS

HD-DOMS (HyperDesk Distributed Object Management System).  A
CORBA-compliant DOMS.  Includes a GUI API driver for prototyping and
exercising objects, a bundled object database for persistent object
storage, a Kerberos-based authentication service, a location service, a
set of base classes to speed development, and a test script language.
Revision 1.0 has been shipping since beginning of '92.  Revision 1.1
(which includes support for CORBA's static client interface) is available
now, and a NetWare version is in the works.  Submitted a C++ language
mapping for IDL to the OMG recently.

HyperDesk Corporation
2000 West Park Drive
Westboro, MA 01581
(508)366-5050


> HP ORB Plus and HP Distributed Smalltalk

  ============================================================================
  SUBJECT:  HP INTRODUCES DISTRIBUTED-COMPUTING SOLUTION FOR BUILDING
            SCALABLE, OBJECT-ORIENTED APPLICATIONS
  DATE:     September 27, 1993
  ----------------------------------------------------------------------------

   PALO ALTO, Calif.--(BUSINESS WIRE) via First! -- Hewlett-Packard Company
 today introduced a distributed-computing solution for building scalable,
 object-oriented applications.

   With HP ORB Plus, programmers can develop scalable, object-based
 applications that can be distributed throughout the enterprise.  HP also
 introduced an enhanced version of HP Distributed Smalltalk.

   HP ORB Plus and HP Distributed Smalltalk are major components of HP's
 overall distributed-computing strategy, which is designed to give customers
 integrated, desktop access to enterprise-wide information and resources in
 distributed heterogeneous systems environments.  Of all computer companies,
 HP believes it is best positioned to help customers take advantage of
 distributed computing. HP provides a wide variety of distributed-computing
 products, understands how to help customers adopt new technology for maximum
 business benefit, and offers worldwide support and training programs,
 ranging from analysis and design to deployment.

   HP ORB PLUS:  CORBA AND DCE COMBINED

   HP ORB Plus is the only environment that combines the complete CORBA 1.1
 specification from the Object Management Group with the DCE standard from
 the Open Software Foundation(tm) as its transport mechanism.  DCE is
 designed to let developers write one application and then deploy it --
 without modification -- on any other system that supports DCE.  HP ORB Plus
 reduces the complexity of developing distributed applications so programmers
 can concentrate on the application itself without needing to know multiple
 operating systems, networking protocols or where application objects are
 stored.

   The DCE (Distributed Computing Environment) standard provides an
 integrated set of services that can be used separately or together to
 provide a distributed computing environment that's easy to administer.  The
 CORBA (common-object-request-broker architecture) specification provides a
 standard for how objects (in applications, repositories or class libraries)
 make requests and receive responses across a distributed network.

   HP ORB PLUS DETAILS

   HP ORB Plus consists of several components: the Distributed Object
 Management Facility (DOMF), object services, developers' and administrative
 tools, and sample applications.  HP's DOMF provides a location-transparent
 object-communication mechanism across heterogeneous networks by using the
 DCE standard.  This object- enabling technology specification was jointly
 developed with SunSoft. By following a common specification, HP and SunSoft
 have made it easier for their customers to port applications between their
 platforms.

   In addition, HP is working with IBM to integrate HP's DOMF with IBM's
 System Object Model with extensions for distribution.  This integration will
 eventually provide users with complete scalability, portability and
 interoperability of distributed applications across HP and IBM platforms.
 This is part of the companies' planned approach toward a standards-based,
 "plug-and-play"  object-oriented environment.  This will give developers,
 system administrators and end users language-neutral, enterprise-wide,
 heterogeneous support for building, managing and using distributed object-
 oriented applications.

   "We're so convinced of the value of object technology that we're staking
 our entire company on it,"  said Richard Tanler, president and chief
 executive officer of Information Advantage, Inc.  "Our object-based
 applications for retailers provide the means to a competitive business edge.
 We plan to use HP ORB Plus to develop new object-based products that
 retailers can distribute to end users throughout headquarters, all chain
 stores, and warehousing and distribution operations."

   HP DISTRIBUTED SMALLTALK 2.0

   In a related announcement, HP introduced Version 2.0 of HP Distributed
 Smalltalk.  This toolset works with VisualWorks from ParcPlace Systems to
 provide programmers with a rapid development environment for creating and
 running distributed applications.  These applications can use object
 databases (currently OpenODB from HP and Gemstone from Servio) as their
 storage mechanism to facilitate the reuse of objects.

   Applications built using HP Distributed Smalltalk currently run without
 modification on HP, Sun and IBM UNIX(R) system-based workstations.  They
 also will run on Apple Macintosh computers and on any PC running the Windows
 3.1 or Windows NT operating systems from Microsoft(R) Corp., once
 VisualWorks 2.0 is released (expected within two months.)

   New HP Distributed Smalltalk 2.0 features include the following:

   --  easier deployment, with the ability to run multiple HP
       Distributed Smalltalk-based applications on a single system;
   --  up to 400 percent increased performance, through quicker
       sending and receiving of remote messages, and reusable
       object libraries;
   --  run-time version, for full production deployment; and
   --  easier development, with remote object browsing so
       developers can find and use objects more quickly.

   TECHNICAL DETAILS AND AVAILABILITY

   HP's DOMF includes the object request broker, interface- definition-
 language compiler, static and dynamic invocation interface and interface
 repository.  In addition to these OMG-specific features, most developers
 writing distributed, object-oriented applications require additional
 interfaces to use objects effectively.  So developers don't need to create
 their own, HP has supplied several object-service interfaces for developers
 to use. That's why HP ORB Plus includes OMG interfaces and implementations
 for properties, life cycle, associations, event notification and naming.

   HP's limited release of HP ORB Plus to key developers is designed so that
 customer input can be incorporated into the product early in its development
 cycle.  The initial version will work with the C++ programming language.
 For the generally available Developer's Kit, C++, C and Smalltalk
 interoperability is planned so objects written in different languages can be
 combined into one application.  The Developer's Kit is scheduled to be
 available mid- 1994; prices will be announced then.  HP ORB Plus runs on the
 HP Apollo 9000 Series 700 workstations and HP 9000 Series 800 business
 servers.

   Hewlett-Packard Company is an international manufacturer of measurement
 and computation products and systems recognized for excellence in quality
 and support.  The company's products and services are used in industry,
 business, engineering, science, medicine and education in approximately 110
 countries.  HP has 94,900 employees and had revenue of $16.4 billion in its
 1992 fiscal year.

 EDITORIAL CONTACTS:
	Hewlett-Packard Company
	Lynne Hanson, 408/447-1415, Cupertino, Calif.
	Jill Kramer, 408/447-4275, Cupertino, Calif.

 ==================
   For more information about HP ORB Plus, contact Kathy Litch
   (litch_k@apollo.hp.com).

   For more information about HP Distributed SmallTalk, contact
   Jerry Boortz (jerry_boortz@hp4000.desk.hp.com).


> Iris RDOM

From: rcbc@cs.cornell.edu (Robert Cooper)
Subject: Re: DCE vs. CORBA
Reply-To: rcbc@isis.com
Product: Isis Reliable Distributed Object Manager(tm) (RDOM)
Company: Isis Distributed Systems, Inc., Ithaca NY, USA.

Isis RDOM(tm) is a fault tolerant distributed ORB platform for reliable
multi-lingual object-oriented applications. RDOM provides an "object group"
paradigm for constructing complex applications out of collections of
cooperating objects. RDOM is built on top of the Isis Distributed
Toolkit(tm). RDOM provides interfaces from Smalltalk (Parcplace),
Objective-C, and C++, and runs on most Unix workstations. RDOM is currently
not CORBA compliant, but will be brought to compliance during 3Q93.

Status:

RDOM has been at beta test sites since January. General release of
the Smalltalk and Objective-C language interfaces is expected in June.
The C++ interface in August. Customers include AMD, Consilium and Swiss
Bank Corp).

From ankh.iia.org!babbage.ece.uc.edu!news.kei.com!bloom-beacon.mit.edu!senator-bedfellow.mit.edu!faqserv Wed Nov 23 21:57:34 1994
Path: ankh.iia.org!babbage.ece.uc.edu!news.kei.com!bloom-beacon.mit.edu!senator-bedfellow.mit.edu!faqserv
From: Bob Hathaway <rjh@geodesic.com>
Newsgroups: comp.object,comp.answers,news.answers
Subject: Comp.Object FAQ Version 1.0.7 (10-27) Part 3/10
Supersedes: <object-faq/part3_782395740@rtfm.mit.edu>
Followup-To: comp.object
Date: 29 Oct 1994 11:42:14 GMT
Organization: Geodesic Systems
Lines: 1504
Approved: news-answers-request@MIT.Edu
Distribution: world
Expires: 12 Dec 1994 11:40:18 GMT
Message-ID: <object-faq/part3_783430818@rtfm.mit.edu>
References: <object-faq/part2_783430818@rtfm.mit.edu>
NNTP-Posting-Host: bloom-picayune.mit.edu
Summary: Frequently Asked Questions (FAQ) List and Available Systems For Object-Oriented Technology
X-Last-Updated: 1994/10/28
Originator: faqserv@bloom-picayune.MIT.EDU
Xref: ankh.iia.org comp.object:7428 comp.answers:4418 news.answers:13677

Archive-name: object-faq/part3
Last-Modified: 10/27/94
Version: 1.0.7

> ORBELINE - The SMART Object Request Broker

ORBeline is a complete implementation of OMG's Common Object Request
Broker Architecture (CORBA).  ORBeline goes beyond the standard
specification to provide a SMART communication framework allowing
you to easily develop large distributed applications that are robust,
scalable, flexible and maintainable.  ORBeline incorporates PostModern's
proven communication framework that links thousands of nodes.

See Appendix E:65 for a complete description and anon FTP info.


> Orbix

Orbix
Iona Technologies Ltd.
8-34 Percy Place
Dublin 4
Ireland

The latest release of Orbix, Version 1.2, includes an Object Loader function
for the first time, as well as an upgraded Interface Repository, a new
approach to filtering, and more code examples to guide programmers.

Orbix was launched in June 1993 as the first full and complete implementation
of the Object Management Group's (OMG's) Common Object Request Broker
Architecture (CORBA) standard.  With Orbix, programmers can develop
distributed, object oriented applications following a consistent and
straightforward, standards-based model.

With Orbix Version 1.2 IONA has added the ability to dynamically load objects
at runtime through its Object Loader function. This enables developers to more
easily integrate Orbix applications with existing data stores be they
traditional flat file databases, relational databases or object oriented
databases.

The improved Interface Repository is an integral part of IONA's CORBA
implementation. The Interface Repository operates as a dynamic browser which is
populated with all objects or services available at runtime keeping programmers
informed of the functions, attributes and characteristics of objects and
services.

In version 1.2 IONA has also extended the whole approach to filtering of
requests, and has made it easier for users to integrate Orbix with their
security systems providing for improved reliability of distributed systems
built using Orbix. IONA has also extensively extended the number, and scope, of
code examples it ships with the product to help developers learning how to use
the system.

IONA released Orbix for SunSoft Solaris and SunOS at the Object World
exhibition in San Francisco, Calif., June 1993.  Since then it has rolled
out versions of Orbix for Microsoft Windows NT,  Silicon Graphics IRIX  and
HP/UX. IONA demonstrated a version of Orbix for Microsoft Windows 3.1 at
Object World in London, England last October.  Orbix for Microsoft Windows
3.1 is now in beta.  In January 1994, IONA and SunSoft Inc. signed an
agreement to align their implementations of CORBA. The two companies
demonstrated interoperability between IONA's Orbix running on Microsoft
Windows 3.1 and SunSoft's Distributed Objects Everywhere (DOE) on Solaris.

In addition Orbix-TP, integration with Tuxedo for transaction processing, has
just entered beta testing. Work is underway on Orbix-FT, integration with
the Isis distributed system, will deliver a fault-tolerant ORB.

Paul Hickey,                                        tel: +353-1-6686522
Iona Technologies Ltd.,                             fax: +353-1-6686573
8-34 Percy Place,                                   email: pth@iona.ie
Dublin 4
Ireland

Availability
------------

The full Orbix availability and release schedule looks like:

Operating System	C++ Compiler		Release
						Date
-------------------------------------------------------
SunOS 4.1             SPARCompiler 2.1    NOW
SunOS 4.1             SPARCompiler 3.0.2  NOW
SunOS 4.1             Lucid 3.1           NOW
SunOS 4.1             GNU 2.5.8           NOW
Solaris 2.x           SPARCompiler 3.0.2  NOW
Solaris 2.x           SPARCompiler 4.0    NOW
Solaris 2.x           GNU 2.5.7           NOW
IRIX 4.0.5H           Native              NOW
IRIX 5.x              Native              NOW
HP-UX                 Native              NOW
Microsoft Windows NT  Visual C++          NOW
Microsoft Windows NT  Borland             NOW
Microsoft Windows 3.1 Visual C++          In Beta
IBM AIX               C Set++             4th Qtr
OSF/1                 DEC C++             4th Qtr
SCO                   Native              4th Qtr
UnixWare              Computer Innovations 4th Qtr
Ultrix                DEC C++             4th Qtr

Release of Orbix on OS/2 is also imminent.

Documents Available from IONA
-----------------------------

	electronic mail server     - server@iona.ie
	anonymous ftp file server  - ftp ftp.iona.ie
	World Wide Web             - http://www.iona.ie/


> NCR 'Cooperative Frameworks' -- a Distributed Object Foundation

From: Randy Volters <randy.volters@columbiasc.ncr.com>
Subject: re-post: NCR Cooperative Frameworks (new phone no.)

November 19, 1993

NCR ANNOUNCES BETA AVAILABILITY
OF 'Cooperative Frameworks' --
a Distributed Object Foundation

Product Background -
NCR Cooperative Frameworks(TM) were first released for sale
in 10/1991 as "the frameworks" part of the NCR COOPERATION(TM)
product, and are based on NCR's submission to OMG.
Cooperative Frameworks release 3.0 makes the product
available apart from COOPERATION.

Product Description -
Cooperative Frameworks is a distributed object foundation
for building computing applications and services on networks
of heterogeneous computers.

Cooperative Frameworks consists of an integrated suite of
C++ class libraries that:

	-	defines and implements a comprehensive enterprise
		architecture and methodology for creating
		distributed implementations of C++ classes over
		networks

	-	allows customers to build and use object services
		over a network

	-	supports TCP/IP, NetBIOS, Lan Manager NetBEUI and
		OSI protocols, X.25

NCR Cooperative Frameworks currently has two portable ORB
toolkits (others are planned for future release) --
(1) C++ ORB toolkit consisting of over 300 C++ classes and
    runtime libraries

(2) CORBA 1.1 toolkit  Both are for:

	-	wrapping existing databases and legacy
		applications for improved availability
		and maintainability on systems of heterogeneous
		computers, operating systems and networks

	-	building next-generation, object-oriented,
		distributed computing applications for
		networks of heterogeneous computers, operating
		systems and network operating systems

Cooperative Frameworks come with predefined object services
for implementing distributed systems:

	-	Naming - network implementation of X.500 directory
		provides object naming service

	-	Logging - provides local and server based error
		logging

	-	Fine-grain Data Management - class libraries are
		designed around fine grained objects, developers can
		build distributed objects as large or as small as
		needed

	-	Persistence - the same object stream model for
		communication between internal ORB functions is used to
		support object persistence.  Persistent objects can be
		files, relational or object databases

	-	Dynamic Service Location - provides a mechanism for
		registering services and entities in a distributed
		system and invoking targeted services based on service
		characteristics -- rather than names

	-	Dynamic Service Activation - provides a mechanism for
		object activation when method invocations are required,
		and deactivation when not needed

	-	Event Service (Release 3.1) - Implements an OMG/JOSS
		compliant event service

	-	Network Configuration Tools - simplifies creation of
		directory entries required for cross domain operation
		in a multiple domain heterogeneous network.

NCR Cooperative Frameworks run on multiple UNIX platforms,
including HP-UX, Sun Solaris, NCR 3000 UNIX and NCR
StarServer UNIX SVR4; and on MS Windows 3.1.  Cooperative
Frameworks has been demonstrated on Novell NetWare v3.11,
and was originally developed on MS OS/2 v1.x.  Development
environments supported include CFRONT and C++ Workbench from
NCR, HP Softbench Sun SPARCworks and Borland IDE.

Implementation - implementation is for client/server system
architectures as a set of DLL and shared libraries

Languages used for IDL mapping - IDL bindings for C, (or
object services can be implemented directly in C++)

Release date - Release 3.0 is available now to early
developers with general availability set for December, 1993;
Release 3.1 will be available to early developers 1Q 1994
with general availability set for 2Q 1994

Product interoperability - Full interoperability between NCR
Cooperative Framework implementations on supported platforms
is available now; interoperability with selected CORBA 1.1
ORBs and CORBA 2.0 ORBs is planned

Company Name -
NCR Corporation (An AT&T Company)

Address --	Software Products Division-Columbia
			3245 Platt Springs Road
			West Columbia SC 29170

			Phone
			(803) 939-7500
			FAX
			(803) 939-7745
			Contact Name
			Randy Volters, Sr. Product Manager
			Cooperative Frameworks
			Email: Randy.Volters@ColumbiaSC.NCR.COM
			Ext. 7774

Company Description -
NCR, AT&T's computer business, brings computing and
communications solutions together to provide people easy
access to information and to each other -- anytime,
anywhere.


> Suite Software SuiteDOME

Product:  DOME - Distributed Object Management Environment

Company:  Object Oriented Technologies Ltd
          118-120, Warwick Street, Leamington Spa, CV32 4QY  England

Contact:  Chris Nugent,  email: chris@rtc.co.uk
          tel: +44 (0)926 313133  fax: +44 (0)926 422165

Short Description:
        DOME provides heterogenous distribution across many platforms
        and networks, including:
            UNIX, Windows, Windows NT, OS/2, OSF/1 (AXP), OpenVMS,
            SunOs, Solaris, HP-UX, SGI Unix, Stratus FTX,
            TCP/IP, NetBIOS, XTI
        As a fully peer-to-peer product DOME can be used to build systems
        using any combination of the above.

Long Description:
        DOME is an ORB toolkit for the production of user-configured
        ORBs and servers. It is a multi-threaded high performance ORB
        suitable for use in large scale commercial systems and embedded
        real-time systems.

        DOME is non-intrusive, meaning that the application development
        is separated from the means of distribution and the problem of
        distributed object management; this allows the application to
        be built and tested on a single machine using local resources.
        Existing software can also be incorporated easily, providing
        integration for legacy systems.

        DOME is constructed as a C++ class library, from which ORBs
        can be configured and constructed to best suit the runtime
        environment. This provides great flexibility since new classes
        can be derived from existing ones and the resulting configurations
        implemented to user-specific requirements.

        Database distribution can be as simple persistent files,
        RDBMSs, OODMS, or a combination of these.

        DOME has a CORBA-conformant interface, and is CORBA 1.0 compliant
        with the following divergences -
        additions:
        - full C++ binding,
        - integral support for GUI development,
        - network monitoring & analysis,
        - transaction management,
        - location broking,
        - enhanced security;
        ommissions:
        - dynamic invocation, which is seen as detrimental to performance
          and network security; however, DOME does allow stream operators
          to perform the same function.

        DOME was first released in August 1993; version 2 in May 1994.


3.8.7  Books, Articles, And Literature
--------------------------------------

This section is expected to grow considerably in the future.

"Distributed Object Computing With CORBA", C++ Report, July/August 1993

The Object Database Standard: ODMG-93
edited by: R.G.G. Cattell
published by Morgan Kaufmann Publishers, San Mateo, California
[Covers CORBA standards with respect to OODBs]


3.9)  Why Is Garbage Collection a Good Thing?
---------------------------------------------

  From: Paul Johnson (paj@gec-mrc.co.uk)

Garbage collection (GC) is a facility in the run-time system associated with a
language which will automatically reclaim objects which are no longer used.
OO Languages which require garbage collection include Eiffel, Smalltalk and
CLOS.  C and C++ can have garbage collection retrofitted (see [3] below).
[Ada has switchable GC, too -bob]

Without GC programmers must explicitly deallocate dynamic storage when
it is no longer needed (in C this is done by a call to free(3)).
There are a number of problems with this:

1: Bugs due to errors in storage deallocation are very hard to find,
   although products are available which can help.

2: In some circumstances the decision about whether to deallocate
   storage cannot be made by the programmer.  Drawing editors and
   interpreters often suffer from this.  The usual result is that the
   programmer has to write an application-specific garbage collector.

3: An object which is responsible for deallocating storage must be
   certain that no other object still needs that storage.  Thus many
   modules must co-operate closely.  This leads to a tight binding
   between supposedly independent modules.

4: Libraries with different deallocation strategies are often
   incompatible, hindering reuse.

5: In order to avoid problems 3 and 4, programmers may end up copying
   and comparing whole objects rather than just references.  This is a
   particular problem with temporary values produced by C++ overloaded
   operators.

6: Because keeping track of storage is extra work, programmers often
   resort to statically allocated arrays.  This in turn leads to
   arbitrary restrictions on input data which can cause failure when
   the assumptions behind the chosen limits no longer apply.  For
   instance many C compilers limit expression nesting, identifier
   length, include file nesting and macro stack depth.  This causes
   problems for programs that generate C.

One partial solution to a lack of GC is reference counting.  In this
scheme each object keeps a count of references to it.  When this count
drops to zero the object is automatically deallocated.  However this
is inefficient (swapping two references will result in three
decrements, three increments and six comparisons) and cannot reclaim
circular data structures.  Two systems that use a reference count GC
are the Interviews C++ graphics library and the Unix file system (the
link count).

Opponents of GC reply that it introduces an overhead which is
unacceptable in some applications.  However the overhead of manual
storage deallocation is probably as high as GC.  GC algorithms are
also available with good real-time behaviour.

[Further, GC can perform compaction improving locality of reference.]

Further Reading:

[1] "Object-Oriented Software Construction" by Meyer puts the argument
for GC.

[2] "Uniprocessor Garbage Collection Techniques," by Paul R. Wilson,
in Memory Management (proceedings of 1992 Int'l Workshop on Memory
Management, Sept. 1992, St. Malo, France, Yves Bekkers and Jacques Cohen,
eds.), Springer Verlag Lecture Notes in Computer Science #637.

This is an excellent summary of the state of the art in GC algorithms.  This
and other papers about garbage collection are available in PostScript via
anonymous ftp (cs.utexas.edu:pub/garbage/gcsurvey.ps.  [See APPENDIX E]

[3] "Garbage Collection in an Uncooperative Environment" by Boehm and
Weiser.  Software --- Practise and Experience vol 18(9), pp 807-820.
Sept 1988.  This describes GC in C and C++.


3.10)  What Can I Do To Teach OO To The Kids?
---------------------------------------------

Smalltalk (in its original 1972 version) was initially intended to make
computer programming easy enough for children.  The idea was that manipulating
objects was something more intuitive and natural than coding procedures.

Other entries or suggestions are welcome, please send to the author of the FAQ.


3.11) What Is Available On Object-Oriented Testing?
---------------------------------------------------

[This entry was donated by Doug Shaker and is certainly a FAQ]

Testing of Object-Oriented Programming (TOOP) FAQ/Resource Summary

Posted to comp.object, comp.lang.c++, comp.lang.smalltalk and
comp.software.testing.

Last revised on 93.10.27.  The most notable change is in the additions
to the Software section.  Also a couple of articles added to the
Written Material section.


> What?

This is a summary of resources on the Testing of Object-Oriented
Programming that have been mentioned to me over the net, in email,
or other means.  Sections include Written Material, Courses, and
Software.  It is kind of like an FAQ, though it isn't organized
that way.

> Who?

I work for a Unix software house, Qualix Group, in the US.   Here is
my sig:
 - Doug Shaker
	voice:	415/572-0200
	fax:	415/572-1300
	email:	dshaker@qualix.com
	mail:	Qualix Group
		1900 S. Norfolk St., #224
		San Mateo, CA 94403
I am NOT a researcher on the testing of object-oriented programming.
I just collate the stuff that is sent to me by people who REALLY know
something.  See the section "ACKs" at the end.

I just think it is important.

> Why?

Why is this important? If classes are really to be reused in
confidence, they must be blatantly correct.  The classes must be easily
testable during initial evaluation by the client programmer.  They must
also be testable under different OS configurations, different compiler
optimizations, etc.  This means that testing modules must be
constructed in a way which is recognized as correct and the modules
must be shipped with the class libraries.

As soon as one major class library vendor starts to ship real test code
with their libraries, all of the other vendors will be forced, by
market pressure, to do so as well, or face market share erosion.  Think
about it.  If you had to recommend a class library to a committee that
was choosing a basis for the next five years of work, wouldn't you feel
safer with a class library that could be auto-tested in your
environment?


> Written Material

Berard, Edward.  Essays on Object-Oriented Software Engineering.
	Prentice-Hall, Englewood Cliffs, NJ. $35.
	This book has two chapters on testing of object-oriented software,
	focusing on how to do it.

Berard, Edward.  Project Management Handbook.  Must be purchased
	direct from Berard Software Engineering, Ltd., 902 Wind River
	Lane, Suite 203, Gaithersburg, Maryland 20878.  $225.
	The book focuses on the management of OOP projects.  It
	includes one chapter on testing OO software and one chapter
	on quality assurance.

Bezier, Boris, "Software Testing Techniques", 2nd edition, Van Nostrand
	Reinhold, 1990, 503pp, $43, ISBN 0-442-20672-0.  While this is
	not specifically about testing of OOP, it is mentioned so often
	by so many people as a definitive software testing work, that
	I have to mention it anyway.

Cheatham Thomas J., and Lee Mellinger, "Testing Object-Oriented
	Software Systems",  Proceedings of the 18th ACM Annual Computer
	Science Conference, ACM, Inc., New York, NY, 1990, pp. 161-165.

Doong, Roong-Ko and Phyllis G. Frankl, "Case Studies on Testing
	Object-Oriented Programs", Proceedings of the 4th Symposium on
	Testing, Analysis, and Verification (TAV4), 1991, ACM, Inc.,
	New York, NY, 1991, pp. 165-177.

Fiedler, Steven P., "Object-Oriented Unit Testing", Hewlett-Packard
	Journal, April, 1989, pp. 69-74.

Firesmith, D.G., "Testing Object-Oriented Software", Proceedings
	of 11th. TOOLS USA Conference, Santa Barbara, Aug 1993, pp 407-426.

Frankl, Phyllis G. and Roong-Ko Doong, "Tools for Testing
	Object-Oriented Programs", Proceedings of the 8th Pacific
	Northwest Conference on Software Quality, 1990, pp. 309-324.
	One author can be reached at pfrankl@polyof.poly.edu.

Graham, J.A., Drakeford, A.C.T., Turner, C.D. 1993. The Verification,
	Validation and Testing of Object Oriented Systems, BT Technol
	J.  Vol 11, No 3. One author's email address is
	jgraham@axion.bt.co.uk.

Harrold, Mary Jean, John D. McGregor, and Kevin J. Fitzpatrick,
	"Incremental Testing of Object-Oriented Class Structures",
	International Conference on Software Engineering, May, 1992,
	ACM, Inc., pp. 68 - 80.

Hoffman, Daniel and Paul Strooper.  A Case Study in Class Testing.
	To be Presented at the IBM Center for Advanced Studies Fall
	Conference, October 1993, Toronto.  Email addresses for authors
	are dhoffman@csr.uvic.ca and pstropp@cs.uq.oz.au.  Describes an
	approach to testing which the authors call Testgraphs.  An
	example is worked out in C++ which tests a commercial class.

Hoffman, D. M.  A CASE Study in Module Testing.  In Proc. Conf. Software
	Maintenance, pp. 100-105. IEEE Computer Society, October 1989.

Hoffman, D.M. and P.A. Strooper.  Graph-Based Class Testing.  In
	7th Australian Software Engineering Conference (to appear), 1993.

Klimas, Edward "Quality Assurance Issues for Smalltalk Based Applications",
	The Smalltalk Report, Vol. 1, No. 9, pp.3-7.  The author's
	email address is "ac690@cleveland.freenet.edu".

Lakos, John S.  "Designing-In Quality in Large C++ Projects" Presented
	at the 10th Annual Pacific Northwest Software Quality Conference,
	Portland, Oregon, October 21, 1993.  Abstract:
		The focus of this paper is on ensuring quality by
		designing software that avoids acyclic component
		dependencies.  This in-turn permits incremental,
		hierarchical testing.  The importance of good physical
		design becomes a key factor only for large and very
		large projects.  Intuition gained from smaller projects
		leads to errors in large designs.  Compile-coupling
		("Insulation") is also discussed.
	Copies of the postscript file can be obtained by sending email
	to "john_lakos@warren.mentorg.com".

Leavens, G. T., "Modular Specification and Verification of
	Object-Oriented Programs", IEEE Software, July 1991, pp. 72-80.

Love, Tom.  Object Lessons.  SIGS Books, 588 Broadway #604, New York, NY
	10012. $49.
	This book eloquently elucidates the need for testing of object-
	oriented code and has a chapter on how it was done at Stepstone
	during the first release of their initial class library.

Marick, Brian.  The Craft of Software Testing, Prentice-Hall, in press.
	Makes the argument that testing of object-oriented software is
	simply a special case of testing software which retains state
	and which is reused.  The author can be reached at
	info@testing.com.

Narick, Brian. "Testing Software that Reuses", Technical Note 2, Testing
	Foundations, Champaign, Illinois, 1992. Copies may be obtainable
	via email. The author can be reached at info@testing.com.

Murphy, G.C., Wong, P. 1992, Towards a Testing Methodology for
	Object Oriented Systems, M.P.R Teltech Ltd. A poster at the
	Conference on Object Oriented Programming Systems, Languages
	and Applications ACM. Copies of this paper can be obtained
	through townsend@mprgate.mpr.ca.

Murphy, G. and P. Wong.  Object-Oriented Systems Testing Methodology: An
	Overview.  Techical Report TR92-0656, MPR Teltech Ltd., October
	1992.

Perry, D.E. and G.E. Kaiser, "Adequate Testing and Object-Oriented
	Programming", Journal of Object-Oriented Programming,
	2(5):13-19, Jan/Feb 1990.

Purchase, Jan A. and Russel L. Winder, "Debugging tools for
	object-oriented programming", Journal of Object-Oriented
	Programming, June, 1991, Vol. 4, No. 3, pp. 10 - 27.

Smith, M. D. and D. J. Robson, " A Framework for Testing Object-Oriented
	Programs", JOOP, 5(3):45-53, June 1992.
	Describes ways in which the usual approach to software testing
	could be adapted for object-oriented software.
	This paper, or one with the same title and authors, is
	available by anonymous ftp from vega.dur.ac.uk as
	"/pub/papers/foot.dvi".

Smith, M. D. and D. J. Robson, "Object-Oriented Programming - the
	Problems of Validation",  Proceedings of the 6th International
	Conference on Software Maintenance 1990, IEEE Computer Society
	Press, Los Alamitos, CA., pp. 272-281.

Taylor, David. "A quality-first program for object technology", Object
	Magazine, Vol. 2, No. 2, July-August 1992, pp17-18. SIGs
	Publications.  The article talks some about why testing is
	important for OOP and describes one quality program.

Theilen, David.  "No Bugs.  Delivering error free code in C and C++.",
	Addison-Wesley, 1992, ISBN:0-201-60890-1.

Turner, C. D. and D. J. Robson, "The Testing of Object-Oriented Programs",
	Technical Report TR-13/92, Computer Science Division, School of
	Engineering and Computer Sciences (SECS), University of Durham,
	England.
	Includes a survey of existing literature on testing of OO
	programs.  Testing of OOP is compared with traditional software
	testing.  A state-based approach is described.
	This paper is available by anonymous ftp from vega.dur.ac.uk in
	/pub/papers. Get "toop.ps.Z" for A4 paper and "toopus.ps.Z" for
	US letter paper formatting.

Turner, C. D. and D. J. Robson, "A Suite of Tools for the State-Based
	Testing of Object-Oriented Programs", Technical Report
	TR-14/92, Computer Science Division, School of Engineering and
	Computer Science (SECS), University of Durham, Durham,
	England.  Describes a series of tools for the generation and
	execution of test cases for OOP.  These tools assume a
	state-based testing approach.
	This paper is available by anonymous ftp from vega.dur.ac.uk in
	/pub/papers.  Get "tools.ps.Z" for A4 paper formatting or get
	"toolsus.ps.Z" for US letter formatting.

Turner, C. D. and D. J. Robson, "Guidance for the Testing of Object-
	Oriented Programs", Technical Report TR-2/93, Computer Science
	Division, School of Engineering and Computer Science (SECS),
	University of Durham, Durham, England.  Discusses different
	methods of making class declarations and the implications of
	those methods for testing.
	This paper is available by anonymous ftp from vega.dur.ac.uk in
	/pub/papers.  Get "guide.ps.Z" for A4 paper formatting or get
	"guideus.ps.Z" for US letter formatting.

Turner, C. D. and D. J. Robson, "State-Based Testing and Inheritance",
	Technical Report TR-1/93, Computer Science Division, School of
	Engineering and Computer Science (SECS), University of Durham,
	Durham, England.
	Discusses the implications of inheritance for testing,
	particularily incremental testing.
	This paper is available by anonymous ftp from vega.dur.ac.uk in
	/pub/papers.  Get toopinht.ps.Z" for A4 paper formatting or get
	"toopinhtus.ps.Z" for US letter formatting.

Wong, P. Automated Class Exerciser (ACE) User's Guide.  Technical
	Report TR92-0655, MPR Teltech Ltd., September 1992.

> Courses

Berard Software Engineering, Inc. teaches a seminar on Testing of
Object-Oriented Software (TOOS).  The next one scheduled that I know of
is November 8-12, in Washington.  Call 301-417-9884 for details.

Quality Fractals, Inc. has a course called "Testing Object-Oriented
Software".  Contact: 508-359-7273 (Box 337, Medfield, MA 02052).  The
course is taught by Shel Siegel of YESS!, Inc.  Contact: 916-944-1032.


> Software

There is a smalltalk class library in the Univ. of Illinois archives
which includes a simple Tester class written by Bruce Samuelson
(bruce@utafll.uta.edu). It is a general superclass for application
specific classes that test non-interactive objects such as trees,
collections, or numbers. It is not suitable for testing user interface
components such as windows, cursors, or scroll bars. The filein
includes Tree classes, Tester itself, and subclasses of Tester that are
used to validate the Tree classes. For ParcPlace Smalltalk (ObjectWorks
4.1 and VisualWorks 1.0). To get it ftp the file
"/pub/st80_vw/TreeLW1.1" from st.cs.uiuc.edu.

IPL Ltd. (in the UK) has a testing tool called Cantata which allows for
testing C++, but as far as I am able to determine, it has no special
features for C++ testing.  From the product literature:
	Cantata allows testing to be performed in an intuitive way
	making the tool exceptionally easy to use and productive in
	operation. Cantata is suitable for testing software written in
	either C or C++.

	Cantata provides comprehensive facilities for all forms of
	dynamic testing, including: functional testing, structural
	testing, unit testing and integration testing. Cantata has been
	specifically designed to operate in both host and target
	systems and so allow full portability of tests between these
	environments.
For more information contact IPL:
	IPL Ltd.
	Eveleigh House, Grove Street, 
	Bath  BA1 5LR
	UK
	(0225) 444888
	(0225) 444400 (FAX)
	email: shaun@iplbath.demon.co.uk

TestCenter from CenterLine will do coverage testing of C++ (and C)
code.  Also does some memory debugging (similar to Purify) and regression
testing.  Highlights from CenterLine literature:
  *Automatic run-time error-checking on executables to enhance quality 
  *Automatic memory leak detection on executables to optimize memory use
  *Graphical test coverage to highlight any code not executed during test runs
  *Intuitive GUI for easy test analysis 
  *Programmatic interface to output files and cumulative code coverage 
   to support batch-mode and regression testing
  *No recompilation needed, resulting in quick turnaround
  *Complete C and C++ language support
  *Integration with leading programming tools for maximum productivity gains

MicroTech Pacific Research (mpr.ca) has a C++ class testing tool called
ACE (Automated Class Exerciser) which is available under non-disclosure
agreement.  It is not currently for sale.  If you are interested,
contact Paul Townsend, townsend@mprgate.mpr.ca.

Software Research Inc. (625 Third St, San Francisco, CA 94107-1997,
voice: 1-415-957-1441, email: info@soft.com) has a coverage tool for C++
that is called tcat++.  It is an extension of SRI's tcat program.

Quality Assured Software Engineering (938 Willowleaf Dr., Suite 2806,
San Jose, CA 95128, voice: 1-408-298-3824 ) has a coverage tool for
C and C++ called MetaC.  It also dones some syntax checking and memory
allocation checking.

A group of volunteers is building a C++ test harness for the automated
testing of C++, C and Perl programs.  The system is called ETET (Extended
Test Environment Toolkit).  To join the group of volunteers, send email to
	etet_support@uel.co.uk
The software is available via anonymous FTP from bright.ecs.soton.ac.uk
(152.78.64.201) as "/pub/etet/etet1.10.1.tar.Z".  They are looking for
other FTP sites - sned email to the above address if you can provide
one.  This is a beta release and _should_ compile on any POSIX.1 system.
As much of this work is being done by SunSoft, my guess is that the
software will have the fewest problems on SunOS or Solaris releases.

> ACKs

Thanks to the following for helping assemble this list:
	Benjamin C. Cohen, bcohen@scdt.intel.com
	Brian Marick, marick@hal.cs.uiuc.edu
	Bruce Samuleson, bruce@utafll.uta.edu
	Daniel M. Hoffman, dhoffman@uvunix.uvic.ca
	Edward Klimas, ac690@cleveland.freenet.edu
	John Graham, J.Graham@axion.bt.co.uk
	Jim Youlio, jim@bse.com
	Jeffery Brown, jeffrey.brown@medtronic.com
	Lars Jonsson, konlajo@etna.ericsson.se
	Manfred Scheifert, ch_schie@rcvie.co.at
	Mark Swanson, mswanson@mechmail.cv.com
	Mary L. Schweizer, mary@gdwest.gd.com
	Michael Einkauf, Michael_Einkauf@iegate.mitre.org
	Paul Townsend, townsend@mprgate.mpr.ca
	Phyllis G. Frankl, pfrankl@polyof.poly.edu
	Rachel Harrison, rh@ecs.soton.ac.uk
	Risto Hakli, rkh@tko.vtt.fi
	Russ Hopler, russ@bse.com
	Stephane Barbey, barbey@di.epfl.ch
	Tony Reis, tonyr@hpsadln.sr.hp.com
	Yawar Ali, yali@bnr.ca


3.12) What Distributed Systems Are Available?
---------------------------------------------

The following post helps to provide some answers with at least a partial list.
See also Appendix E.

From: rmarcus@bcsaic.boeing.com (Bob Marcus)
Newsgroups: comp.object,comp.client-server
Subject: Distributed Computing Products Overview
Date: 17 Sep 93 00:02:40 GMT
Organization: Boeing Computer Services
           
             DISTRIBUTED COMPUTING PRODUCTS OVERVIEW

  There was a recent posting concerning the relationship between OMG's CORBA
 and Distributed Transaction Processing Monitors. In general, there is a lot of
 uncertainty as to how the various distributed computing tools, products and
 environments might work together.  Below is the outline of an eight-page
 posting to the Corporate Facilitators of  Object-Oriented Technology (CFOOT)
 mailing list addressing these issues. Let me know if you would like a copy
 of the posting and/or to be added to the CFOOT mailing list. 
     
                                          Bob Marcus 
                                          rmarcus@atc.boeing.com
 -----------------------------------------------------------------------
 SOME GENERAL REFERENCES FOR ADDITIONAL INFORMATION 
 -----------------------------------------------------------------------
 MULTIPROTOCOL NETWORK TRANSPORTS

  Peer Logic (PIPES)
  ATT (Transport Layer Interface) 
 -----------------------------------------------------------------------
 MICROKERNELS

  OSF(Mach)
  Chorus Systems (Chorus)
  Microsoft (NT)
 -----------------------------------------------------------------------
 REMOTE PROCEDURE CALLS

  NobleNet (EZ-RPC)
  Netwise (Netwise-RPC) 
  ATT/Sun (TI-RPC)
  OSF (DCE/RPC)
 -----------------------------------------------------------------------
 CONVERSATIONAL PROGRAMMING

  IBM(Common Programming Interface-Communications)
 -----------------------------------------------------------------------
 MESSAGING PRODUCTS

  System Strategies/IBM (MQ Series)
  Horizon Strategies (Message Express) 
  Covia Systems(Communications Integrator)
  Momentum Software(X-IPC)
  Creative System Interface (AAI)
  Digital (DECmessageQ)
  HP (Sockets)(BMS)
  IBM (DataTrade)(DAE)
  Suite Software (SuiteTalk)
  Symbiotics (Networks)
 -----------------------------------------------------------------------
 PUBLISH AND SUBSCRIBE MESSAGING 
 
  Sun(Tooltalk)
  Teknekron (Teknekron Information Bus)
  ISIS(Distributed News)
  Expert Database Systems (Rnet)
 ----------------------------------------------------------------------
 DISTRIBUTED COMPUTING ENVIRONMENTS

  OSF/DCE
  ISIS(Distributed Toolkit)
 -----------------------------------------------------------------------
 TRANSACTION PROCESSING MANAGERS 

  Unix Systems Lab (Tuxedo) 
  Information Management Company (Open TransPort) 
  NCR (TopEnd)
  Transarc (Encina)
  IBM/HP/Transarc (Open CICS)
 -----------------------------------------------------------------------
 DISTRIBUTED WORKSTATION EXECUTION SYSTEMS

  Aggregate Systems (NetShare)
  Platform Computing(Utopia)
  ISIS(Resource Manager)
 -----------------------------------------------------------------------
 OBJECT REQUEST BROKERS 

  Hyperdesk (Distributed Object Manager)
  IBM Distributed System Object Model(DSOM)
  Microsoft (Distributed OLE)
  Iona Technologies Ltd. (Orbix) 
  BBN (Cronus)
  ISIS (RDOM)
  Qualix (NetClasses)
  Symbiotics (Networks!)
  Digital(ACA Services) 
  Suite Software (SuiteDOME)
 -----------------------------------------------------------------------
 SYSTEM MANAGEMENT  

  OSF (Distributed Management Environment)
  Legent
  Digital Analysis (HyperManagement)
 -----------------------------------------------------------------------
 DISTRIBUTED DEVELOPMENT/EXECUTION PRODUCTS   

  Texas Instruments (Information Engineering Facility)
  HP (SoftBench)
  Digital (COHESIONworX) 
 -----------------------------------------------------------------------
 DISTRIBUTED DEVELOPMENT/EXECUTION PRODUCTS   

  Independence Technologies (iTRAN)
  Intellicorp(Kappa) 
  ISIS Distributed Systems (RDOM) 
  Early, Cloud & Company (Message Driven processor)
  Expersoft(XShell)
  Cooperative Solutions(Ellipse)
 -----------------------------------------------------------------------


3.13) What Is The MVC Framework?
--------------------------------

MVC stands for Model-View-Controller.  This framework was originally adopted
in Smalltalk to support Graphical User Interfaces.  Views support graphical
interfacing, controllers handle interaction, and models are the application
objects.  See [Krasner 88] and [LaLonde 90b].

From: Carl Petter Swensson <cepe@taskon.no>
  Prof. Trygve Reenskaug is generally cited as being the creator of
  the MVC concept. He worked with the Smalltalk group at Xerox PARC
  as a visiting scientist in 78/79. During this stay at Xerox PARC 
  he developed the MVC. I know him well and have talked to him about
  this. He confirms it, although stating that it was a collaborative
  effort at Xerox PARC.

  The implementation of MVC in Smalltalk-80 has since been further
  developed by ParcPlace Systems.

  He has worked with Smalltalk in a commercial and research
  environments since then. His group at the Centre for Industral
  Research in Oslo (now part of the SINTEF group) had the only
  Smalltalk-78 implementation outside Xerox PARC.  He is now working
  with Taskon AS.

  The ideas that initially gave MVC has been developed further and 
  is the basis of the work Trygve is currently doing on the
  OOram methodology.


3.14) What is Real-Time?
------------------------

Real-time is our linear extrapolation/perception of imaginary time (along a
quantum wave function (OTU) in ten dimensions, of course).

[This section is YTBI]


3.15) What Is Available on OO Metrics?
--------------------------------------

This section is still building.

[Berard 93] contains an elaborate bibliography and section on OO metrics.
[Booch 94] also contains some coverage.

Also:
Object Oriented Software development
Mark Lorenz ISBN 0-13-726928-5
Prentice Hall

Software Metrics
Grady-Caswell ISBN 0-13-821844-7
Prentice Hall

Measuring Software Design Quality
Card-Glass ISBN 0-13-568593-1
Prentice Hall

From: trilk@informatik.tu-muenchen.de (Joern Trilk)
Newsgroups: comp.object,comp.lang.c++,comp.lang.smalltalk,comp.databases.object
Subject: Re: In search of OO Metrics
Date: 20 Jun 1994 14:29:27 GMT
Organization: Technische Universitaet Muenchen, Germany

>...
Here are some references:

@article{inheriting:1993,
    author  = {G. Michael Barnes and Bradley R. Swim},
    title   = {Inheriting software metrics},
    journal = {JOOP},
    year    = {1993},
    month   = {Nov./Dec.},
    volume  = {6},
    number  = {7},
    pages   = {27-34}
}


@article{a-new-metr:1993,
    author  = {J.-Y. Chen and J.-F. Lu},
    title   = {A new metric for object-oriented design},
    journal = {Information and Software Technology},
    year    = {1993},
    month   = apr,
    volume  = {35},
    number  = {4},
    pages   = {232-240}
}


@inproceedings{towards-a-:1991,
    author  = {Shyam R. Chidamber and Chris F. Kemerer},
    title   = {Towards a Metrics Suite for Object Oriented Design},
    booktitle = {OOPSLA '91 Proceeedings},
    year    = {1991},
    pages   = {197-211}
}


@inproceedings{software-m:1992,
    author  = {J. Chris Coppick and Thomas J. Cheatham},
    title   = {Software Metrics for Object-Oriented Systems},
    booktitle = {CSC '92 Proceedings},
    year    = {1992},
    pages   = {317-322}
}


@inproceedings{some-metri:1991,
    author  = {B. Henderson-Sellers},
    title   = {Some metrics for object-oriented software engineering},
    booktitle = {TOOLS Proceedings},
    year    = {1991},
    pages   = {131-139}
}


@article{object-ori:1993,
    author  = {Wei Li and Sallie Henry},
    title   = {Object-Oriented Metrics that Predict Maintainability},
    journal = {J. Systems Software},
    year    = {1993},
    volume  = {23},
    pages   = {111-122}
}


@inproceedings{workshop-r:1992,
    author  = {Teri Roberts},
    title   = {Workshop Report - Metrics for Object-Oriented Software Development},
    booktitle = {OOPSLA '92 (Addendum to the Proceedings)},
    year    = {1992},
    pages   = {97-100}
}


@techreport{softwareme:1991,
    author  = {A. Buth},
    title   = {Softwaremetriken f{\"u}r objekt-orientierte Programmiersprachen},    institution = {Gesellschaft f{\"u}r Mathematik und Datenverarbeitung},
    year    = {1991},
    month   = jun,
    number  = {545},
    type    = {Arbeitspapiere der GMD}
}


The Software Engineering FAQ lists the following references concerning
metrics for object-oriented systems:

Date: 26 Jan 1993 Originally collected by: ZUSE%DB0TUI11.BITNET@vm.gmd.de
(Horst Zuse) 

a. Morris Kenneth L.  Metrics for Object-Oriented Software Development
   Environments (master's thesis). 1989, MIT.
b. Rocacher, Daniel: Metrics Definitions for Smalltalk.  Project ESPRIT 1257,
   MUSE WP9A, 1988.
c. Rocacher, Daniel: Smalltalk Measure Analysis Manual.  Project ESPRIT 1257,
   MUSE WP9A, 1989.
d. Lake, Al: A Software Complexity Metric for C++.  Annual Oregon Workshop on
   Software Metrics, March 22-24, 1992, Silver Falls, Oregon, USA.
e. Bieman, J.M.: Deriving Measures of Software Reuse in Object Oriented
   Systems.  Technical Report #CS91-112, July 1991, Colorado State Universty,
   Fort Collins/ Colorado, USA.

Hope this helps,
	Joern

----------------------------------------------------------------------
Joern Trilk			Phone: ++49-89-2105-2391
Institut fuer Informatik (H1)	Fax:   ++49-89-2105-5296
TU Muenchen			Email: trilk@informatik.tu-muenchen.de
80290 Muenchen                    
----------------------------------------------------------------------


SECTION 4:  COMMONLY ASKED LANGUAGE SPECIFIC QUESTIONS
======================================================

4.1)  What is Downcasting?
--------------------------

Downcasting is the term used in C++ for casting a pointer or reference to
a base class to a derived class.  This should usually be checked with an
embedded dynamic typing scheme if such a scheme is not present in the
language, such as with a typecase (Modula-3) or inspect (Simula) construct.
In C++, it is even possible to use conversion functions to perform some
checks, although the proposed RTTI will perform checked downcasting as
its primary ability.


4.2)  What are Virtual Functions?
---------------------------------

Look under "Dynamic Binding" and "Polymorphism".


4.3)  Can I Use Multiple-Polymorphism Or Multi-Methods In C++?
---------------------------------------------------------------

Yes, but you'll need to embed a dynamic typing scheme to do it.  With dynamic
types in place, an overriding method in a derived class can explicitly check
argument types in a switch statement and invoke the desired method emulating
multiple-polymorphism [See Coplien 92].  

For true CLOS multi-methods, the above technique implemented as a base function
(CLOS defgeneric), switching to specialized functions (CLOS methods, made
friends of all arguments) will provide the functional calling syntax, multiple-
polymorphism and access to parameters found in CLOS.  This can require some
complex switching, which is somewhat mitigated when multiple-polymorphism
is implemented with virtual functions.

Future FAQs should contain more detail.


4.4)  Can I Use Dynamic Inheritance In C++?
-------------------------------------------

Yes, [Coplien 92] describes a scheme where a class can contain a pointer to
a base class that can switch between its derived classes, providing a limited
form.  Earlier chapters contain entries on bypassing C++'s message system and
even bypassing static linking.

Future FAQs should contain more detail.



ANNOTATED BIBLIOGRAPHY
======================

[Agrawal 91]  R. Agrawal et al.  "Static Type Checking of Multi-Methods".
 OOPSLA 91.  Object-Oriented Programming Systems, Languages, and Applications.  
 ACM Press.  Addison Wesley.

  Compile-time checking and optimizations for multi-methods.

[Aho 86] Alfred V. Aho, Ravi Sethi, and Jeffrey D. Ullman.  Compilers:
 Principles, Techniques, and Tools. Reading, MA: Addison-Wesley, 1986.

  Authoritative, classic book on compilers and optimizations.  Type chapter
  contains section on type inferencing (using ML as an example).

[Berard 93]  Edward V. Berard.  Essays on Object-Oriented Software
  Engineering.  Prentice Hall.

  Many topics on OOSE, includes coverage of OO domain and requirements
  analysis.

[Black 86] A. Black et al.  Object-Structure in the Emerald System.  OOPSLA
 '86 Conference Proceedings, SIGPLAN Notices (Special Issue), Vol. 21, n0. 11,
 pp 78-86.    [I believe there is a more recent article, YTBI]

  The original article on Emerald.  OO language without inheritance but with
  abstract types and static subtype polymorphism.  Also designed for
  distributed programming and reuse.  See article for references: Jade on
  reuse [Raj 89]) and Distr. Prog.

[Black 87] A. Black, N. Hutchinson, E. Jul, H. Levyand L. Carter.  Distribution
 and Abstract Types in Emerald, IEEE Transactions on Software Engineering, Vol.
 SE13, no. 1 Jam., pp 65-76.
 
  Subtype polymorphism for distributed programming in Emerald [Black 86].

[Blair 89] "Genericity vs Inheritance vs Delegation vs Conformance vs ..."
 Gordon Blair, John Gallagher and Javad Malik, Journal of Object Oriented
 Programming, Sept/Oct 1989, pp11-17.

  Recommended by a reader, but the Author has yet to review this article.

[Boehm 86] B.W. Boehm. A Spiral Model of Software Development and Enhancement.
 Software Engineering Notes, Aug., vol. 11 (4), p 22.

 Presents an alternative evolutionary approach to the strict waterfall software
 engineering life-cycle.  Now a classic, most OO methodologies now emphasize
 the iterative or evolutionary approach to software development.

[Booch 87] Grady Booch.  Software Engineering with Ada.  2nd Ed.  Benjamin
 Cummings.

  Booch in his early years.  Mostly object-based programming with Ada.

[Booch 87b] Grady Booch.  Software Components With Ada, Structures, Tools,
 and Subsystems.  Benjamin Cummings.

  A taxonomy and collection of object-based components in Ada (includes code).
  Has many examples with generics.

[Booch 91] Booch, Grady. Object-Oriented Design With Applications.  Benjamin
  Cummings.

  The often referred to book on OOD.  Offers design notation and methodology.
  Brief coverage of OOA and elaborate OOD/P coverage in the applications.
  Good on basic principles and has case studies in Smalltalk, Object Pascal, 
  C++, CLOS and Ada.

  Also contains an *elaborate* classified bibliography on many areas of OO.

[Booch 94]  Grady Booch.  Object-Oriented Analysis And Design With
 Applications, 2nd Ed. Benjamin Cummings.  ISBN 0-8053-5340-2.

  The next FAQ should be updated to the second edition.  All examples are now
  in C++.  Booch incorporates several other major methodologies including
  Wirf-Brock's CRC (Class-Responsibility-Collaboration) and Jacobson's Use-
  Cases.

[Cardelli 85]  L. Cardelli and P. Wegner.  On Understanding Types, Data
 Abstraction, and Polymorphism.  ACM Computing Surveys vol. 17 (4).

 Long, classic article on Object-Oriented Types, Data Abstraction and
 Polymorphism.  Formal coverage with a type system analysis model as well.

[Chambers 92]  Craig Chambers.  The Design and Implementation of the SELF
 Compiler, an Optimizing Compiler for Object-Oriented Programming Languages.
 Dept of Computer Science, Stanford University, March 1992.

  Covers type optimizations for OO compilers.  See Appendix E, PAPERS.

[Chambers 93]  Craig Chambers.  Predicate Classes.  Proceedings ECOOP '93
  O. Nierstrasz, LNCS 707. Springer-Verlag, Kaiserslautern, Germany
  July 1993 pp 268-296

   "... an object is automatically an instance of a predicate class whenever
   it satisfies a predicate expression associated with the predicate class.
   The predicate expression can test the value or state of the object, thus
   supporting a form of implicit property-based classification that augments
   the explicit type-based classification provided by normal classes.  By
   associating methods with predicate classes, method lookup can depend not
   only on the dynamic class of an argument but also on its dynamic value or
   state. [...] A version of predicate classes has been designed and
   implemented in the context of the Cecil language.

  See Appendix E, PAPERS.

[de Champeaux 93] Dennis de Champeaux, Doug Lea, Penelope Faure.
 Object-Oriented System Development.  Addison-Wesley, ISBN 0-201-56355-X.

  Covers an integrated treatment of OOA and OOD.  Takes serious the
  computational model of one thread per object.  Gives more than usual
  attention to the OOA&D micro process.  Presents a unique OOD language.

[Coad 91]  Peter Coad and Edward Yourdon. Object-Oriented Analysis, 2nd ed.
 Englewood Cliffs, NJ. Prentice Hall.

  Coad and Yourdon's OO analysis method.

[Coad 91b]  Peter Coad and Edward Yourdon. Object-Oriented Design.  Englewood
 Cliffs, NJ. Prentice Hall.

  Coad and Yourdon's OO design method.

[Coleman 94] Derek Coleman, et. al.  Object-Oriented Development - The Fusion
 Method.  Prentice-Hall Object-Oriented Series. ISBN 0-13-338823-9

  Fusion is considered to be a second generation OOAD method in that it builds
  on successful components of a number of first generation methods (OMT, Booch,
  CRC, Objectory, etc).  However, this has been done with the requirements of
  industrial software developers in mind. And so issues of traceability,
  management etc. have been taken into consideration and the Method provides
  full coverage from requirements through to code.

[Cook 90] W.R. Cook, W.L.Hill, P.S. Canning. Inheritance Is Not Subtyping.
  Appeared in [Hudak 90] and Gunter 94].

    Theoretical article on the separation between type and class, or as the
    authors state between implementation inheritance and subtyping.

[Coplien 92] James O. Coplien.  Advanced C++ Programming Styles and Idioms.
  Addison Wesley.

  Covers advanced C++ programming and performing other more advanced and
  dynamic styles of OO in C++.

[Colbert 89]  E. Colbert.  The Object-Oriented Software Development Method: a
 practical approach to object-oriented development.  Tri-Ada Proc., New York.

  Presents the Object-Oriented Software development method.  Has emphasis on
  objects.

[Cox 86,91] Cox, Brad J.  Object-Oriented Programming, An Evolutionary
 Approach.  Addison Wesley.

  The original book on Objective-C.  Coverage on object-oriented design and
  programming.  Also covers Objective-C implementation, even into object code.
  
  Objective-C... '91 AW by Pinson and Wiener provide another good text.

[Embley 92]  D.W. Embley, B.D. Kurtz, S.N. Woodfield.  Object-Oriented Systems
 Analysis, A Model-Driven Approach. Yourdon Press/Prentice Hall, Englewood
 Cliffs, NJ.

  Presents the Embley and Kurtz OO methodology.

[Garfinkel 93]  Simson L. Garfinkel and Michael K. Mahoney.  NeXTSTEP
 PROGRAMMING  STEP ONE: Object-Oriented Applications.  Springer-Verlag.

  Introduction to the NextStep environment and applications development.
 
[Goldberg 83] Adele Goldberg and David Robson. Smalltalk-80 The Language and
 Its Implementation.  Addison Wesley.

  The original book on Smalltalk.  Covers implementation.  Also known as "the
  Blue Book".  Out of print.  Superceded by [Goldberg ??].

[Goldberg ??] Adele Goldberg and David Robson. Smalltalk-80: The Language.
 Addison-Wesley. 

  The "Purple Book".  Omits the obsolete abstract virtual machine description
  from the Blue Book.

[Gunter 94] Carl A. Gunter and John C. Mitchell. Theoretical Aspects of Object-
 Oriented Programming. MIT Press.  ISBN 0-262-07155-X.

  Highly mathematical, formal coverage of object-oriented programming;
  primarily on typing.

[Harmon 93] Paul Harmon.  Objects In Action: Commercial Applications Of Object-
 Oriented Technologies.  Jan, 1993.  A-W ISBN 0-201-63336-1.

  Sponsored by the OMG to summarize the use of OO technology in industry and
  business, contains a brief history and summary of OO and many case studies.

[HOOD 89] HOOD Working Group.  HOOD Reference Manual Issue 3.0.  WME/89-173/JB.
 Hood User Manual Issue 3.0. WME/89-353/JB.  European Space Agency.

  Presnets the HOOD (Hierarchical Object-Oriented Design) OOSE methodology.
  From the European Space Agency.  Based on Ada and object-based.

[Hudak 90] P. Hudak. Principles of Programming Languages.  ACM Press, pp 125
 -135.

  Contains several articles, including [Cook 90].

[Hudak 92] Paul Hudak and Simon Peyton Jones.  Haskell Report. SIGPLAN Notices.
 1992, vol 27, no 5.

  Haskell reference.

[Humphrey 89]  Watts Humphrey.  Managing the Software Process.  Addison Wesley.

  Sponsored by the Software Engineering Institute (SEI), the presented project
  management model is inspired by the work of Boehm, Brooks, Deming and Juran
  and represents a strong step in the direction of achieving 6 sigma defect
  rate prevention and optimizing the software development process for quality,
  productivity, and reliability.  Presents the CMM, see section .

[IBM 90,91]  Various Documents from the IBM International Technical Centers:
 GG24-3647-00, GG24-3641-00, GG24-3566-00, GG24-3580-00.

  Present IBM's OOSE methodology.

[Jacobson 92]  Ivar Jacobson, et al.  Object-Oriented Software Engineering - A
 Use Case Driven Approach. ACM Press/Addison Wesley.

  Presents Jacobson's new OOSE methodology based on use cases.

[Jones 92]  Rick Jones. Extended type checking in Eiffel. Journal of Object-
 Oriented Programming, May 1992 issue, pp.59-62.

  Presents subtype polymorphic extension to Eiffel (static typing only).

[Jurik 92] John A. Jurik, Roger S. Schemenaur, "Experiences in Object Oriented
 Development," ACM 0-89791-529-1/92/0011-0189.

  Presents the EVB OOSE methodology.  Also: Barbara McAllister, Business
  Development, EVB Software Engineering, Inc., (301)695-6960, barb@evb.com.

[Kiczales 92] Gregor Kiczales, Jim des Rivieres, Daniel G. Bobrow.  The Art
 of the Metaobject Protocol.  The MIT Press.

  Reflection and Metaobject Protocols (MOPs).  Uses a CLOS subset, Clossette,
  as a foundation.

[Kim 89]  Won Kim and Frederick Lochovsky Editors.  Object-Oriented Concepts,
 Applications, and Databases.

  Collection of articles on advanced OO and research systems.

[Krasner 88] G. E. Krasner and S. T. Pope. A Cookbook for Using the Model-View-
 Controller User Interface Paradigm in Smalltalk-80. JOOP, vol 1, no 3, August/
 September, 1988, pp 26-49,

  An early paper published on MVC.

[Lakoff 87] George Lakoff.  Women, Fire, and Dangerous Things: What Categories
  Reveal About The Mind.  UOC Press.

  An almost formal view of classification/categorization by the noted cognitive
  scientist, George Lakoff.  His view blasts objectivism and contends to
  replace it with a subjectivist view, based on a study of humans, natural
  language, and concept formation.

[LaLonde 90]  Wilf R. LaLonde and John R. Pugh.  Inside Smalltalk: Volume 1.
 Prentice Hall.

  Good introduction to Smalltalk.

[LaLonde 90b]  Wilf R. LaLonde and John R. Pugh.  Inside Smalltalk: Volume 2.
 Prentice Hall.

  Excellent coverage of MVC. However, it's based on ParcPlace Smalltalk-80,
  version 2.5, which is obsolete.

[Liskov 93] Barbara Liskov and Jeannette M. Wing.  Specifications and Their use
 in Defining Subtypes.  OOPSLA 93, pp 16-28.  ASM SIGPLAN Notices, V 28, No 10,
 Oct. 1993.  A-W ISBN 0-201-58895-1.

  Specifications on Subtype hierarchies.  Helps to insure the semantic
  integrity of a separate subtype system.  See section 2.7.

[Madsen 93] Ole Lehrmann  Madsen, Birger Moller-Pedersen, Kristen Nygaard:
 Object-oriented programming in the BETA programming language.  Addison-Wesley,
 June 1993. ISBN 0 201 62430 3

  The new and authoritative book on BETA, by the original designers.  They
  are some of the same designers of the Simula languages, originating OO.
  Also just announced:
	Object-Oriented Environments: The Mjolner Approach
	Editors: Jorgen Lindskov Knudsen, Mats Lofgren, Ole Lehrmann Madsen,
		 Boris Magnusson
	Prentice Hall: The Object-Oriented Series
	ISBN: 0-13-009291-6 (hbk)

[Martin 92] James Martin and James J. Odell. Object-Oriented Analysis and
 Design, Prentice-Hall, Englewood Cliffs, NJ.  

  Its primary purpose is to indicate how information engineering (IE) can be 
  evolved to accommodate OO.  The analysis portion (starting at Chapter 15) 
  attempts to go back to 'first principles' and is based on a formal foundation.
  Therefore, the IE aspect is not required.  Emphasis is more on analysis than 
  design.

[Meyer 88] Bertrand Meyer. Object-Oriented Software Construction.  Prentice
 Hall.  [Is there a new edition out?]

  The original book on Eiffel.  Coverage on object-oriented design and
  programming.  Also:


[Meyer 92] Bertrand Meyer. Eiffel: The Language. Prentice Hall. Englewood
 Cliffs, NJ. 1992.

  The definitive book on Eiffel by its author.

[Meyer 94] Bertrand Meyer. Reusable Software: The Base Object-Oriented
 Components Libraries.

  The new Eiffel class Libraries.

[Mugridge 91] Warwick B. Mugridge et al.  Multi-Methods in a Statically-Typed
 Programming Language. Proc. ECOOP.

  Efficient implementation of Multi-Methods.

[Murray 93] Robert B. Murray.  C++ Strategies and Tactics.  Addison Wesley.

  C++, has template examples.

[Nerson 92] Jean-Marc Nerson.  Applying Object-Oriented Analysis and Design.
 CACM, 9/92.

  Demonstrates the basics of the BON method/notation.  Nerson: marc@eiffel.fr

[Paepcke 93] Andreas Paepcke.  Object-Oriented Programming: The CLOS
 Perspective.  MIT Press.  ISBN 0-262-16136-2.

  CLOS, readable introduction to its metaobject protocol, comparisons with
  other languages, uses and methodology, and implementation.  Develops a
  persistent object metaclass example.

[Raj 89] R.K. Raj and H.M. Levy.  A Compositional Model for Software Reuse.
 The Computer Journal, Vol 32, No. 4, 1989. 

  A novel approach aading reuse to Emerald [Black 86] without inheritance.

[Reenskaug 91] T. Reenskaug, et al.  OORASS: seamless support for the creation
 and maintenance of object-oriented systems. Journal of Object-Oriented
 Programming, 5(6).

  Presents the Object-Oriented Role Analysis, synthesis, and Structuring
  OOSE methodology.

[Royce 70] W. W. Royce. Managing the Development of Large Software Systems.
 Proceedings of IEEE WESCON, August 1970.

 Introduces the Waterfall Process Model.

[Rumbaugh 91] Rumbaugh James, et al.  Object-Oriented Modeling and Design.
 Prentice Hall.

  The often referred to book on OOA/OOD.  Introduces the Object Modeling
  Technique (OMT) OOA/D notation and methodology.  Has case studies.

[Sciore 89] Edward Sciore.  Object Specialization. ACM Transactions on
 Information Systems, Vol. 7, No. 2, April 1989, p 103.

  A hybrid approach between delegation and classical OO.

[Selic 94] Bran Selic, Garth Gullekson, and Paul T. Ward. Real-Time
 Object-Oriented Modeling. Published by John Wiley & Sons. 
 ISBN 0-471-59917-4

  OO method addresses complete lifecycle needs of real-time systems. Emphasizes
  executable models for early validation of requirements, architecture, and
  design combined with techniques for automatic generation of implementations.
  Specifically real-time with iterative and incremental development process.
  Single consistent graphical modeling concepts apply uniformly to OOA/D/I.

[Shlaer 88] Sally Shlaer and Stephen J. Mellor.  Object-Oriented Systems
 Analysis: Modeling the World in Data.

  Credited as the first book proposing an OOA method.

[Shlaer 92] Sally Shlaer and Stephen J. Mellor.  Object Lifecycles: Modeling
  the World in States.

  An addition to [Shlaer 88], provides dynamic modeling with a state-
  transition driven approach.

From ankh.iia.org!babbage.ece.uc.edu!news.kei.com!hookup!bloom-beacon.mit.edu!senator-bedfellow.mit.edu!faqserv Wed Nov 23 21:57:34 1994
Path: ankh.iia.org!babbage.ece.uc.edu!news.kei.com!hookup!bloom-beacon.mit.edu!senator-bedfellow.mit.edu!faqserv
From: Bob Hathaway <rjh@geodesic.com>
Newsgroups: comp.object,comp.answers,news.answers
Subject: Comp.Object FAQ Version 1.0.7 (10-27) Part 4/10
Supersedes: <object-faq/part4_782395740@rtfm.mit.edu>
Followup-To: comp.object
Date: 29 Oct 1994 11:42:17 GMT
Organization: Geodesic Systems
Lines: 1490
Approved: news-answers-request@MIT.Edu
Distribution: world
Expires: 12 Dec 1994 11:40:18 GMT
Message-ID: <object-faq/part4_783430818@rtfm.mit.edu>
References: <object-faq/part3_783430818@rtfm.mit.edu>
NNTP-Posting-Host: bloom-picayune.mit.edu
Summary: Frequently Asked Questions (FAQ) List and Available Systems For Object-Oriented Technology
X-Last-Updated: 1994/10/28
Originator: faqserv@bloom-picayune.MIT.EDU
Xref: ankh.iia.org comp.object:7429 comp.answers:4419 news.answers:13678

Archive-name: object-faq/part4
Last-Modified: 10/27/94
Version: 1.0.7

[Strachey 67]  C. Strachey.  Fundamental Concepts in programming languages.
 Lecture Notes for International Summer School in Computer Programming,
 Copenhagen, Aug.

  Contains original, classical definition of polymorphism.

[Stroustrup 90] Ellis, M.A., Stroustrup. The Annotated C++ Reference Manual.
 Addison Wesley.

  The ARM; the original and definitive book on C++.  Serves as the ANSI
  base document for C++.  Also covers C++ implementation.  It is meant as 
  a reference (including for compiler writers), not as a tutorial for
  beginners.  Perhaps a better ref is [Stroustrup 91].

[Stroustrup 91] Stroustrup, B.  The C++ Programming Language (2nd edition).

  Has the ARM, better reference for the use of C++ (recommended by bs).
  Contains sections on object-oriented software engineering.

[Tasker 93]  Dan Tasker.  The Problem Space, Practical Techniques for
  Gathering & Specifying Requirements. ISBN: 0-646-12524-9.  Avail only from
  author, dant@swdev.research.otc.com.au.

  Object-oriented requirements definition.  Hypertext.  Uses Rumbaugh's OMT as
  a base.  See also APPENDIX D.

[Ungar 87] D. Ungar and R.B. Smith.  The Self Papers. [Entry To Be Completed]

  The documents on Self; a delegation/prototyping language.  Also covers Self
  implementation and optimization.  See also APPENDIX E, PAPERS section.

[Wasserman 90] A.I. Wasserman et al. The Object-Oriented Software Design
 Notation for Software Design Representation. IEEE Computer, 23(3).

  Presents the Object-Oriented Structured Design (OOSD) OOSE methodology.
  Traditional structured techniques to OO, hybrid containing structured
  design and Booch.

[Wegner 87] Peter Wegner. "Dimensions of Object-Based Language Design",
  Proceedings of OOPSLA '87, October 4-8 1987, SIGPLAN Notices
  (Special Issue), V22, No 12, pp168-182, 1987.

[Wikstrom 87] Ake Wikstrom.  Functional Programming Using Standard ML.
 Prentice Hall, ISBN 0-13-331661-0, 1987.

  ML reference.

[Wilkie 93] George Wilkie. Object-Oriented Software Engineering - The
 Professional Developer's Guide. Addison Wesley.

  Covers OOSE, 11 popular analysis and design methodologies with examples,
  comparisons, and analysis, information systems (OODB), and case studies.

[Winter Partners]  Winter Partners 

  A proprietary toolset (OSMOSYS) for OOA and OOD.
  Winter Partners
    London Office:                 Zurich Office:
      West Wing, The Hop Exchange
      24a Southwark Street           Florastrasse 44
      London SE1 1TY                 CH-8008 Zurich
      England                        Switzerland
      Tel. +44-(0)71-357-7292        Tel. +41-(0)1-386-95 11
      Fax. +44-(0)71-357-6650        Fax. +41-(0)1-386-95 00

[Wirfs-Brock 90] Rebecca Wirfs-Brock, Brian Wilkerson, Lauren Wiener.
 Designing Object Oriented Software, Englewood Cliffs, NJ. Prentice Hall.

  Presents a "Responsibility Driven Design" (RDD) with "Class, Responsibility,
  Collaboration" (CRC) technique, a modern and new OOA/OOD methodology.

[Yaoqing 93]  Gao Yaoqing and Yuen Chung Kwong.  A Survey of Implementations
 of Parallel, Concurrent, and Distributed Smalltalk.  ACM SIGPLAN Notices.
 Vol 28, No. 9, Sept 93.

  Covers implementations of Parallel, Concurrent, and Distributed Smalltalk.

[Yourdon 92]  Edward Yourdon.  Decline and Fall of the American Programmer.
 YPCS.

  Excellent coverage of modern software engineering practice and world-class
  software development organizations.



APPENDICES
==========


APPENDIX A  VIPS
================

These are individuals whose names appear in comp.object most often. 
Please send recommendations for *major* VIPS often cited or referenced.

Booch, Grady <egb@rational.com>
-------------------------------

Grady Booch has been an object- based/oriented advocate for some time.  He's
written books such as Software Engineering with Ada [Booch 87], Software
Components with Ada [Booch 87b], and OOA/D with Applications [Booch 91, 94].
His latest notations are often referred to as simply the "Booch" method or
notation and he is Chief Scientist at Rational, a company providing training
and automated support for the method with a tool named "Rose" (See Appendix D).
The Booch method now incorporates many modern methods, including OMT, and Dr.
Rumbaugh has recently joined forces with Grady at Rational.


Cox, Brad
---------

Founder of Objective-C, which grafts the Smalltalk facilities of an
Object id and a messaging mechanism onto C.  Author of [Cox 87].


Goldberg, Adele  (Alan Kay, Dan Ingalls)
----------------------------------------

One of the founders of Smalltalk (with Alan Kay and Dan Ingalls).  Coauthor
of [Goldberg 83, ??], "Smalltalk-80 The Language and its Implementation".
Smalltalk was invented by a group at Xerox PARC; and a spinoff, ParcPlace, is
now marketing Smalltalk environments (see APPENDIX C).


Meyer, Bertrand <bertrand@eiffel.com>
-------------------------------------

Founder of Eiffel, author of [Meyer 88].  Often posts to comp.lang.eiffel
and comp.object [what a FAQ writer notices].  His company, Interactive
Software Engineering, has a case tool called EiffelCase (see APPENDIX D).


Nygaard, Krysten (and Dahl, Ole-Johan)
--------------------------------------

Inventor of Simula, the first object-oriented programming language.  Also
inventor of object oriented design, for which Simula-67 was considered an
implementation technique.  Now B.B. Kristensen, O.L. Madsen, B. Moller-
Pedersen, and K. Nygaard are working on BETA, their successor to Simula.


Rumbaugh, Dr. James
-------------------

Part of Rumbaugh, Blaha, Premerlani, Eddy and Lorenson, the authors of
[Rumbaugh 91].  They all work for GE Corporate Research and Development Center
in Schenectady New York (See below) and have an OOA/OOD notation/methodology
called the "Object Modeling Technique" (OMT).  It is a rather formal and
complete method often discussed in comp.object.  OMTool is the name of the
CASE system provided by Martin Marietta which supports OMT.  See APPENDIX D.

Recently, Dr. Rumbaugh has joined forces with Chief Scientist Grady Booch at
Rational: Rumbaugh@rational.com 


Shlaer, Sally (and Mellor, Stephen J.)
--------------------------------------

>Sally Shlaer            sally@projtech.com
>Project Technology      Training and Consulting using Shlaer-Mellor OOA/RD
>Berkeley, CA            (510) 845 1484
Also: steve@projtech.com

Cofounder of the Shlaer/Mellor OOA/RD method, president of Project Technology.
As shown above, occasionally posts to comp.object [what a FAQ writer notices].


Stroustrup, Bjarne (bs@alice.att.com)
-------------------------------------

Inventor of C++, a C superset, which has probably gained the most widespread
use of any object-oriented language today.  Often found in comp.lang.c++ and
comp.object.



APPENDIX B  OBJECT-ORIENTED DATABASES AND VENDORS
=================================================

This is a list of available Object-Oriented databases.  Thanks go to Stewart
Clamen, who's survey on schema evolution provided a good start.  Additional
short entries are encouraged; please send additions to the author of the FAQ
(and/or to Stewart).

The most recent copy of Stewart Clamen's summary on available databases
support for schema evolution will be available indefinitely via anonymous
FTP from BYRON.SP.CS.CMU.EDU:/usr/anon/OODBMS/evolution-summary.

[Kim 89] covers a few of the research systems below in depth.

Starred entries also have an entry in "APPENDIX E  ANONYMOUS FTP SITES".

See also section 3.5 for an Object Database Management Group (ODMG) reference.


TABLE OF CONTENTS

Extended Relational Database Model
 Research Systems
  POSTGRES*     [marketed by Montage]
  Starburst     [IBM almaden, entry NYI]
 Commercial Systems
  Montage       [Research System POSTGRES]

Object-Oriented Data Model
 Research Systems
  AVANCE
  CLOSQL
  ConceptBase*
  COOL/COCOON
  Encore*
  Exodus*
  Machiavelli
  MOOD4-PC*
  OBST/STONE*
  Ode*
  Oggetto
  Orion [marketed as ITASCA, see Entry]
  OTGen
  VODAK
 Commercial Systems
  ArtBASE
  EasyDB (Objective Systems, Sweden)
  GemStone/GeODE
  ITASCA
  Matisse
  NeoAccess
  O2
  Objectivity/DB
  ObjectStore
  Ontos [formerly VBase]
  Odapter/OpenODB program (HP)
  Poet
  Statice
  UniSQL
  Versant

Other Models
 Research Systems  
  GRAS*
  IRIS
 Commercial Systems  
  IDL
  Kala
  Pick

Interfaces
 Research Systems
  Penguin
 Commercial Systems
  AllegroStore (Franz)
  Persistence
  Subtlware
  Synchronicity (Smalltalk)


EXTENDED RELATIONAL DB MODEL
----------------------------

Research Systems
________________


> POSTGRES (Berkeley)

POSTGRES is an extended-relational database manager that supports
inheritance, user-defined types, functions, and operators, ad-hoc
queries, time travel, a rules system, tertiary storage devices,
and very large typed objects, among other things.  POSTGRES speaks
postquel, a derivative of the quel query language originally
designed at berkeley for the ingres database system.  User functions
may be written in C or in postquel.  C functions will be dynamically
loaded into the database server on demand, and either kind of function
may be executed from the query language.

POSTGRES and the papers that describe it are available free of charge
from toe.CS.Berkeley.EDU (128.32.149.117) in directory pub/postgres.
The code is stored in a directory named after the latest release; at
the time of this writing, that directory is postgres-v4r1.  The list
of officially-supported ports is short (decstations running ultrix 4.x
and sparcstations).  Unofficially, many more are supported -- people
elsewhere have done the ports and distribute their versions of the
code.  The list of unofficial ports is available in pub/postgres as
file UNOFFICIAL-PORT-LIST.

On Type Evolution:
You ask explicitly about type evolution.  We support schema
modification on all classes, including user classes.  This means that
you can add attributes (instance slots) and methods at any time.
Further, since postgres is a shared database system, such changes are
instantly visible to any other user of the class.

The language syntax supports attribute deletion, but the system won't
do it yet.  Since all data is persistent, removing attributes from a
class requires some work -- you need to either get rid of or ignore
all the values you've already stored.

Contact:
Paul Aoki <aoki@cs.berkeley.edu>

The postgres code from uc berkeley is being commercialized by
Miro Systems, Inc.        [This seems to have been updated to Montage]

Contact:
  paula hawthorn (paula@miro.com) 
  dave segleau (dave@miro.com)


Commercial Systems
------------------

> Montage (ORDBMS) [Research System POSTGRES]

From: markh@montage.com (Mark Helfen)
Subject: Montage Database - brief product announcement
Followup-To: sales@montage.com 
Organization: Montage Software, Inc.
Date: Wed, 10 Nov 1993 23:05:03 GMT

The Montage object-relational database management system 
(ORDBMS) is now available from Montage Software, Inc. 

The Montage object-relational database management system 
includes the Montage Server(tm) database engine, the Montage 
Viewer(tm) -- a new visualization tool that simplifies queries of 
complex data -- and Montage DataBlades(tm), specialized modules 
that extend the capabilities of the database for specific applications.  
Montage represents the commercialization of the seven-year 
POSTGRES research project.   

The Montage Server extends the relational database model through 
its ability to handle complex information, and the inclusion of object-
oriented facilities and capabilities.  It uses the familiar relational row-
column metaphor for all data, so that text, numbers and complex data 
are all viewed, managed, manipulated and queried the same way.   
The relational metaphor is extended to allow data of any size and 
complexity to be stored and accessed in the way that is most 
effective.   SQL, used to access and manage data, is extended with 
SQL3-based capabilities to allow the definition of user data types and 
functions.

The Montage Viewer uses visualization technology to organize 
information in visual terms -- by location, shape, color and intensity, 
for example.  Similar to a "flight simulator," the Montage Viewer allows 
the user to visually navigate through data, refining each step by 
"panning" and "zooming" with a mouse.  

A DataBlade is a combination of data types and functions that are 
designed to support a specific application.   Text, Spatial, and Image 
are the first of many DataBlades that will comprise a full-range of 
industry-specific products created by Montage, third parties and 
users based upon their own expertise.    

o     The Text DataBlade expands the database's functionality by 
adding new data types and functions that manage text and document 
libraries, as well as a providing a new access method (Doc-Tree) 
which provides exceptional search performance for text.  

o     The Image DataBlade supports image conversion, storage, 
manipulation, enhancement and management of more than 50 image 
formats, and performs automatic conversion of formats at the user's 
discretion.  

o     Points, lines, polygons and their spatial relationships are now 
supported in the relational model with the Spatial DataBlade.  The 
DataBlade defines nine basic spatial types and makes over 200 SQL 
functions available for use on spatial data, as well as supports the 
R-Tree access method for high speed navigation of spatial data.    

Montage Software was co-founded by Gary Morgenthaler of 
Morgenthaler Ventures and Dr. Michael Stonebraker of the University 
of California, Berkeley, .  Morgenthaler is Montage Software's 
chairman of the board and Stonebraker serves as the company's 
chief technology officer.    Morgenthaler and Stonebraker co-
founded Ingres Corporation (then called Relational Technology, 
Inc.), in 1980.    

FOR ADDITIONAL INFORMATION:

Montage Software Inc. can be contacted at:

email:                        sales@montage.com
phone:                        (510) 652-8000
fax:                          (510) 652-9688

Mailing Address:

Montage Software, Inc.
2000 Powell Street, Suite 1405
Emeryville, CA  94608

OO DATA MODEL
-------------

Research Systems
________________

> AVANCE (SYSLAB)

An object-oriented, distributed database programming language.  Its
most interesting feature is the presence of system-level version
control, which is used to support schema evolution, system-level
versioning (as a way of improving concurrency), and objects with their
own notion of history.  System consists of programming language (PAL)
and distributed persistent object manager. 

REFERENCES: 
        Anders Bjornerstedt and Stefan Britts. "AVANCE: An
        Object Management System".  Proceedings of OOPSLA88.



> CLOSQL (University of Lancaster)

Status:-
CLOSQL is a research prototype OODB designed primarily for prototyping 
various schema evolution and view mechanisms based on class versioning.
The system is built using CommonLISP. It would really only be of interest
to other parties as a research tool.

Requirements:-
Common LISP including CLOS standard. The Graphical user interface requires
the Harlequin LispWorks Tool-kit. The system was built on a Sun4 and
has not been tested on any other platform.

Features:-
As a prototype, CLOSQL is not robust enough to sell. The system is single
user and does not properly support persistence - that is, the data has to
be loaded and saved explicitly. The query language is quite good 
making good use of the functional nature of the environment. 
Methods (LISP and query language only), class versioning and
multiple inheritance are all supported in the data model. Type checking
information is held in the database, but is NOT enforced at present. The
GUI is notable for its support for schema evolution, but otherwise rather
ordinary.

Availability:-
Probably freely available, but as the project was part funded by an
industrial partner, some consultation with them would be necessary before
the system could be released.

References:-
[1]  Monk, S. R. and I. Sommerville, "A Model for Versioning of Classes 
in Object-Oriented Databases", Proceedings of BNCOD 10, Aberdeen. 
pp.42-58. 1992.

[2]  Monk, S. "The CLOSQL Query Language". Technical report No. SE-91-15. 
Computing Dept, Lancaster University, Lancaster, LA1 4YR, UK. 1991.

[3]  Monk, S., "A Model For Schema Evolution In Object-Oriented Database 
Systems", PhD thesis, Dept of Computing, Lancaster University, Lancaster
LA1 4YR, UK. 1992.

On Schema evolution (from original survey):
CLOSQL implements a class versioning scheme (like ENCORE), but employs a
conversion adaptation strategy.  Instances are converted when there is a
version conflict, but unlike ORION and GemStone, CLOSQL can convert instances
to older versions of the class if necessary.

        Aberdeen, Scotland. July, 1992.

Contacts;
Simon Monk:      srm@computing.lancaster.ac.uk
Ian Sommerville: is@computing.lancaster.ac.uk 


> ConceptBase - A Deductive Object Manager for Meta Data Bases

ConceptBase is a multi-user deductive object manager mainly 
intended for conceptual modeling and the coordination of design 
environments. The system implements a dialect of Telos which 
amalgamates properties of deductive and object-oriented languages. 

Key features are 

   hybrid representation with frame-like objects, 
   semantic nets and logical specifications 

   unlimited extensibility by metaclass 
   hierarchies (useful for IRDS, schema evolution etc.) 

   deductive rules & integrity constraints 

   queries as classes with membership constraints 

   persistent object management with the ability to interrogate 
   past states of the database 

ConceptBase follows a client-server architecture. Client programs 
can connect to the ConceptBase server and exchange data via 
interprocess communication. The X11-based ConceptBase user 
interface offers a palette of graphical, tabular and textual tools 
for editing and browsing the object base. The ConceptBase 
programming interface allows the users to create their own 
client programs in C or Prolog. 

The system can be obtained for free from ftp.informatik.rwth-aachen.de in 
      /pub/CB/CB_3.2.4 (released 26-Apr-1994 for Sun/SPARC, SunOS 4.1.3) 
      /pub/CB/CB_3.3 (released 26-Apr-1994 for Sun/SPARC, Solaris 2.3) 
Both versions are functionally equivalent. They only differ in the 
operating system platform.Please read file /pub/CB/doc/InstallationGuide 
(resp. /pub/CB/doc/InstallationGuide_3.2.4) before downloading the software. 
For running the ftp version you must ask for a key by email.

Contact
ConceptBase-Team
RWTH Aachen - Informatik V
D-52056 Aachen - Germany

Tel./Fax: +49-241 80 21 501 / +49-241-8888321
email: CB@picasso.informatik.rwth-aachen.de 
href="http://www.informatik.rwth-aachen.de/I5/CBdoc/cbflyer.html"


> COOL/COCOON (Ulm Universitaet)

The COCOON project was intended to extend the concepts and the
architecture of relational database management systems (DBMSs) beyond
nested relational to object-oriented ones. Based upon the nested
relational DBMS kernel DASDBS, we have built a prototype implementation
of the COCOON model. Key characteristics of COCOON are: generic,
set-oriented query and update operators similar to relational algebra
and SQL updates, respectively; object-preserving semantics of query
operators, which allows for the definition of updatable views; a
separation of the two aspects of programming language "classes": type
vs. collection; predicative description of collections, similar to
"defined concepts" in KL-One--like knowledge representation
languages; automatic classification of objects and views (positioning
in the class hierarchy); physical clustering of subobjects via the use
of nested relations as the internal storage structures; support for the
optimization of both, the physical DB design and query transformation,
by corresponding optimizers.

Project goals are:

- to develop a general formal framework for investigations of all
  kinds of schema changes in object-oriented database systems
  (including schema design, schema modification, schema tailoring, and
  schema integration);
- to find implementation techniques for evolving database schemas,
  such that changes on the logical level propagate automatically to
  adaptations of the physical level (without the need to modify all
  instances, if possible).

In their current paper [see below], schema evolution is used as
example of a general framework for change in OODBs, supporting change
on three levels of database objects: data objects, schema objects, and
meta-schema objects.

Contact: Markus Tresch <tresch@informatik.uni-ulm.de>


REFERENCES:
        M. Tresch and M.H. Scholl. "Meta Object Management
        and its Application to Database Evolution."  In
        _Proceedings of the Eleventh International
        Conference on the Entity-Relationship Approach",
        Karlsruhe, Germany, Oct 1992.  Springer Verlag (to
        appear).



> Encore (Brown University)
email:bpe@browncs.brown.edu

Encore is an object-oriented database system targeted at large scale
software engineering applications which are involved in data modeling.
It was developed at Brown University in the late 1980s.  It is notable
for its special support for long-lived (ie. cooperative) transactions,
popular in design applications, and its support for class versioning.
Objects are never converted, rather, classes are versioned, and the
user can specify filters to make old-style instances appear as new
instances to new applications (and vice versa).


References/Additional Information:

 [] Mary F. Fernandez. OBSERVER: A storage system
    object-oriented applications. Technical Report CS-90-27,
    Brown University, Providence, RI, 1990.

 [] Mark F. Hornick and Stanley B. Zdonik. A shared, segmented
    memory system for an object-oriented database. ACM
    Transactions on Office Information Systems, 5(1):70--95,
    January 1987.

 [] Andrea H. Skarra and Stanley B. Zdonik. Type evolution in an
    object-oriented database. In Research Directions in
    Object-Oriented Programming, MIT Press Series in Computer
    Systems, pages 393--415. MIT Press, Cambridge, MA, 1987. An
    early version of this paper appears in the OOPSLA '86
    proceedings.

 [] Andrea H. Skarra and Stanley B. Zdonik. Concurrency control
    for cooperating transactions in an object-oriented database.
    In Won. Kim and Frederick H. Lochovsky, editors,
    Object-Oriented Concepts, Databases and Applications.
    Addison-Wesley, Reading, MA, 1989.

FTP: Complete source can be found in wilma.cs.brown.edu/pub/encore.tar.Z
See also APPENDIX E.


> Exodus (University of Wisconsin)

EXODUS is a DBMS from the University of Wisconsin.  An overview,
excerpted from the abstract of [CDG+90] reads:

    EXODUS,   an   extensible database    system  project that is
    addressing  data management problems  posed  by  a variety of
    challenging new applications.  The  goal of the project is to
    facilitate   the   fast    development of   high-performance,
    application-specific  database  systems.     EXODUS  provides
    certain  kernel facilities,   including  a versatile  storage
    manager.  In addition, it provides an architectural framework
    for building  application-specific database systems; powerful
    tools   to  help  automate the  generation   of such systems,
    including  a   rule-based query optimizer generator    and  a
    persistent  programming  language;  and libraries  of generic
    software components (e.g., access methods) that are likely to
    be useful for many application domains.

The programming language is called E, an extension of C++. [RC89]

REFERENCES:
(see "ftp.cs.wisc.edu:exodus/bibliography" for a complete list)

[CDG+90] Michael J. Carey, David J. DeWitt, Goetz Graefe,
         David M. Haight, Joel E. Richardson, Daniel T. Schuh,
         Eugene J. Skekita, and Scott L. Vandenberg. The EXODUS
         extensible DBMS project:  An overview. In Stanley B.
         Zdonik and David Maier, editors, Readings in
         Object-Oriented Database Systems, Data Management
         Series. Morgan Kaufmann, San Mateo, CA, 1990. Also
         available as WISC-CS-TR 808.

[CDRS89] Michael J. Carey, David J. DeWitt, Joel E. Richardson,
         and Eugene J. Skekita. Storage management for objects
         in EXODUS. In Won. Kim and Frederick H. Lochovsky,
         editors, Object-Oriented Concepts, Databases and
         Applications, chapter 14. Addison-Wesley, Reading, MA,
         1989. After Carey et al. Object and File Management in
         the EXODUS Database System, Proceedings of the Twelveth
         International Conference on Very Large Data Bases,
         1986.

[GD87]   G. Graefe and D. DeWitt. The EXODUS optimizer
         generator. In U. Dayal and I. Traiger, editors,
         Proceedings of the SIGMOD International Conference on
         Management of Data, San Francisco, CA, May 1987.

[RC89]   Joel E. Richardson and Michael J. Carey. Persistence in
         the E language:  Issues and implementation. Software --
         Practice and Experience, 19(12):1115--1150, December
         1989.


FTP: source code, documentation and a complete bibliography can be
     found at ftp.cs.wisc.edu:exodus/

See also APPENDIX E.


On Schema Evolution (from original survey):
No solution for the problem of schema evolution is provided.
Emulation is rejected by the authors, who claim that the addition of a
layer between the EXODUS Storage Manager and the E program would
seriously reduce efficiency.  Automatic conversion, whether lazy or
eager, is also rejected, as it does not mesh well with the C++ data
layout.  To implement immediate references to other classes and
structures, C++ embeds class and structure instances within its
referent.  The resulting change in the size of the object might
invalidate remote pointer references.

        Joel E.  Richardson and Michael J.  Carey.  "Persistence
        in the E language: Issues and Implementation."  Appeared
        in "Software -- Practice and Experience",
        19(12):1115-1150, December 1989.


> Machiavelli (University of Pennsylvania)

Machiavelli is a statically-typed programming language developed
at the University of Pennsylvania. Its most outstanding innovation 
is the use of conditional typing scheme in its type inference system. 
It does not address type evolution.

[communication with limsoon@saul.cis.upenn.edu]

[Note: Machiavelli is included in this summary because it
       previously incorporated persistence in its data model.]



> MOOD4-PC: Material's/Miniature Object-Oriented Database Prototype for
             NEC/IBM-PC

is an object-oriented database system(OODBS) program developed in the
course of our research project MOOD. The aim of the project MOOD is to
develop a material database system to handle raw material data which
are produced and accumulated in materials research and referred to by
material experts when they face scientific or engineering problems
where the expected behavior of particular materials in particular
environments are crucial importance. We all know that the conventional
database systems do not fulfill this requirement, though they serves
well for bibliographic databases or fact databases which deals with
the standard properties of standard materials.

MOOD4-PC is written in Arity/Prolog and available in source and
executable form via anonymous ftp from:

   ~/pub/mood/mood4
   at mood.mech.tohoku.ac.jp [130.34.88.61]
   
    ~/pub/database/mood
    at ftp.uu.net [192.48.96.9]

    ~/pub/computing/databases/mood
    at src.doc.ic.ac.uk [146.169.2.1]

Although it is true enough to say that MOOD4 is a general purpose
OODBS, it may be appropriate to point out that MOOD4 is significantly
different from what is generally meant by the term, the
Object-Oriented Database System.

That is, OODBSs, in general, consist of two parts:

   (1) Disk storage manager
   (2) Database language to define and manipulate data objects to
       be stored to and retrieved from the disk.

The database language of OODBS is akin to the object-oriented
programming language such as Smalltalk or C++. You can enjoy the full
versatility of these general purpose programming language in writing
application programs with the database language.

As apparent from these, OODBSs, in general, are for programmers who
write application programs which serve end users' needs. MOOD, on the
other hands, is not; it is for end users. It is provided with a user
interface named the object editor or OE in short. With OE, we can;

  (1) Edit class definition objects and save them. This replaces the
      data definition language.

  (2) Edit data objects and save them.

  (3) Create query objects, let the system select data objects which
      match the queries, and browse them.

In the other words, we can do everything necessary to manage and use
database with OE. MOOD, therefore, needs no programming language and,
in fact, has none. In this regard, MOOD may better be categorized to
the OODBS application.

The architecture of MOOD as such is the consequence of the nature of
information to be dealt with in material database. If we describe the
nature with a single word, "variety" will be the one most appropriate. 
No fixed data structure can handle a handful of material data because
their contents differ from one to another. The feature of OODBS
relevant here is not the intimacy with programming languages but the
flexibility of data structure which allows us to construct data
objects with a variety of structures which match the variety in the
information to be dealt with. Upon inputting and retrieving data
objects, end users are forced to face this variety in data structure
since significant information is born in the structures of individual
representations.

Yet, we say that MOOD is a general purpose OODBS. This is not in the
sense that we can develop application programs on it, but in the
sense that it generally supports the essential capabilities of OODBS;

  (1) The abstract data type.

  (2) The nesting of structured data objects.

  (3) The class hierarchy.

  (4) The inheritance of attributes along the hierarchy.

  (5) Matching between objects along their structures with the
      knowledge of the class hierarchy.

For additional features of MOOD4, please consult its manual available
with the program. Although they are biased to the processing of
material data (or, more generally, scientific and technical data),
MOOD with these capabilities can be used in any application domain at
least by the stage where you are to examine how well the pieces of
information of interest are represented in OODBS and how well specific
items of interest are discriminated out from the database as such.

Questions and suggestions on this software which are ever welcome
indeed may be addressed to;
 
     Noboru Ono                                             
     Dept. of Machine Intelligence and Systems Engineering, 
     Faculty of Engineering, Tohoku University.            
     Tel:++22-216-8111,
     Fax:++22-216-8156,
     E-mail:ono@mood.mech.tohoku.ac.jp



> OBST/STONE (Forschungszentrum Informatik [FZI], Karlsruhe, Germany)

OBST3-4 is now available at ftp.fzi.de under /pub/OBST/OBST3-4.
(Please do not confuse this new release with the older OBST3-3.4).

Experienced users will notice that we've changed the structure of
our ftp directory tree somewhat: compressed and gzip'ed files are
now cleanly separated. By sending
	echo 'info ftp_listing' | mail obst-listserv@fzi.de
you will get a directory listing from our ftp server.

OBST3-4 is a major release with a new meta schema interface
that enables schema modifications. A graphical schema browser
(USE) based on tclOBST is now also available. Please note that this
new tool has not yet been tested outside the FZI and that it
is currently not part of the OBST core cdistribution.

Beside bug fixes and performance improvements, we have added support
for IBM AIX and FreeBSD and improved the installation on LINUX PCs.

We would like to thank all OBST users who have helped us by testing a 
beta version of OBST, most notably:
  Naresh Sharma (N.Sharma@LR.TUDelft.NL)
  Michael Reifenberger (root@rz-wb.fh-sw.de)
  Hans-Ulrich Kobialka (kobi@borneo.gmd.de) 
  Jean Safar (jsafar@lehman.com)
  Gabor Karsai (gabor@vuse.vanderbilt.edu)
  Stefan Bohm (bohm@math.uni-muenster.de)

The installation of OBST requires a C++ compiler
(GNU g++ 2.3.3/2.4.5/2.5.8, or AT&T 2.1/3.01).

The OBST graphical tools run under the X-Windows
system (currently X11R4, X11R5 and X11R6). 
Installation has been tested for SunOS4.1.3 and LINUX only.

Best regards and happy OBST programming. 

   The OBST Team

------------------------------------------------------------------------------
README of OBST3-4
-----------------

Version: OBST3-4
Date:    11/4/94

The OBject system of STONE --- OBST
-----------------------------------

The persistent object management system OBST was developed by
Forschungszentrum Informatik (FZI) as a contribution to the STONE
project (supported by grant no. ITS8902A7 from the BMFT, i.e. the
German Ministry for Research).

OBST was originally designed to serve as the common persistent
object store for the tools in software engineering environments.


Data Model
---------

The OBST data model can be characterized by the following properties:

 * Schema definition language syntactically similar to C++
 * Support of multiple inheritance
 * Generic classes
 * Abstract classes and methods
 * Distinction between public, protected, and private methods
 * Redefinition of methods
 * Overloading of methods

Schemas and Containers
----------------------

Schemas are compiled by the OBST schema compiler. The compilation
results are instances of classes of the meta schema. From these
instances in a next step interfaces to different programming languages
can be generated. At present the C++ language binding is implemented.

Objects are stored in so-called containers. The container an object
belongs to is determined at the time of object creation and fixed
throughout the object's lifetime. Containers are the units of 
clustering, synchronization, and recovery. Objects can be referenced
by other objects across container boundaries.

Incremental Loading
-------------------

OBST provides a mechanism to incrementally load methods. This enables
programs to deal with objects whose type is defined after the program 
itself has been developed. This is useful in systems that provide for 
inheritance and it supports schema evolution. We used it e.g. for
programs that interpret the object base and call methods of the
found objects (for example the below mentioned browser).

Prototype
---------

Since end 1990 the first prototype of OBST is available and is shipped
to interested universities and research institutions. The current
version is publicly available via FTP (see below) since March '92.
There is a mailing list (see below) with >>100 subscribers.

The system comes with the schema compiler, a library of predefined
classes (like Set<Entity>, List<Entity>, String, ...), a graphical
object browser (more a shell than a browser), a graphical schema
designer (USE), the structurer and flattener (STF), tclOBST,
and all manuals.
For USE, STF and tclOBST see below.

Schema Evolution Support Environment (USE)
------------------------------------------

This environment consists of a graphical schema designer built with
tclOBST (see below). It can be used to inspect existing class hierarchies
and to modify these hierarchies; it allows the addition of new classes
as well as the modification of existing ones.

Structurer and Flattener (STF)
------------------------------

This is a tool to build objects from bytestrings and flatten objects
down to bytestrings. It is intended to be used when coupling UNIX
tools to the object management system. The user defines a grammar that
describes her objects. Afterwards, the structurer parses an ascii 
text according to the given grammar and creates an OBST object
structure that represents the corresponding parse tree.
The flattener does the inverse transformation, that means it generates
an ascii text from a given OBST object structure according to the given
grammar.

tclOBST
-------

tclOBST is a library which provides an embedding of OBST into the
interactive tool command language tcl, developed by John Ousterhout
at the University of Berkeley.
Based on the standard tcl shells, which are also comprised in the
tclOBST distribution, tclOBST offers interactive access to the complete
functionality modelled by OBST schemata.


System Requirements
-------------------

For the prototype's installation a C++ compiler
(GNU g++ 2.3.3/2.4.5/2.5.7 or AT&T 2.0/2.1/3.01) and the
X-Windows system (currently X11R4 or X11R5) for the graphical tools
are required.
Installation is well-tried on SUN Sparc stations and should be no
problem on other UNIX machines, too. You can find a more detailed
description of the supported platforms in the README.install.OBST*.

--------------------------------------------------------------------

For more information please mail to:

                Forschungszentrum Informatik (FZI)
                       OBST Projekt
                 Haid-und-Neu-Strasse 10-14
                     D-76131 Karlsruhe
                          Germany

or email to:  obst@fzi.de

Phone:        ++49-721-9654-701
Fax:          ++49-721-9654-709
Teletex:      721 190 fziKA

The OBST system is available via anonymous FTP from
ftp.fzi.de [141.21.4.3] and some mirror servers.

The system as well as some overview papers, documentation
(User's Guide, Language Reference Manual, Tutorial, ...),
and lots of manual pages can be found in the directory /pub/OBST.

There are mailing lists for announcing OBST enhancements,
new versions, porting hints, etc. as well as for exchanging experiences
with other OBST users.

Send a mail with content 'LONGINDEX' to obst-listserv@fzi.de to learn about
the mailing lists which are currently installed:
	echo LONGINDEX | mail obst-listserv@fzi.de

The mailing lists are maintained by an automatic list processor.
Use 'HELP' to learn about the commands understood by this processor:
	echo HELP | mail obst-listserv@fzi.de

Bug reports should contain a small example program with which the
bug can be reproduced, or at least a detailed description of the
observed phenomenon. They should also mention:
     o OBST version 
     o configuration parameters for your OBST version
       (from file config.status)
     o kind and version of C++ compiler 
     o machine
     o operating system

Besides bug reports we are strongly interested in all experiences
our users make with OBST (e.g. sufficiency of data model, performance,
...) and in our users' application areas and the applications as
well. So, please don't hesitate to send us a short note.

Best regards and happy OBST programming.

   The OBST Team,

	Boris Boesler, Dirk Eichberg, Frank Fock, Axel Freyberg,
	Michael Gravenhorst, Ingolf Mertens, Michael Pergande, Christian Popp,
	Bernhard Schiefer, Dietmar Theobald, Axel Uhl, Walter Zimmer

---

BTW "Obst" is the German word for "fruit",
    so have a fruitful time with OBST!


> Ode

                                 Ode 2.0
                       An Object-Oriented Database

       C++ Compatible, Fast Queries, Complex Application Modeling,
       Multimedia Support, and more

See APPENDIX E, Databases, for description.
Note: Ode version 3.0 is now available.


> Oggetto, University of Lancaster, UK.

Developed at the University of Lancaster, UK.  Summary NYI.

"Oggetto: An Object Oriented Database Layered on a Triple Store",
J.A. Mariani, The Computer Journal, V35, No 2, pp108-118, April 1992.


> ORION (Now marketed as ITASCA)

ORION was a prototype OODBMS developed at MCC, an American consortium by Won
Kim and his group.  Won Kim has left MCC and formed a new company, UniSQL, in
Austin, with a new product of the same name.

See also entry under "ITASCA".

REFERENCES:

I have found nearly a dozen papers published by the ORION folks.
Overviews at various stages in its development and commercialization
can be found in:

[KBGW91] Won Kim, N. Ballou, J.F. Garza, and D.; Woelk. A
         distributed object-oriented database system supporting
         shared and private databases. ACM Transactions on
         Information Systems, 9(1):31--51, January 1991.

[KGBW90] W. Kim, J.F. Garza, N. Ballou, and D. Woelk.
         Architecture of the orion next-generation database
         system. IEEE Transactions on Knowledge and Data
         Engineering, 2(1):109--24, March 1990.

[KBCG89] Won Kim, Nat Ballou, Hong-Tai Chou, and Darrell Garza,
         Jorge F. Woelk. Features of the ORION object-oriented
         database system. In Won. Kim and Frederick H.
         Lochovsky, editors, Object-Oriented Concepts, Databases
         and Applications, chapter 11. Addison-Wesley, Reading,
         MA, 1989.

[KBC+88] Won Kim, N. Ballou, Hong-Tai Chou, J.F. Garza,
         D. Woelk, and J. Banerjee. Integrating an
         object-oriented programming system with a database
         system. In Proceedings of the ACM Conference on
         Objected-Oriented Programming:  Systems, Languages and
         Applications (OOPSLA), pages 142--152, San Diego, CA,
         September 1988. Published as ACM SIGPLAN Notices
         23(11).
         [Pointers to the previous papers documenting each of the
          advanced features listed above are cited therein.]


The paper most relevant to the issue of schema evolution is the
following:

[BKKK87] J. Banerjee, W. Kim, H-J. Kim, and H.F. Korth.
         Semantics and implementation of schema evolution in
         object-oriented databases. In U. Dayal and I. Traiger,
         editors, Proceedings of the SIGMOD International
         Conference on Management of Data, San Francisco, CA,
         May 1987.


You might also like to look at Kim's book, which provides a good
introduction to OODBMS, while focusing on the ORION work:

[Kim90]  Won Kim. Introduction to Object-Oriented Databases.
         Computer Systems. MIT Press, Cambridge, MA, 1990.


> OTGen (Carnegie Mellon University/UMass Amherst)

OTGen is a design for a system to support schema evolution in
object-oriented databases.  The chief contribution of OTGen is support
for programmer extensibility of transformation functions to allow a
system to support a wide range of schema changes, not just those that
can be easily automated.  While OTGen was never implemented, it is
based on the implementation of TransformGen, a system to support the
evolution of the specialized databases used by Gandalf programming
environments.  For more information on OTGen and TransformGen, please
see: 

Barbara Staudt Lerner and A. Nico Habermann, "Beyond Schema Evolution
    to Database Reorganization", in Proceedings of the Joint ACM 
    OOPSLA/ECOOP '90 Conference on Object-Oriented Programming:
    Systems, Languages, and Applications, Ottawa, Canada, October
    1990, 67-76. 

Barbara Staudt, Charles Krueger, and David Garlan, TransformGen:
    Automating the Maintenance of Structure-Oriented Environments, 
    Computer Science Department Carnegie-Mellon University, Technical 
    Report CMU-CS-88-186, November 1988.

David Garlan, Charles W. Krueger, and Barbara J. Staudt, "A Structural
    Approach to the Maintenance of Structure-Oriented Environments",
    in Proceedings of the ACM SIGSOFT/SIGPLAN Software Engineering
    Symposium on Practical Software Development Environments, Palo
    Alto, California, December 1986, 160-170.

Contact:
Barbara Lerner
blerner@cs.umass.edu


> VODAK

Research in the framework of VODAK focuses on an extensible data
model and database programming language, an advanced transaction
model, object-oriented query language, and support for multimedia data.

The VODAK Data Model Language VML

Usually database models lack mechanisms for extending them with
additional modeling primitives. This limitation does not allow the
adaptation of the models for specific application needs, e.g. database
integration, multimedia document handling, hypertext modeling, etc.

The VODAK Model Language VML  homogeneously integrates the concept of
metaclasses and the separation of types and classes with other
object-oriented concepts such as properties, methods, inheritance, and
object identity. Complex nested data structures can be defined using
the set, array, tuple, and dictionary type constructors. VML supports
its own programming language for implementing methods, specifying
transactions and an ad hoc query language.

In VML classes are used to organize a set of objects corresponding to
real world entities and relationships between them. Object types define
the structure of objects and the operations defined on these
structures.  They are associated with classes in order to determine the
structure and behavior of the class' instances. Metaclasses are first
class objects whose instances are classes. Metaclasses are associated
with three object types: an (optional) own-type extending their own
behavior, an instance-type specifying the behavior of their instances
(which are classes), and an  instance-instance-type specifying the
behavior of the instances of their instances.  Metaclasses can be
organized in an instantiation hierarchy of arbitrary depth.

This approach leads to an open, adaptable data model which provides for
the specification of additional modeling primitives at a meta layer of
the database schema. The concept of metaclasses and the separation of
classes and types allow to determine the structure and behavior of
objects and the individual inheritance behavior via semantic
relationships between arbitrary objects already at the meta layer
independently from the specifications given at the application layer
for the application specific classes.


The VODAK Transaction Model

In VODAK, we focus on two specific problems of transaction management.

1. Operations to read and edit (hyper)documents are typically complex,
interactive and of long duration. A high degree of concurrency is
required to reduce the number and length of times a transaction is
blocked.

2. A publication environment has to handle existing database systems
for using and modifying remote information and documents.  Transaction
managers of existing systems, i.e. concurrency control and recovery,
have to be integrated in a transparent way utilizing the functionality
of existing managers.

Our transaction model is based on open nested transactions. Compared to
conventional flat transactions, nested transactions allow more
concurrency and are more flexible for recovery.  A nested transaction
is a tree-like structure, dynamically built up by the call of
subtransactions until a bottom implementation level is encountered.

We extended the open nested model from a fixed calling hierarchy of
operations in a layered system (multi-level transactions) to an
arbitrary calling hierarchy of operations in an object-oriented system.
Commutativity of operations is applied to system defined VODAK methods,
and to methods of user defined object types.  For the second type of
operations, we developed a framework to specify commutativity and
inverse operations in VML.

Query Processing

Although nearly all object-oriented data models proposed so far include
behavioral aspects, most object-oriented query languages, algebras and
query optimization strategies simply adapt relational concepts since
they focus on the complex structures of objects and neglect the
behavior. We claim that this approach is not sufficient since it does
not reflect the much richer semantics methods can carry which have to
be taken into account for really efficient query processing. The quite
straightforward approach we consider is to integrate methods in an
algebraic framework for query processing and to make there partial
knowledge about methods available in the form of equivalences. We
integrate algebraic set operators with methods defined in database
schemas within an object-oriented data model. We investigate the impact
on the architecture of the query processor when the algebra becomes an
extendible component in query processing.

Multimedia Support

The V3 Video Server was built as a demonstration showing a multimedia
application developed on top of the VODAK database management system.
The V3 Video Server allows a user to interactively store, retrieve,
manipulate, and present analog and short digital video clips. A video
clip consists of a sequence of pictures and corresponding sound.
Several attributes like author, title, and a set of keywords are
annotated.

In the future, the VODAK DBMS will be enhanced with new built-in
functionality for multimedia datatypes. Therefore, existing components
of VODAK must be changed and new ones must be added to support time
dependencies, high data volumes, and user interaction.

Query Processing

Although nearly all object-oriented data models proposed so far include
behavioral aspects, most object-oriented query languages, algebras and
query optimization strategies simply adapt relational concepts since
they focus on the complex structures of objects and neglect the
behavior. We claim that this approach is not sufficient since it does
not reflect the much richer semantics methods can carry which have to
be taken into account for really efficient query processing. The quite
straightforward approach we consider is to integrate methods in an
algebraic framework for query processing and to make there partial
knowledge about methods available in the form of equivalences. We
integrate algebraic set operators with methods defined in database
schemas within an object-oriented data model. We investigate the impact
on the architecture of the query processor when the algebra becomes an
extendible component in query processing.

The VODAK Prototype

The system architecture consists of a central database environment and
several external database environments to which the user wants to have
integrated access. Each of these environments consists of an object
manager, a message handler, a transaction manager, and a communication
manager. In addition to these components an external database
environment includes a database interface module which realizes the
access to an external database system.

The DBMS components are currently built on top of DAMOKLES and will be
in the near future on top of ObjectStore.

A first version of a C++ based prototype of VODAK is available for Sun
Sparc Stations under certain conditions.  It implements all the
features specified in including e.g. metaclasses, transactions, and
remote message execution.

References

P. Muth, T. Rakow, W. Klas, E. Neuhold:  A Transaction Model for an
Open Publication Environment.  A. K. Elmagarmid (Ed.): Database
Transaction Models for Advanced Applications. Morgan Kaufmann
Publishers, San Mateo, Calif., 1992.

Wolfgang Klas, Karl Aberer, Erich Neuhold Object-Oriented Modeling for
Hypermedia Systems using the VODAK Modeling Language (VML) to appear
in: Object-Oriented Database Management  Systems, NATO ASI Series,
Springer Verlag Berlin Heidelberg, August 1993.

Karl Aberer, Gisela Fischer Object-Oriented Query Processing: The
Impact of Methods on Language, Architecture and Optimization
Arbeitspapiere der GMD No. 763, Sankt Augustin, July 1993.

T.C. Rakow, P. Muth The V3 Video Server: Managing Analog and Digital
Video Clips, Sigmod 93, Washington, DC.

For further information contact

{aberer,muth,rakow,klas}@darmstadt.gmd.de

  GMD-IPSI                                             
  Dolivostr. 15                                                           
  D-64293 Darmstadt
  GERMANY    
                                    
  FAX: +49-6151-869 966   


Commercial Systems
__________________

> ArtBASE  (Object-Oriented Data Model)

by:     ArtInAppleS Ltd.
        Kremelska 13
        845 03 Bratislava
        SLOVAKIA
        Phone: x42-7-362-889
        fax:   x42-7-777 779
        EMail: artbase.support@artinapples.cs

Distributor for Germany:
        ARS NOVA Software GmbH
        Stettener Strasse 32/3
        73732 Esslingen a.N.
        Germany
        Phone: x49-711 3704001
        Fax:   x49-711 3704001
        EMail: info@arsnova.stgt.sub.org

Languages: Objectworks\Smalltalk by ParcPlace Systems, Inc.

Platforms: Unix, PC Windows, Macintosh

Features:
- Fully implemented in Objectworks\Smalltalk
  (ArtBASE is delivered with source code)

- ArtBASE extents Smalltalk of persistency. Persistent objects are handled the
  same way as transient objects.

- Optimistic and pessimistic concurrency control.

- Transactions, including long lived transactions

- User concept with access restrictions

- storing of classes and methods in the database - entire applications 
  may be stored in an ArtBASE database, including the data AND the 
  application classes

- Currently, a single user version is available. The Distributed Multi User Server Version
  will be presented at the OOPSLA'93 at Washington D.C. in September 1993 for Unix
  environments and PCs.

- Existing applications can be turned to database applications very easily using ArtBASE


> EasyDB (Objective Systems, Sweden)

EasyDB features a (programming language independent) Data Definition
Language (DDL) for the definition of schemas.  It relies on the
Entity-Attribute-Relationship model.  Data Manipulation Languages
(DML) include a Navigational Query language (NQL) embedded in a host
language (C available now, Ada in January '93), and a generic C++
class library.

On Schema Evolution (from original survey):
The schema may be freely extended with new items (types, domains,
attributes, entities, relationships etc.). Deletion of items is not
allowed.

Data created with an older schema may co-exist with newer data. Old
applications need not be recompiled when the schema is updated.
Attempts by newer applications to access `older' data in an
inconsistent way are detected and reported via an exception handling
system.

[Tomas Lundstrom <tomas@os.se>]

Objective Systems SF AB (Ericsson)
Box 1128
S-164 22 Kista, Sweden
tel : +46-8-703-4591
fax : +46-8-750-8056
contact: Jaan Habma, jaan@os.se


> GemStone (Servio)

First introduced in 1987, Servio's GemStone is the oldest commercial ODBMS
available today. GemStone is particularly well suited for use in complex
multi-user, multi-platform client/server applications. It supports
concurrent access from multiple external languages, including Smalltalk-80,
Smalltalk/V, C++ and C. GemStone also provides a dialect of Smalltalk as an
internal DML, which can execute methods or entire applications in the
database.

Servio also offers GeODE (GemStone Object Development Environment), an
object database application development environment which allows developers
to build complete object applications visually, without writing code. With
GeODE's visual programming tools, programming an application is a matter of
wiring together graphical representations of encapsulated code blocks. A
simple extension mechanism promotes the re-use of code, thereby increasing
the speed of program development. Also, association of application user
interface elements with database objects is established through simple
graphical tools. GeODE applications are stored and run in the GemStone
database, and so are both self-porting and network-aware, and can be
accessed externally from any of the GemStone language interfaces. Because
of GemStone's network architecture, Geode applications can operate easily
in a client/server environment.


 ==============================================================================

GEMSTONE

GemStone is a highly scalable client-multiserver database for commercial
applications. GemStone's features include:

o  Active Database -- GemStone allows database application developers to
   write methods which are stored and executed directly in the database.
   These methods can be accessed either internally, or from external client
   applications. This can significantly reduce network traffic and allow
   applications to take advantage of the superior compute power of the
   server. This also eliminates the need to rebuild and re-deploy
   applications whenever application or business processing rules change.
   This in turn allows for centralized code development and management,
   architecture-independent code that ports itself to new platforms,
   reduced network usage, and true client/server applications that share
   compute load between client and server machines.

o  Concurrent Support for Multiple Languages -- GemStone provides
   concurrent support for applications developed in Smalltalk, C++, C or
   GeODE. All applications, regardless of language, can have simultaneous
   access to the same database objects.

o  Flexible multi-user transaction control -- Multiple users can
   operate in the database simultaneously, with a variety of transaction
   control modes available.

o  Object-level security -- Authorization control can be applied to any
   object in the database, allowing for fine tuning of object security.

o  Dynamic schema and object evolution -- GemStone supports schema
   modification through class versioning and allows full migration of
   objects between versions of their classes with a simple message send.
   Migration is fully customizable and is undoable.

o  Production Services -- GemStone delivers the full suite of features
   required in any production-ready networked database including online
   backup, rapid recovery, referential integrity, sophisticated concurrency
   control, and event signals and notifiers.

o  Scalability -- In a recent independent benchmark, GemStone scaled to
   support more than 1,000 simultaneous log-ins and 100 concurrent active
   users on a mid-sized SMP server.

o  Legacy Gateways -- GemStone incorporates gateways or data bridges
   that allow object applications to integrate legacy data, whether in SQL,
   IMS, VASM or other formats. The level of integration between GemStone
   and legacy data and applications can range from simple query access to
   extensive read-write interoperability.


 ==============================================================================

GEODE

GeODE is a comprehensive environment for rapidly designing, building and
deploying production-quality commercial object applications. Its design
promotes code reuse in a team programming environment for increased
productivity. GeODE consists of six main elements:

o  Visual Application Manager -- Provides centralized management
   of each application and its component parts, and a namespace for
   addressing known objects.

o  Visual Schema Designer -- Allows the development of database schema
   visually, making the process more interactive and intuitive than with
   object-oriented programming languages. It also provides analysis tools
   for examining an existing schema.

o  Visual Forms Designer -- The Forms Designer reads GemStone class
   definitions and an associated data dictionary to automatically create
   default forms suitable for simple data entry. These forms can be rapidly
   customized, using a wide selection of user interface components and
   field types, which include image and sound support, and a large set of
   form design aids. The list of field types can be extended interactively.

From ankh.iia.org!babbage.ece.uc.edu!news.kei.com!hookup!bloom-beacon.mit.edu!senator-bedfellow.mit.edu!faqserv Wed Nov 23 21:57:35 1994
Path: ankh.iia.org!babbage.ece.uc.edu!news.kei.com!hookup!bloom-beacon.mit.edu!senator-bedfellow.mit.edu!faqserv
From: Bob Hathaway <rjh@geodesic.com>
Newsgroups: comp.object,comp.answers,news.answers
Subject: Comp.Object FAQ Version 1.0.7 (10-27) Part 5/10
Supersedes: <object-faq/part5_782395740@rtfm.mit.edu>
Followup-To: comp.object
Date: 29 Oct 1994 11:42:21 GMT
Organization: Geodesic Systems
Lines: 1568
Approved: news-answers-request@MIT.Edu
Distribution: world
Expires: 12 Dec 1994 11:40:18 GMT
Message-ID: <object-faq/part5_783430818@rtfm.mit.edu>
References: <object-faq/part4_783430818@rtfm.mit.edu>
NNTP-Posting-Host: bloom-picayune.mit.edu
Summary: Frequently Asked Questions (FAQ) List and Available Systems For Object-Oriented Technology
X-Last-Updated: 1994/10/28
Originator: faqserv@bloom-picayune.MIT.EDU
Xref: ankh.iia.org comp.object:7430 comp.answers:4420 news.answers:13679

Archive-name: object-faq/part5
Last-Modified: 10/27/94
Version: 1.0.7

o  Visual Program Designer -- The Visual Program Designer allows developers
   to visually create and modify the behavior of an application without
   having to write code. Programs are created by connecting visual program
   blocks to field blocks drawn from the forms created in the Forms
   Designer. A large collection of predefined program blocks is provided
   with GeODE, and users can extend the catalog in any of a number of
   simple ways. Code-based programming can be integrated routinely.

o  Developer Class Library - GeODE comes standard with more than 480
   classes and thousands of methods, and is easily extended for handling
   specialized applications. In a team environment, some programmers can
   develop visual applications while others write new methods that are
   encapsulated into visual program blocks for easy reuse.

o  Developer Tools -- GeODE includes tools for debugging, browsing and
   inspecting applications. Included in this set of tools are several
   debuggers, browsers, inspectors, an object clipboard, an image editor,
   and a code profiler for performance analysis.


 ==============================================================================

PLATFORMS

GemStone release 3.2 and GeODE 2.0 and all language interfaces are
available for UNIX workstations and servers from SUN, HP, IBM, Sequent, and
DEC. Client-only support is available in a number of languages for Windows
3.1, OS/2 and Macintosh. Servio is an active member in the Object
Management Group and the ANSI Smalltalk standardization committee. Servio
supports SUN ODMG, ANSI C++ and intends to comply fully with the emerging
standards.

 ==============================================================================

REFERENCES

  [Maier, et al. 84] D. Maier, J. Stein, A. Otis, A. Purdy, ``Development
  of an object-oriented DBMS'' Report CS/E-86-005, Oregon Graduate Center,
  April 86 - ACM 0-89791-204-7/86/0900-0472

  R.G.G. Cattell: Object Data Management - Object-Oriented and Extended
  Relational Database Systems; Addison-Wesley. ISBN 0-201-53092-9

  Robert Bretl, David Maier, Allen Otis, Jason Penney, Bruce Schuchardt,
  Jacob Stein, E. Harold Williams, Monty Williams. "The GemStone Data
  Management System." Chapter 12 of "Object-Oriented Concepts, Databases
  and Applications", by Kim and Lochovsky.


 ==============================================================================

CONTACTS

 === Headquarters - San Jose ====

Servio Corporation
2085 Hamilton Avenue
Suite 200
San Jose  CA  95125

Tel: 800-243-9369
Tel: 408-879-6200
Fax: 408-369-0422

 === Chicago ====

Servio Corporation
8410 Bryn Mawr
Suite 400
Chicago  IL  60631

Tel: 312-380-1310
Fax: 312-380-1308

 ===  New York ====

Servio Corporation
1120 Avenue of the Americas
4th Floor
New York  NY  10036

Tel: 212-626-6680
Fax: 212-626-6684

 === Dallas ====

Servio Corporation
14875 Preston Road
Suite 550
Dallas  TX  75240

Tel: 214-980-7073
Fax: 214-980-2949

 === Europe/UK ====

Servio UK
Criterion House
Beauchamp Court, Victors Way
Barnet  EN5 5TZ  England

Tel: +44 81 447-0800
Fax: +44 81 447-0577

 === Japan ====

Servio Corporation
Daito-Eiwa Building, 7F
5-11 Nihonbashi-Hakozakicho
Chuo-ku  Tokyo 103  Japan

Tel: +81 3 3660-1910
Fax: +81 3 3663-3287

 =====================
 === Distributors ====
 =====================

 === Germany, Austria, Switzerland ====

ObjectOriented System Technologies
Baroper Str. 337
Dortmund  50  W-4600
Germany

Tel: +49 231 975 990
Fax: +49 231 975 99-20

 === Japan ====

Japan Information Processing Service Co., Ltd.
2-4-2 Toyo , Koto-ku
Tokyo, 135, JAPAN

Tel: +81 3 5690 3268
Fax: +81 3 5690 3390

--------------------

Nexus Technology K.K.
Suite 901
Botan 3-11-1
Koto-ku  Tokyo 135  Japan

Tel: +81 3 3660-1910
Fax: +81 3 3663-3287

 === Taiwan ====

Anco Technologies
11-1F, 76 Tun Hwa S. Road, Sec. 2
Taipei
Taiwan, R.O.C.

 === Italy ====

Etnoteam S.P.A.
Via Adelaide Bono Cairoli 34
Milano  20127  Italy

Tel: +39 2 261 621
Fax: +39 2 261 10755

 === England ====

AI International Ltd.
1 Parkview Road
Berkhamsted
Herts  HP4 2EY  England

Tel: +44 442 876 722
Fax: +44 442 877 997

 ==== Mexico ====

TEIX, Sistemas de Informacion
Estrategica S.A. de C.V.
Antonio M. Anza No. 43
Col Roma  Mexico D.F.  06700

Tel: +52 5 564-7146


> ITASCA
                       ITASCA ODBMS V2.2

                      Itasca Systems, Inc.
                       7850 Metro Parkway
                      Minneapolis, MN 55425
                        sales@itasca.com
                         (612) 851-3155

                          Sandy Miezwa
                         (612) 851-3169

Introduction

Itasca Systems develops, markets, and supports ITASCA, a distributed 
active object database management system and related tools. The initial 
research work for ITASCA occurred in the Object-Oriented and Distributed 
Systems Lab at the Microelectronics and Computer Technology 
Corporation (MCC) in Austin, Texas. The research was known as the 
ORION prototypes. 

The ITASCA Distributed ODBMS is a language neutral, full-featured, active 
object database that supports data access from various object
languages. ITASCA allows clients to transparently access data that is
distributed among multiple servers.  ITASCA supports full dynamic schema
modification that can be performed during any phase of the software
lifecycle.  Applications written in dissimilar and incompatible languages,
such as C++ and CLOS, share objects through ITASCA. ITASCA stores methods
inside the database, promoting reusability and maintainability.  The only
commercial ODBMS based upon the MCC Orion technology, ITASCA is considered
by many to be the most feature-rich ODBMS on the market today.

This overview describes release 2.2 of the ITASCA Distributed Object 
Database Management System. It describes how ITASCA functions, 
outlines its implementation features, and explains some of the system 
benefits. 


History of ITASCA

ITASCA is based on a series of object database research prototypes. Work 
on these prototypes began in 1985 at the Microelectronics and Computer 
Technology Corporation (MCC) Object-Oriented and Distributed Systems 
Laboratory. MCC released the first prototype, ORION-1, in May, 1987, as 
a single-user system. MCC extended ORION-1 to the ORION-1SX 
prototype system and released it to the shareholder companies in April, 
1988. ORION-1SX was a multi-user system with a multi-client, single 
server architecture. The third prototype, ORION-2, introduced a distributed, 
object-oriented architecture for a multi-user environment. MCC released 
the third prototype to shareholder companies in July, 1989. ORION-2 has a 
multi-client, multi-server architecture. Having met its objectives, MCC 
stopped all work on ORION at that time. Over five million dollars was spent
for the three generations of prototypes.

The ITASCA product is an extension and commercialization of the ORION-2
prototype from MCC. Itasca Systems has added major enhancements and
features, improved the performance, and strengthened the code. It now runs
on UNIX systems from multiple vendors. ITASCA is an industrial-strength,
documented product, fully supported by Itasca Systems, Inc. Itasca Systems
continues to develop tools and other products to work with ITASCA.


Overview

ITASCA employs a distributed architecture with private and shared objects 
spread across UNIX-based computers on a local-area network. The 
ITASCA model follows the object-oriented view that uniformly models any 
real-world entity as an object. Each object has a unique identifier along with 
a state and behavior. Attributes represent the state of an object. Methods 
(code) define the behavior of an object. A class object collects objects that 
share the same set of attributes and methods. Subclasses derive from 
existing classes. The resulting schema, or database definition, is a class 
hierarchy. Each subclass inherits all the attributes and methods of its 
superclasses. ITASCA supports multiple inheritance. A subclass may derive 
from more than one superclass. 

One of the breakthroughs of object-oriented technology is the reusability of 
code. ITASCA allows for the active management of both reusable code and 
data in an integrated system. Developers may write applications in C++,
CLOS, C or Common Lisp. This means ITASCA is language neutral. Objects 
stored using one programming language can be accessed by other 
programming languages. It also means an application program need not be
written in an object-oriented language. 

The ITASCA database management system has features belonging to most any 
database system. This includes persistent storage for data and schema, 
concurrency control and locking, transaction management, multiple 
security levels, and logging and recovery for both CPU and disk media 
failure. Additional features of ITASCA include dynamic schema 
modification, long-duration transactions, shared and private databases, 
distributed version control, distributed transaction management, distributed 
query management, distributed change notification, object migration, and 
an extensible architecture.

Shared and private databases exist in a distributed environment in ITASCA. 
The shared database is distributed across workstations (sites) in a network. 
An ITASCA server controls the partition of the shared database at each site. 
ITASCA clients provide transparent access to the various partitions of the 
shared database. The architecture allows any number of private databases at 
each distributed database site. Data can move between private and shared 
databases. Private databases allow private data that is not shared with other 
users of the database.

ITASCA stores the schema redundantly at each site to improve 
performance. The schema storage also includes code in the form of 
methods. Management of schema updates is automatic for all sites. This 
includes sites that were off-line during any changes. Automatic distribution 
of schema changes, including method code changes, simplifies database 
administration.

ITASCA stores each instance of data in one site. The system or a user may 
move the data from one site to another to improve data locality. Access to 
moved data remains transparent. There is no need for a user or application 
to know the specificlocation of data in the ITASCA distributed database. 
ITASCA will automatically find the location of the data. This simplifies 
distributed application development. The developer can rely on ITASCA 
finding data in the distributed database.

No single site acts as a master site, thus ITASCA's architecture has no 
single point of failure. ITASCA has neither a central data server nor a 
central name server. This is important for maintaining a database system 
with high availability in a networked workstation environment.

ITASCA supports dynamic schema modification to create a flexible 
environment for changing or customizing a database system. Authorized 
users can add and remove attributes or change the subclass/superclass 
relationship at any time. Authorized users can also add or remove partitions 
of the shared database at any time. All this can be done interactively without 
affecting other parts of the ITASCA database at the time changes occur to 
the schema. There is no need to "bring the system down" or off-load/reload 
data to restructure the database. Dynamic schema modification can 
significantly reduce maintenance costs. It also is useful in environments 
where change to data definitions are normal or relatively frequent.

ITASCA has a sophisticated security authorization technique tied to the 
class hierarchy. It supports both positive and negative authorizations at any 
level in the class hierarchy. For example, granting access to all objects but 
one requires only two authorizations: a global grant followed by a specific 
denial. Authorization extends to classes, instances of classes, attributes, 
and methods. Also, inheritance of authorization reduces the work of database 
administration. 

Long-duration transactions allow users to check objects out of the shared, 
distributed database into their private databases. Users can then change the 
objects in the private databases without affecting the shared database or 
other users. These changes can be committed to the private database. Then, 
at any later time, the user can check the updated object or objects back into 
the shared database.

ITASCA supports version control of objects. A new version of an object 
promotes the original or parent object to restrict further changes to the 
parent. ITASCA also supports alternate versions such that multiple versions 
can have the same parent. Promoting an object version to a released status 
restricts any deletion of the object. ITASCA uses generic versions to 
dynamically reference the most recent or default version of an object 
without any intervention by a user or application.

Change notification in ITASCA is either flag-based or message-based. 
Flag-based notification will identify an updated object upon querying the 
object for such information. It is a passive notification scheme. Message-
based notification, on the other hand, is an active notification scheme. It 
will execute a method (or code) upon an update or other change to an object. 
Such methods can send mail messages or invoke other methods or 
programs. 

Memory management in ITASCA uses both page and object buffers. 
ITASCA has a traditional database page buffer scheme that contains pages 
with multiple objects. Desired objects move from the page buffer to an 
object buffer. The object buffer then provides ITASCA with enhanced in-
memory performance because it contains only frequently-referenced 
objects. 


> Matisse

OODBMS FEATURES LIST:

An Industrial Strength Open Semantic Object Database

Performance
-       Symmetric, Fine Grain, Multi-Threaded Architecture
-       Parallel and Asynchronous Disk I/O
-       Automatic Disk Optimization through Dynamic Clustering
-       High Speed OLTP Environment
Reliability
-       24 Hour - Mission Critical Operation
-       Media Fault Tolerant (Object Replication)
-       Transparent On-line Recovery
Database Administration
-       Full On-line Administration (No Down Time)
-       On-line Incremental or Full Back-Up
-       Dynamically Increase Database Size -   On-line
-       Full On-line Monitoring
Data Management and Consistency
-       Dynamic Schema Evolution
-       Consistent Database Reads without Locking
-       Historical Versioning, both Schema and Data Objects
-       Built-in Enforced Referential Integrity
-       Object Level Implicit or Explicit Locking
Scalability
-       Hundreds of Concurrent On-line Users
-       Hundreds of Gigabytes Per Database
-       From Few Bytes to Four Gigabytes for Each Object
-       Up to Four Giga-objects Per Database
Object Model
-       Full Object Oriented Model
-       User Extensible Object Meta-Schema
-       Support for Complex, Highly Dynamic, Variable Sized Objects
-       Multiple Inheritance
Intelligent Objects
-       Triggers at Object, Attribute, or at Relationship Level
-       Consistency Rules at Object, Attribute, or at Relationship Level
-       Customizable Intelligent Object Indexing
-       Automatic Inverse Relationships
Open Systems
-       Open C, C++ API
-       Supports Any Commercial Development Tool and Language
-       No Proprietary Tool Required
-       Heterogeneous Cross Platform Client/Server Architecture

For Information on MATISSE, Contact one of the following offices:

USA:
ODB, an Intellitic International Company
238 Broadway
Cambridge, MA  02139
Phone:(617) 354-4220
Fax: (617) 547-5420
email:  info@odb.com

EUROPE:
INTELLITIC INTERNATIONAL
12-14 rue du Fort de Saint-Cyr
Montigny-le-Bretonneux
78182 Saint Quentin en Yvelines Cedex France
Phone:   33(1) 30.14.54.30
Fax:    33 (1) 30.14.54.40

JAPAN:
SGN CO. LTD.
Urban Toranomon Building
16-4 Toranomon
Minato-Ku Tokyo 105 Japan
Phone:   81 (3) 3593.34.31
Fax:   81 (3) 3593.34.32


> NeoAccess

A cross-platform object-oriented database engine based on C++. It allows
developers to embed the power of a fully-functional object-oriented database
system into their applications. All of the data contained in the database,
including indices, can be in a single file, so users can treat a database
file as they would a standard document file. The programming model is
designed to keep visible complexity to a minimum while providing a
feature-rich foundation on which to build and enhance applications.

NeoAccess has taken a different approach toward the issues surrounding object
persistence than have other solutions that have been offered. We believe that
objects should be viewed as having a set of properties with a pliable state.
With NeoAccess persistent objects are provided with persistence and sharing
properties. These properties allow objects to maintain an association with a
file. This association, which can be built and broken freely, allowing
objects to migrate freely between disk and memory. The API to these
properties address issues such as adding or deleting the object from a file,
sorting and indexing, locating and later freeing the object in memory, object
sharing, and maintaining relationships between objects.

NeoAcces
s with has been fully integrated into standard application frameworks such as
Borland's ObjectWindows and MacApp 3.0 and the THINK Class Library on the
Macintosh. A single source tree can be used to build the engine in all
development environments. Database files are binary-compatible across
platforms so users on different types of machines can share data without
conversion.

Contact:
Bob Krause
NeoLogic Systems
1373 Third Avenue
San Francisco, CA 94122
(415) 566-9207


> O2 (INRIA/O2 Technology)

This is an entry on schema evolution.  General papers on O2 are included.

We have implemented in O2 schema updates in our first release but
without NO IMPACT on the database (we have a design to implement
deferred update, but it is a paper design). However, users manage to
convert their instances by hand, using their O2 programs written
themselves, and with the aid of the following tools:

1- There is a set of predefined classes whose instances contain
   objects representing a schema (i.e., a Meta-schema). These classes
   may be used in a conversion program, they may even be extended by
   the programmer.

2- There is a save-restore program that allows to take an O2 database,
   save it on a file or a tape in a logical way (i.e., independent of
   the physical format of objects on disk), and restore it again on a
   (perhaps new release) of the system, in an empty database.
   Currently, when saving a database its schema is also saved. The
   next extension to this save/restore program will be to save the
   database without saving its schema, and then restore the database
   on a new version of that schema. The restore program will be able
   to perform automatically some conversions like "add attribute" or
   "delete attribute".


Schema updates with impact on the database will be implemented in future 
releases.

[Fernando Velez <fernando@o2tech.fr>]


For more information on O2, consult the following REFERENCES:

        Francois Bancilhon, Claude Delobel, Paris
        Kanellakis.  "Building an Object-Oriented Database
        System: The Story of O2".  Morgan Kaufmann Series
        in Data Management Systems, San Mateo, Calif., 1992.
        
        F. Bancilhon, G. Barbette, V. Benzaken, C. Delobel,
        S. Gamerman, C. Lecluse, P. Pfeffer, P. Richard,
        and F. Velez.  "The Design and Implementation of
        O2, and Object-Oriented Database System".
        Advances in Object-Oriented Database Systems,
        Springer Verlag. (Lecture Notes in Computer Science
        series, Number 334.)

        C. Lecluse, P. Richard, and F. Velez. "O2, an
        Object-Oriented Data Model".  Proceedings of
        SIGMOD88.  Also appears in Zdonik and Maier,
        "Readings in Object-Oriented Database Systems",
        Morgan Kaufmann, 1990.

 ==== Corporate headquarters:
O2 Technology
7 Rue du Parc de clagny
78035 Versailles Cedex
France
tel : 33 1 30 84 77 77
fax : 33 1 30 84 77 90

[They have many other contacts worldwide]


> Objectivity/DB (Objectivity)

Introduction:

Objectivity/DB has a fully distributed client/server architecture that
transparently manages objects distributed across heterogeneous environments and
multiple databases.  It provides an application interface that uses transparent
indirection to ensure integrity and provides a single logical view of all
information, with all operations working transparently on any database on the
network, with scalable performance as users and objects increase.  A
higher-level Object Definition Language (ODL) is available as well as a C
functional interface, integrated C++ interface, and SQL++.


Objectivity/DB

Objectivity/DB [Reference:  Technical Overview, Objectivity, 1993], a product
of Objectivity, Inc. of Menlo Park, CA, provides an integrated C++ programming
interface with an emphasis on the DBMS engine for robustness and scalability
from workgroups to enterprise-wide production applications.  In production use
today with more than 50,000 end users licensed, it supports a fully
distributed, rather than central-server, architecture, with all operations
working transparently over a mixture of multiple databases, schemas, users, and
computers, and over heterogeneous hardware, operating systems, and networks. 
The language interface includes a C++ class library interface, soon to be ODMG;
a C function library; and SQL++, supporting query predicates with either SQL or
C++ syntax, interactively or programmatically.  Over forty administrative and
GUI tools provide both an interactive and programmatic interface, and a
messaging backplane allows third party tools integration at four different
levels, with a list of partners at all levels.

One of the key architectural concepts of Objectivity/DB is an object reference
mechanism that ensures data integrity.  Unlike traditional ODBMSs that use
direct pointers, which become invalid after commit and hence lead to crashes
and corrupt databases, Objectivity/DB uses an indirection to guarantee safe
reference.  Transparent to the user, this indirection requires an extra test
and pointer dereference, or a couple of cycles, which is not measurable in most
applications.  However, it ensures integrity of all references, even across
transaction boundaries, resulting in production quality robustness.  Also, it
provides object level granularity for the object manager, allowing it to move,
cluster, and swap objects as necessary, one of the keys required for
scalability in objects and users.  Finally, it allows object-level granularity
for current features, such as heterogeneity and versioning, and future
extensions, such as object-level security.

A higher-level Object Definition Language (ODL) is provided that allows
declaration of modeling concepts such as bi-directional associations, behavior
of associations between objects as they version (move, copy drop), and
propagation of methods across associations.  These then result in automatically
generated methods and declarations for both C++ and C.  The standard C++ API
allows application programmers to work with any standard compilers and
debuggers, with no extra pre-processors, providing ODBMS capabilities via
overloading C++ operators (new, ->, etc.), and declarations via provided
classes (for references, etc.).

Workgroup through enterprise-wide and cross-enterprise computing is supported
via a distributed client/server architecture that provides a single logical
view over multiple databases on heterogeneous machines.  The user sees a
logical view of objects connected to objects and need not worry that one object
is in a database on a Sun workstation, while another may be in a database under
Windows or VMS.  All operations work transparently across this environment,
including atomic transactions with two-phase commit, propagating methods, and
versioning.  Objects may be moved between databases and platforms without
affecting working applications or requiring changes to the applications. 
Multiple schemas may be created, without affecting other users or databases,
and may be used simultaneously with shared schemas, allowing local groups to
define their own models but still connect to other groups.  Databases may be
detached from this shared environment (federated database) and used on portable
devices, reconnected or moved to different (compatible) environment, or
distributed as parts or image libraries.  Gateways to RDBMSs are provided via
third-party integration with Persistence Software, and more generally to any
foreign data store, as long as the user installs the appropriate access
methods, extending the single-logical-view to include read/write access to
arbitrary foreign data stores.  Together, these allow delegation of
responsibilities to the appropriate users, integration with existing systems,
and gradual migration toward full enterprise-wide sharing.

The on-demand object manager directly and automatically manages object access
and buffering, rather than relying on system facilities such as virtual memory
or user manual get/put calls.  Mechanisms used include multiple buffer pools
locally and remotely, b-trees, hashing, scoped names, keys, and iterators, with
distributed catalogues for schemas and databases.  A direct connection is
established between the user and the objects used, so that users do not
conflict unless and until they are competing for the same objects, thus
avoiding the traditional central-server bottleneck.  Short transactions are
based on traditional (transient) locks, owned by the process, and group
together an arbitrary set of operations.  Long transactions are based on
persistent locks, owned by the user, and provide the same arbitrary grouping. 
Default concurrency is two-phase locking and serialization, but extensions
available include MROW, or multiple-readers concurrent with one-writer, and
allow users to lock with or without wait or with timed waits, to implement more
sophisticated mechanisms.

Objects may be modeled using C++ structures augmented by classes provided such
as strings, dictionaries, and relationship management, as well as some
particular domain libraries.  A simple object is a C++ class (or C structure)
with associated access methods.  A complex object may include multiple varrays,
each being a dynamically varying sized array of arbitrary structure.  A
composite object is any network of related objects that acts as a single
object, both structurally and behaviorally, via propagation of behaviors to
component objects.  Any number of composite objects may be contained in
composite objects, and a single object may participate in any number of
composites.  The relationship mechanism supports uni- and bi-directional
relationships, one-to-one, one-to-many, and many-to-many.  Versioning is
supported at object granularity, may be turned on or off at any time for each
object, may be restricted to linear or allow branching with multiple writers. 
References to versioned objects may be to a specific version or to the default
version, which may be separately specified by a method and may allow multiple
defaults.  Schema and object evolution are supported via versioning of the
type-defining objects.  Each time a type definition is changed, its defining
object is versioned, allowing arbitrary changes.  Objects may then be instances
of the old or new type version.  Object evolution or upgrading to the new type
version is supported  by the user writing conversion methods which are
installed and invoked by the system.

ANSI SQL query is supported in the SQL++ product.  Predicate syntax may be
either C++ or SQL.  The ODBC and SQL Access Group (SAG) protocols are
supported.  Queries may be invoked programatically or interactively, with ad
hoc support.  Access to object features is available via methods and traversal
of relationships.

Over forty administrative and developer tools are provided, each with both an
interactive and programmatic interface.  These include GUI object and type
browsers, query browsers, report generator, tools to examine and force short
and long locks, to move objects and databases, etc.  On-line incremental backup
provides a consistent network-wide snapshot, including referential integrity
across all databases, and runs incremental and full database backups with no
need to acquiesce the databases and no interference with active applications. 
All tools are built around a messaging backplane, which supports four levels of
integration with user and third-party tools.  Integrated products include HP
SoftBench (full operational level), CenterLine's ObjectCenter (tool level), 
Persistence RDBMS gateway, PTech and ProtoSoft Design and Analysis (language
level), and XVT and UIM/X (compatibility level).

Objectivity/DB is resold by Digital Equipment Corporation as DEC Object/DB,
providing a multi-billion-dollar second source vendor.  Over 50,000 end users
are licensed in production use, with applications including real-time
telecommunications, aerospace, defense, case, CAD/CAM, CIM, manufacturing, oil
& gas, process control, transportation, multi-media, case, document management,
financial analysis, and corporate information management.  Platform support
includes all Sun, all DEC (including VMS, alpha, OSF-1), HP/9000 series (both
68xxx and PA-RISC), IBM RS/6000, NCR 3300, SGI, Windows 3.1, and Windows NT.

On Schema Evolution (from original survey):
In the just-released Version 2.0 (shipping Oct 92), schema evolution
is supported via dynamic versioning of type-defining objects [ie.
class versions -- SMC], and via a step-by-step approach that allows
conversion of instance data via user-provided conversion methods.
Also, a full dynamic type manager interface is available for doing
fancier things.

Contact:

Drew Wade
Objectivity, Inc.
800 El Camino Real
Menlo Park, CA  94025 USA
drew@objy.com
1(415)688-8000 voice
1(415)325-0939 fax
admin ass't:  Vickie Clements (vickie@objy.com)
information:  info@objy.com


> ObjectStore Object Database System From Object Design, Inc.


Product Description	

ObjectStore[TM] is a high performance ODBMS designed for ease of use in
development of sophisticated applications using object-oriented
development techniques.  It offers a tightly-integrated language
interface to a complete set of traditional DBMS features including
persistence, transaction management (concurrency control and
recovery), distributed access, associative queries over large amounts
of data, and database administration utilities.  ObjectStore's data
management facilities combined with popular development tools create a
high productivity development environment for implementing
object-oriented applications.

Key Features:

   - Transparent interface designed for popular C and C++ programming
     environments. 

   - Concurrent access to large amounts of persistent data. 

   - Distribution of objects over networks using a variety of popular
     network protocols.

   - Access to persistent data at the same speed as transient data.

   - Extensible data modeling capabilities for applications requiring
     complex data structures.

   - Easy migration path for existing C and C++ applications.

   - Class libraries for version and configuration management.

   - Class libraries for managing collections of objects.

   - A fully distributed (multi-server/multi-database) ad hoc query
     capability.

   - An interactive Browser to inspect objects and object
     descriptions.

   - Interoperable with ObjectStore servers running on other operating
     systems and hardware environments.

   - Complete schema evolution for an application's metadata and
     existing object instances.

   - Full online backup for continuous processing environments.

   - Meta object protocol with programmatic access to schema
     information. 

   - Dynamic Type creation for extending existing class definitions
     during program execution.


System View

ObjectStore supports cooperative access through its flexible
client/server software architecture, which allows users to make the
take advantage of the computational power that exists on the desktop.
ObjectStore's client/server implementation allows one server to
support many client workstations, each workstation to simultaneously
access multiple databases on many servers, and a server to be resident
on the same machine as a client.  ObjectStore's distributed
architecture supports several network environments for
interoperability among popular workstations and PC's and includes
support for TCP/IP, Novell IPX/SPX, other popular network protocols.


Application Interface

Access to ObjectStore is provided through a library based application
interface compatible with popular C and C++ compilers and programming
environments.  The ObjectStore application interface provides support
for C++ compilers -- such as those from workstation suppliers -- and
development environments from independent software vendors such as
Visual C++ from Microsoft, ObjectCenter from CenterLine Software, Inc.
and Energize from Lucid, Inc.  The application interface provides
powerful high-level function calls which enable the programmer to
create multi-user application which share large amounts of data.
These functions include:

   - Relationship Management
   - Version Management
   - Collection Management
   - Storage Management
   - Associative Queries
   - Object Iteration
   - Transaction Management 
   - Index Management
   - Clustering

Applications developed using ObjectStore library calls are
source-level compatible with ObjectStore applications developed for
other operating systems on other hardware platforms.

Platforms

ObjectStore is available on the following major platforms:
	
Unix Workstation Platforms

   - DEC MIPS Ultrix 
   - HP 700 Series HP-UX
   - HP 800 Series HP-UX 
   - IBM RS/6000 AIX
   - NCR 3000 
   - Olivetti LSX-50xx SVR4
   - Silicon Graphics IRIX 5.x
   - SunSoft Intel Solaris 2
   - SunSoft SPARC Solaris 1 SunOS 4
   - SunSoft SPARC Solaris 2 SunOS 5
   - Univel UnixWare

PC Platforms

   - Windows 3.1 (Win32s)
   - Windows NT (Intel)
   - OS/2 Release 2.0 and 2.1
   - Novell Netware Release 3.1 and 4.0 (server only)

The Company

ObjectStore[TM], Object Design's object-oriented database management
system, is currently used by more than 500 companies.  The company
targets end-user customers in major corporations and governments
through its direct sales force, and also focuses on independent
software developers, systems integrators and international
distributors to license its products.  In the systems software market,
Object Design has already licensed object storage technology to
SunSoft that will be embedded in the Solaris(r) (Project DOE)
environment.  Through this relationship Hewlett Packard also has rights
to the technology for use in HP/UX(r) (DOMF).

In April 1993, IBM Corporation became one of the company's leading
investors as part of a far-reaching strategic relationship involving
an equity investment, internal use and joint development agreements.

Object Design's Support Services group provides extensive support
services tailored to meet each customer's specific needs.  A regularly
scheduled series of training courses are offered, either at Object
Design facilities across North America, select international locations
or at customer sites, that reduce the learning curve for
object-oriented development.  The training courses include
"Introduction to Object-Oriented Programming and C++," "Designing
Object-Oriented Database Applications" and "Building High Performance
Applications with ObjectStore."  To further assist its customers,
Object Design makes its team of experts available to provide a wide
range of training, support and consulting services.

The company distributes its products through a direct sales and
telesales force in the North America, wholly-owned subsidiaries in
Australia (61-2-212-2766), Germany (49-611-39707-0), Japan
(81-3-3251-2882), and the United Kingdom (44-793-486111) as well as
through distributors in 15 countries.

The US headquarters are located in Burlington, Mass., the company
maintains regional or district offices in Atlanta; Chicago; Los
Angeles; New York; Portland; San Mateo, Calif.; and Washington, DC.

You may obtain information about ObjectStore or Object Design by any
of the following methods:

Address:

	Object Design, Inc.
	25 Burlington Mall Road
	Burlington, MA 01803

Telephone:

	Call toll-free 1-800-962-9620 in the USA or 617-674-5000 and
	ask for telemarketing.

Internet:

	Send email requests to info@odi.com.

	You can also download public information from our ftp server,
	ftp.odi.com (198.3.16.17).  Login as "anonymous", and use your
	mail address (username@site) as your password.  Major files of
	interest include:

	/pub/docs/techsum-net.ps    Technical Summary (postscript)
	/pub/docs/techsum.net	    Technical Summary (FrameMaker)
	/pub/oo7/results.ps	    OO7 Benchmark Results (postscript)

CompuServe:

	GO ODIFORUM, section 1.

International distributors contact information follows:

GERMANY

Patzschke + Rasp 
Software und Systeme
Bierstadter StraBe 7
D-65189 Wiesbaden Germany
011-49-611-17-310
011-49-611-17-3131 FAX

SPAIN, PORTUGAL

DyM
Diseno y Metodologia, SA
Francisco Gervas, 17, 5.0 G
Madrid, Spain 28020011-34-1-571-3123 or 571-3880
011-34-1-571-3942 FAX


SWEDEN, NORWAY, DENMARK, FINLAND

ENEA Data
Box 4150
S-203 12 Malmo
Sweden
011-46-40-70930
011-46-40-230240 FAX

SWITZERLAND

UNISYS (Schweiz) AG
Zucherstrasse 59-61
A-8800 Thalwill
Switzerland
011-411-723-3366
011-411-720-3737 FAX

ITALY

AIS S.p.a.
Via Rombon, 11-20134
Milano, Italy
011-39-226-40197
011-39-2 2641-0744 FAX

ISRAEL

TACTLINE, Ltd.
Beit-Oved 76800
Israel
011-972-840-4898
011-972-840-6927 FAX

JAPAN

Mitsui Engineering & Shipbuilding Co., Ltd.(MES)
6-4 ,Tsukiji 5-chome
Chuo-ku,Tokyo, 104 
011-81-3-3544-3355
011-81-3-3544-3036FAX

Stan Systems Corporation
Sumitomo Higashi Shinbashi Bldg.
1-1-11 Hamamatsucho
Minato-Ku, Tokyo 105 Japan
011-81-3-5472-5515
011-81-3-5472-5544 FAX


System Network Corporation:
Tohto Bldg. 6F
5-1-4 Toranomon, Minato-ku, 
Tokyo  105 Japan
Phone#:   +81-3-3437-4081
Fax#:       +81-3-3437-4060

Toyo Information Systems Co.,Ltd.
Nihonbashi Toyo Bldg. 4F
2-7-24 Nihonbashi
Chuo-Ku, Tokyo 103 Japan
011-81-3-3271-7681
011-81-3-3271-7685 FAX

TAIWAN, R.O.C.

Exartech International Corp 
10F, 82, Chung-Cheng S. RD.
Sanchung, Taipei, Taiwan, ROC
011-886-2-977-6828
011-886-2-977-6829 FAX

SOUTH AFRICA

Realtime Computer Services (Pty) Ltd.
4th Floor, 35 Wale Street
Cape Town 8001
South Africa
011 27 21 24 4350
011 27 21 221507 FAX

        
> Ontos [formerly VBase] (Ontologic)

Entry on schema evolution only:

*Ontos provides schema evolution. It allows any class to be modified.
*The major drawback is that data does not migrate ie., instances are
*not modified to adopt to the new class definition. So schema changes
*can be done only on classes that do not contain instances and do not
*have sub classes that contain instances.
*[h.subramanian@trl.OZ.AU]

*As a system for experiments, we are currently using ONTOS from
*Ontologic Inc.  Unfortunately, there is no transparent concept of
*schema evolution for populated database. Thus, we still investigate
*how it works.

ONTOS has a version of ONTOS for OS/2.  Approximately $11K. Others I don't know


> Odapter/OpenODB (Hewlett-Packard)

Odapter is HP's new object/relational adapter which
enables object-oriented developers to share a common
object model stored in the ORACLE7 relational database
management system (RDBMS).  Odapter is also available with
HP's ALLBASE/SQL RDBMS.  The combination of Odapter
and ALLBASE/SQL is called OpenODB.

Odapter 
Technical Data 
Object/Relational Adapter 
  
A Productivity Tool for Scalable Object-Oriented 
Applications 
  
Odapter is a tool for developers writing scalable 
object-oriented applications requiring the 
integration of new objects and legacy information. 
Odapter is valuable because it: 
* accelerates application development 
* reduces the cost of keeping applications current 
* enables applications to scale 
  
Odapter delivers the productivity of object 
technology while adhering to your data management 
standards. 
  
Consider Odapter if you need to be able to do one 
or more of the following: 
* develop object-oriented applications and 
store objects in a relational database 
* easily access legacy data and existing 
applications from your new system 
* support a large number of end-users who will 
be simultaneously accessing information 
* store large amounts of  complex information 
  
The following are examples of applications well- 
suited for Odapter: 
* a customer billing application written in 
Smalltalk combining data stored in DB2 with new 
objects. (Telecommunications) 
* a network management application written in C 
using Odapter as the object manager, able to scale 
to millions of objects (Manufacturing) 
* a complex Oil and Gas industry standard model 
automatically generated from an Express analysis 
and design tool. 
(Oil & Gas) 
* a medical application using Odapter to 
combine heterogeneous components of patient 
records. (Healthcare) 
  
Odapter provides authorized access to sharable 
objects, including existing data and business 
processes. By bringing object-oriented capabilities 
to heterogeneous systems environments, Odapter 
delivers increased functionality while leveraging 
the stability of existing RDBMSs and legacy 
information. 
  
Odapter Object Model 
  
The Odapter object model is based on three key 
concepts - objects, types and functions. 
* Objects are a combination of data and 
behavior (functions). Figure 2 is an example of an 
object. 
* Types are dynamic templates allowing you to 
group together similar components or objects. 
* Functions define the attributes, 
relationships and behavior of objects. Odapter 
supports four types of user-defined functions: 
  
Stored functions define attributes and 
relationships that are stored in the database. In 
Figure 2, flightno is a stored function. The 
functions aircraft and crew are also stored 
functions with user-defined results. 
  
SQL-based functions allow you to access existing 
relational tables with Odapter's object-oriented 
model. In Figure 2, citypair is an SQL-based 
function accessing values from an existing 
relational table. 
  
OSQL-based functions define attributes and 
relationships that are derived or calculated with 
OSQL statements. In Figure 2, delay and depart are 
OSQL-based functions. Delay calculates changes in 
arrival and departure times based upon events that 
disrupt the schedule; depart handles the update of 
functions related to departure and transitions the 
flight from OnGround to InAir. 
  
External functions are a reference to code or data 
stored outside of Odapter. In Figure 2, cancel is 
an external function that executes code outside of 
Odapter to free up resources no longer assigned to 
the flight. 
  
Odapter Language 
  
The Odapter language can be combined with functions 
implemented in C++, Smalltalk or C. You create and 
manipulate objects, types and functions using 
Odapter's object-oriented structured query language 
(OSQL). OSQL is a functional language that is a 
semantic superset of SQL, the structured query 
language for relational databases. OSQL is a 
computationally complete language with statements 
allowing you to define and manipulate information 
in your Odapter enhanced relational database, 
specify authorization for individuals or groups, 
define transactions, embed program logic within 
functions, and administer the database. 
  
OSQL includes programming flow statements, such as 
IF/THEN/ELSE, FOR and WHILE. This procedural 
language allows Odapter functions to model complex 
behavior, simplifying your application code. By 
decoupling behavior from the applications, multiple 
applications can share information with benefits 
such as consistency, security and integrity. See 
Table 5 for a list of all OSQL statements. 
  
Odapter Object Storage 
  
Odapter objects are stored in the developer's 
choice of relational databases. Odapter interfaces 
to the underlying RDBMS through an SQL command 
interface. Currently, developers can choose to 
store their objects in ORACLE7 or HP ALLBASE/SQL. 
  
The choice of RDBMS is made when a particular 
database is created. The users are only limited by 
the number of Odapter concurrent user licenses 
purchased. This flexibility allows database 
administrators to continue using their existing 
administration procedures and keeps the group from 
having to choose yet another database management 
system. 
  
During the initial development of an application, 
developers can make rapid progress without 
knowledge of the underlying relational database. 
Optimization of the objects and how they are stored 
in the underlying relational database is best 
done during the deployment phase. 
  
Odapter Development Environments 
  
Odapter developers have a choice of development 
environments. Whether Smalltalk, C++ or more 
traditional C and C-linkable languages are used, 
Odapter enables object storage in a scalable and 
robust relational database. In fact, objects can be 
shared between different applications, allowing 
different projects to employ the best tools for the 
job! 
  
Odapter and Smalltalk 
  
Odapter provides Smalltalk developers with 
transparent access to information stored in the 
underlying relational database. 
  
Odapter's Smalltalk Class Builder utility 
automatically generates ParcPlace Smalltalk 
compatible classes and methods based upon an 
Odapter object model. The developer can select 
specific Odapter types and functions, resulting in 
a corresponding set of Smalltalk classes and 
methods. Once the Smalltalk schema is generated, 
the Smalltalk developer can transparently access 
the underlying relational database, as shown in 
Figure 3. 
  
printFlight 
   |allFlightObjects| 
   allFlightObject:=Flight allObjects. 
   AllFlightObjects do: [:aFlight| 
      Transcript show :aFlight flightno value; cr]. 
Figure 3 
  
  
Figure 3 shows how to access the flight objects 
shown in Figure 2 through Smalltalk. This example 
retrieves all flight object identifiers and prints 
the flight# for each one of the flight objects. 
  
All Smalltalk classes and methods which result in 
the access of Odapter structures are italicized. 
Flight is a Smalltalk class that corresponds to the 
Odapter type Flight. The Smalltalk methods 
allObjects and flightno map to Odapter calls that 
access data from the relational database storage 
manager. 
  
Odapter and C++ 
  
For C++ developers, once the corresponding C++ 
model is created, Odapter provides the abilility to 
manage C++ objects stored in the underlying 
relational database, as shown in Figure 4. 
  
void printFlight() 
{ 
   int i; 
   ODBType Flight ("Flight"); 
   ODBBag allFlights=Flight.allObjects(); 
   ODBFunc flightno("flighno"); 
  
   for(i=0;i<allFlights.size();i++){ 
      cout<<flightno(allFlights[i]); 
   } 
} 
Figure 4 
  
Figure 4 shows a C++ version of the Smalltalk 
example in Figure 3. That is, Figure 4 shows how to 
access all the flight objects shown in Figure 2 and 
prints the flight number associated with each 
flight object. 
  
The Odapter C++ library includes a set of classes 
(e.g. ODBType, ODBClass, ODBFunc, ODBBag) and 
corresponding member functions (e.g. allObjects). 
User-defined classes (Flight) and member functions 
(flightno) are also shown. In Figure 4, all Odapter 
calls are in italics. 
  
Odapter and C-linkable Languages 
  
For traditional developers using C, or any 
languages linkable with C, the object-oriented 
features are provided by Odapter. Odapter objects 
are manipulated by embedding OSQL statements in the 
C program, similar to the db.execosql call shown in 
Figure 4. In addition, the C interface requires the 
conversion of data types from Odapter to C. 
  
By embedding Odapter calls in a C program, the C 
language becomes object-oriented. 
  
Features and Benefits 
  
Accelerates Application Development 
  
Odapter accelerates application development by 
integrating with familiar development environments 
and by providing a robust object-oriented model. 
  
Odapter's choice of development environments 
includes those which support the Smalltalk, C++ and 
C languages. 
  
Odapter's robust object model enables the 
integration of legacy data and business processes 
in the context of one sharable business object 
model, shielding the developer from the data 
storage complexity. 
  
The following Odapter features accelerate 
application development: 
  
Automatic mapping of objects to relational 
databases 
The application developer is shielded from the task 
of converting complex object models to two 
dimensional relational tables. 
  
Smalltalk Class Builder 
Once an OSQL schema is created, whether using 
available analysis and design tools or manually, 
Odapter's Smalltalk Class Builder can generate 
corresponding Smalltalk classes and methods. The 
developer can select the relevent part of the 
Odapter schema to generate. As the Odapter object 
model changes, developers can also incrementally 
update the Smalltalk classes. 
  
Object Identity 
Each object manipulated by Odapter has a unique, 
system-provided handle called an object identifier 
(OID). OIDs eliminate the need for creating unique 
keys to identify stored information. Additionally, 
OIDs reduce duplication of information when several 
attributes would be needed to uniquely identify 
information in the database. OIDs are also a 
powerful way to tune data access and performance. 
  
Inheritance 
Odapter objects can use functions defined on parent 
types in the type hierarchy. For example, as shown 
in Figure 5, a subtype of Employee called Pilot 
could inherit functions from Employee like hire and 
name, while defining unique functions like 
hoursflown and status. 
  
  
Multiple Inheritance 
Functions defined on a type can be inherited by one 
or more subtypes. In Figure 5, functions accessible 
by the type ManagingPilot are inherited from its 
parents, namely all functions defined on Employee, 
Pilot and Manager. By inheriting rather than 
redefining functions, you can easily add 
functionality to your application. 
  
OSQL 
If you already know SQL, you can quickly be 
productive using Odapter's OSQL. Both query 
languages are set-based, that is they retrieve sets 
of information based upon queries. Thus, OSQL does 
not require users to navigate through the database 
chasing pointers or object references. 
  
Encapsulation 
Odapter protects end-user applications from changes 
to the internal definition of objects. Since 
Odapter only allows access to data through 
functions with well defined arguments and results, 
your applications are protected from changes to the 
function body and you have control over how 
information is used. 
  
Aggregate Types 
Aggregates are used to represent collections, such 
as crew members (maybe several pilots, flight 
attendants and a mechanic) for a particular flight, 
or the employees reporting to a particular manager. 
Aggregates are not required to have a predetermined 
size. Odapter manages the memory associated with 
aggregates, relieving your application of this 
work. 
  
User-defined Data Types 
You can construct user-defined data types in 
Odapter, such as a type called Flight, Employee or 
Aircraft, as shown in Figure 6. Functions defined 
on these types can manipulate data stored within 
the current object, within other related objects or 
outside of Odapter. User-defined types maximize 
flexibility and lead to more manageable, clearer 
code. 
  
Complex Objects 
With Odapter you can construct complex objects from 
simpler objects. For example, Figure 6 shows the 
relationships between the types Flight, Aircraft 
and Employee.  Complex objects relieve applications 
from managing such relationships. 
  
  
Reduces the Cost of Keeping Applications Current 
  
Odapter supports a server-centric business model 
which means the business logic and associated data 
is sharable by multiple applications. By separating 
out business objects (data and processes), from the 
application development environment, your company's 
business can be modified without impacting the 
applications. These changes can be immediately 
leveraged by the calling applications without 
recompilation 
  
The following features make applications easier to 
keep current: 
  
External Functions 
Using external functions, you can access 
distributed data and code stored outside of the 
relational database used by Odapter for storage, 
regardless of location or data format. Examples of 
external data sources include IMS, DB2 as well as 
custom databases and flat files. Odapter acts as an 
integrator so your application can manipulate 
information as recognizable business objects. This 
not only allows transparent migration of data over 
time, it accelerates developer productivity by 
hiding the complexity of a diverse data storage 
environment. 
  
Overloaded Functions 
Multiple functions can have the same name with 
different implementations. An application calls a 
function (e.g. salary) and Odapter determines at 
run-time which code (salary for Manager or salary 
for Pilot) to execute, based upon the type of the 
object against which the function is invoked. The 
application is simplified since the conditional 
logic for determining which function to execute is 
now in Odapter. 
  
Dynamic Schema Modification 
Odapter object models can be modified while the 
database is running. Developers can add new 
functions and types, as well as change the 
implementation of functions. This capability is 
particularly valuable to applications with high 
availability requirements. 
  
Dynamic Typing 
You can change the type of an object without 
destroying and recreating the object. An object can 
also belong to more than one type. As shown in 
Figure 7, once a Flight leaves the ground, it would 
change state from being an OnGround to an InAir 
Flight. OnGround functions such as maintenancecrew 
and availableseats would no longer be needed. An 
InAir object would need certain functions like 
bestroute and delay to calculate the most time 
efficient route and to calculate a projected delay 
based current weather conditions. Dynamic Typing 
allows you to represent an object in Odapter which 
transforms itself over time and, therefore, changes 
capabilities and attributes. 
  
Late Binding 
Odapter supports functions that are resolved at 
runtime. Late binding allows you more flexibility 
in application development and gives you the full 
power of overloaded functions as described earlier. 
On the other hand, Odapter will precompile or do 
early binding to improve performance. However, when 
types and functions changes at runtime, impacting a 
particular function, late binding occurs and the 
application automatically takes advantage of the 
new implementation of the function when it is 
called. 
  
Referential Integrity 
Since Odapter manages the relationships between 
objects, it can manage referential integrity on 
your behalf. That is, if an object referenced by 
other objects is deleted, the system removes all 
dependencies.  Your application code is simplified 
since Odapter is able to keep the logical business 
model intact automatically. 
  
Multimedia 
Odapter allows you to manage large, unformatted 
data in binary format and treat that data as an 
attribute of an object. For example, you may want 
to create a function called diagram to show the 
sections and seating for an Aircraft object. 
Multimedia information can include graphics, images 
and voice. You can also define functions in Odapter 
to manipulate this multimedia information. For 
example, you can create a function called showexits 
that adds information to the diagram. Thus, various 
applications can share these complex functions. 
  
Import Facility 
The Odapter Import facility allows developers to 
update existing Odapter functions with data from 
external files such as spreadsheets or other 
databases. This is an object-oriented version of 
the relational "bulk load" functionality. 
  
Enables Applications to Scale 
  
Odapter makes applications more scalable by storing 
objects in a choice of RDBMSs, like ORACLE7. As a 
result, applications can access large volumes of 
data, be used by a large numbers of users, and 
perform on-line backup. In addition, Odapter 
protects against unauthorized access from users in 
a distributed environment. 
  
Odapter, with the help of the underlying relational 
storage manager, ensures the integrity and security 
of your data while maximizing the availability of 
that data for end users. 
  
The following features enable applications to 
scale: 
  
Indexing 
Indexes are automatically generated when you create 
types and functions in Odapter. You can also define 
your own indexes using B-tree and hashing 
algorithms. Indexes make end user access to 
information faster. 
  
Clustering 
Related functions and objects which have the same 
value for a function can be stored close to each 
other. This ability to influence how objects are 
stored allows you to tune the performance of the 
database based on how the information will be 
accessed by applications. 
  
Transaction Management 
Odapter ensures the logical and physical integrity 
of your database by giving you complete control 
over the unit of work to be performed within a 
single transaction. With this control, you can save 
or rollback a transaction (throw away temporary 
work) at your discretion. Savepoints are also 
supported so that you can rollback parts of a 
transaction. 
  
Multi-user Concurrency Control 
Odapter is designed to support hundreds of users 
accessing the same information while guaranteeing 
the integrity of that information. 
  
Authorization 
You can control access to an Odapter enhanced 
database at the database and function levels based 
on individuals or groups of users. For example, 
authorization statements can provide read access to 
a large group of users while limiting write or 
delete access. 
  
High Availability 
Because Odapter actually stores objects in an 
RDBMS, Odapter can leverage RDBMS features to 
maximize the availability of your information by 
providing: 
* on-line backup of the database, to backup the 
database while it is being accessed 
* dual logging, to ensure the integrity of your 
log file 
* switch log, to automatically switch to a 
second log file if the original log file becomes 
full 
* dynamic file expansion, to expand the size of 
your database as it becomes full 
  
Odapter will also take advantage of other available 
features of the underlying relational database 
management system such as replication or "warm 
standby". 
  
Recovery 
Odapter uses the robust logging and recovery 
facilities of the RDBMS. In case of a failure, you 
can rollback work or perform rollforward recovery 
to a particular time, using the log file to 
recreate saved work. 
  
Odapter  Software Components 
  
Odapter uses a client/server architecture, enabling 
you to efficiently utilize your computing power. 
Clients use the object application call interface 
(OACI) to communicate with the server over the 
network. The clients and server components can also 
reside on the same machine. 

From ankh.iia.org!babbage.ece.uc.edu!news.kei.com!yeshua.marcam.com!news.mathworks.com!hookup!bloom-beacon.mit.edu!senator-bedfellow.mit.edu!faqserv Wed Nov 23 21:57:35 1994
Path: ankh.iia.org!babbage.ece.uc.edu!news.kei.com!yeshua.marcam.com!news.mathworks.com!hookup!bloom-beacon.mit.edu!senator-bedfellow.mit.edu!faqserv
From: Bob Hathaway <rjh@geodesic.com>
Newsgroups: comp.object,comp.answers,news.answers
Subject: Comp.Object FAQ Version 1.0.7 (10-27) Part 6/10
Supersedes: <object-faq/part6_782395740@rtfm.mit.edu>
Followup-To: comp.object
Date: 29 Oct 1994 11:42:24 GMT
Organization: Geodesic Systems
Lines: 1557
Approved: news-answers-request@MIT.Edu
Distribution: world
Expires: 12 Dec 1994 11:40:18 GMT
Message-ID: <object-faq/part6_783430818@rtfm.mit.edu>
References: <object-faq/part5_783430818@rtfm.mit.edu>
NNTP-Posting-Host: bloom-picayune.mit.edu
Summary: Frequently Asked Questions (FAQ) List and Available Systems For Object-Oriented Technology
X-Last-Updated: 1994/10/28
Originator: faqserv@bloom-picayune.MIT.EDU
Xref: ankh.iia.org comp.object:7431 comp.answers:4421 news.answers:13680

Archive-name: object-faq/part6
Last-Modified: 10/27/94
Version: 1.0.7

Odapter is bundled with the following client and 
server components, as shown in Figure 8: 
  
Client Components 
  
* Interactive Object-Oriented SQL (IOSQL) 
This interface allows you to interactively enter 
all Object-oriented SQL (OSQL) statements, 
facilitating rapid prototyping and testing. IOSQL 
provides query, administration and editing 
capabilities. 
  
* Graphical Browser (GOSQL) 
The Graphical Browser is a tool that allows you to 
graphically explore your database schema and 
contents, and execute any OSQL statement. This tool 
is designed to assist application developers by 
making it easier to view and manipulate your object 
model stored in Odapter. 
  
* Windows OSQL (WINOSQL) 
This PC-based interactive interface to OSQL allows 
you to interactively enter all OSQL statements. 
  
* Object Application Call Interfaces (OACI) 
Odapter provides client interface libraries for the 
Smalltalk and C++ object-oriented programming 
languages, allowing these languages to be tightly 
coupled with Odapter. 
  
You can also write Odapter applications using any 
programming language that can be linked with C 
(such as Ada, COBOL, FORTRAN and Pascal). The 
programmatic interface is similar to a "Dynamic 
SQL" interface, and passes strings representing 
OSQL statements to the Odapter server. No 
preprocessors are required. 
  
Server Components 
  
* Odapter Object Manager 
The Object Manager executes OSQL calls made by the 
Odapter clients. The Object Manager processes 
requests, and accesses data and code stored in the 
Odapter enhanced relational data storage manager or 
passes the request to a subsystem outside of 
Odapter using Odapter External Functions. 
  
* External Functions 
External functions allow you to access data and 
code stored outside of Odapter, regardless of data 
format or location. External functions can 
automatically link to specific data sources using 
the Odapter EDA-Objects class library and the 
EDA/SQL product from Information Builder's, Inc. 
(IBI). External functions can also be implemented 
by you as subroutines written in general-purpose 
programming languages and compiled outside of 
Odapter. External functions can be called by any 
OSQL statement, allowing you to manipulate this 
remote data and application code like any other 
Odapter object. For example, Figure 9 shows how 
Odapter integrates diverse heterogeneous 
information in an Oil and Gas environment. 
  
* EDA-Objects 
HP and IBI have jointly developed an external 
function library called EDA-Objects. Coupled with 
IBI's EDA/SQL product, EDA-Objects provides 
connections to over 50 commonly used databases on 
35 different platforms. The external function 
library to connect to EDA/SQL is shipped with 
Odapter; however, you must purchase other EDA/SQL 
components from IBI directly to use the product. 
EDA-Objects is one way to integrate external data 
from multiple servers into a single business model 
managed by Odapter. This is done without physically 
moving the data or changing the applications which 
are dependent on the data in its current form. 
  
Additional Products 
  
* Development Environments and Tools 
Odapter allows you to use your favorite development 
environments for application development. Some 
tools are more tightly coupled with Odapter than 
others. HP has recruited tools partners to address 
all aspects of application development including 
application design and analysis, data model 
manipulation, fourth generation language 
application development, report writing and legacy 
data access. 
  
* Relational Database 
Odapter uses a relational database as its storage 
manager for the storage of Odapter objects. The 
relational database performs physical file 
management and database functions such as multi- 
user concurrency, transaction management, and 
recovery. The relational database allows you to 
perform on-line backup and recovery, manage 
physical distribution of files, maximize 
availability and change database parameters. 
  
* COMPASS 
COMPASS is a consulting product which includes the 
Hewlett-Packard implementation of the 
Petrotechnical Open Software Corporation (POSC) 
Software Integration Platform (SIP) specification. 
The SIP specification defines a data model and an 
interface which allow users and applications to 
access exploration and production data, independent 
of the database engine technology. 
  
The COMPASS package is an add-on to Odapter and 
includes: 
* COMPASS specific consulting/training (1 day) 
* POSC-based DAE interface library and documentation 
* Interactive user interface called ixpres 
* Archived copy of a pre-loaded Odapter 
enhanced database with sample reference data 
* Scripts for building a POSC-based Odapter 
enhanced database 
* Contributed software library (data loaders, 
demonstration programs) 
  
COMPASS gives developers a 'jump start' on building 
applications focused on petroleum exploration and 
production. Other industries will find COMPASS an 
inexpensive and useful approach for building 
geographic information systems (GIS) and other 
applications which can re-use of the cartography 
(mapmaking) and geometric objects defined in the 
model. 
  
POSC is a not-for profit organization created to 
lower the costs associated with accessing and 
integrating exploration and production data for the 
oil and gas industry. 
  
System Environment 
  
Hardware       Operating    Memory      Disk Space 
platform       System       (minimum)   (minimum)* 
  
HP 9000 S700   HP-UX 8.07   32MB        10MB + 
S800           or later                 necessary 
                                        swap space 
  
Sun            Solaris 1.0  32MB        10MB + 
               (SunOS 4.3);             necessary 
               Solaris 2.0              swap space 
               (SunOS 5.2) 
  
IBM RS/6000    AIX 3.2.5    32MB        10MB + 
                                        necessary 
                                        swap space 
  
X Terminal                  6MB         none 
  
IBM PC         DOS 5.0,     4MB         1MB 
compatible     MS-Windows 
               3.1 or later 
Table 1:  Odapter Client Environments 
  
* Swap space needed will depend on the complexity 
of the application and the number of concurrent 
users. Swap space will significantly increase the 
necessary disc space. 
  
Hardware       Operating    Memory      Disk Space 
platform       System       (minimum)   (minimum)* 
  
HP 9000 S700   HP-UX 9.0    64MB        15MB + 
S800           or later                 necessary 
                                        swap space 
Table 2:  Odapter Server Environment 
  
* Additional memory may be required. Swap space 
will significantly increase the necessary disc 
space. The amount of memory and swap space depends 
on the complexity of the application and the number 
of concurrent users. 
  
Odapter Software Requirements 
  
To use Odapter, you will need one of the RDBMSs 
listed below, TCP/IP transport and ARPA Berkeley 
Services (for Unix systems), HP LAN Manager or 
Microsoft LAN Manager (for the PC client) software. 
To use the Odapter Graphical Browser, you will need 
X11 X-Window support. 
  
Table 3: Relational Databases 
  
            Version          Memory      Disk Space 
                             (minimum)   (minimum) 
  
ORACLE7     7.0.13 or later  refer to    refer to 
            with "procedural Oracle      Oracle 
            option" (PL/     manuals     manuals 
            SQL), Pro*C, 
            SQL*Plus & Oracle 
            common libraries and 
            utilities 
  
ALLBASE/SQL shipped with     64MB A/SQL  10MB 
            OpenODB          and Odapter 
  
* ALLBASE/SQL is included with the Odapter 
software. The combination of Odapter and 
ALLBASE/SQL is known as OpenODB. 
  
  
Ordering Information 
  
Software, training, consulting and support can be 
purchased separately, as well as in bundles. 
Pricing for the stand-alone software is based on 
the number of user processes accessing a single 
database server at the same time. Any number of 
user licenses can be ordered. You must also order 
the Odapter Media & Manuals product when ordering 
the Developer's Bundle or the Concurrent User 
License. HP standard support options are available 
for all Odapter license and media products. 
The OpenODB and Odapter products are sold together. 
OpenODB is the combination of Odapter and 
ALLBASE/SQL. You are only limited by the number of 
concurrent licenses purchased for Odapter. 
  
Product Number and Product Description 
  
B3767BB  Odapter/OpenODB Concurrent User License 
Software license only. Must order B3768BA to 
receive software and manuals. Must specify number 
of users. 
  
B3768BA  Odapter/OpenODB Media and Manuals  Must 
choose media option. Includes software and one set 
of manuals. Requires prior or concurrent purchase 
of software license. 
  
B2470BA  Odapter/OpenODB Developer's Bundle 
Includes 8 user software license, 5 days of on- 
your-site consulting, one year of on-line support 
and 2 passes to the Odapter/OpenODB Training Class. 
Must order B3768BA to receive software and manuals. 
  
B3179A  Odapter/OpenODB Evaluator's Bundle 
Includes a 40 user software license for 3 months, 
media, documentation, 3 months of on-line support, 
and 1 pass to the Odapter/OpenODB Training Class. 
  
B3184S  Odapter/OpenODB Training Class (5 days) 
  
B3185A  Odapter/OpenODB Reference Manuals  Includes 
the Odapter/OpenODB Reference Manual and the 
Odapter/OpenODB System Functions Manual. 
  
B3186A  Odapter/OpenODB Consulting  Customized 
consulting in any of the following areas: COMPASS, 
object-oriented analysis and design, schema design 
and review, authorization/security design and 
review, performance tuning, advanced usage, 
Odapter/OpenODB application development planning 
and review and implementation of access to legacy 
data sources. 
  
To order these products, please contact your local 
HP sales representative or one of the offices on 
the back page of this document. 
  
Table 5. Odapter Features 
  
OBJECT-ORIENTED FEATURES 
Aggregates (BAG, LIST, SET, TUPLE) 
Complex Objects 
Dynamic Schema Modification 
Dynamic Typing 
Encapsulation 
External Functions 
Functions (Stored Code or Methods) 
Late Binding 
Multiple Inheritance 
Object Identity (OID) 
Overloaded Functions 
Type (Class) Hierarchy 
User-defined Data Types 
Versioning Primitives 
  
CLASS LIBRARIES 
C++ 
EDA-Objects 
Smalltalk 
Softbench 
  
CLIENT INTERFACES 
Graphical Browser (GOSQL) 
Import 
Interactive OSQL 
Object Application Call Interfaces (OACI): 
  C++ 
  SmallTalk 
  C-linkable languages  (Ada, COBOL, FORTRAN, 
Pascal) 
Smalltalk Class Builder 
Windows OSQL 
  
OSQL STATEMENTS 
Add/Remove Type To/From Object 
Add/Remove User 
Begin/Commit/Rollback Work 
Call Function 
Change Owner 
Change Password 
Connect/Disconnect 
Create/Delete Function 
Create/Delete Index 
Create/Delete Object 
Create/Delete Type 
Create/Delete User/Group 
Declare/Delete variables 
Grant/Revoke 
If/Then/Else, While, For 
Implement/Modify Function 
Open/Fetch/Close Cursor 
Raise Error 
Security On/Off 
Savepoint 
Select 
Store 
Update 
  
PRIMITIVE DATA TYPES 
Binary 
Boolean 
Character 
Date 
Datetime 
Decimal 
Floating Point 
Integer 
Interval 
Small Integer 
Time 
  
Sales Offices 
For more information, call you local sales office 
listed in your telephone directory or an HP 
regional office listed below for the location of 
your nearest sales office. 
  
United States: 
1-800-637-7740, extension 8521 
  
Canada: 
Hewlett-Packard Ltd. 
6877 Goreway Drive 
Mississauga, Ontario L4V 1M8 
(416) 678-9430 
  
Japan: 
Yokogawa-Hewlett-Packard Ltd. 
15-7, Nishi Shinjuku 4 Chome 
Shinjuku-ku 
Tokyo 160, Japan 
(03) 5371-1351 
  
Latin America: 
Hewlett-Packard 
Latin American Region 
Headquarters 
5200 Blue Lagoon 
Suite 950 
Miami, FL 33126 
(305) 267-4220 
  
Australia New Zealand: 
Hewlett-Packard Australia Ltd. 
31-41 Joseph Street 
Blackburn, Victoria 3130 
Australia (A.C.N. 004 394 763) 
(03) 895 2805 
  
Asia Pacific: 
Hewlett-Packard Asia Ltd. 
22/F Bond Centre, West Tower 
89 Queensway 
Central, Hong Kong 
(852) 848-7777 
  
Europe/Africa/Middle East: 
Hewlett-Packard S.A. 
150, Route du Nant-d'Avril 
CH-1217 Meyrin 2 
Geneva, Switzerland 
(22) 780 81 11 
  
Technical information in this document is subject 
to change without notice. 
All brand and product names appearing herewith are 
registered trademarks or trademarks of their 
respective holders. 
  
` Copyright Hewlett-Packard Company 1994.  All 
rights reserved.  Reproduction , adaptation, or 
translation without prior written permission is 
prohibited except as allowed under the copyright 
law. 
Printed in USA 7/94 
5963-2045E


For more information, please send a message to 
odapter@cup.hp.com with the subject of "index" or
"help".  If you would like to speak with someone
in person, please leave a voice mail message at
the Odapter Support, Training and Consulting number,
(408) 447-5051 and someone will get back to you
as soon as possible.


> POET <Persistent Objects and Extended Database Technology>  (BKS Software)

C++ Language Support

o    tight semantic integration with C++
o    any C++ object or structure can be made persistent by adding the 
     persistent keyword
o    storing and reading a C++ object does not change its state or behavior
o    full support for C++ encapsulation, object identity,  inheritance, and 
     polymorphy
o    C++ pointers and references are automatically converted to database 
     references when storing objects
o    database references are automatically converted to C++ pointers and 
     references when reading objects
o    all database definition is done through a small extension to C++ 
     declaration syntax

Database Functionality
navigation, queries, sorting, indexes, single-user operation, multi-user
operation using client/server architecture, flexible locking for objects
and sets, nested transactions, watch & notify for objects and sets,
event handling, database size limited only by hard disk size

C++ Language Extensions
persistence, indexes, transient data elements in persistent classes, sets,
dependent objects

PTXX-Precompiler
automatically converts extended C++ class declarations into ANSI 2.0 code,
registers classes in the class dictionary, provides class versioning

Predefined C++ Classes
date, time, strings, and BLOBS (binary large objects)

Portability
all platforms are source-code compatible, any POET database may be read by
any computer full support for heterogeneous networks

Platforms
Available for MS-DOS / MS-Windows (Borland C++, Microsoft), 
OS/2 (Borland C++), Novell, Macintosh MPW, and various Unix 
systems, including NeXT (NeXTStep) and Sun OS (Sun C++).

How to Contact Us:
BKS has offices in Santa Clara, Hamburg, and Berlin.  Silicon 
River, Limited, is responsible for POET in the United Kingdom.  

Santa Clara:    (North America, Australia, Asia)

BKS Software
4633 Old Ironsides Drive  Suite 110
Santa Clara, CA 95054
Phone:  408 / 748 - 3403
Fax:    408 / 748 - 9060

Contact Person: jrobie@netmbx.netmbx.de (Jonathan Robie)


> Statice (Symbolics)

From: fischerm@darmstadt.gmd.de (Markus Fischer)
Newsgroups: comp.databases.object,comp.lang.lisp
Subject: Statice now runs on Unix
Date: 15 Jun 93 14:55:48 GMT

Hi there,

since I've never seen 'Symbolics' or 'Statice' in
comp.database.object, this might be interesting:

A few days ago, Symbolics announced the availability of a beta-
release of their ODBMS 'Statice' on Unix platforms. It is quite
powerful and tightly integrated within Common Lisp.
Currently, Symbolics and LUCID are supported.
People (like me) used to Symbolics' Genera development environment 
can continue to use Statice there (where it has been already
successfully employed in 'real world' applications)
and now also use it on Unix Workstations.  (Those are the cheaper
boxes, I guess). Both kinds of platforms can be freely intermixed
in a network.

Statice is based on standards of Lisp: CLOS and CLIM 
(Common Lisp Object System, resp. Common Lisp Interface Manager)

Here's the address of Symbolics in Germany; they're mostly 
responsible for Statice on Unix:

Symbolics Systemhaus GmbH
Mergenthalerallee 77
6236 Eschborn (til June 31)
65760 Eschborn (from July 1)
Tel. (49) 6196-47220, Fax (49) 6196-481116

Contact person is Dr. Thomas Neumann (TN@symbolics.de).

Also:

"Update Database Schema" brings an existing database into conformance
with a modified schema.  Changes are classified as either compatible
(lossless, i.e., completely information-preserving) or incompatible
(i.e., potentially information-losing in the current implementation).
Basically, any change is compatible except for the following:

    -- If an attribute's type changes, all such attributes extant
    are re-initialized (nulled out).  Note that Statice permits
    an attribute to be of type T, the universal type.  Such an
    attribute can then take on any value without schema
    modification or information loss.

    -- If a type's inheritance (list of parents) changes, the
    type must be deleted and re-created, losing all extant
    instances of that type. This is Statice's most serious
    current limitation.  The simplest workaround is to employ a
    database dumper/loader (either the one supplied by Symbolics
    or a customized one) to save the information elements and
    then reload them into the modified schema.

[Lawrence G Mayka <lgm@IExist.ATT.COM>]


> UniSQL

UniSQL offers a state-of-the-art suite of integrated object-oriented database
systems and application development products which can be used separately or
together to support complex development projects which use object-oriented
development techniques, integrate sophisticated multimedia data, and require
true multidatabase access to relational and object-oriented databases. The
UniSQL product suite includes:

        UniSQL/X Database Management System;
        UniSQL/M Multidatabase System; and
        UniSQL/4GE Application Development Environment
        User interfaces include: C++, C, Object SQL, SmallTalk, and ODBC
        Database interfaces include: Ingres, Oracle, Sybase, UniSQL/X, and EDA/SQL

UniSQL offers:

- A wide selection of user interfaces including C++, SmallTalk, C, Microsoft's
  ODBC, both embedded (static and dynamic) and interactive Object SQL, and UniSQL
  and 3rd-party development tools.

- Mission-critical database features such as a high-level query language
  (SQL/X), cost-based query optimization, automatic transaction management,
  automatic concurrency control, dynamic schema evolution, dynamic authorization,
  physical disk structuring options, and installation tuning parameters.

- The UniSQL Multimedia Framework which provides natural and uniform database
  system support for all types of large unstructured data objects. The Multimedia
  Framework also provides for seamless integration of multimedia devices such as
  fax machines, CD jukeboxes, satellite feeds, image compression boards, etc.

- The UniSQL/M Multidatabase System enables developers to manage a collection
  of multi-vendor databases -- Ingres, Oracle, Sybase, DB2, UniSQL/X, and others
  -- as a single federated database system with full object-oriented
  capabilities.

UniSQL has well over 150 customers around the world, the majority of which are
using UniSQL database products for mission-critical applications which require
object-oriented, multimedia, post-relational, and heterogeneous database
capabilities.

A typical UniSQL customer is a Fortune 500 company, a commercial software
developer, or government organization that is using UniSQL database products
to:

- support mission-critical application development projects which are being
  developed using object-oriented programming languages and development
  techniques,

- support applications which must integrate many different types of corporate
  data -- text and documents, tabular data, images and audio, engineering
  drawings, GIS data, procedural data (programs), etc. -- into a single
  application context.

- support the full object-oriented development paradigm using existing
  relational database systems such as Ingres, Oracle, Sybase, and DB2.

- logically integrate one or more relational and object-oriented databases to
  form a single, homogenized database server which supports both relational and
  object-oriented facilities.

In September 1992, UniSQL was selected by the Petrotechnical Open Software
Corporation (POSC) -- over more than 25 other industry vendors -- to provide
database technology which is being used by POSC in their development of a new
data management specification for the oil & gas industry. Also during 1992,
because of its powerful multimedia capabilities, UniSQL was selected by the MIT
AthenaMuse Consortium on multimedia as the consortium's multimedia database
system.

During the DB/EXPO '93 Conference and Exhibition, UniSQL was chosen in
competition with major industry database vendors as a finalist in the
``RealWare Awards''.  The ``RealWare Awards'' honor companies that have
had a major impact in the user community.

UniSQL was founded in May 1990 by Dr. Won Kim, President and CEO, delivering
the UniSQL/X DBMS in March of 1992. With its world-class database research and
architectural team, UniSQL has perfected what the database industry has sought
since the mid-1980s: a fully object-oriented data model that is a natural
conceptual outgrowth of the popular relational model. Both the UniSQL/X DBMS
and the UniSQL/M Multidatabase System represent the first of a powerful new
generation of client-server database systems that support the full
object-oriented paradigm yet retain all of the strengths and capabilities of
relational database systems including support for ANSI-standard SQL.

UniSQL currently has 45 employees and is privately owned and managed by Dr.
Kim. The company has secured long-term funding from NTT Data Communications
Systems Corp. (NTT Data), a $2 billion company, which is Japan's foremost
systems integrator and UniSQL's exclusive distributor in Japan.

For more information, contact:

        UniSQL, Inc.
        9390 Research Blvd., II-200
        Austin, Texas 78759-6544
        Tel.: 512/343-7297
        Tollfree: 800/451-DBMS
        Fax.: 512/343-7383

And:
From: jonh@unisql.UUCP (Jon Higby)
Newsgroups: comp.databases,comp.databases.theory,comp.databases.object,comp.object
Subject: Re: SQL3, Itasca, & UniSQL/X
Message-ID: <6143@unisql.UUCP>
Date: 10 Sep 93 14:26:04 GMT
References: <CD1Ln5.9G3@dcs.glasgow.ac.uk>
Organization: UniSQL, Inc., Austin, Texas, USA

>>...
For UniSQL/X, feel free to contact me (email, snail-mail or phone).

UniSQL/X is a SQL compliant database with Object Oriented extensions
(classes, inheritance, methods, etc).  We have an information packet
available which includes a white-paper on our OORDMS approach.

Jon Higby
Technical Services Consultant

UniSQL, Inc.
9390 Research II, Suite 200
Austin, Texas  78759-6544
(512) 343-7297

*****************************************************************************
Standard disclaimer ... All opinions expressed are my own and not of my 
                        employer.......................................
*****************************************************************************



> Versant (Versant Object Technology)

Versant is a client/server object database management system (ODBMS) targeted at
distributed, multi-user applications.  Versant runs on UNIX and PC platforms, 
including Sun, IBM, HP, DEC, SGI, Sequent, OS/2, with support for Windows NT is 
planned during 1993.

Versant provides transparent language interfaces from object-oriented 
programming languages such as C++ and Smalltalk.  Versant also supports a C API.

Versant is built with an object-level architecture, which means that operations 
are generally performed on the object (or group thereof) level.  Key Versant 
features include:

 Performance
 -----------

*  Object-level locking for fine granularity concurrency control
*  Server-based query processing to reduce network I/O
*  Dual caching to speed warm traversals
*  Dynamic space reclamation and reuse

 Distribution
 ------------

*  Immutable, logical object identifiers for data integrity
*  Object migration (transparent relocation across nodes)
*  Transparent cross-node references (distributed db)
*  Automatic two-phase commit

 Other
 -----

*  Schema evolution (online via lazy updates)
*  Standard workgroup features (e.g., versioning, checkin/out)
*  Detachable, personal databases
*  DBA utilities


Additional information available from

info@versant.com  (General information)
davek@versant.com (Dave Kellogg)

Versant Object Technology 
1380 Willow Road
Menlo Park, California  94025

415-329-7500 phone.
415-325-2380 fax.


On Schema Evolution (from original survey):
We support run-time schema evolution.  It uses a lazy scheme, so
schema operations are very fast.  Objects on disk may have an older
`storage class' and they will be updated to the new schema when they
are used.

In older releases schema evolution was allowed only on leaf classes
(those with no subclasses).  In our new release 2 (going to beta test
soon) you can do schema evolution on any class.

In the future we're working on more general view mechanisms so you can
see a subset of the attributes in memory, or some more complicated
transformation.  This goes together with support for multiple
compilers and multiple languages.

[Joe Keane <osc!jgk@amd.com>]

Also: 1-800-Versant




Other Models
------------

Research Systems
________________

> GRAS

--------------------------------------------------------------
GRAS - A Graph-Oriented Database System for SE Applications
Copyright (C) 1987-1993  Lehrstuhl Informatik III, RWTH Aachen
--------------------------------------------------------------

See the GNU Library General Public License for copyright details.

Contact Adresses:

    Dr. Andy Schuerr 
    Lehrstuhl fuer Informatik III,
    University of Technology Aachen (RWTH Aachen),
    Ahornstr. 55,
    D-5100 Aachen

Email to

    andy@i3.informatik.rwth-aachen.de

GRAS is a database system which has been designed according
to the requirements resulting from software engineering
applications. Software development environments are composed
of tools which operate on complex, highly structured data.
In order to model such data in a natural way, we have selected
attributed graphs as GRAS' underlying data model.

A first prototype of the GRAS (GRAph Storage) system - described
in /BL 85/ - was already realized in 1985. Since this time
gradually improving versions of the system have been used at
different sites within the software engineering projects
IPSEN /Na 90/, Rigi /MK 88/, MERLIN /DG 90/, and CADDY /EHH 89/.
Based on these experiences, almost all parts of the original
prototype have been redesigned and reimplemented.

Thus, nowadays a stable and efficiently working single-process
version of the system GRAS with interfaces for the programming
languages Modula-2 and C is available as free software for Sun
workstations (the GRAS system itself is implemented in Modula-2
and consists of many layers which might be reusable for the
implementation of other systems):

  Via anonymous ftp from ftp.informatik.rwth-aachen.de
  in directory /pub/unix/GRAS in file gras.<version-no>.tar.Z.

  There are several files containing documentation, sources, binaries,
  application examples, and libraries. All binaries are for Sun/4
  machines. Sun/3 binaries are shipped only if explicitly requested.

  You have to use the following sequence of operations for installing
  the GRAS system at your site:

  1) 'ftp ftp.informatik.rwth-aachen.de' (with login name "anonymous"
     and password equal to your mail address).
  2) 'cd pub/unix/GRAS' (for changing the current directory).
  3) 'binary' (command for changing ftp mode).
  4) 'get gras.<version-no.>' (use 'ls' for finding the currently used
      GRAS version nr.).
  5) 'bye' (for exiting ftp).
  6) 'uncompress gras.<version-no>.tar'.
  7) 'tar xvf gras.<version-no>.tar' (creates a subdirectory GRAS_2 for
     the Modula-2 implementation of GRAS including its C-interface).
  8) Follow the instructions in file GRAS_2/README.


The current version has programming interfaces for Modula-2 and C
and supports:

  - the manipulation of persistent attributed, directed node- and
    edge-labeled graphs (including the creation of very long
    attributes and of attribute indexes).

  - the manipulation of temporary/volatile generic sets/relations/lists,

  - the coordination of graph accesses by different GRAS applications
    (multiple-read/single-write access with graphs as lock units),

  - error recovery based on shadow pages and forward logs,

  - nested transactions and linear undo/redo of arbitrarily long
    sequences of already committed graph modifying operations based
    on forward and backward logs,

  - event-handling (with certain kinds of graph-modifications
    as events and graph-modifying transactions as event-handlers),

  - primitives for version control comprising the capability
    for efficiently storing graphs as forward/backward deltas to
    other graphs,

  - and primitives for declaring graph schemes and for incremental
    evaluation of derived attributes.

Furthermore, tools for (un-)compressing graphs and a X11R5-based
graph browser are part of this release.

A multi-process version of the system GRAS supporting the inter-
action of multiple client and multiple server processes within
one local area network is nearby completion (version 6.0/0).

Thus, the GRAS system may be considered to be the core of a graph
oriented DBMS environment. The development of such an environment
based on a very high-level specifications language named PROGRES
is under way (the underlying calculus of this specification language
are so-called PROgrammed GRaph REwriting Systems).

This environment will comprise the following tools (a prerelease
of this environment might be made available upon request):

  - a syntax-directed editor for graph schemes, graph rewrite rules,
    and sequences of graph rewrite rules,

  - an incrementally working consistency checker,

  - an incrementally working compiler&interpreter translating
    PROGRES specifications into sequences of GRAS procedure
    calls (for C as well as for Modula-2),

  - and an "enhanced" graph (scheme) browser.


References
----------

Refer to the following publications for further info about GRAS, PROGRES,
and related topics:

/BL85/          Brandes, Lewerentz: A Non-Standard Data Base System within
                a Software Development Environment. In Proc. of the Workshop
                on Software Engineering Environments for Programming-in-the-
                Large, pp 113-121, Cape Cod, June 1985

/DHKPRS90/      Dewal, Hormann, Kelter, Platz, Roschewski, Schoepe: Evaluation
                of Object Management Systems. Memorandum 44, University
                Dortmund, March 1990

/Feye92/	Feye A.: Compilation of Path Expressions (in German), Diploma
		Thesis, RWTH Aachen (1992)

/Hoefer92/	Hoefer F.: Incremental Attribute Evaluation for Graphs (in
		German), Diploma Thesis, RWTH Aachen (1992)

/HPRS90/        Hormann, Platz, Roschweski, Schoepe: The Hypermodel Benchmark,
                Description, Execution and Results. Memorandum 53, University
                Dortmund, September 1990

/KSW92/ *       Kiesel, Schuerr, Westfechtel: GRAS, A Graph-Oriented Database
                System for (Software) Engineering Applications. Proc. CASE 93,
		Lee, Reid, Jarzabek (eds.): Proc. CASE '93, 6th Int. Conf. on
		Computer-Aided Software Engineering, IEEE Computer Society
		Press (1993), pp 272-286
		Also:  Technical Report AIB 92-44, 

/Klein92/	Klein P.: The PROGRES Graph Code Machine (in German), Diploma
		Thesis, RWTH Aachen (1992)

/Kossing92/	Kossing P.: Modelling of Abstract Syntax Graphs for normalized
		EBNFs (in German), Diploma Thesis, RWTH Aachen (1992)

/LS88/          Lewerentz, Schuerr: GRAS, a Management System for Graph-
                Like Documents. In Proceedings of the Third International
                Conference on Data and Knowledge Bases, Morgan Kaufmann
                Publ. Inc. (1988), pp 19-31

/Nagl89/        Nagl (ed.): Proc. WG'89 Workshop on Graphtheoretic Concepts
                in Computer Science, LNCS 411, Springer-Verlag (1989)

/NS91/          Nagl, Schuerr: A Specification Environment for Graph Grammars,
                in Proc. 4th Int. Workshop on Graph-Grammars and Their
                Application to Computer Science, LNCS 532, Springer-
                Verlag 1991, pp 599-609

/Schuerr89/     Schuerr: Introduction to PROGRES, an Attribute Graph Grammar
                Based Specification Language, in: /Nagl89/, pp 151-165

/Schuerr91a/ *  Schuerr: PROGRES: A VHL-Language Based on Graph Grammars,
                in Proc. 4th Int. Workshop on Graph-Grammars and Their
                Application to Computer Science, LNCS 532, Springer-
                Verlag 1991, pp 641-659
		Also:  Technical Report AIB 90-16

/Schuerr91b/	Schuerr: Operational Specifications with Programmed Graph
		Rewriting Systems: Theory, Tools, and Applications, 
		Dissertation, Deutscher Universitaetsverlag (1991) (in German)

/SZ91/ *        Schuerr, Zuendorf: Nondeterministic Control Structures for
                Graph Rewriting Systems, in Proc. WG'91 Workshop in Graph-
                theoretic Concepts in Computer Science, LNCS 570, Springer-
                Verlag 1992, pp 48-62
		Also: Technical Report AIB 91-17

/Westfe89/      Westfechtel: Extension of a Graph Storage for Software
                Documents with Primitives for Undo/Redo and Revision Control.
                Technical Report AIB Nr. 89-8, Aachen University of Technology,
                1989

/Westfe91/      Westfechtel: Revisionskontrolle in einer integrierten Soft-
                wareentwicklungsumgebung, Dissertation, RWTH Aachen, 1991

/Zuendorf89/    Zuendorf: Kontrollstrukturen fuer die Spezifikationssprache
                PROGRES, Diplomarbeit, RWTH Aachen, 1989

/Zuendorf92/ *  Zuendorf A.: Implementation of the Imperative/Rule Based
                Language PROGRES, Technical Report AIB 92-38, RWTH Aachen,
                Germany (1992)

/Zuendorf93/ *  Zuendorf A.: A Heuristic Solution for the (Sub-) Graph
                Isomorphism Problem in Executing PROGRES, Technical
                Report AIB 93-5, RWTH Aachen, Germany (1993)
 
* : All reports marked with an asterisk are available via anonymous ftp from
    ftp.informatik.rwth-aachen.de in directory /pub/reports/... .
 
See also PROGRES documentation.

[See also APPENDIX E]


> IRIS (HP Labs)

[Iris is a system out of HP Labs that began as a prototype and eventually
became a commercial product.  I believe it was eventually incorporated into
the new HP product, OpenODB. - clamen]

Long and short system summaries can be found in:

[FISH89] D.H. Fishman et. al. Overview of the Iris DBMS. In Won.
         Kim and Frederick H. Lochovsky, editors,
         Object-Oriented Concepts, Databases and Applications,
         chapter 10, pages 219--250. Addison-Wesley, Reading,
         MA, 1989.

[FBC+87] D.H. Fishman, D. Beech, H.P. Cate, E.C. Chow,
         T. Connors, J.W. Davis, N. Derrett, C.G. Hock, W. Kent,
         P. Lyngbaek, B. Mahbod, M.A. Neimat, T.A. Tyan, and
         M.C. Shan. Iris:  An object-oriented database
         management system. ACM Transactions on Office
         Information Systems, 5(1):48--69, January 1987.

The abstract of the latter (written early in the project) follows:

   The Iris database management system is a research prototype of
   a next-generation database management system intended  to meet
   the needs of new and emerging database applications, including
   office    automation and knowledge-based systems,  engineering
   test and measurement, and hardware  and software design.  Iris
   is exploring a rich set of  new database capabilities required
   by    these   applications,   including  rich    data-modeling
   constructs, direct  database support for inference,  novel and
   extensible data types, for example to  support graphic images,
   voice,    text,   vectors,  and  matrices,    support for long
   transactions   spanning  minutes  to  many  days, and multiple
   versions of data.  These capabilities are, in addition  to the
   usual support for  permanence   of data, controlled   sharing,
   backup and recovery.

   The   Iris   DBMS consists   of  (1) a  query   processor that
   implements  the   Iris object-oriented  data    model, (2)   a
   Relational Storage Subsystem (RSS) -like  storage manager that
   provides  access paths and  concurrency  control, backup   and
   recovery, and (3) a collection of programmatic and interactive
   interfaces.  The data   model supports  high-level  structural
   abstractions,  such  as  classification, generalization,   and
   aggregation, as  well  as behavioral    abstractions.      The
   interfaces to  Iris  include an  object-oriented extension  to
   SQL.


On Schema Evolution (from original survey):
Objects in the Iris system may acquire or lose types dynamically.
Thus, if an object no longer matches a changed definition, the user
can choose to remove the type from the object instead of modifying the
object to match the type.  In general, Iris tends to restrict class
modifications so that object modifications are not necessary.  For
example, a class cannot be removed unless it has no instances and new
supertype-subtype relationships cannot be established.


Commercial Systems
__________________


> IDL (Persistent Data Systems)

IDL is a schema definition language. Schema modifications are defined
in IDL, requiring ad-hoc offline transformations of the database, in
general.  A simple class of transformations can be handled by
IDL->ASCII and ASCII->IDL translators (i.e., integer format changes,
list->array, attribute addition).

[conversation with Ellen Borison of Persistent Data Systems]


ADDITIONAL REFERENCES:
        John R. Nestor. "IDL: The Language and Its
        Implementation". Prentice Hall. Englewood Cliffs,
        NJ., 1989.



> Kala
                         Kala Technical Brief

Summary

Kala(tm) is a Persistent Data Server managing distributed, shared,
arbitrarily complex and evolving persistent data. Kala is highly
efficient and secure. Kala manages the visibility of persistent data
elements to its clients, thus supporting any types of transactions,
versions, access control, security, configurations. Kala does not
restrict you to any particular model. Kala provides the mechanism, but
imposes no policy. Usable as either a link library communicating to a
server or as a standalone, Kala is compact and simple.

Kala is used for applications such as: kernel of DBMS products,
substrate for extended file systems, implementation of language
persistence, data manager for groupware applications as well as
applications which deal with large, complex, and changing volumes of
data (text databases, financial distributed transaction systems). Our
current customers use Kala in applications ranging from CASE
repositories to CAD systems, from document management for financial
institutions to OODBMS platforms, from real-time applications to
database research.  Kala is a component of broad reuse.


Motivation

The simplest persistent data storage available to you is the file
system on your disk drive. File systems have some attractive
characteristics; their performance is good, they can hold any data,
they're easy to use, and, of course, the price is right. Conversely,
files are unreliable.  They provide no mechanism for in maintaining
data consistency and only primitive data sharing facilities. Few file
systems offer version control and all require that you transform data
between "internal" and "external" forms all the time.

Unlike a file system, a true database management system provides
mechanisms for sharing data and for ensuring the integrity of the
data.  It supports transactions and version control, although the
specifics of these functions may not be exactly what your application
needs. Finally, a database system is scalable, and much more robust
than a file when your hardware or software fails.

The downside to a database system is that, compared to a file system,
it is slower by an order of magnitude or more. Also, a database system
generally confines you to dealing only with the kind of data that it
can handle. In addition, a database is usually very complicated,
difficult to learn and use, and expensive, both in terms of your cost
of operation and in the amount of system resources they consume.

Whether you choose a file system or a database manager, then, you
have to sacrifice either economy or performance. Is there a happy
medium?  Something with the speed and flexibility of files, the
reliability, shareability and robustness of databases, and at a cost
that won't break your wallet or the available hardware? Sure there is!
Kala is a first in a new breed of products, persistent data servers,
aimed squarely at the yawning gap between DBMSs and file systems.


Overview

Kala is *not* a DBMS. Instead, you use Kala whenever the few canned
combinations of DBMS features do not meet the needs of your
application. A DBMS product constrains you to accept *its* choice of
an end-user graphical interface, a query language binding, a specific
high level data or object model, a particular transaction model, a
single versioning scheme, etc. This either compromises your
application's functionality, or forces your to spend substantial
development effort and money to bridge the impedance mismatch to the
application.  Instead, Kala allows *you* to develop no more and no
less than the functionality you need. You build your domain specific
functionality our of a small set of primitives with very little code.
Your gains in productivity, efficiency, and flexibility are
substantial.

To sustain this level of flexibility and reuse, Kala manages any data
that you can represent in machine memory out of bits and references.
Examples include records, dynamically linked graphs and lists,
executable code, and object encapsulations.

Kala can handle data as small as one bit, and as large as the virtual
memory and more, while being totally unaware of the data's semantics.
Its stores and retrieves data efficiently, and compactly over a
distributed and dynamically reconfigurable set of Stores. Upon
retrieval, Kala dynamically relocates embedded references to retain
the original topological structure of the data, thus preserving
referential integrity. Kala also supports active data, physical store
management, and automatic archiving.

Kala repackages the fundamentals and universals of data management in
one reusable data server, separating them from the application domain
specific models and policies. Kala defines a low level interoperabi-
lity point for the data storage domain, just as X does for the display
domain and Postscript does for the printing domain.

Kala has matured through four successive versions to its present
industrial strength implementation and stable API. Kala is lean,
compact, and portable. Kala is a high performance, low overhead
system. We call it a Reduced Instruction Set Engine (RISE). Unlike
large, complex, and typically bulky DBMS products, Kala is small,
simple, and suitable for managing anywhere from a single diskette to
terabytes of distributed data.


Benefits

* For those who need functionality traditionally associated with
  databases, but cannot tolerate the overhead and complications DBMS
  products introduce, Kala offers a flexible, compact, performant,
  elegant, and simple alternative.

* For those whose application domain requires data models where the
  mapping to those offered by today's DBMS products is cumbersome,
  introduces development and execution overhead, and is not portable
  across multiple linguistic and environmental platforms, Kala offers
  a data model independent interface against any data model
  expressible in terms of bits and pointers can be easily built.

* For those who need DBMS functionality or qualities that no single
  DBMS product now has, Kala offers the opportunity to build that
  functionality now with little effort out of a simple set of
  primitives, and not wait for one vendor or another to deliver
  it later.

* For those who have determined that the only viable option for their
  application's persistent data needs is the file system, and have
  resined to the idea that they will have to build everything else
  they need from scratch, Kala offers an off-the-shelf implementation
  without loss of any of files' advantages.

* For those who need performance, size, portability, storage
  compactness, and industrial strength that no single DBMS product can
  now satisfy, Kala offers all of the above now.

* For those who realize that while object-level interoperability is a
  strong desideratum, the likelihood of a single, universal such model
  in the foreseeable future is quite low, Kala offers a solid, long
  term alternative. Data store interoperability that brings us beyond
  file systems is the best practical bet. Kala is the basis for data
  store interoperability now.

* Finally, for all of you who are concerned about the economics of
  software, and take the view that there are many elements that
  could contribute negatively to the soundness of your business, such
  as operational costs, software maintenance costs, software licensing
  costs, software development and learning costs, etc., you will find
  Kala an economically sound, sensible, and practical product.


Features

- The execution architecture is that of multiple (communicating)
  servers and multiple clients. Kala can also be configured in a
  standalone (single process) mode. Kala's IPC is built for maximum
  performance, portable to any given datagram protocol.

- The managed data elements are made out of uninterpreted bits and
  references. Data elements (named `monads') are universally uniquely
  identified. Bits are stored with no overhead. References,
  represented in memory as native machine pointers, are stored
  very compactly, introducing an average of 2.5 bytes overhead.

- Kala is a fully recoverable system, short of media damage. Recovery
  from hardware failures can be supported by the layer beneath Kala.

- The Kala primitives support arbitrary transaction models, including
  classic short transactions, long (persistent) transactions, nested
  transactions, shared transactions, pessimistic and optimistic
  policies, etc. Concurrency control is achieved through two locking
  mechanisms (short-term and long-term (persistent, shared) locking),
  with full support for atomicity of operations and two-phase commit.

- The Kala primitives support arbitrary versioning models, allowing
  versions to co-exist in split/rejoined networks, various version
  organization strategies (single-thread, tree, DAG, etc.). Kala
  primitives provide mechanisms for arbitrary access and update
  triggers, such as notifications, security checks upon access/update,
  etc. __ with no limitations on what the trigger code does. Kala
  provides protection measures against virus and other intruding
  executions.

- The Kala primitives support a wide range of access control, security
  and protection models, including revocable access rights, access
  control without the overhead of ACL management, arbitrary access
  validation routines, etc. Kala does not introduce any more security
  holes than the operating environment already has.

- Kala has primitives for physical store allocation and de-allocation
  management, for a wide spectrum of store administrative tasks, as
  well as licensing administration. The latter includes application-
  sensitive time-limited client-connect-based licensing, as well as
  metered (connect/load/store) usage. Kala can be set up to do
  automatic archiving and backup of its physical store.

- Kala provides a wide spectrum of licensing schemes, usable by
  platforms and applications built upon Kala to their customer base.
  Kala provides renewable licenses, perpetual licenses, full
  protection against duplication without hardware (hostid) support,
  metered (pay-by-use) usage, etc.

- And more ... not fitting on this page-long Technical Brief.


Availability

o Kala is available now on Sun platforms (SunOS / 68K & SPARC), as
  well as on 80x86/MS-DOS (both Microsoft and Borland compilers &
  runtimes supported) platforms. If you are interested in a port to
  your favorite platform, call us to discuss our Development and
  Porting Partnership Programme.

o Kala's interface is ANSI C, also callable from C++. If you are
  interested in an interface or a binding to your favorite programming
  language, please call us to discuss out Development Partnership
  Programme.

o For pricing and other information, please contact us by phone, fax
  or via e-mail at Info@Kala.com


 _     _     ____   _         ____ tm ____________________________________
 \\   /     |    \   \       |    \       \\\\ 
  \\ /__     \ __ \   \       \ __ \       \\\\ 
   \\    \    \    \   \       \    \       \\\\  
    \\    \    \    \   \       \    \       \\\\  No more than you need !!!
     \\'   \'   \'   \'  '____'  \'   \'      \\\\  No less than you want !!!
      ........................................................................
      Penobscot Development Corporation                 email: Info@Kala.com
       One Kendall Square Building 200 Suite 2200 Cambridge MA 02139-1564 USA
        voice +1-617-267-KALA fax +1-617-859-9597 tech support +1-201-539-7739
         ...............(5252) fax +1-617-577-1209.............................



     +---------------------------------------------------------------+
     |   Copyright (c) 1992-93, Penobscot Development Corporation.   |
     |   Kala is a Trademark of Penobscot Development Corporation.   |
     +---------------------------------------------------------------+

On Schema Evolution (from original survey):

Kala manages an untyped persistent store, implementing the semantics
of robust, distributed, secure, changing, and shareable persistent
data.  Layers built upon the Kala platform can implement the semantics
of objects with the same properties.

As it operates below the schema layer, Kala does not address schema
evolution directly. However, It supports the building of schema'ed
layers above it and below the application, and those layers can
provide for schema evolution conveniently using Kala primitives.
This parts-box approach requires extra work on the part of the developer
compared to out-of-the-box solutions, but provides power and
flexibility sufficient for relatively low cost solutions in
difficult environments (e.g. graph-structured data, dynamic classing) 
where no out-of-the-box solution is available.


Contacts:
Sergiu Simmel           sss@kala.com
Ivan Godard             ig@kala.com
general information     info@kala.com
subscription to moderated newsletter    forum-request@kala.com


REFERENCES:
        Segui S. Simmel and Ivan Godard. "The Kala Basket: A
        Semantic Primitive Unifying Object Transactions,
        Access Control, Versions, annd Configurations


> Pick

With Pick and its variants you only have problems if you want to
redefine an existing field.  Because of the way the data are stored
and the separation of the data and the dictionary you can define
additional fields in the dictionary without having to do anything to
the data - a facility which we have found very useful in a number of
systems.

There is no general facility to redefine an existing field - you just
make whatever changes are required in the dictionary then write an
Info Basic program to change the data.  We have seldom needed to do
this, but it has not been complicated to do.

If a field in the database is no longer used, it is often easiest
simply to delete the reference to that field in the dictionary, and
accept the storage overhead of the unused data.  In such cases, while
the data cannot be accessed through the query language, (Pick)Basic
programs can still access them.

[Geoff Miller <ghm@ccadfa.cc.adfa.oz.au>]



Interfaces
----------


Research Systems
________________


> Penguin (Stanford)

Penguin is an object-oriented interface to relational databases.
Penguin has its own simple language-independent object model with
inheritance for composite objects defined as views (called
view-objects) of a relational database.  These view-objects represent
data according to application requirements in such a way that multiple
applications can share overlapping, but different, sets of data.
Multiple applications may share data by having overlapping schemata
with differing composite objects and differing inheritance mappings.
We have a C++ binding, which supports multiple inheritance.  The
result is a framework for collaboration among multiple users, each
with differing perspectives about the system and its data.

For additional information, please contact ark@db.stanford.edu

References:

``A C++ Binding for Penguin: a System for Data Sharing among
Heterogeneous Object Models,'' Arthur M. Keller, Catherine Hamon,
Foundations on Data Organization (FODO) 93, October 1993, Chicago.

``Querying Heterogeneous Object Views of a Relational Database,''
Tetsuya Takahashi and Arthur M. Keller, Int. Symp. on Next Generation
Database Systems and their applications, Fukuoka, Japan, September
1993, to appear.

``Updating Relational Databases through Object-Based Views,'' by
Thierry Barsalou, Niki Siambela, Arthur M. Keller, and Gio Wiederhold,
ACM SIGMOD, Denver, CO, May 1991.

``Unifying Database and Programming Language Concepts Using the Object
Model'' (extended abstract), Arthur M. Keller, Int. Workshop on
Object-Oriented Database Systems, IEEE Computer Society, Pacific
Grove, CA, September 1986.


Commercial Systems
__________________
  
>AllegroStore

See Databases & Development Sept. 5, 1994, p1. 

"Lisp, Smalltalk Languages Given Database Systems"

Quote:
Franz, based in Berkeley, Calif., is now shipping AllegroStore, which the
company calls the first object database system designed for object-oriented
Lisp.
 
[...] The database is based on the ObjectStore engine from Object Design, also
in Burlington.  It supports multiple clients and servers, [...]

Franz is at 800-333-7260 or 510-548-3600.


> Persistence

                PERSISTENCE(TM): BRIDGING THE GAP BETWEEN OBJECT 
                    ORIENTED DEVELOPMENT AND RELATIONAL DATA

Persistence is an application development tool which provides object
oriented access to existing relational data.  Persistence uses an
automatic code generator to convert object models into C++ classes
which know how to read and write themselves to a relational database.

Leverage existing data

Persistence enables object oriented access to existing relational
databases. Applications built with Persistence can work side by side
with legacy systems.

Automate database access

By generating the methods to convert relational data into objects,
Persistence saves the developer from having to write literally hundreds
of lines of code per class.

Speed application development

With Persistence, major changes to the application object model can be
completed in minutes, not weeks.

Quality

Persistence generates tested, bug-free code. Using Persistence helps
ensure the reliability and reusability of your applications.

Performance

At Runtime, Persistence manages an object cache to enhance performance
while ensuring data integrity. The Persistence object cache can provide
a factor of ten performance improvement for data intensive
applications.

Portability

Code generated by Persistence is database independent. You can choose
which database to work with at link step, increasing application
portability.

                        TECHNICAL SPECIFICATIONS

The Persistence Database Interface Generator converts object schemas
into C++ classes.

                                                Custom
                                                Code
                                                   |
                                                   v

Object schema    --->   Persistence    ---->    Generated
                        Generator               Classes
                                                   ^
                                                   |
                                                   v
                                                Persistence
                                                Object Cache
                                                   ^
                                                   |
                                                   v
                                                Legacy Data


Encapsulation

Each class generated by Persistence maps to a table or view in the database.
- Query using ANSI SQL or attribute values
- Add custom code to generated classes
- Preserve custom code when model changes

Inheritance

Persistence supports inheritance of attributes, methods and relationships.
- Propagate superclass queries to subclasses
- Use virtual methods for polymorphism

Associations

Persistence maps associations to foreign keys in the database. Each class has methods to access related classes.
- Ensure referential integrity between classes
- Specify delete constraints for associations

Object Caching

The Persistence Runtime Object Management System caches objects during
transactions and ensures data integrity. In the object cache,
Persistence "swizzles" foreign key attributes into in-memory pointers,
speeding object traversal.

Transactions

When a transaction is committed, Persistence walks through the object
cache and writes out changes to the database.

Environment

Platforms/Operating systems
Persistence will support all major Unix and Intel platforms
- Sun/SunOS 4.x, Solaris 2.x
- HP/HP-UX 8.0, 9.0
- IBM/AIX (planned 11/93)
- Intel/NT (planned 3/94)

Development Tools

Persistence supports all major C++ compilers and integrates with GE's
OMTool, allowing developers to go straight from an object model to a
running C++ application.
- Cfront 2.1: ObjectCenter 1.0, SPARCompiler, ObjectWorks
- Cfront 3.0: ObjectCenter 2.0, SPARCompiler, Softbench C++
- GE's OMTool

Databases

Persistence provides database independence. With our Objectivity
integration, we also provide a clear migration path to object
databases.
- Oracle V6, V7
- Sybase 4.x
- Ingres 6.x
- Objectivity ODBMS
- Informix (planned 9/93)
- ODBC (planned 3/94)

                            CUSTOMER QUOTES

"We wanted to use object technology while continuing to support our
legacy systems. Persistence made this feasible by automating over 30
percent of our development cycle." Steve Hunter, Sterling Software

"Persistence cut our development time by approximately 40%, because we
would have had to do all the mapping functions ourselves." Jim
Adamczyk, Partner, Andersen Consulting

"I'm convinced we'll save weeks or months of time because of
Persistence." Mike Kubicar, SunSoft Defect Tracking Team

From ankh.iia.org!babbage.ece.uc.edu!news.kei.com!yeshua.marcam.com!news.mathworks.com!hookup!bloom-beacon.mit.edu!senator-bedfellow.mit.edu!faqserv Wed Nov 23 21:57:36 1994
Path: ankh.iia.org!babbage.ece.uc.edu!news.kei.com!yeshua.marcam.com!news.mathworks.com!hookup!bloom-beacon.mit.edu!senator-bedfellow.mit.edu!faqserv
From: Bob Hathaway <rjh@geodesic.com>
Newsgroups: comp.object,comp.answers,news.answers
Subject: Comp.Object FAQ Version 1.0.7 (10-27) Part 7/10
Supersedes: <object-faq/part7_782395740@rtfm.mit.edu>
Followup-To: comp.object
Date: 29 Oct 1994 11:42:28 GMT
Organization: Geodesic Systems
Lines: 1769
Approved: news-answers-request@MIT.Edu
Distribution: world
Expires: 12 Dec 1994 11:40:18 GMT
Message-ID: <object-faq/part7_783430818@rtfm.mit.edu>
References: <object-faq/part6_783430818@rtfm.mit.edu>
NNTP-Posting-Host: bloom-picayune.mit.edu
Summary: Frequently Asked Questions (FAQ) List and Available Systems For Object-Oriented Technology
X-Last-Updated: 1994/10/28
Originator: faqserv@bloom-picayune.MIT.EDU
Xref: ankh.iia.org comp.object:7432 comp.answers:4422 news.answers:13681

Archive-name: object-faq/part7
Last-Modified: 10/27/94
Version: 1.0.7

"The good thing is that you can change your object model and just
re-generate the database interface classes at the press of a button."
Richard Browett, Product manager, K2 Software Developments, Ltd.

"The Persistence package saved at least 25 to 50 percent of the
development time, and seemed extremely robust. Support has been nothing
short of phenomenal." Stew Schiffman, DuPont Research and Development

                        FOR MORE INFORMATION

For more information on Persistence, please contact Carl White, VP Sales:
- By phone: (415) 341-1280
- By fax: (415) 341-8432 
- By email: information@persistence.com

Persistent Data Systems
PO Box 38415
Pittsburgh, PA  15238-9925


> Subtlware

From: subtle@world.std.com (Ted p Kyriakakis)
Subject: Re: OOP access to relational databases?
Summary: C++ to SQL RDBMS Mapping Tool and Literature
Date: Mon, 25 Oct 1993 06:51:48 GMT

koch@eis.cs.tu-bs.de (Andreas Koch) writes:
>I am interested in approaches and examples of transparent access to
>relational databases within OOPLs such as C++ and Smalltalk. Of interest
>are pointers to literature and articles as well as ftp'able sample code.
>Any hints are appreciated.

There is a book out from MIS Press by Al Stevens called "C++ Database
Development" which addresses this topic in detail for C++ OO development.  The
book does a good job of describing issues with object persistence and the
implications of using a RDBMS as an object database.

There is also a C++ to SQL mapping product, Subtlware for C++/SQL, that
provides a tool and framework which addresses many of the issues mentioned in
the book. The tool automates the production of the code necessary to map C++
objects to a SQL RDBMS using C++ header files as input.  

If you want more information, you can contact me at:

          subtle@world.std.com

or you can contact Subtle Software at:

	(508) 663-5584 

> Synchronicity

See Databases & Development Sept. 5, 1994, p1. 

"Lisp, Smalltalk Languages Given Database Systems"

Easel's Synchronicity 2.0 is a new release of the company's business object
modeling system, fromerly known as Synchrony.  The new version, which will
run under Windows and OS/2, lets developers using Easel's Enfin development
system map Smalltalk objects to relational databases.

Easil is at 617-221-2100.


APPENDIX C  OBJECT-ORIENTED LANGUAGES AND VENDORS
=================================================

See also APPENDIX D.

FORMAT:
    tool name, 
    description and methods
    operating systems
    Vendor name, 
    city/state, phone (if known)

ACTOR ($495)
------------
*Prototyping & Code generation (ACTOR, access to C, Pascal)
*IBM PS/2, PC AT/XT
The Whitewater Group Inc.
600 Davis, Evanston, IL 60201

Allegro CL
----------
*Advanced Object Oriented Development System based on CLOS.  Incremental
 compiler; automatic memory management; integrated editor, debugger class
 browsers, and profilers; multiple inheritance, method combination, multiple
 argument discrimination, meta-object protocol.
*Unix workstations (Sun/Sparc, IBM RS/6000, HP, Silicon Graphics)
 PCs with Microsoft Windows
Franz Inc.
1995 University Avenue
Berkeley, CA 94704
(510) 548-3600, FAX (510) 548-8253
Email info@franz.com

Bootcon
-------
*DOS
Modular Software System

CaseVision
----------
*Browser, Static Analysis, no compiler (yet), Editor Debugger, Profiler, ... 
Silicon Graphics

Classic-Ada
-----------
*Object-Oriented Ada Environment (to Ada translator)
Software Productivity Solutions
(407) 984-3370.

Comeau C++ 3.0.1 With Templates
-------------------------------
* compiler
* many OS's (MS-DOS, AmigaDOS, UNIX (SVR4, SPARC, UNIX 386, etc), etc)
Comeau Computing
91-34 120th Street
Richmond Hill, NY 11418-3214
718-945-0009, comeau@csanta.attmail.com

Distributed Smalltalk (HP)
--------------------------
*ParcPlace's VisualWorks Extension, world's first complete implementation of
*the OMG CORBA 1.1.
European Knowledge Systems Centre (HP's European software tools specialists)
ph:    44 272 228794
email: wjb@hplb.hpl.hp.com

Energize (5 $16250, single $4250, lcc 1500)
-------------------------------------------
*Debugger, Class Language Calltree Error Project Browsers
*SunOS 4.1
Lucid
707 Laurel St.
Menlo Park, CA 95025
(415) 329-8400

Frameworks 3.1 ($495.)
----------------------
*IDE, Browser, Debugger, Compiler, ...
*DOS, Windows
Borland International
1800 Greenhills Road
Scotts Valley, CA  95067
800-331-0877

FUSE ($1560 C++, $1944 FUSE)
----------------------------
*Distr Builds, Editor, Debugger, Profiler, Call Graphs, Call Tree Animation,
 Browser, ...
*Ultrix RISC, OSF/1 AXP  (planned to alpha NT)
DEC
14475 Northeast 24th St.
Bellvue, WA 98007

GNU GCC (g++)
-------------
*C++ compiler, (non-graphical) debugger.
*Unix
prep.ai.mit.edu:/pub/gnu/gcc-2.4.5.tar.gz

GNU GCC (g++)
-------------
*C++ compiler, (non-graphical) debugger.
MS-DOS
grape.ecs.clarkson.edu:/pub/msdos/djgpp/djgpp.zip 

Hamilton C-Shell
----------------
*A shell
*OS/2, Windows
Hamilton Labs

HighC/C++ (basic $795, w/Phar Lap $995)
---------------------------------------
*Editor, Debugger, Windows ADK, Unix Utilities, Speedkit
*Unix
MetaWare Inc.
2161 Deleware Ave.
Santa Cruz, CA  95060
(408) 429-6382

Iconix Power Tools
------------------
*Multiuser, OO development toolset
*Macintosh
Iconix Software Engineering
Santa Monica, Ca.

MetaC
-----
*testing tool, code coverage, lint-style chking, C, C++, tests mem alloc errors
 QASE (Quality Assured Software Engineering)
938 Willowleaf Dr.
Suite 2806
San Jose, CA 95128
(408) 298-3824 ext. 5

MKS Toolkit
-----------
*Make, ...
*PC (Unix-Like)
MKS

NEXPERT
-------
*GUI-type builder, rule based, objects, classes, subclasses, rule inheritance,
 embedded, but you can call external routines. 
Neuron Data Elements 
From: jrp@accint.com (Jason R. Pascucci)  (abstract from a post)

NextStep
--------
*Application, DB, Windows, Indexing, 3D Graphics Kits, Project and Interface
 Builder, Viewers, Modelers, Compilers/Debuggers, Performance, PostScript, ...
*Next, 486, ???
Next Computer, Inc.
900 Chesapeake Drive
Redwood City, CA 94063
800-TRY-NEXT

ObjectCenter
------------
*C++ programming environment, high quality graphics, browser, debugger,
 interpreter.
*Sun, ???
CenterLine
(kendall@)centerline.com

ObjectIQ
--------
*OO devel environ. Objects, rules, debugger, browser, GUI builder, more.
*RAD and intelligent decision support applications.
European Knowledge Systems Centre (HP's European software tools specialists)
ph:    44 272 228794
email: wjb@hplb.hpl.hp.com

ObjectWorks, VisualWorks
------------------------
*Smalltalk programming environment from the Smalltalk people.
ParcPlace Systems, Inc.
999 E. Arques Avenue
Sunnyvale, CA 94086
email:	info@parcplace.com
fax:	1-408-481-9095
voice:	1-800-759-PARC

OpenTalk
--------
*Smalltalk to C++ and C Translator.
TNI Industries (Techniques Nouvelles d'Informatique)
ZI du Vernis
29200 Brest
France
tel 98 05 24 85, fax 98 49 45 33

OST/Look
--------
*C++ program animator.
*Suns, PCs, others coming.
Admiral Software
193-199 London Road
Camberley
Surrey
UK
Tel: (44) (276) 692269
Fax: (44) (276) 677533

Prograph
--------
*OO visual programming environment
*Macintosh
TGS Systems
Halifax, Nova Scotia
902-455-4446

SDE WorkBench/6000 ($918 - $7350)
---------------------------------
*Editor (syntax Highlighting), Browser, Flow Grapher, Make, Test Coverage
 Analysis, Debugger, Profiler, ...
*HP Apollo 9000, Sparcstations
IBM, Canada
PRGS Toronto Laboratory
895 Don Mills Road
North, York
Ontario, Canada, M3C 1W3
800-IBM-CALL

SNAP
----
*Template based devel. environment for building distributed OO applications
Template Software Inc.
13100 Worldgate Drive, Suite 340
Herndon, VA  22070-4382
(703) 318-1000

SNiFF+
------
*C/C++ development environment with fuzzy parser, Emacs integration and code
 browsers, free to universities.  See APPENDIX E, TOOLS AND CASE
*SunOS 4.x, Solaris 2.x, AIX 3.2, HP/UX 8.0/9.0
takeFive Software
Jakob-Haringer-Strasse 8
5020 Salzburg, AUSTRIA
phone: +43 662 457 915
fax:   +43 662 457 915 6
email: sniff@takefive.co.at

SoftBench ($1785 C++, $4500 Softbench)
--------------------------------------
*C++ class constructor, CASE (graphically modify C++), Browser, Analyzer,
 Editor, Builder, Debugger, ...
HP
3404 E. Harmony Rd. MS 81
Fort Collins, CO 80525
800-845-0070
or
Cupertino, Ca.
800-752-0900 ext. 2707
or 303-229-2255

SparkWorks ($1995, $995 C++)
----------------------------
*Debugger, Profiler, Source Browser, File Merge, MakeTool
*Suns
SunPro
2550 Garcia Ave.
Mountain View, CA 94043
(800) 926-6620

Zortech C++ v. 3.1 ($499)
-------------------------
*Debugger, Workbench, Resource Workshop
*PCs?
Symantec Corp
10201 Torre Ave.
Cupertino, CA 95014
(408) 253-9600


APPENDIX D  OBJECT-ORIENTED CASE (OOA/D/P TOOLS) AND VENDORS
============================================================

See also APPENDIX C.

Below is a list of available OO CASE environments.  Many thanks to James Odell
<71051.1733@compuserve.com> for his extensive list and to Ron Schultz
<ron@bse.com> for a list posted to comp.object on 9/13/92.  Many additional
entries have been added and additional entries are encouraged; please send
additions and updates to the author of the FAQ (and/or to James and Ron).

Second is a collection of articles, products, and papers on CASE systems.
These appeared as posts to comp.object.

I. graphic-only OO-CASE
	EasyCASE
	HOOD Toolset
	Model 5w
	Stood
	TurboCASE

II. OO-CASE with some code generation (1 to 60%)
	AdaVantage
	Bachman/Analyst
	BOCS
	EiffelCase
	HOMSuite
	IE\O (canceled)
	ILOG KADS Tool
	MacAnalyst/Designer
	ObjectCraft
	Objecteering
	ObjectModeler
	ObjecTool
	Object Oriented Designer
	ObjectOry
	ObjectTeam
	OEW
	OMTool
	OOSD
	OOTher
	Prosa/om
	Rational Rose
	S-CASE
	Select/OMT
	SES/Objectbench
	System Architect
	VIEWS-SF
	Westmount I-CASE OMT
	001

III. Meta OO-CASE (CASE that builds CASE)
	Envision
	Excelerator II
	GraphTalk
	MetaEdit
	Object Maker
	Paradigm Plus
	Toolbuilder

IV.  Full execution OO-CASE
	BridgePoint
	ObjecTime
	Ptech
	OMW

Available CASE Systems

FORMAT:
    tool name, 
    description and methods
    operating systems(price, if known)
    vendor name, 
    vendor contact information

001
---
*Object-oriented, full life cycle CASE
*VAX/VMS, Unix ($24,000)
Hamilton Technologies Inc
17 Inman St., Cambridge MA  01239
(617) 492-0058

AdaVantage ($1095--$1780)
-------------------------
*analysis, design (Ada) Generators: production code, Ada compiler and tool set
 reusable components library
*PC AT/XT, Mac, Unix Workstations
Meridian Software Systems, Inc.
23141 Verdugo Dr., Ste 105, Laguna Hills CA 92653

Bachman Data Analyst
--------------------
*Data Modeling and analysis with OO support
*PC-DOS, OS/2, Unix
Bachman Information Systems
8 New England Executive Park, Burlington, MA  01803
(617) 273-9003

BOCS
----
*Semantic Nets, Object-Message Diagrams, State Transition Diagrams, Petri-Nets
*Generates C++
*PC-DOS, OS/2, Windows Macintosh ($595)
Berard Software Engineering 
902 Wind River Lane, Suite 203
Gaithersburg, MD  20878
301-417-9884

BridgePoint
-----------
*Shlaer/Mellor notation
*general purpose code generator from"Action Language" psuedo code
*based on user-defined templates
*simulation tool
*Unix ($6,000)
Objective Spectrum
901 Kildaire Rd
Cary, NC  27511
(919) 460-1500
(919) 380-6463 (fax)

EasyCASE
--------
*Parts of Shlaer/Mellor method plus lots of other non-OO notations
*Windows, DOS ($495 to $1,295)
Evergreen CASE Tools, Inc
8522 154th Ave NE
Redmond, WA  98052
(206) 881-5149
(206) 883-7676 (fax)

EiffelCase
----------
*ISE's BON (Better Object Notation)
*Generates Eiffel class templates
*Unix, Windows NT ($1,995)
Interactive Software Engineering, Inc
270 Storke Road, Suite 7
Goleta, CA  93117
(805) 685-1006
(805) 685-6869 (fax)

Envision
--------
*Methodology independent, user defined.  Meta-CASE.  Template code
 generation.  Examples include BPR, Yourdon/ER, OMT.
*Windows,NT,OS/2,(Chicago),Network Servers (8,000 Single, Multiple discounts).
Future Tech Systems (Leon Stucki)
824 E. Main
Auburn, Washington 98002
(206) 939-7552
(206) 735 6763 (fax)

Excelerator II
--------------
*Odell/Martin, Rumbaugh, Jacobson, and Wirfs-Brock notation
*Can customize and mix parts of on approach with another in a user-friendly manner
*LAN, meta-CASE with customizable graphics and rules
*OS/2, Windows NT ($9,500)
Intersolv, Inc
3200 Tower Oaks Blvd
Rockville, MD  20852
(301) 230-3200
(301) 231-7813(fax)

GraphTalk
---------
*many notations (IE, NIAM, HOOD, Merise, SADT)
*configurable meta-CASE tool
*executable code generation of C (via enhanced pseudo code) and GQL
*Sun, DEC, RS6000, UNIX, Motif, PS/2, PC 386, OS/2
Rank Xerox
AI & CASE Division
7, rue Touzet Gaillard
93586 Saint-Ouen Cedex
France
+33 (1) 494 85085

HOMSuite
--------
*responsibility-driven design
*Generates C++ and Smalltalk/V
*Windows ($595)
Hatteras Software Inc
208 Lochside Dr
Cary, NC  27511
(919) 851-0993

HOOD Toolset (design only)
--------------------------
*HOOD notation
*Unix, DOS
CASET Corporation
33751 Connemara Dr
San Juan Cap., CA  92693
(714) 496-8670

IE\O IEF (IE\O canceled)
------------------------
*OO version of IEF.  IEF now handles some OO CASE?
*OS/2 
Texas Instruments
1-800-336-5236

ILOG KADS Tool
--------------
*knowledge-based system (KBS) approach named KADS, part is OO to
*capture knowledge, part involves rules that capture decision-making logic,
*generates C++
*Unix, DEC VMS
ILOG
2, ave Gallieni, BP 85
94523 Gentilly Cedex
France
+33 1 4663-6666
+33 1 4663-1582 (fax)

LOV/Object Editor
-----------------
*Rumbaugh notation
*generates C++
*interfaces with Verilog product suite
*Unix, OSF/Motif
Logiscope, Inc.
3010 LBJ Freeway, Suite 900
Dallas, TX  75234
(214) 241-6595
(214) 241-6594

MacAnalyst and MacDesigner
--------------------------
*various notations
*screen prototyping
*Macintosh ($995-2,590)
Excel Software
PO Box 1414
Marshalltown, IA
(515) 752-5359
(515) 752-2435 (fax)

MetaEdit
--------
*Analysis and design tool that supports most available structured
 and OO analysis and design methods, and can be easily customized. 
 OO methods supported: Booch, Coad/Yourdon, Demeter, Rumbaugh, OSA and MOSESA.  
*MetaEdit is available for MS-Windows 3.1 (499$ - 1500$).
MetaCase Consulting OY
P.O. Box 449
Ylistnmentie
FIN-40101 Jyvskyl
Finland
tel. & fax. +358-41-650 400

[The shareware version can be found from Simtel, Cica, and their mirrors. The
 version 1.0 is shareware but the latest version 1.1 is fully commercial.]

[MetaEdit 1.1 - MetaCase Consulting Oy - metacase@jsp.fi
                shareware version "metaed10.zip" can be ftp'd from ftp.funet.fi
                (other sites also have the file, check archie)]

Model 5w 
--------
*prototype, free with purchase of OOA text "The Problem Space".
 GUI front end for integrated repository supporting OO requirements
 analysis, including events, rules, participants, and locations.
*Windows 3.X under DOS or OS/2
Dan Tasker Consulting
Sydney, Australia
Phone/Fax +61 2 909-8961
dant@swdev.research.otc.com.au

ObjectCraft
-----------
*OOT's own graphic notation
*Generates C++ 
*DOS ($99)
Object-Oriented Technologies
2124 Kittredge St,  Suite 118
Berkeley,  CA  94704
(415) 759-6270 (voice/fax)

Objecteering
------------
*Softeam's "Class Relation" approach notation
*Generates C++ ("up to 60%"), open with multiple, concurrent user
*Sun, DEC, HP, RS6000, Unix, X Windows/Motif ($9,500)
Softeam
One Kendall Square, #2200
Cambridge, MA  02139
(617) 621-7091
(617) 577-1209 (fax)

ObjecTime  
---------
*ROOM methodology (Real-Time Object-Oriented Modelling) notation
*OO state charts with methods specified in own Smalltalk-like language or C++
*generates Smalltalk, C, C++ and interfaces with C++ environment
*internally used product by Bell-Northern for several years
*full code generation for embedded RT systems
*Unix  ($20,000 includes training and support)
ObjecTime Limited
340 March Road, Suite 200
Kanata, Ontario,
Canada K2K 2E4
(613) 591-3400

ObjectMaker
-----------
*supports many diagramming notations
*customize methods, checking, and semantics with external rules
*configurable meta-CASE tool
*Cobol, Ada, C, and C++ generation (shell) and reverse engineering
*Macintosh, VAX, Windows 3, X Windows/Motif ($8,000 to $25,000)
Mark V Systems Ltd
16400 Ventura Blvd
Encino, Ca.
(818) 995-7671

ObjectModeler
-------------
*Rumbaugh, Coad/Yourdon, Jacobson and Booch notation
*multiple, concurrent user
*generates SQL, C++, Smalltalk templates
*Macintosh, Unix ($1,495--5,995)
Iconix Software Engineering
2800 28th St.,  Suite 320
Santa Monica, CA  90405
(310) 458-0092

ObjecTool (was OOA/OODTool), Together/C++(new)
-----------------------------------------------
*Coad/Yourdon, Object-oriented analysis.  ObjectTool (Startup tool)
*Windows, OS/2, HP/Sun Unix.
*Together/C++ (Windows only) Code/Design integration.
Object International, Inc.
8140 N. MoPac Expwy
Austin, Tx  78759-6535
800-926-9306
(512) 795-0202
(512) 795-0332 (fax) 

Object Oriented Designer (Freeware: See Appendix E:66)
------------------------------------------------------
*Only object model (with some extension) of Rumbaugh notation
*generates C++
*primitive graphics editor
*Unix machine(SunSparc, HP, Solaris, Linux, RS6000)
*written by C++ with OSF/Motif 1.2
*freeware 
*obtainable from any ftp.x.org site (/contrib/devel_tools/OOD)
	and from ASSET project
*a little unreliable
Prof. Taegyun Kim (ktg@taejo.pufs.ac.kr)
Pusan Univ. of Foreign Studies
55-1 Uam-Dong Pusan 608-738 Korea
82 (051) 640-3178

Objectory 
---------
*Jacobson notation.
*Generates C++, CMM support.
*Windows, Unix, 4 configurations, $5000.00 - $10000.00 (USD)
Objective Systems SF AB
Torshamnsgatan 39, 
Mail Box 1128, S-164 ss
Kista
Sweden
support@os.se

ObjectTeam (also Teamwork)
--------------------------
*Shlaer/Mellor, Rumbaugh (a "special edition" of Paradigm Plus)
*SQL, ADA, Smalltalk, C, and C++ generation
*VAX/VMS, Unix, OS/2, PC-DOS  Rumbaugh: PC($4000)/Unix($8000),
*SM: Unix (1 at a time) 
*Demo Tutorial, Eval copies.  ATM example + others.
Cadre Technologies, Inc
222 Richmond St.,
Providence, RI
(401) 351-5950
(401) 455-6800 (fax)

OEW (Object Engineering Workbench)  
----------------------------------
*Martin/Odell object diagrams
*generates C++ (templates unless supplemented with C coded methods)
*reverse engineers C++
*Sun OS, PC Windows 3.x ($99-$2190)
Innovative Software GmbH
Niddastr. 66-68
6000 Frankfurt/M 1
Germany
+49 60 236 929
+49 69 236930 (fax)

OOTher
------
*Coad/Yourdon OOA, FSM(subset of SDL), Jacobson's Use Case and Object
* Interaction diagrams.  Consistency, C++ header gen. from OOA.
*MS-Windows 3.1
*Freeware for students/schools/home users. Corp 1-5 Shareware (USD $170).
*See Appendix E, entry 67
Roman M. Zielinski <conrozi@kk90.ericsson.se>
Tre Kaellors Vaeg 7
S-145 65 Norsborg
Sweden

OMW (Object Management Workbench)
---------------------------------
*draws and executes from Martin/Odell diagrams
*produces fully executable ANSI C environment
*UI construction facilities, "object engine" for managing objects
*AI "rule engine" for managing rules 
*interfaces with multiple databases
*Unix; generated code runs on any ANSI C environment ($5,000-25,000) 
IntelliCorp
1975 El Camino Real West 
Mountain View, CA  94025 
(415) 965-5500
(415) 965-5647 (fax)

OMTool (see also StP/OMT)
--------------------------
*OMTool(tm) version 2.0 (Object Modeling Tool, Rumbaugh) PC-based graphical
 tool for OO analysis and design. graphical prep and editing of object models
 for systems, programs, databases using the OMT.
*8MB mem/math coproc(16MB without), Windows 3.1, Mouse, Hard Disk with 4 MB of
 available disk space, 386 CPU, Video Graphics Adapter.
*Price: $995.00 US.
Martin Marietta Advanced Concepts Center
640 Freedom Business Center
King of Prussia, PA 19406
  +1 (610) 992-6200, 
  +1  800  438-7246, 
  +1 (610) 992-6299  (FAX) 
  
OSMOSYS
-------
*OOA and OOD for OSMOSYS
Winter Partners
London Office:                 Zurich Office:
  West Wing, The Hop Exchange
  24a Southwark Street           Florastrasse 44
  London SE1 1TY                 CH-8008 Zurich
  England                        Switzerland
  Tel. +44-(0)71-357-7292        Tel. +41-(0)1-386-95 11
  Fax. +44-(0)71-357-6650        Fax. +41-(0)1-386-95 00

Paradigm Plus
-------------
*CASE toolset supporting Booch(new), Coad/Yourdon, EVB, and others.
*configurable meta-CASE tool
*Rev eng code.  Gen code templates.  Incr code gen next release, year end.
*Windows: Fixed/1 machine, $3995, maint $599. Floating/net $4995, maint $750.
*Unix: $7770, $1155 maint.    Multiple discounts.
*Eval, Demo, 30 day eval copy.
Protosoft
17629 El Camino Real 202
Houston TX 77058
713 480 3233
Fax 713 480 6606

Prosa/om
--------
*Coad/Yourdon notation
*Generates C++, SQL
*Windows, OS/2,  Motif 
Prosa Software
Kirkkokato 5 B
SF-90100 Oulu, FInland
+358 (81) 376-128
+358 (81) 371-754

Ptech
-----
*Martin/Odell notation
*modifiable meta-model
*supports Martin/Odell notation, "data model is the database", C++ and Ontos
 or Objectivity code generation (fully executable code), formal foundation
*Unix, ($5,000-25,000)
Ptech, Inc.
200 Friberg Parkway
Westborough, MA 01581  USA
(508) 366-9166

Rational Rose
-------------
*Booch notation OOA/D
*generates C++
*Unix, AIX ($749-5,249)
*(PC version formerly sold by Palladio Software)
Rational
3320 Scott Blvd.
Santa Clara, Ca.  95054
(408) 496-3700
Also:
*C++ Booch Components 1-800-767-3237 ext. 23

S-CASE
------
*Booch-93 notation
*generates C++ headers and stubs
*project management aids, multi-user
*Windows, OSF/Motif, Open Look, Macintosh ($249-995)
MultiQuest Corp
1699 E. Woodfield Rd Suite A-1
Schaumburg, IL  60173
(708) 240-5555, (708) 240-5556 (fax)

Select OMT
----------
*Rumbaugh notation
*generates C++
*Windows ($695)
Select Software Tools, Ltd
1526 Brookhollow Dr.
Santa Ana, CA  92705
(714) 957-6633; (714) 957-6219

SES/Objectbench
---------------
*Shlaer/Mellor notation, supports GUI and database links editors, browsers,
 test utilities, and statistical analysis for simulation development.
 Emphasizes importance of model animation to functionally verify the analysis.
*generates C++
*Macintosh, MS-DOS, UNIX ($4,900 to $24,300)
Software & Engineering Software (SES)
4301 Westbank Dr., Bldg A, Austin, TX 78746
(512) 328-5544, (512) 327-6646 (fax)

Stood
-----
*HOOD (version 3.1) notation, supports Ada, C, C++
*Unix, RISC, X windows
Techniques Nouvells d'Informatique
Technopole Brest-Iroise
ZI du Vernis, Case postale 1
29608 Brest Cedex, France
+33 9 8052744, +33 9 849-4533 (fax)

StP/OMT - Software through Pictures
-----------------------------------
*Member of StP family of integrated multi-user software development tools.
 Developed jointly by MM ACC and IDE. Open architecture, object- and system-
 level designs, reuses existing class structures to build applications.
 Stand-alone or part of OMT Success Packages which combines training,
 consulting, mentoring, and maintenance in addition to software.  Shared
 repository, version control and locking, code and document generation.
*StP/OMT runs on; AIX, DECstation, RS/6000, Sun OS, SPARCstation, HP 700/800,
 and Sun Solaris.
*Price: $12,000.00 US
Interactive Development Environments.
595 Market Street, 10th Floor
San Francisco, CA 94105
+1 (415) 543-0900, 
+1  800  888-4331

System Architect
----------------
*Booch, Coad/Yourdon, Shlaer-Mellor.
*design portion specific to Smalltalk, Ada, Object Pascal, and C++
*dialogues and menu management (Windows, C, C++),  DB views (SQL, C++),
 other (C++)
*Windows ($1395, single User), OS/2($1795, base).
Popkin Software
11 Park Place
New York, NY  10007
(212) 571-3434
(212) 571-2426 (fax)

Toolbuilder
-----------
*many notation (IE, HOOD, SSADM, Shlaer-Mellor)
*configurable meta-CASE tool
*executable code generation of C, C++, Cobol, ADA (via enhanced design-level
 action diagrams) and Motif and Open Look
*interfaces  to Sybase, Oracle, Informix
*Sun Sparc, Apollo, HP 9000, DECstation, RS6000 ($17,000)
IPSYS Software
28 Green St.
Newbury, MA 01951
(508) 463-0006
IPSYS Software plc
Marlborough Court
Pickford Street
Macclefield, Cheshire 
SK11 6JD  U. K.
+44 (625) 616722

TurboCASE
---------
*ER diagrams and state charts
*design portion supports class hierarchy, collaboration
*Macintosh ($995)
StructSoft
5416 156th Ave SE
Bellevue, WA  98006
206-644-9834

VIEWS-SF
--------
*supports VSF's extensive approach (including rules) some of which are based on other popular notations
*C++ template generation, reverse engineerings 
*OS/2, Unix ($8,000--$23,500)
Virtual Software Factory, Inc
13873 Park Center Rd, #218
Herndon, VA  22071
(703) 318-1180

Westmount I-CASE OMT
--------------------
*Rumbaugh notation
*generates SQL and C++
*multi-developer
*WIndows
*Open repository (Informix, Ingres, Sybase)
*Documentation and report generation
Westmount Technology B.V.
Olof Palmestraat 24
P.O.Box 5063
2600 GB  DELFT
The Netherlands
Tel. (+31) (0)15 - 141212
Fax. (+31) (0)15 - 120267
Westmount USA Inc.
1555 Wilson Blvd.,
Suite 300,
Arlington, VA 22209,
U.S.A.
Tel. (+1) 703 875 8799
Fax. (+1) 703 527 5709


ARTICLES, PRODUCTS, AND PAPERS ON CASE SYSTEMS
----------------------------------------------

> "CASE Products 1990: A survey of CASE Products from US Vendors",
  Arbeitspapiere der GMD 518, March, 1991.  Heinz W. Schmidt,

Ovum Ltd
1 Mortimer Street
London W1N 7RH
England
Tel: +44 71 255 2670
Fax: +44 71 255 1995

From: oil@idt.unit.no (Odd Ivar Lindland)
Subject: Re: CASE Survey
Organization: Norwegian Institute of Technology, University of Trondheim
Date: Fri, 9 Jul 93 06:57:25 GMT
>...
A comprehensive survey of 35 commercial CASE tools is given in 
"Ovum evaluates: CASE products". It is from 1993 and is continuously updated. 
It has all the information you asked for. The bad thing is that it is very
expensive ($1995 !!!). You should get a 40 % academic discount, however.
Moreover, recently they had a "quick-answer discount" making the full price
(before academic discount) $1295. Anyway, I believe it is good investment if you
quickly want to have comprehensive information about the current CASE market.
Particularly valuable is the comparative evaluation of the 35 products.


> Proceedings of the Workshop on the Next Generation of CASE Tools (NGCT)

From: sjbr@cs.utwente.nl (Sjaak Brinkkemper)
Subject: 
Organization: University of Twente, Dept. of Computer Science
Date: Fri, 9 Jul 1993 11:05:51 GMT

The proceedings of the Fourth Workshop on the Next Generation of
CASE Tools (NGCT'93) are available as a technical report from the
Center for Telematics and Information Technology, University of
Twente.

Price: Nfl 45, US$ 25 (including shipping and money transfer)

Order by sending a message including a POSTAL ADDRESS to:
Sjaak Brinkkemper
CTIT
E-mail: sjbr@cs.utwente.nl

*******************************************************
*      Proceedings of the Fourth Workshop on the      *
*           Next Generation of CASE Tools             *
*     Universite Paris 1 Sorbonne - 7/8 June 1993     *
*******************************************************

Editors: S. Brinkkemper and F. Harmsen
Center for Telematics and Information Technology
University of Twente
the Netherlands
174 pages

Abstract

The Workshop on the Next Generation of CASE Tools (NGCT) is an
annual event, bringing together leading researchers on Computer
Aided Software Engineering (CASE). NGCT workshop is a pre-conference
workshop of the annual Conference on Advanced Information Systems
Engineering (CAiSE). The goal of this year's workshop, held in
Paris, is to conduct an in-depth discussion of research approaches
in the area of Computer Aided Software Engineering. Three main
themes have been identified: 
*       CASE architectures
*       Development process support
*       Advanced requirements engineering
The workshop committee accepted fourteen papers, which are grouped
in the proceedings according to these three themes. Among the topics
of the papers are: multiparadigm specification for interoperable
information systems, capturing design decisions, automated user
interface derivation, deductive repositories, human error analysis,
and business modeling.



APPENDIX E  ANONYMOUS FTP SITES
===============================

These are anonymous ftp sites of interest to the OO community.  Thanks go to
Mike DeVaney (dm_devaney@pnl.gov gen ftp site list) and to Bill Kinnersley
(billk@hawk.cs.ukans.edu, anon ftp programming languages list), whose initial
lists helped to get things going.  Additional short entries are encouraged;
please send additions to the author of the FAQ (and/or to Mike and Bill).

Entries will be standardized and summarized in future FAQs and are not
limited to one category.

Starred entries have a summary below and can be found as ">#" followed by the
description.  These entries will eventually be cleaned up.

PROGRAMMING LANGUAGES
---------------------

ajpo.sei.cmu.edu:/public/ada9x                  Ada-9x info, ARM
cs.nyu.edu:pub/gnat/...                        *Ada-9x (compiler, GNU,50)
ftp.inria.fr:lang/alcool                       *Alcool-90 (dyn ML,1)
arjuna.ncl.ac.uk:/pub/Arjuna                   *Arjuna (Distr Prog System,2)
munnari.oz.au:pub/bebop.tar.Z                  *BeBOP(seq,par,LP,OO,meta,46) 
sales@mjolner.dk                                BETA (Mjolner Informatics Demo)
monch.edrc.cmu.edu:/usr0/snl/archive/bos-1.2   *BOS (prototyping,3)
grape.ecs.clarkson.edu:/pub/msdos/djgpp/djgpp.zip C++ (for MS-DOS)
prep.ai.mit.edu:/pub/gnu/gcc-2.4.5.tar.gz       C++ (for Unix, & Objective-C)
omnigate.clarkson.edu:/pub/msdos/djgpp         *G++ for DOS (Many sites,4)
tsbgw.isl.rdc.toshiba.co.jp:
  pub/toshiba/cooc-beta.1.1.tar.Z              *cooC (Concurrent, OO C ext.,5)
parcftp.xerox.com:pcl                           CLOS
pion.lcs.mit.edu                                CLU (Sun, VAX)
ftp.cs.cornell.edu:/pub/CML-0.9.tar.Z           CML
arisia.xerox.com                                Pcl (Portable CommonLoops)
xcf.berkeley.edu:src/local/fmpl                *FMPL (prototyping,6)
nebula.cs.yale.edu                              Glasgow Haskell
piggy.cs.chalmers.se                            Chalmers Haskell (hbc)
software.watson.ibm.com                         Hermes (Unix)
cs.arizona.edu                                  Icon
sun.soe.clarkson.edu                            ISETL (DOS, Mac, Unix, VMS,src)
cs.orst.edu                                     Little Smalltalk (C src)
ftp.ircam.fr:/pub/IRCAM/programs               *MAX (visual OO,7)
128.59.24.6 (MeldC@cs.columbia.edu)             MeldC (Rflctv, prllel, OO lang)
gatekeeper.dec.com                              Modula-3 (SRC)
cs.uni-sb.de:/pub/osmall/machine               *O'small (OO lang for teaching,8)
obj3dist@csl.sri.com (license or request)      *OBJ3 (OO lang,9)
gate.fzi.de:/pub/OBST                          *OBST (lang, perst, OODB,10)
prep.ai.mit.edu:/pub/gnu/gcc-2.4.5.tar.gz       Objective-C (for Unix, & C++)
128.100.1.192:/pub/ootDistrib                  *OOT (OO Turing demo,11)
neptune.inf.ethz.ch                             Oberon (MacII, SPARC, DECstn)
wuarchive.wustl.edu:/mirrors/msdos/pgmutl/oberon11.zip Oberon (MS-DOS)
ux1.cso.uiuc.edu:pub/amiga/fish/ff380           Oberon (Amiga)
watserv1.waterloo.edu                           occam (VAX sim, Tahoe)
wuarchive.wustl.edu:/mirrors/unix-c/languages/ops5 OPS5 (interpreter)
wuarchive.wustl.edu:/mirrors/msdos/pli/runpli1a.arc PL/I (interpreter)
watserv1.waterloo.edu                           Russell
parcftp.xerox.com:pub/russell                   Russell
ftp.icsi.berkeley.edu:pub/sather               *Sather (was simple Eiffel,12)
altdorf.ai.mit.edu: scm                         Scheme (small, portable)
gatekeeper.dec.com: elk                         Scheme (for Suns)
acorn.cs.brandeis.edu: gambit                   Scheme (for 68K's)
otis.stanford.edu                              *Self (13)
self.stanford.edu                               Self
cs.nyu.edu                                      SETL2 (DOS, OS/2, Mac, Unix)
rascal.ics.utexas.edu                           SIMULA 67 (Mac)
prep.ai.mit.edu:pub/gnu                         Smalltalk-80 (GNU v1.1)
st.cs.uiuc.edu                                 *Smalltalk V (38)
cs.yale.edu:pub/ml                              SML/NJ
research.att.com:dist/ml                        SML (Version 0.75)
sbcs.sunysb.edu                                 SML (lazy)
ucbvax.berkeley.edu                             tcl
tk.telematik.informatik.uni-karlsruhe.de:/pub/tnt/tnt-0.1.tar.gz *Trellis,69
ftp.cs.umu.se:/pub/umlexe01.zoo                 uML

csd4.csd.uwm.edu:/pub/compilers/list            Free Compilers/Interp's list
primost.cs.wisc.edu: pub/comp.compilers/LanguageList*  Bill Kinnersley's list
idiom.berkeley.ca.us: pub/compilers-list/LanguageList*
http://cui_www.unige.ch/langlist                Bill on Prog Langs & contacts
ftp://ftp.wustl.edu/doc/misc/lang-list.txt      (billk@hawk.cs.ukans.edu)

See also Knowledge Media cd-rom collection on Languages, entry 47.


COMPILER TOOLS
--------------

prep.ai.mit.edu:pub/gnu/bison-1.14.tar.Z        Yacc
ftp.th-darmstadt.de:/pub/programming/languages/C++ *C++ gram, etc.,14
  [See also Free Compilers and Kinnersley's List above!]


DATABASES (See also APPENDIX B)
-------------------------------

ftp.informatik.rwth-aachen.de:pub/CB            *ConceptBase (OODB, reqkey,15)
pippin.cs.monash.edu.au:pub/export/diamond-0.1.2.tar.Z  *C++ OODB (16)
wilma.cs.brown.edu/pub/encore.tar.Z              Encore of Brown Univ
ftp.cs.wisc.edu:exodus                          *Exodus (Storage Man, perst,17)
ftp.informatik.rwth-aachen.de:/pub/unix/GRAS522_3 *GRAS (18)
mood.mech.tohoku.ac.jp                          *MOOD   (OODB, lim arch,19)
src.doc.ic.ac.uk:/computing/databases            MOOD/Postgres/OBST copies
gate.fzi.de:/pub/obst                           *OBST/STONE(schema,prst obj,10)
research.att.com                                *Ode    (C++ OODB,20)
postgres.berkeley.edu:pub                       *POSTGRES (Ext. Rel. DBMS,21)
toe.CS.Berkeley.EDU:pub/postgres                *POSTGRES,21
cs.utexas.edu:pub/garbage/{swizz,texaspstore}.ps *Texas Persistent Store,41

See also idiom.berkeley.ca.us:pub/free-databases, object-oriented databases.


TOOLS AND CASE
--------------

ftp.cs.purdue.edu:/pub/gb/*                     *C++ Signatures (subtyping),40
ftp.centerline.com:/pub/tags-1.0.tar.Z          *C++ tags, 23
ftp.th-darmstadt.de:/pub/programming/languages/C++ *Cls bwsr,tmplates,GC,etc,14
ftp.informatik.uni-stuttgart.de:/pub/eiffel     *Eiffel archive, 24
interviews.stanford.edu:/pub/3.1.tar.Z           InterViews 3.1 (C/C++ browser)
export.lcs.mit.edu:/contrib/devel_tools/OOD     *OO Designer CASE Tool,66
OAK.Oakland.Edu:pub/msdos/windows3/oot-106f.zip *OOTher OO CASE Tool,67
wsmr-simtel20.army.mil(192.88.110.20)            OOTool (win31 directory?)
labrea.stanford.edu:/pub/pomoco                 *ORBELINE: CORBA,65
ftp.informatik.uni-stuttgart.de:/pub/eiffel/eiffel-3/sig *short tool, 24
siam.unibe.ch:C++/Sniff1.6/                     *Sniff (C++ devel environ,22)
self.stanford.edu:/pub/sniff                    *Sniff,22


LIBRARIES AND INTERFACES
------------------------

arjuna.ncl.ac.uk                             *C++SIM (Simula-like Sim Pkg,38)
csc.ti.com:pub/COOL.tar.Z                    *COOL(C++, orig from TI,25)
cs.utexas.edu:pub/COOL/GE_COOL2.1.tar.Z      *COOL(C++, Cfront 2.1, from GE,25)
ftp.fu-berlin.de:/pub/unix/languages/cool/cool-2.1.tar.Z *CooL Soft Prod Env,70
omg.org:pub/NEC_DII/93-1-2...                 CORBA (DII)
claude.ifi.unizh.ch:under pub/standards/spec  CORBA Spec
omg.org:pub/OMG_IDL_CFE_1.2/bin              *idl.SunOS4.x, idl.Solaris2.x,26
ftp.cica.indiana.edu:/pub/pc/win3/programr   *MindFrame for Windows,54
ftp.th-darmstadt.de:pub/programming/languages/C++ *NIHCL COOL OATH ET++,etc,14
straylight.acs.ncsu.edu:/pub/ose             *OSE:C++ Prog tools & Class Lib,42
watmsg.UWaterloo.ca:pub/uSystem              *u++:C++ Trans. and Concry RTS,48


DOCUMENTATION AND INFO SERVERS
------------------------------

ftp.ncsa.uiuc.edu:Web/xmosaic or info.cern.ch:pub/www  *Browser for OO info,27
ftp.th-darmstadt.de:/pub/programming/languages/C++ *C++ docs, code, net sums,14
ftp.cm.cf.ac.uk:pub/Eiffel                     Eiffel FAQ
zaphod.uchicago.edu:/pub/faq.8-25[.Z]          OO FAQ (this document)
http://cui_www.unige.ch/OSG/FAQ/OO-FAQ/       *OO FAQ(hypertext version),WWW,27
http://cui_www.unige.ch/OSG/OOinfo/           *OO Information sources on WWW,27
byron.sp.cs.cmu.edu:/usr/anon/OODBMS/evolution-summary OODB Schema Evol Summary
byron.sp.cs.cmu.edu:/usr/anon/OODBMS/Manifesto.{PS,txt}.Z OODB Manifesto


PAPERS
------

ftp.cs.tcd.ie:/pub/tcd/tech-reports                 *Amadeus,persistence,62
scslwide.sony.co.jp:pub/CSL-Papers                  *Apertos (MO Distr OS,28)
sail.stanford.edu:pub/MT/93actors.ps.Z              *Actors Paper (UIUC,29)
biobio.cs.uiuc.edu:directory pub/papers             *Actors Papers,29
euagate.eua.ericsson.se:ftp/pub/eua/c++/rules.ps.Z  *C++ coding standard,44
choices.cs.uiuc.edu                                  Choices OO OS
ftp.chorus.fr:pub/chorus-reports                    *Chorus,Dist,RT,MicroK,63
http://cui_www.unige.ch/Chloe/Oscar/home.html        Concurrency Papers,WWW,27
ftp.ens.fr:/pub/reports/liens/liens-94-18.A4.dvi.Z  *Contra-/Co- Variance,71
ftp.gte.com:pub/dom                                 *Distrib Reports GTE,52
ftp.ifi.unizh.ch: pub/techreports/electra.ps.Z       Electra ORB, sec 3.8.6
cs.utexas.edu:pub/garbage/gcsurvey.ps                Garbage Collection,sec 3.9
wilma.cs.brown.edu:/pub/gdbiblio.{tex,ps}.Z         *graph drawing,31
world.std.com:/pub/kala/TechDocs/Overview_Sun.ps,*  *Kala Archive,45
ftp.ccs.neu.edu:pub/demeter/documents               *Law of Demeter,32
ftp.cs.ualberta.ca:pub/oolog/state.ps.Z              MUTABLE STATE OOPL SURVEY
mushroom.cs.man.ac.uk:/pub/mushroom/papers          *OO Dyn Grping, memory,33
st.cs.uiuc.edu:/pub/papers                           OO Frameworks, R. Johnson
http://pclsys64.dcrl.nd.edu/papers                   OS Papers (OO?),68
http://www.gh.cs.su.oz.au/Grasshopper/index.html     Perst. Operating Systems
cs.washington.edu:/pub/chambers/predicate-classes.ps.Z *Pred Classes (Cecil,34)
ginger.cs.berkeley.edu/pub/raidPapers                RAID Papers  (Berkeley) 
sprite.(cs.)berkeley.edu:~ftp/pub/RAID-II            RAID configs (Berkeley) 
ius4.ius.cs.cmu.edu:/usr/chimera/public/CMU_RI_TR_93_11.ps.Z *Real Time,49
self.stanford.edu:pub/papers/chambers-thesis        *Self Opt,ChambersThesis,30
self.stanford.edu:/pub/papers/hoelzle-thesis.ps.Z   *Self Opt,HoelzleThesis,64
self.stanford.edu:pub/papers/                        Self Papers
vega.dur.ac.uk:/pub/papers/foot.dvi                  Testing OO (sect 3.11)
townsend@mprgate.mpr.ca                              Testing OO (sect 3.11)
ftp.parc.xerox.com:/pub/mops/traces.ps              *Traces,kiczales,MOP,DI,43
neptune.inf.ethz.ch: pub/issac93.ps.Z                Types, Comp alg (Santas)
cui.unige.ch:OO-articles                             U. Geneva OO Group papers
research.microsoft.com:/pub/papers/vdg.ps           *Value Dependence Graphs,57
ftp.cs.utwente.nl:/pub/doc/TRESE                    *Various on OO,58

The Postgres, OBST and Exodus sites also contain a good selection of papers. 
See below for a huge collection of CS bibliographies (about 290,000) including
references on OO.  Contact: Alf-Christian Achilles <achilles@ira.uka.de>
  FTP: ftp.ira.uka.de[129.13.10.90]:pub/bibliography
  WWW: http://www.ira.uka.de/ftp/ira/bibliography/index.html



GENERAL
-------

ics.uci.edu:gnu/C++_wrappers.tar.Z    *ACE Lib, C++ Networking,55
scslwide.sony.co.jp:pub/CSL-Papers    *Apertos(Meta-Obj Distr OS, research,28)
euagate.eua.ericsson.se:ftp/pub/      *Archive site,C++,Coplien,papers,etc,44
research.att.com:dist/drawdag/*.Z     *Graph service,37
parcftp.parc.xerox.com:/pub/ilu/ilu.html *ILU OMG CORBA,59
netcom.com:/pub/softia/keobj.zip      *KEOBJ, OO DSP micro-kernel,53
ftp.th-darmstadt.de:/pub/programming/languages/C++ *lots for C++,14
st.cs.uiuc.edu                        *Manchester Archive and some,35
ftp.odi.com:/pub/oo7/results.ps       *Object Design's OO7 Results,36
ftp.gmd.de:gmd/peace                   Peace, OO parallel OS
http://www.taligent.com                Taligent
wuarchive.wustl.edu:languages/ada/crsware *Teaching OO Course Slides,51
cs.orst.edu:pub/budd/oopintro/slides/* *Teaching Intro to OO Slides, T. Budd,56
gatekeeper.dec.com:/pub/usenet/com.sources.unix/volume20/metrics *Metrics,61


OTHER
-----

Knowledge Media                       *Big col. on cd-roms, lots of freeware,47
Computer Select Database              *commercial on cd-rom,39
Walnut Creek                          *Internet Info CDROM, including FAQs,60
godot.uvic.ca:/pub/oopsla-93           OOPSLA-93 Info


DESCRIPTIONS
------------

>1  Alcool-90 (dyn ML)

What: Alcool-90 Release 0.40.3
From: rouaix@inria.fr (Francois Rouaix)
Date: 18 May 92 09:36:22 GMT

Alcool-90 is an experimental extension of ML with run-time overloading and
a type-based notion of modules, functors and inheritance.

New constructs have been added:
        * Overloaded symbols (overload).
        * Local definition of abstract values (overload in).
        * Implementations and parametric functors (pack to). 
        * Extension functors (overload with).
        * Class-based Dynamics (dynamic).

This version of Alcool is based on the CAML Light implementation (release
0.4) of the ML language, but this release is autonomous.

Alcool-90 is available by anonymous FTP from ftp.inria.fr:

    host:      ftp.inria.fr  (128.93.1.26)
    directory: lang/alcool
    files:
     README                 Copyright information.
     alcool270492.tar.Z     Sources for Un*x machines (Apr 27 1992 Release).
     alcooldoc.dvi.tar.Z    DVI for the Alcool-90 report draft.

For questions, comments, bug reports, please e-mail to Francois.Rouaix@inria.fr


>2  Arjuna (Distr Prog System)

What: Release 2 of Arjuna Distributed Programming System
From: arjuna@newcastle.ac.uk (Arjuna Project)
Date: Mon, 17 May 1993 12:37:34 GMT

        We are pleased to announce the  availability  of a new  version 
of Arjuna:  a programming system for  reliable  distributed  computing, 
and the Arjuna mailing list.

        The software  and the manual  for  the  Arjuna  system  can  be 
obtained by anonymous ftp: arjuna.ncl.ac.uk (128.240.150.1)

Arjuna System

        This beta release of  ArjunaPR2.0  fixes all known bugs present 
in ArjunaPR1.2B that have  been  reported to us or  that we have found, 
and contains only minimal information about how to use the new features 
provided.   This  release  should  be  compilable  with  the  following 
compilers:

        AT&T Cfront Release 2.1, on SunOS 4.1.x,
            (using Sun supplied lex and yacc).
        AT&T Cfront Release 3.0.1, on SunOS 4.1.x and Solaris 2.1,
            (using Sun supplied lex and yacc).
        GCC versions 2.1, 2.2.2, on SunOS 4.1.x,
            (using flex(v2.3.x) and bison).
        Patched GCC version 2.3.3 on SunOS 4.1.x and Solaris 2.1,
            (using flex(v2.3.x) and bison).
        Sun C++ 2.1, on SunOs 4.1.x,
            (using Sun's lex++ and yacc++).
        HP  C++ (B2402 A.02.34), HP-UX 8.07,
            (using HP supplied lex and yacc or lex++ and yacc++).

The major new features are:

        - Faster object store.
        - Support for replicated objects.
        - Memory resident object store.
        - Support for ANSAware (not available via ftp)

        Arjuna supports nested atomic actions (atomic transactions) for 
controlling operations on objects (instances of C++ classes), which can 
potentially be persistent. Arjuna has been implemented in C++ to run on 
stock  platforms  (Unix  on  SUNs,  HPs  etc).  The  software available 
includes  a C++  stub generator  which hides  much  of the  details  of 
client-server  based  programming,  plus  a system  programmer's manual 
containing  details of  how  to  install  Arjuna and  use it  to  build 
fault-tolerant  distributed  applications.  The software and the manual 
can be obtained by anonymous ftp: arjuna.ncl.ac.uk (128.240.150.1)

        Several  enhancements   and   ports  on   various   distributed 
computing platforms are in progress.  We would be pleased  to hear from 
researchers and teachers  interested in using Arjuna.  The programmer's 
manual  contains the  e-mail  addresses for sending  your  comments and 
problem reports.

ANSAware version of Arjuna

The ANSAware version of Arjuna is available from:

Architecture Projects Management Limited
Poseidon House
Castle Park                                  Phone    +44 223 323010
Cambridge                                    Fax      +44 223 359779
CB3 0RD                                      Internet apm@ansa.co.uk
United Kingdom                               UUCP     ...uknet!ansa!apm

Arjuna Mailing List

To enable us to  help people using Arjuna,  an electronic mail list has 
been setup. You can join  the Arjuna mailing list  by sending an e-mail 
message to "mailbase@mailbase.ac.uk" containing:

join arjuna <Your Name>

For example : join arjuna John Smith

Mail  messages  can  then   be  sent  to  "arjuna@mailbase.ac.uk",  for 
distribution.


Arjuna Project Team
The Department of Computing Science,
The University,
Newcastle upon Tyne.
NE1 7RU, UK.

Fax:           +44 91 222 8232
e-mail:        arjuna@newcastle.ac.uk
anonymous ftp: arjuna.ncl.ac.uk (128.240.150.1)

EMAIL = arjuna@newcastle.ac.uk
POST  = Computing Laboratory, The University, Newcastle upon Tyne, UK NE1 7RU
VOICE = +44 91 222 8067         FAX = +44-91-222-8232

Subject: Arjuna papers announcement
Date: Tue, 8 Jun 1993 16:47:02 GMT

This is to announce the availability of most Arjuna related papers and
theses via anonymous ftp from arjuna.ncl.ac.uk. These papers are
available in both US Letter and European A4 standards in postscript and
should now print on systems. Any problems in printing should be directed to
arjuna@newcastle.ac.uk.

Since there are too many papers to describe in one posting there is an index
available in /pub/Arjuna/Index which contains the abstracts from all of
the papers/theses and their locations within the ftp hierarchy.


>3  BOS (prototyping)

What: BOS
From: Sean.Levy@cs.cmu.edu
Date: 23 Apr 92 18:07:32 GMT

[For readers of comp.object and self-interest, BOS is a prototype-based
object system that I have, er, prototyped in Tcl. It is available via anon
FTP to monch.edrc.cmu.edu under /usr0/snl/archive/bos-1.2.tar.Z (you have to
cd to /usr0/snl/archive first and then get the file, due to CMU security hacks
in ftpd). I thought that this would be of interest to comp.object and
self-interest, so I'm cross-posting/mailing --S]

Note: I play very fast and loose with the terminology of OOP to get my
point across. I apologize if I offend any sensibilities, and will clarify what
I say if it is obfuscated by my use of terms.


>4  G++ for DOS (Many sites)

:From: DJ Delorie <dj@ctron.com>
:Newsgroups: gnu.announce,gnu.misc.discuss

:               DJGPP 1.10 is now available!
                         :
                         :
:               --- DJGPP - G++ for MSDOS/386 ---

:djgpp is normally uploaded to:
:  omnigate.clarkson.edu                 128.153.4.2     pub/msdos/djgpp
:  math.utexas.edu                       128.83.133.215  pub/msdos/djgpp(*)
:  ftp.uni-koeln.de                      134.95.128.208
:                                                       msdos/gnuprogs/djgpp (*)
:  ftp.eb.ele.tue.nl                     131.155.40.15
:                                                       pub/pc/gnu/gcc-pl* & gcc-newst
:  wowbagger.pc-labor.uni-bremen.de      134.102.228.9   pub/msdos/djgpp
:  src.doc.ic.ac.uk                      146.169.2.1     ibmpc/djgpp
:  ftp.mcc.ac.uk                         130.88.200.7    pub/djgpp
:  UK.AC.MCC.FTPJ (JANET)                user<guest>     <PUB>djgpp

:(*) Please do not access during working hours (7am - 6pm their local time)


>5  cooC (Concurrent, OO C ext.)

From: maeda@isl.rdc.toshiba.co.jp (Ken-ichi Maeda)
Subject: cooC FTP release (2nd posting)
Date: 2 Jul 93 15:13:11
Organization: TOSHIBA R & D Center, Kawasaki, JAPAN.

        We are pleased to announce the release of new object oriented
language based on C.  The language has support for concurrent object
execution with synchronous or asynchronous message pssaing and wait when
necessary reply handling.  The language known as cooC (concurrent object
oriented C) is available by anonymous FTP for research purposes.

        FTP Site:  tsbgw.isl.rdc.toshiba.co.jp (133.196.1.11)
        File: pub/toshiba/cooc-beta.1.1.tar.Z

        The released version of cooC employs SunOS(TM) LWP (light weight
process), to obtain concurrent execution.  The release consists of the
language translator (cooC->C), a runtime library (SunOS(TM)), a
concurrent object based debbuger, an example groupware application
(SharedDraw) and some technical papers.

BECAUSE THE SYSTEM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY FOR
ANY PART OF THE SYSTEM.

        TOSHIBA Corporation while making cooC free for research, retains
copyright.

        For further detail, please refer to COPYRIGHT notice in the
package.

        Any questions and/or comments are welcome at the following
e-mail address.

        cooc@isl.rdc.toshiba.co.jp

--
--------------------------------------------------------------------
Ken-ichi Maeda <maeda@isl.rdc.toshiba.co.jp>
Communication and Information Systems Research Lab. II
TOSHIBA Research & Development Center
1, Komukai Toshiba-cho, Saiwai-ku, Kawasaki 210, JAPAN
TEL. (+81- or 0)44-549-2237  FAX. (+81- or 0)44-520-1841
--------------------------------------------------------------------


>6  FMPL (prototyping)

What: Interpreter for FMPL of Accardi, Release 1
From: blojo@xcf.berkeley.edu (Jon Blow)
Date: 2 Jun 92 08:42:26 GMT

An interpreter for FMPL of Accardi, Release 1 is now available for ftp at 
xcf.berkeley.edu:src/local/fmpl/.

*FMPL is a prototype-based object-oriented programming language.
*FMPL possesses lambda-calculus based constructs.
*FMPL is an event-driven language; the events it responds to are mainly
based on the behavior of input/output streams, not only within the unix domain
but across the internet as well.
*FMPL supports "pretty"-printing of internally-represented code back into
readable form.
*FMPL is an experimental language developed at the Experimental Computing 
Facility of the University of California, Berkeley.  This release is something
of a beta test since the language has not been widely used outside Berkeley.
It is hoped that this release will draw useful comments and suggestions from
the world at large that will help in improving future versions of FMPL.


>7  MAX (visual OO)

From: fingerhu@ircam.fr (Michel Fingerhut)
Subject: IRCAM DSP software for DEC/ALPHA and DEC/MIPS
Organization: Inst. de Recherche et Coordination Acoustique/Musique, Paris
Date: Fri, 13 Aug 93 11:25:23 GMT

ftp.ircam.fr:/pub/IRCAM/programs contains some of the IRCAM-developed
software packages (in demo version; see further down for availability
of the fully functional versions), including runnable binaries for
both the DEC/ALPHA (osf1) and DEC/MIPS (ultrix) architectures, and soon
available on other platforms (SGI and Macintosh).

MAX

MAX is a visual, object-oriented, programming language, initially
designed for interactive musical performance, but which is suitable for
digital signal processing as well as real-time control.  It allows
interconnecting of oscillators and filters, building custom controller
modules and simulation units all from a core collection of signal
processing objects.

First developed by Miller Puckette at IRCAM in late 1986 to control
the IRCAM 4X, it was later implemented on the Apple Macintosh as a
graphical programming environment for MIDI applications.  This version
has been extended by the Opcode company in Palo Alto, CA (USA), and is
available through them.

The Alpha version (and its demo-only subset) is based on the NeXT
version, where it is used to control the IRCAM-designed ISPW board.
This card, based on two Intel i860 microprocessors, handles
numerically-intensive real-time operations.

To date, it has been extensively used in live performance of
full-length musical compositions (see some references in the MAX/doc
directory), as well as in scientific and experimental applications
requiring real-time control.

SVP

SVP (``Super Vocodeur de Phase'') is a signal processing tool which was
designed and developed at IRCAM by Gilles Poirot and Philippe
Depalle.  It is a full system for the analysis and synthesis of sound,
whose core is a phase vocoder, and which comprises several modules for
analysis (FFT, LPC..), filtering (band modes, surface modes...), time-
scaling, mixing, spectral combination, cross-synthesis and
amplification, which can be combined in multiple ways.

UDI

UDI is a library of C routines which provides a coherent software
approach for developing and maintaining digital signal processing
algorithms on stand-alone workstations or on host/array processor
configuration.  Initially designed for sound signal analysis and
synthesis, it can be used by any application which does vector math
calculation.

It provides functions ranging from elementary vector and matrix
operations to more specific DSP operations, such as, but not limited
to, FFT, least-square, linear prediction coding, discrete cepstrum and
pitch detection.

UDI was actually used in implementing SVP.

HOW TO RETRIEVE

The following example contains underlined text.  If it does not print
nicely, use your favorite editor in order to remove all occurrences of
"^H_" (control-H followed by underscore).

Connect via ftp to ftp.ircam.fr.  Engage into the following dialog (the
underlined text is the reply you should provide

        220 ftp FTP server (Version 6.17 Thu Mar 11 08:30:51 MET 1993) ready.
        Name (ftp:host): f_t_p_            (or: a_n_o_n_y_m_o_u_s_)
        Passwd: l_o_g_i_n_@_y_o_u_r_m_a_c_h_i_n_e_       (see NOTE further down)
        230-...
        230-(informational messages, please read!)
        230-...
        ftp> c_d_ _p_u_b_/_I_R_C_A_M_/_p_r_o_g_r_a_m_s_
        250 CWD command successful.
        ftp> g_e_t_ _R_E_A_D_M_E_
        200 PORT command successful.
        150 Opening ASCII mode data connection for README (nnn bytes).
        226 Transfer complete.
        local: README remote: README
        nnn bytes received in mmm seconds (xxx Kbytes/s)
        ftp> b_i_n_
        200 Type set to I.
        ftp> g_e_t_ _s_v_p_._t_a_r_._g_z_             (or u_d_i_._t_a_r_._g_z_ or m_a_x_._t_a_r_._g_z_)
        ...
        ftp> q_u_i_t_

NOTE

The ftp server requires you to give as password something of the form
        l_o_g_i_n_@_h_o_s_t_
where l_o_g_i_n_ is your login name (or account name, or user information)
and h_o_s_t_ is the fully-qualified name of the machine you are currently calling
from, which is not necessarily the one on which you get your mail.  If you
mistype it, the ftp server will advise you with an informative error message.

AVAILABILITY

For information on availability of these and other IRCAM tools with
full functionality and documentation, and/or licensing of source code,
as well as IRCAM publications (technical/scientific reports) please contact
(in french or english, preferably):

        Mr. Vincent Puig
        Directeur de la Valorisation
        IRCAM
        31, rue Saint-Merri
        F-75004 Paris, France

        email:  puig@ircam.fr
        FAX:    +33 1 42 77 29 47

Additional info can be found in the README file in the above directory.

REPORTING PROBLEMS AND GETTING HELP

... in retrieving the software and/or in running it: please send email to

        manager@ircam.fr



>8  O'small (OO lang for teaching)

From: hense@sol.cs.uni-sb.de (Andreas Hense)
Subject: *** NEW O'small compiler available by ftp !!! ***
Date: 25 Jun 1993 13:54:35 GMT
Organization: Universitaet des Saarlandes,Rechenzentrum

             O'small - THE object-oriented language for teaching
             ---------------------------------------------------
                       (Announcement of a new compiler)

*** An object-oriented language for teaching?

Depending on which aspects of object-orientation you want to convey you
may choose your teaching language. If you want to teach the aspect of
software reuse and nice graphical user interfaces, you should choose
Smalltalk. If you want to show students how to program in a best
selling language you should choose C++.


*** In which case should I choose O'small?

You should consider O'small if you believe that computer languages
should have a GOOD FORMAL SEMANTICS. Everyone will agree that a
language needs a formal semantics. Otherwise, your program will yield
different results on different implementations. A good formal
semantics does not only serve the purpose of precisely defining what
the results of your programs are, it also gives insights about the
nature of the language. 

You should consider O'small if you do not want to waste time on
unnecessary details. O'small is CONCISE. Its syntax and semantics
takes no more than one page (if you choose the right font). Its syntax
is similar to more traditional languages. O'small has been used in a
lecture showing the differences between wrapper semantics
(denotational) and method lookup semantics (operational). 

O'small is FREE! Up to now, there has only been an O'small interpreter
written in Miranda [Hen91b]. This interpreter is directly based on the
denotational semantics of O'small [Hen91d]. The interpreter itself is
available by ftp. However, you need Miranda in order to run it. Now,
there is a NEW IMPLEMENTATION of O'small based entirely on EASILY
AVAILABLE SOFTWARE. This software is not free but it does not cost
anything. The new implementation is based on an abstract machine [Boe93].

You can MODIFY the language and have your students make experiments
with it. The source code of the abstract machine and the
specifications for the parser and scanner generators are available.
Using these generators you can make experiments for your own research
in statical analysis of object-oriented languages.


*** I would like to TRY O'small

You get the implementation by anonymous internet ftp.
The following table gives the ftp connection information.

Host:                   Net Address:      Directory:
-------------------------------------------------------------
cs.uni-sb.de            134.96.7.254      /pub/osmall/machine

The directory /pub/osmall/machine contains the files
        README 
        ANNOUNCE                this file
        HowToGetML 
        oma.1.00.tar.Z          compressed tar-file


***************************************************************************
NOTE: Ftp should be put into binary mode before transferring the compressed
tar file.
***************************************************************************

Here is a sample dialog:

   ftp
   ftp> open cs.uni-sb.de
   Name: anonymous
   Password: <your name>
   ftp> binary
   ftp> cd /pub/osmall/machine
   ftp> get README
   ftp> get ANNOUNCE
(  ftp> get HowToGetML  )
   ftp> get oma.1.00.tar.Z
   ftp> close
   ftp> quit

If you have a Sun 4 or a SPARC you can use the existing executable files.
Otherwise, you need 'sml-yacc', 'sml-lex' and 'sml-noshare'. Read
'HowToGetML' to obtain them.

Instructions on using the machine are contained in the file README.

From ankh.iia.org!babbage.ece.uc.edu!news.kei.com!bloom-beacon.mit.edu!senator-bedfellow.mit.edu!faqserv Wed Nov 23 21:57:36 1994
Path: ankh.iia.org!babbage.ece.uc.edu!news.kei.com!bloom-beacon.mit.edu!senator-bedfellow.mit.edu!faqserv
From: Bob Hathaway <rjh@geodesic.com>
Newsgroups: comp.object,comp.answers,news.answers
Subject: Comp.Object FAQ Version 1.0.7 (10-27) Part 8/10
Supersedes: <object-faq/part8_782395740@rtfm.mit.edu>
Followup-To: comp.object
Date: 29 Oct 1994 11:42:31 GMT
Organization: Geodesic Systems
Lines: 1509
Approved: news-answers-request@MIT.Edu
Distribution: world
Expires: 12 Dec 1994 11:40:18 GMT
Message-ID: <object-faq/part8_783430818@rtfm.mit.edu>
References: <object-faq/part7_783430818@rtfm.mit.edu>
NNTP-Posting-Host: bloom-picayune.mit.edu
Summary: Frequently Asked Questions (FAQ) List and Available Systems For Object-Oriented Technology
X-Last-Updated: 1994/10/28
Originator: faqserv@bloom-picayune.MIT.EDU
Xref: ankh.iia.org comp.object:7433 comp.answers:4423 news.answers:13682

Archive-name: object-faq/part8
Last-Modified: 10/27/94
Version: 1.0.7

References

[Boe93]  Christoph Boeschen.  Christmas - An abstract machine for
         O'small.  Master's thesis, Universit"at des Saarlandes, 
         Fachbereich 14, June 1993.

[Hen91b] Andreas V. Hense.  An O'small interpreter based on denotational
         semantics.  Technical Report A 07/91, Universit"at des Saarlandes,
         Fachbereich 14, November 1991.

[Hen91c] Andreas V. Hense. Type inference for O'small. Technical Report A
         06/91, Universit"at des Saarlandes, Fachbereich 14, October 1991.

[Hen91d] Andreas V. Hense.  Wrapper semantics of an object-oriented pro-
         gramming language with state. In T. Ito and A. R. Meyer, editors,
         Theoretical Aspects of Computer Software, volume 526 of Lecture No-
         tes in Computer Science, pages 548-568. Springer-Verlag, September
         1991.

[Hen93]  Andreas V. Hense.  Denotational semantics of an object-oriented
         programming language with explicit wrappers.  Formal Aspects of
         Computing, 5(3), 1993. to appear.

[HS92]   Andreas V. Hense and Gert Smolka.  A verification of extensible
         record types.  In Zhongzhi Shi, editor, Proceedings of the IFIP
         TC12/WG12.3 International Workshop on Automated Reasoning,
         pages 137-164, Beijing, P.R. China, 13-16 July 1992. Internatio-
         nal Federation for Information Processing, Elsevier, North-Holland,
         Excerpta Medica.

[HS93]   Andreas V. Hense and Gert Smolka.  Principal types for object-
         oriented languages. Technical Report A 02/93, Universit"at des Saar-
         landes, Fachbereich 14, June 1993.


>9  OBJ3 (OO lang)

What: Release 2.0 of OBJ3 (needed for FOOPS and OOZE, concurrent OOP)
Date: Thu, 4 Jun 92 15:07:26 BST
From: Paulo.Borba@prg.oxford.ac.uk

OBJ is available from SRI, see the message below; prototypes implementations of
FOOPS (without the concurrent extension) and OOZE are due to the end of the
year, but for both you also need OBJ. 

Unfortunately, I don't have any document about the FOOPS extension now, but
probably by the end of the year. I will send it to you as soon as possible.


What: Release 2.0 of OBJ3 is now available
From: winkler@csl.sri.com (Timothy Winkler)
Date: 6 Apr 92 08:35:40 GMT

Release 2.0 of OBJ3 is now available!

Improvements in this version include some language extensions and additional 
theorem proving features.  In addition, an effort has been made to speed up
the implementation; rewriting is often twice as fast as in the original
implementation.  We are including the AKCL patches from the University of
Texas at Austin in the distribution, which are necessary for maintaining the
portability of OBJ3 and also improve its efficiency.  In addition, we are
distributing a SPARC version of OBJ3.

OBJ3 has pattern matching modulo associativity, commutativity, and identity.
New: the system automatically computes conditions for rules involving matching
modulo identity that are used to prevent obvious non-termination problems.

Also new to this version of OBJ3 is a facility for controlled rewriting. This
provides substantially increased support for the use of the system for
equational theorem proving.

To receive the OBJ3 distribution tape or an OBJ3 license, send a request
to:

           Judith Burgess (OBJ3)
           Computer Science Laboratory
           SRI International
           333 Ravenswood Ave.
           Menlo Park, CA 94025-3493, USA

        Telephone: (415) 859-5924
        Fax: (415) 859-2844
            email: obj3dist@csl.sri.com

Be sure to give us your postal mailing address.  Then we will send you the
OBJ3 Information Form, and License Agreement, with instructions on how to
fill them out.  (A KCL license form will also be included.)  When you return
them to us, appropriately filled out and signed, we will send you the tape,
somedocumentation, and, in case you are requesting a tape, an invoice for
$150.00 plus any required taxes.

If you already have an OBJ3 license, then you don't need to get a new license,
but, if you are requesting a tape from SRI, you are asked to pay the above
distribution fee.

It is also possible to get a license for OBJ3 at no charge from SRI and then
get the OBJ3 distribution itself from some third party also having a license.

Jose Meseguer, Timothy Winkler, and Patrick Lincoln
Computer Science Laboratory
SRI International
333 Ravenswood Avenue
Menlo Park, California 94025, USA

Joseph Goguen
Programming Research Group
Computing Laboratory
Oxford University
11 Keble Road
Oxford OX1 3QD, United Kingdom


>10  OBST (lang, perst, OODB)

See entry under Appendix B.


>11  OOT (OO Turing demo)

What: OOT
From: holt@turing.toronto.edu (Ric Holt)
Date: 26 Apr 93 20:14:43 GMT

OBJECT ORIENTED TURING: DEMO AVAILABLE VIA FTP

OOT (Object Oriented Turing) is a programming language that has been 
developed at the University of Toronto.  An OOT demo, which includes the 
fully implemented language, is available for Sun/4's running X windows.  
See below for instructions to copy the demo to your site.

OOT supports the standard OOPL features of information hiding, classes,
polymorphism and generics, as well as the usual features in C and Pascal 
style languages.  It also supports concurrency, exception handling 
and system programming (pointer arithmetic, bit manipulation, etc).  

The OOT environment is designed for teaching Computer Science.
It is being used in introductory programming courses, courses
on OO concepts, compiler courses, OS courses, etc.

The OOT environment is fully integrated, with multi-window editing, turbo 
speed compiler, integrated color graphics, GUI user interface, implicit MAKE, 
on-line manual, integrated demos, etc.  The system includes an experimental
CASE tool with an interface browser and a visual system browser.


>12  Sather (simple Eiffel)

What: SATHER

Sather is under development at the International Computer Science Institute.
Sather has clean and simple syntax, parameterized classes, object-oriented
dispatch, multiple inheritance, strong typing, and garbage collection. The
compiler generates efficient and portable C code which is easily integrated
with existing code.

The initial beta test release of the language was in May, 1991. The compiler,
debugger, Emacs development environment, documentation, and library classes
are available by anonymous ftp from "icsi-ftp.berkeley.edu".
"sather@icsi.berkeley.edu" is a mailing list for discussing aspects of Sather
and "sather-admin@icsi.berkeley.edu" should be used for bug reports and
requests to be added or deleted from the mailing list.

Sather is based on Eiffel but is more concerned with efficiency and less with
some of the formal and theoretical issues addressed by Eiffel. The language is
much smaller than the current Eiffel, it eliminates over 40 keywords and
simplifies the syntax and inheritance rules. 

Like Eiffel, Sather code is compiled into portable C and efficiently links
with existing C code. The Sather compiler is written in Sather and has been
operational for almost a year, though it is still being improved. Preliminary
benchmarks show a performance improvement over Eiffel of between a factor of 4
and 50 on basic dispatching and function calls. On the benchmarks used at
Stanford to test Self (including 8 queens, towers of hanoi, bubblesort, etc),
Sather is even slightly faster than C++.

The Sather compiler and libraries are publicly available under a very
unrestrictive license aimed at encouraging contribution to the public library
without precluding the use of Sather for proprietary projects.  The goal is to
establish a repository for efficient, reusable, well written, publicly
available, classes for most of the important algorithms in computer science.
There are currently about 120 classes in the library. The libraries are
growing quickly and will collect together classes from many authors under the
same unrestrictive license. 

A GNU emacs development environment for Sather is available. A debugger based
on gdb from the Free Software Foundation is also available. A parallel version
of Sather for shared memory machines called "Psather" is also under
development.

From the Sather FAQ, August 16, 1993 (See Section 1.24):

Q 1: What is Sather?
     ~~~~~~~~~~~~~~ 
Sather is an object oriented language which aims to be simple,
efficient, interactive, safe, and non-proprietary. It aims to meet the
needs of modern research groups and to foster the development of a
large, freely available, high-quality library of efficient
well-written classes for a wide variety of computational tasks. It was
originally based on Eiffel but now incorporates ideas and approaches
from several languages. One way of placing it in the "space of
languages" is to say that it attempts to be as efficient as C, C++, or
Fortran, as elegant and safe as Eiffel or CLU, and to support
interactive programming and higher-order functions as well as Common
Lisp, Scheme, or Smalltalk.

Sather has garbage collection, statically-checked strong typing,
multiple inheritance, separate implementation and type inheritance,
parameterized classes, dynamic dispatch, iteration abstraction,
higher-order routines and iters, exception handling, assertions,
preconditions, postconditions, and class invariants. The development
environment integrates an interpreter, a debugger, and a
compiler. Sather code can be compiled into C code and can efficiently
link with C object files.


>13  Self

From: hoelzle@Xenon.Stanford.EDU (Urs Hoelzle)
Subject: Announcing Self 3.0
Date: 28 Dec 93 22:19:34 GMT

               ANNOUNCING Self 3.0 
 
The Self Group at Sun Microsystems Laboratories, Inc., and Stanford
University is pleased to announce Release 3.0 of the experimental
object-oriented programming language Self.
 
This release provides simple installation, and starts up with an
interactive, animated tutorial.
 
Designed for expressive power and malleability, Self combines a pure,
prototype-based object model with uniform access to state and
behavior. Unlike other languages, Self allows objects to inherit state
and to change their patterns of inheritance dynamically. Self's
customizing compiler can generate very efficient code compared to
other dynamically-typed object-oriented languages.
 
The latest release is more mature than the earlier releases: more
Self code has been written, debugging is easier, multiprocessing is more
robust, and more has been added to the experimental graphical user interface
which can now be used to develop code. There is now a mechanism
(still under development) for saving objects in modules, and a
source-level profiler.
 
The Self system is the result of an ongoing research project and
therefore is an experimental system. We believe, however, that the
system is stable enough to be used by a larger community, giving
people outside of the project a chance to explore Self.
 
2 This Release
 
This release is available free of charge and can be obtained via
anonymous ftp from Self.stanford.edu. Also available for ftp are a
number of published papers about Self.
 
There is a mail group for those interested in random ramblings about Self,
Self-interest@Self.stanford.edu. Send mail to self-request@self.stanford.edu
to be added to it (please do not send such requests to the mailing list
itself!).
 
2.1 Implementation Status
 
Self currently runs on SPARC-based Sun workstations running SunOS 4.1.x
or Solaris 2.3. The Sun-3 implementation is no longer provided.
 
2.2 Major Changes
 
Below is a list of changes and enhancements that have been made since
the last release (2.0.1).  Only the major changes are included. 
 
o The graphical browser has been extended to include editing
  capabilities. All programming tasks may now be performed through the
  graphical user interface (the "ui"). Type-ins allow for expression
  evaluation, menus support slot editing, and methods can be entered and
  edited. If you are familiar with a previous version of the Self
  system, Section 14.1 of the manual entitled "How to Use Self 3.0"
  contains a quick introduction to the graphical user interface. The
  impatient might want to read that first.
 
o A mechanism - the transporter - has been added to allow arbitrary
  object graphs to be saved into files as Self source. The system has
  been completely modularized to use the transporter; every item of
  source now resides in a transporter-generated
  module. Transport-generated files have the suffix .sm to distinguish
  them from "handwritten" files (.Self), though this may change as we
  move away from handwritten source.  The transporter is usable but rough,
  we are still working on it.

o Every slot or object may now have an annotation describing the
  purpose of the slot. In the current system, annotations are strings
  used to categorize slots. We no longer categorize slots using
  explicit category parent objects. Extra syntax is provided to annotate
  objects and slots.
 
o A new profiler has been added, which can properly account for the
  time spent in different processes and the run-time system, and which
  presents a source-level profile including type information (i.e.,
  methods inherited by different objects are not amalgamated in the
  profile, nor are calls to the same method from different sites). It
  also presents a consistent source-level view, abstracting from the
  various compiler optimizations (such as inlining) which may confuse
  the programmer.
 
o Privacy is not enforced, although the privacy syntax is still
  accepted. The previous scheme was at once too restrictive (in that
  there was no notion of "friend" objects) and too lax (too many object
  had access to a private slot). We hope to include a better scheme in
  the next release.
 
o The "new" compiler has been supplanted by the SIC ("simple inlining
  compiler"), and the standard configuration of the system is to
  compile first with a fast non-optimizing compiler and to 
  recompile later with the SIC. Pauses due to compilation or
  recompilation are much smaller, and applications usually run faster.
 
o Characters are now single-byte strings. There is no separate
  character traits.
 
o Prioritized inheritance has been removed; the programmer must now
  manually resolve conflicts. We found the priority mechanism of
  limited use, and had the potential for obscure errors.
 
2.4 Bug Reports
 
Bug reports can be sent to self-bugs@self.stanford.edu. Please include
an exact description of the problem and a short Self program
reproducing the bug.
 
2.5 Documentation
 
This release comes with two manuals:
   How to Use Self 3.0 (SelfUserMan.ps)
   The Self Programmer's Reference Manual (progRef.ps)

Happy Holidays!

-- The Self Group


>14  C++ gram, etc.

What: ftp site for C++ material
From: schrod@iti.informatik.th-darmstadt.de (Joachim Schrod)
Date: 27 May 92 22:32:35 GMT

There were a lot of questions about C++ material in the last time and some 
announcements which involved our ftp server.
        ftp.th-darmstadt.de [130.83.55.75]
        /pub/programming/languages/C++
At the moment we have:
 -- documentation and assorted stuff
        C++ products list as announced by Saumen K Dutta (in a subdirectory!)
        C++ YACC grammar, ET++ tutorial, summaries from the Net,
        sources from James Coplien's book (idioms...), etc.
 -- class libraries
        NIHCL (original, persistent for ObjectStore, with g++ 1.4x changes)
        COOL, OATH, RogueWave vector, ET++,
        RPC package, a package for sockets, awe (thread package)
 -- tools
        class browser (for GNU Emacs), indent++, yacc+, template
        processor of Brad Cox[sp?], DEC garbage collector

More stuff is always welcome.  (Btw, Interviews and Motif C++ wrapper
classes are to be found in the /pub/X11 subtree.)


>15  ConceptBase (OODB, reqkey)

What: ConceptBase

See APPENDIX B.

A four week test-version of ConceptBase V3.1 is available 
on the FTP server ftp.informatik.rwth-aachen.de in the 
directory pub/CB.  For running the ftp version you must ask for a 
key by email.


>16  C++ OODB
Exodus (Storage Man, perst)

From: darrenp@dibbler.cs.monash.edu.au (Daz)
Subject: Re: Class libraries for accessing RDBs ?
Organization: Monash University, Melb., Australia.
Date: Thu, 17 Jun 1993 23:53:22 GMT

shekar@gizmo.CS.MsState.Edu (Chandrashekar Ramanathan) writes:

>Hello,
>       Are there any shareware/ftp'able C++ class libraries that
>provide Relational Database access? I would also appreciate any
>pointers (ideas/articles/journals) to the various issues that one has
>to consider in designing such library. 
Ok, I'm not sure if it's exactly what you want, but it's a database, it's
fully written in c++ with classes etc, and it's out for beta testing.

Check out pippin.cs.monash.edu.au:pub/export/diamond-0.1.2.tar.Z
and please mail darrenp@dibbler.cs.monash.edu.au if you decide to play with
it.

Daz.
--
Darren Platt, Department of Computer Science
darrenp@dibbler.cs.monash.edu.au
Monash University, Clayton Melbourne, Victoria, Australia


>17  Exodus (Storage Man, perst)

What: Exodus project software (Storage Manager & GNU E)
From: zwilling@caseus.cs.wisc.edu (Mike Zwilling)
Date: 16 Jul 92 04:53:19 GMT

In the past there have been discussions in comp.object and comp.databases
about persistent storage for object-oriented databases and programming
languages.  As you may know, the EXODUS Database Toolkit project at the
University of Wisconsin has researched these issues and others for a number of
years.  The purpose of this note is to inform you that the software from the
EXODUS project is freely available via anonymous ftp.  The EXODUS software
includes the EXODUS Storage Manager and the compiler for the E persistent
programming language.  Also included is documentation, and a suite of test
programs for both components.  This note briefly describes the software and
explains how to obtain it.  We currently support DECstation 3100s/5000s and
SPARC based workstations.  Others have ported the code to HP700s and IBM
RS6000s.

The EXODUS Storage Manager is a client-server object storage system which
provides "storage objects" for storing data, versions of objects, "files"
for grouping related storage objects, and indexes for supporting efficient
object access.  A storage object is an uninterpreted container of bytes which
can range in size from a few bytes to hundreds of megabytes.  The Storage
Manager provides routines to read, overwrite, and efficiently grow and shrink
objects.  In addition, the Storage Manager provides transactions, lock-based
concurrency control, and log-based recovery.

GNU E is a persistent, object-oriented programming language developed as part
of the Exodus project.  GNU E extends C++ with the notion of persistent data,
program level data objects that can be transparently used across multiple
executions of a program, or multiple programs, without explicit input and
output operations.

GNU E's form of persistence is based on extensions to the C++ type system to 
distinguish potentially persistent data objects from objects that are always
memory resident.  An object is made persistent either by its declaration (via
a new "persistent" storage class qualifier) or by its method of allocation
(via persistent dynamic allocation using a special overloading of the new
operator).  The underlying object storage system is the Exodus storage manager,
which provides concurrency control and recovery in addition to storage for
persistent data.

The current release of GNU E is based on gcc/g++ version 2.2.2, and is upward 
compatible with C++ as implemented by that compiler.

A bibliography of EXODUS related papers can be obtained from the ftp site
described below.

To obtain the software, simply ftp to ftp.cs.wisc.edu (128.105.8.18), login
as anonymous with your email address as a password, "cd" to the "exodus"
directory, and follow the directions (directions will be given as you "cd").
See the README for the latest information about the software and an indication
of our future plans.  If you decide to use the software, please contact us at
exodus@cs.wisc.edu so that we can notify you of changes.


>18  GRAS

GRAS - A Graph-Oriented Database System for SE Applications
Copyright (C) 1987-1992  Lehrstuhl Informatik III, RWTH Aachen
This library is free software under the terms of the GNU Library 
General Public License.

Lehrstuhl f"ur Informatik III --> GRAS
University of Technology Aachen (RWTH Aachen),
Ahornstr. 55,
D-5100 Aachen
Contact : Dr. Andy Sch"urr (or Richard Breuer),
andy@rwthi3.informatik.rwth-aachen.de
ricki@rwthi3.informatik.rwth-aachen.de (for technical support)

The system GRAS with interfaces for the programming languages Modula-2
and C is available as public domain software for Sun3/Sun4 workstations
(the GRAS system itself is implemented in Modula-2 and consists of many
layers which might be reusable for the implementation of other systems): 

  Via anonymous ftp from tupac-amaru.informatik.rwth-aachen.de
  (137.226.112.31) in the directory /pub/unix/GRAS522_3

  There are several files contain documentation, sources, binaries,
  and libraries. All binaries are for Sun/4 machines. Sun/3 binaries
  are shipped only if explicitly requested.

[See APPENDIX B]


>19  MOOD   (OODB, lim arch)

What: MOOD/P3 Ver.2.00 OODBS {Miniature,Materials}OODBS.
From: ono@mood.mech.tohoku.ac.jp (Noboru Ono)
Date: 18 May 92 10:28:42 GMT

The following program/sample database package is available through anonymous
FTP at mood.mech.tohoku.ac.jp (130.34.88.61). Sorry it is not the sources and
operates only in NEC-PC9801/MS-DOS environment.  Sorry again documents are all
in Japanese. We will tell you later when English documents has become ready.

      MOOD/P3 Ver.2.00
      Material's Object-Oriented Database, Prototype 3

This program, as you may guess,

      1) is an Object-Oriented database system program,
      2) operates on PC-9801 series personal computer, and
      3) is accompanied by sample material database schema.

Although this program has been developed and being used in the experiments
on material data processing in which we are now involved, it is a general
purpose OODBS. 

Noboru Ono
Dept. of Machine Intelligence and Systems Engineering,
Faculty of Engineering, Tohoku University.
Tel:++22-222-1800
Fax:++22-268-3688
E-mail:ono@mood.mech.tohoku.ac.jp


>20  Ode    (C++ OODB)

Note: Ode version 3.0 is now available.

What: Ode Release 1.1
From: nhg@research.att.com

Ode is an object-oriented database based on the C++ database model. The
primary interface to Ode is the database programming language O++ which is
based on C++.

Ode 1.1 is now available to Universities.  This is a beta release.  The
current version of Ode runs on Sun (Sparc) workstations and users must have
C++ release 2.0 or a later release.  If you are interested in using Ode and
giving us feedback on your experience with Ode, please send me mail with the
appropriate information.

Narain Gehani
AT&T Bell Labs 3D-414
600 Mountain Ave
Murray Hill, NJ 07974


From: thssamj@iitmax.iit.edu (Aditya M. Jani)
Subject: *Announcement* UserGroup for ODE (OODBMS from AT&T)
Organization: Illinois Institute of Technology, Chicago
Date: Fri, 25 Jun 93 17:27:53 GMT

                    Ode Object database v2.0
                    ------------------------
Ode 2.0 is available via ftp from research.att.com.
Here is a sample session showing how to retrieve Ode 2.0
which is kept in the directory

    dist/ode2.0

as a compressed tar file named

2.0.oppbin.tar.Z

First create the directory on the local machine
where ode is to be installed, e.g.,

mkdir ode
cd ode

Retrieve the compressed tar Ode file using ftp into
as illustrated below.
Then uncompress it

uncompress 2.0.oppbin.tar.Z

and unbundle it

tar xvf 2.0.oppbin.tar

Next see file README, fix install file, and run install

./install
 



Sample ftp session
--------------
$ ftp research.att.com
Connected to tcp!192.20.225.2!1390.
220 inet FTP server (Version 4.271 Fri Apr 9 10:11:04 EDT 1993) ready.
Name (research.att.com:smith): anonymous
331 Guest login ok, send ident as password.
Password: smith@hostname
230 Guest login ok, access restrictions apply.
Remote system type is UNIX.
Using binary mode to transfer files.
ftp> cd dist
250 CWD command successful.
ftp> cd ode2.0
250 CWD command successful.
ftp> get 2.0.oppbin.tar.Z
200 PORT command successful.
150 Opening BINARY mode data connection for 2.0.oppbin.tar.Z (2762525
bytes).
226 Transfer complete.
2762525 bytes received in 1.6e+02 seconds (16 Kbytes/s)
ftp> quit 
221 Goodbye.

-------------------------------------------------------------------------------

                              Available Now!




                                 Ode 2.0
                       An Object-Oriented Database

       C++ Compatible, Fast Queries, Complex Application Modeling,
       Multimedia Support, and more




       Ode 2.0 is now available to Universities.  Users who currently
       have Ode 1.1 will be automatically sent a tape with Ode 2.0.
       There is no charge for Ode.  However, AT&T requires the signing
       of a non-disclosure agreement.



       Details
       -------

       ODE OBJECT-ORIENTED DATABASE

       The Ode object database is based on the C++ object paradigm.
       Ode  uses  one  integrated data model (C++ classes) for both
       database and general purpose manipulation.  The Ode database
       is   defined,   queried  and  manipulated  in  the  database
       programming language O++, which provides simple and  elegant
       facilities for manipulating the database.

       O++  is  an  upward-compatible  extension  of  C++.   A  few
       facilities have been added to C++ to make it into a database
       programming language.  C++ programmers can learn  O++  in  a
       very short time.

       O++ programs can be compiled with C++ programs thus allowing
       the use of existing C++ code.

       THE ODE MODEL OF PERSISTENCE

       Ode offers a simple and elegant notion of persistence  which
       is   modeled  on  the  ``heap''.   Specifically,  memory  is
       partitioned into volatile and persistent.  Volatile  objects
       are   allocated   in   volatile   memory  (stack  or  heap).
       Persistent objects are allocated  in  persistent  store  and
       they  continue  to exist after the program that created them
       has terminated.

       An Ode database is a collection of persistent objects.  Each
       object  is  identified  by  a  unique  object  id  (i.e.,  a
       persistent pointer,  or  to  be  precise,  a  pointer  to  a
       persistent object).

       The database programming language  O++  provides  facilities
       for   creating  and  manipulating  the  Ode  database.   For
       example,   O++   provides    facilities    for    specifying
       transactions,  creating and manipulating persistent objects,
       querying the database, creating and manipulating versions.

       WHAT IS AN OBJECT-ORIENTED DATABASE

       Some  important  characteristics   of   an   object-oriented
       database are:

          + data is stored as objects,

          + data  can  be  interpreted  (using  methods)  only   as
            specified by the class designer,

          + relationship  between  similar  objects  is   preserved
            (inheritance), and

          + references between objects are preserved.

       ADVANTAGES OF OBJECT-ORIENTED DATABASES

          + Speed: Queries can  be  faster  because  joins  (as  in
            relational  databases)  are  often not needed.  This is
            because an object can be retrieved directly  without  a
            search, by following object ids.

          + No impedance mismatch: The same data model is  used  by
            both   the   database   programming  language  and  the
            database;  it  is  not  necessary  to  do  any   format
            conversions  when  reading  the data from disk and when
            storing the data on disk.

          + Programmers  need  to  learn   only   one   programming
            language:  The  same  programming  language is used for
            both data definition and data manipulation.

          + Complex applications: The full power  of  the  database
            programming language's type system can be used to model
            the data structures of a complex  application  and  the
            relationship between the different data items.

          + Multimedia  applications:  The   semantic   information
            stored  in  the  database  (class  methods) facilitates
            correct  interpretation  of  the  data.   This  reduces
            application complexity since applications do no have to
            be responsible for the correct interpretation of data.

          + Versions: Object-oriented databases  typically  provide
            better support for versioning.  An object can viewed as
            the set of all its versions.  Also, object versions can
            be treated as full fledged objects.

          + Triggers  and  constraints:  Object-oriented  databases
            provide systematic support for triggers and constraints
            which are the basis of active databases.

       Finally, most, if not all, object-oriented applications that
       have  database  needs  will  benefit  from  using an object-
       oriented database.  Specifically, C++ applications that have
       database needs will benefit from using Ode.

       FEATURES OF ODE

         1.  Ode is C++ based and compatible with C++.

         2.  The  Ode  object   database   provides   four   object
             compatible  mechanisms  for  manipulating and querying
             the database: O++, OdeView, OdeFS, and CQL++:

                + O++ is a database programming language  based  on
                  C++.   O++  is  upward compatible with C++ and it
                  makes minimal  changes  to  C++.   O++  offers  a
                  simple and elegant notion of persistence which is
                  modeled on the ``heap''.  O++ provides facilities
                  for querying the database, and a variant of other
                  facilities.

                + OdeView is a graphical X-based interface  to  the
                  Ode database.

                + OdeFS is a  file  system  interface  to  the  Ode
                  object  database.   OdeFS  allows  objects  to be
                  treated and  manipulated  like  files.   Standard
                  commands  such as rm, cp and mv and tools such as
                  vi and grep can be used to manipulate objects  in
                  the database.

                + CQL++ is a C++ variant  of  SQL  for  easing  the
                  transition  from  relational databases to object-
                  oriented databases such as Ode.

             Currently, only O++ is shipped with Ode 2.0.  A  beta-
             test version of OdeFS is available upon request.

         3.  Ode supports large objects  (these  are  critical  for
             multi-media    applications).    Ode   provides   both
             transparent access for large objects and a  file  like
             interface  for  large objects.  The latter can be used
             to efficiently access and  update  parts  of  a  large
             object.

         4.  Users can create versions of objects.  Ode will  track
             the   relationship   between   versions  and  provides
             facilities for accessing the different versions.

         5.  Transactions  can  be  specified  as  read-only;  such
             transactions  are  faster  because they are not logged
             and they are less likely to deadlock.

         6.  Users   can   run    ``hypothetical''    transactions.
             Hypothetical  transaction  allow users to pose ``what-
             if'' scenarios (as often  done  with  spread  sheets).
             User  can  change  data  and  see  the impact of these
             changes without changing the database.

         7.  EOS, the storage engine of Ode, is based on a  client-
             server architecture.  Some features of EOS:

               a.  Efficient  and  transparent  handling  of  large
                   objects.  A file-like interface is also provided
                   for very large objects.

               b.  Concurrency is based on  multi-granularity  two-
                   version   two-phase   locking;  it  allows  many
                   readers and one writer to access the  same  item
                   simultaneously.

               c.  Log  records  contain  only  after   images   of
                   updates,  thus making logs small.  Recovery from
                   system failures requires one scan over  the  log
                   resulting in fast restarts.

       USE MODES

       Ode supports two modes of use:

         1.  Client-server (allows multiple  users  to  access  the
             database concurrently).

         2.  Single user (improved performance  compared  to  using
             the client-server mode).

       USERS

       Ode 2.0 is currently being used as the multi-media  database
       engine  for  AT&T's  Interactive TV project.  Ode 1.1 (older
       version of Ode with  limited  capabilities)  has  also  been
       distributed to 30+ sites within AT&T and 135+ universities.


>21  POSTGRES (Ext. Rel. DBMS)

What: Version 4.0 of the POSTGRES DBMS
From: mer@gaia.CS.Berkeley.EDU (Jeff Meredith)
Date: 16 Jul 92 04:53:17 GMT

Version 4.0 of the POSTGRES DBMS is now available for distribution. Version 4.0 
provides significant advances in functionality over 3.1.  General improvements
in the code and some key multi-user bug fixes have resulted in a much more
reliable system than we have ever previously released.

Major new features include:
 o  Complete support for language (POSTQUEL) functions.
 o  Handling of nested dot expressions.
 o  Optimization of predicates with expensive functions.
 o  Binary portals
 o  Initial support of sets
 o  Indices on system catalogs.

Postgres runs on Sparc I, Sparc II, Sun 4 running SunOs, and DECstations
running ULTRIX >= 4.0, as well as Sequent Symmetry machines.  Postgres
consists of about 250,000 lines of C.

If you would like to get Postgres 4.0, you can get it in one of two ways:

(1)  Anonymous FTP from postgres.berkeley.edu

cd pub
get postgres-setup.me
binary
get postgres-v4r0.tar.Z
quit 

Or, if you do not have net.access, you can order a Postgres distribution
tape by sending a check payable to the Regents of the University of California
for $150.00 to:
         Postgres Project
         571 Evans Hall
         University of California
         Berkeley, CA 94720.

Indicate in your accompanying letter whether you want the system on a 9-track
tape at 1600 BPI, at 6250 BPI, on a cartridge tape for SUN shoeboxes (QIC 24 
format), or on a TK50 DEC cartridge tape.


>22  Sniff (C++ devel environ)

[See also APPENDIX C, SNiFF+, for the commercial version]

What: SNIFF (Sniff 1.1b (C++ Development Environment))
From: shite@sinkhole.unf.edu (Stephen Hite)
Date: 23 Aug 92 18:14:00 GMT

Sniff 1.1b is available from iamsun.unibe.ch in the C++ hierarchy.  It's a
development environment for C++ (minus the C++ compiler or interpreter).
It's freely available and you're gonna need OpenWindows 3.0 if you want
to play with it immediately.  I just downloaded it and haven't had a 
chance to look into whether the XView 3.0 package will be able to handle
everything Sniff requires of the OpenLook part.

And:

From: sniff@takeFive.co.at (Mr. Sniff)
Newsgroups: comp.lang.c++,comp.unix,comp.unix.osf.osf1,comp.unix.solaris,comp.object
Subject: SNiFF+ takeFive Starts Free University Distribution of Commercial C/C++ Programming Environment
Date: 22 Sep 1993 15:51:26 GMT
Organization: EUnet EDV-Dienstleistungsgesellschaft m.b.H
Keywords: programming environments, browsing, C++

SNiFF+: takeFive Starts Free University Distribution of Commercial C/C++
Programming Environment

1. Introduction
 ===============
Since the beginning of 1993 takeFive has taken over development and support 
for SNiFF+, a leading edge C/C++ programming environment.  With SNiFF+ 
rapidly gaining commercial acceptance takeFive has decided to offer the 
product free to educational establishments. There are several reasons for 
this step.

...

6. How to Obtain SNiFF+
 =======================
6.1 FTP
 -------
Sniff can be downloaded from anonymous FTP sites in USA and Europe.
You can get all details from info@takeFive.co.at.

And:

From: hueni@iam.unibe.ch (Hermann Hueni)
Subject: Re: Browsers
Date: Fri, 11 Jun 1993 12:37:28 GMT

Sniff is a commercial product.
Send mail to info@takeFive.co.at
AN early version is available as a SUN SPARC binary only from
siam.unibe.ch:C++/Sniff1.6/     (THIS site is in EUROPE)


>23  C++ tags
Eiffel archive,24
short tool, 24

What: ctags/etags for C and C++
From: kendall@centerline.com (Sam Kendall)
Date: 10 Jun 92 09:31:27 GMT

A lot of people have requested this software!  You can now get Tags for
C/C++ version 1.0 via anonymous ftp at:

        ftp.centerline.com:/pub/tags-1.0.tar.Z

ftp.centerline.com is 140.239.2.29.  Anonymous ftp means login as "ftp" and
give your email address as the password.

If you don't have ftp access to the internet, you may want to wait for this
stuff to come out in comp.sources.unix.  Or, if you plan to use it right away,
send me a letter that says "I can't use ftp; please send by email" and I will
do so.


>24  short tool

From: neil@aldur.demon.co.uk (Neil Wilson)
Subject: New version of 'short' available
Date: Sat, 7 Aug 1993 09:38:25 +0000

A new beta release (1.2) of 'short' is available from the Stuttgart
Eiffel archive (ftp.informatik.uni-stuttgart.de) in directory
/pub/eiffel/eiffel-3/sig

Command line processing is now included in the short system. Short can
now cope with multiple input files, the standard input and deal with
most file errors.

Short now depends on the argument cluster which is available from
the same archive and directory.

Short supports the following options:

        -V, +version, -h, +help
                Displays the 'short' version information and gives the
                usage help message for the command.

        -e, +abstract, +eiffel
                Produces a fully deferred version of the input class(es)
                which will compile just like any other class (hopefully :-)

        -l <class_name>, +view <class_name>
                Produces the output from the point of view of the class
                <class_name> - the "short form for <class_name>".
                Special handling for ANY and NONE of course. By default
                short outputs the "short form for ANY".

        -f, +full
                Produces the short form including all the feature
                blocks.  (Implemented as the "short form for NONE".)

        -p, +parents
                Retains the inheritance clause in the output. The default is
                to drop it.

        -b <number>, +blank <number>
                Indent levels by <number> characters. 

        -c <number>, +column <number>
                Width of the output is <number> characters. Should be
                greater than 20.

Obsolete features are not retained. Obsolete classes retain no features.

The output of the tool now conforms to the layout rules in Appendix A of
ETL and should look like the 'short' examples in the book. As much as is
possible the output and command line options conform to ISE's 2.3
version of 'short'.

This release of short has been tested on all the v1.21 Eiffel/S
libraries, itself and the argument clusters, plus any other class
fragments I had lying around at the time.

My biggest debt is of course to David Morgan. This version is only
really a tiny modification of his work. His ELEXER Eiffel 3 parser
remains the core of the tool.  I though am responsible for any remaining
deficiencies or problems with this release.

Problems, suggestions, comments, criticisms to me please. All gratefully
received - I can't improve my Eiffel if somebody doesn't tell me where I
blew it.


>25  COOL(C++, Cfront 2.1, from GE)

COOL is a C++ class library developed at Texas Instruments.

Features are:
1. Rich set of containers like Vector, List, Hash_Table, Matrix, etc...
2. Hierarchy is shallow with no common base class, rather than deep like NIHCL.
3. Functionality close to Common Lisp data structures, like GNU libg++.
4. Template syntax very close to Cfront3.x, g++2.x.
5. Free, with good documentation, and extensive test cases.

Light version of COOL from General Electric:
1. Hairy macros, run-time type, exceptions removed for mainstream C++
   compatibility
2. Free of memory leaks and bound violations. Leaks and bounds are checked
   with Purify.
3. Has memory management and efficient copy in expressions like:
  Set c = a+b+c;    
  Pointers are shared with Handle and Reference count. Deep copy in
  expressions are replaced by shallow copy.
4. Compatible with Cfront2.1, and is being converted to Cfront3.0. You can
  build both static and shared library on SunOS 4.1.x

1. original version from Texas Instruments:
   at csc.ti.com, get pub/COOL.tar.Z
2. Cfront2.1 version modified by General Electric:
   at cs.utexas.edu, get pub/COOL/GE_COOL2.1.tar.Z

I am working on Cfront3.0 version of COOL, using the Beta 3.0 from Sun. I am
experiencing problems with instantiation and specialization of templates.  So
Cfront3.0 version of COOL won't be available until Sun's Cfront 3.0 is
released with bugs fixed.

Van-Duc Nguyen
General Electric 
Research & Development Ctr
1 River Road, Room K1-5C39.
Schenectady, NY 12301.
Phone: (518) 387-5659
Fax:   (518) 387-6845
nguyen@crd.ge.com


>26  idl.SunOS4.x, idl.Solaris2.x

Subject: Binaries for OMG IDL CFE placed on omg.org
Date: 11 Jun 93 00:13:11 GMT
Reply-To: jyl@toss.eng.sun.com


SunSoft has made available statically linked binaries for the OMG IDL CFE,
for both Solaris 1.x and Solaris 2.x. Because they are statically linked,
these binaries can be used on systems which do not have the SparcWorks (TM)
compilers installed.

It is expected that people who only want an IDL parser will prefer to
obtain these binaries instead of compiling the program on their host.
People who want to build a complete compiler, by programming their own
back-end, will continue to obtain the sources which are also provided at
the same location.

The binaries can be obtained by anonymous FTP to omg.org. They are
installed in the directory pub/OMG_IDL_CFE_1.2/bin, in idl.SunOS4.x and
idl.Solaris2.x. Uuencoded versions are also available, in the same
directory.

Please send email to idl-cfe@sun.com if you obtain these files.

The attached copyright applies to the provided binaries and to the source
files provided on the omg.org file server.


Copyright:
Copyright 1992 Sun Microsystems, Inc.  Printed in the United States of
America.  All Rights Reserved.

This product is protected by copyright and distributed under the following
license restricting its use.

The Interface Definition Language Compiler Front End (CFE) is made
available for your use provided that you include this license and copyright
notice on all media and documentation and the software program in which
this product is incorporated in whole or part. You may copy and extend
functionality (but may not remove functionality) of the Interface
Definition Language CFE without charge, but you are not authorized to
license or distribute it to anyone else except as part of a product or
program developed by you or with the express written consent of Sun
Microsystems, Inc. ("Sun").

The names of Sun Microsystems, Inc. and any of its subsidiaries or
affiliates may not be used in advertising or publicity pertaining to
distribution of Interface Definition Language CFE as permitted herein.

This license is effective until terminated by Sun for failure to comply
with this license.  Upon termination, you shall destroy or return all code
and documentation for the Interface Definition Language CFE.

[...] etc. on copyright stuff [...]

SunSoft, Inc.  
2550 Garcia Avenue 
Mountain View, California  94043


>27  Browser for OO info

From: oscar@cui.unige.ch (Oscar Nierstrasz)
Subject: CUI & Object Oriented Information Sources on the World Wide Web
Reply-To: oscar@cui.unige.ch
Organization: University of Geneva, Switzerland
Date: Fri, 25 Jun 1993 12:18:38 GMT

An HTTP server has been installed at the Centre Universitaire d'Informatique
of the University of Geneva.  Information about various research groups at
the CUI is available, as well as a number of other experimental services.

The Object Systems group at CUI is providing a number of pointers to
Object-Oriented Information Sources available on the World Wide Web.
The page containing these sources is accessible from the CUI home page.
The URL is: http://cui_www.unige.ch/home.html

You must have a WWW browser to access the information.  If you do not have
a browser, you should obtain, for example, the xmosaic browser from:
ftp.ncsa.uiuc.edu:Web/xmosaic or info.cern.ch:pub/www.

The material available from CUI is in an early stage of development.
Suggestions for additional OO references to include (or whatever) are welcome!

Oscar Nierstrasz

----------------------------------------------------------------------------
        Dr. O.M. Nierstrasz, Centre Universitaire d'Informatique
University of Geneva, 24, rue General-Dufour, CH-1211 Geneva 4, Switzerland
        Tel: +41 22 705.7664    Secr: 705.7770    Fax: 320.2927
            E-mail: oscar@cui.unige.ch  Home: 733.9568
----------------------------------------------------------------------------


>28  Apertos(Meta-Obj Distr OS, research)

The Apertos (formerly MUSE) project at Sony Research
is a meta-object based distributed OS for turning portable wireless
hand-held computers into fully-connected Dynabook-like
terminals.  It's very very wizzy.  The papers are on: 
        scslwide.sony.co.jp:pub/CSL-Papers

The source is available for research; I think you have to
sign something first.


>29  Actors Paper (UIUC)

From: agha@cs.uiuc.edu (Gul Agha)
Subject: Actor Theory Paper available
Organization: University of Illinois, Dept. of Comp. Sci., Urbana, IL
Date: Wed, 4 Aug 1993 15:41:02 GMT

A new paper providing a definitive and detailed development of the
semantics of actor systems is available via anonymous ftp.  Comments
are especially welcome.  


Title:          A Foundation for Actor Computation

Authors:        Gul Agha, Univerity of Illinois at Urbana-Champaign
                Ian Mason, Stanford University
                Scott Smith, John Hopkins University
                Carolyn Talcott, Stanford University

Abstract:

        We present an actor language which is
        an extension of a simple functional language, and provide a precise
        operational semantics for this extension.  Actor configurations are
        open distributed systems, meaning we explicitly take into account the
        interface with external components in the specification of an actor
        system.  We define and study various notions of equivalence on actor
        expressions and configurations.

to ftp the compressed postscript file:
        ftp sail.stanford.edu  (or 36.28.0.130)
        login: anonymous
        send ident as password.
        cd pub/MT
the file is called:  
        93actors.ps.Z

Note: the paper is 76pp long.  It subsumes work reported in our paper
in CONCUR '92.  

(A number of other recent papers on actor languages and their
implementation may be obtained by anonymous ftp from
biobio.cs.uiuc.edu in the directory pub/papers).


>30  Chambers' Thesis

What: SELF optimizing compiler and Thesis
From: chambers@cs.washington.edu (Craig Chambers)
Date: 9 May 92 22:00:53 GMT

My Ph.D. thesis, entitled "The Design and Implementation of the Self Compiler,
an Optimizing Compiler for Object-Oriented Programming Languages," is now
available as Stanford technical report number STAN-CS-92-1420.  Copies may be
ordered from Stanford.  Stanford requires $20 (plus tax for orders from within
California), in advance, for each copy.

The dissertation also is available in compressed postscript form.  The
electronic version may be copied via anonymous ftp from self.stanford.edu in
the directory pub/papers/chambers-thesis.  This version is free.  Note however
that the thesis is about 250 pages long.


>31  graph drawing

From: rt@cs.brown.edu (Roberto Tamassia)
Subject: annotated bibliography on graph drawing algorithms
Organization: Brown University Department of Computer Science
Date: Wed, 30 Jun 1993 06:45:48 GMT

A new revised version of the annotated bibliography on graph drawing
algorithms by Giuseppe Di Battista, Peter Eades, Roberto Tamassia, and
Ioannis Tollis is now available via anonymous ftp from
wilma.cs.brown.edu (128.148.33.66).  The files are /pub/gdbiblio.tex.Z
and /pub/gdbiblio.ps.Z.


>32  Law of Demeter

From: lieber@ccs.neu.edu (Karl Lieberherr)
Subject: Law of Demeter/Adaptive Software
Organization: College of CS, Northeastern University
Date: Fri, 4 Jun 1993 20:41:49 GMT

 >...
 Yes, the Law of Demeter paper is available in electronic form on the
 net. Indeed, many of the Demeter project papers are available from
 the ftp server at Northeastern University (see instructions below).

 The Law of Demeter idea has been automated in the Demeter Tools/C++
 as an adaptive software tool which automatically makes much of your C++ code
 compliant with the Law of Demeter. The tool is an add-on tool to
 your favorite C++ development environment and is commercially available
 from Demeter International. The Demeter Tools/C++ lift
 object-oriented programming to a higher level of abstraction
 by allowing the user to focus on the essential and
 stable classes. A paper on ADAPTIVE SOFTWARE will appear in 
 the Communications of the ACM and is also available from the
 ftp server.

 For more information, use the ftp instructions below or call

Demeter International
56 Bennett Road
Marblehead, MA 01945

 phone: (617) 639 1544
 fax: (617) 373 5121

or send e-mail to demeter@ccs.neu.edu 

-- Karl Lieberherr

FTP instructions:

Some of our papers are available in one package by anonymous ftp from

ftp.ccs.neu.edu (129.10.10.51)

in directory pub/demeter/documents

Use the following command sequence to copy the Demeter papers:

% ftp ftp.ccs.neu.edu or 129.10.10.51)
Name ( ... ): ftp
Password: your-email-address
ftp> cd pub/demeter/documents
ftp> ls
ftp> binary
ftp> get papers.tar.Z
ftp> quit
% uncompress papers.tar.Z
% tar xf papers.tar

If you want to copy individual papers and not all at once, go to 
directory pub/demeter/documents/papers and retrieve them
individually.

Law of Demeter paper:
  LH89-law-of-demeter.ps
Adaptive Software papers:
  LSLX93-adaptive-programming.ps
  L92a-component-enhancement.ps
  LHSLX92-pp-experience.ps


>33  OO Dyn Grping, memory

From: mario@cs.man.ac.uk (Mario Wolczko)
Subject: Re: OOPLs and Locality of Reference
Keywords: locality of reference
Date: 5 Jul 93 14:39:13 GMT
Organization: Dept Computer Science, University of Manchester, U.K.

[...]
The measurements done as part of the work here on the Mushroom project
show that temporal locality within Smalltalk objects is great (and
hence even conventional caches work reasonably well [unless the GC
scheme trashes the cache]), whereas spatial locality on a scale much
larger than the average object (which is 40 bytes) is much harder to
come by.

More details can be found in these papers (all available by ftp from
mushroom.cs.man.ac.uk in /pub/mushroom/papers):

  dgvm1.ps.Z
    "Dynamic Grouping in an Object Oriented Virtual Memory Hierarchy"
    Ifor Williams, Mario Wolczko, Trevor Hopkins, Proc. ECOOP 87,
    Springer-Verlag LNCS 276, pp.79-88.

  dgvm2.ps.Z
    "Realization of a Dynamically Grouped Object-Oriented Virtual
     Memory Hierarchy", Proceedings of the Workshop on Persistent Object
     Systems: Their Design, Implementation and Use, available as
     Persistent Programming Research Report PPRR-44-87, Universities
     of Glasgow and St. Andrews, Aug. 1987, pp.298--308.

  obma.ps.Z
    "An Object-Based Memory Architecture"
    Ifor Williams and Mario Wolczko, in Implementing Persistent Object
    Bases: Proc. Fourth International Workshop on Persistent Object Systems,
    Morgan Kaufmann, 1991, pp.114-130.
    The first three figures are in obma-fig[123].ps.Z.

Mario Wolczko

   ______      Dept. of Computer Science   Internet:      mario@cs.man.ac.uk
 /~      ~\    The University              uucp:    mcsun!uknet!man.cs!mario
(    __    )   Manchester M13 9PL          JANET:         mario@uk.ac.man.cs
 `-':  :`-'    U.K.                        Tel: +44-61-275 6146  (FAX: 6236)
____;  ;_____________the mushroom project___________________________________


>34  Pred Classes (Cecil)

What: "Predicate Classes" paper
From: chambers@klamath.cs.washington.edu (Craig Chambers)
Date: Fri, 30 Apr 93 01:25:02 GMT

"Predicate classes are a new linguistic construct designed to
complement normal classes in object-oriented languages. Like a normal
class, a predicate class has a set of superclasses, methods, and
instance variables. However, unlike a normal class, an object is
automatically an instance of a predicate class whenever it satisfies a
predicate expression associated with the predicate class. The
predicate expression can test the value or state of the object, thus
supporting a form of implicit property-based classification that
augments the explicit type-based classification provided by normal
classes. By associating methods with predicate classes, method lookup
can depend not only on the dynamic class of an argument but also on
its dynamic value or state. If an object is modified, the
property-based classification of an object can change over time,
implementing shifts in major behavior modes of the object. A version
of predicate classes has been designed and implemented in the context
of the Cecil language."

Comments on the ideas in the paper are appreciated.

-- Craig Chambers


>35  Manchester Archive and some

What: Manchester Archive, SmallTalk-V
From: johnson@m.cs.uiuc.edu (Ralph Johnson)
Date: 18 Dec 91 19:41:38 GMT

We have a complete copy of everything in the Manchester archive, and you
can either access it by e-mail like the Manchester archive or by anonymous
ftp.  Our archive is on st.cs.uiuc.edu, and you can get information about the
e-mail server by sending to archive-server@st.cs.uiuc.edu, and putting the
line help in your message. We actually have a little more than is in the
Manchester archive.  We have the Smalltalk-V code from the defunct
International Smalltalk Association, and a few other odds and ends.

Also:
The University of Illinois Smalltalk Archive is now offering a WWW server
the URL is http://st-www.cs.uiuc.edu/


>36  Object Design's OO7 Results

What: Object Design's Results on the OO7 Benchmarks
From: dudek@odi.com (Glen Dudek)
Date: Thu, 29 Apr 93 17:17:11 GMT

OBJECT DESIGN'S RESULTS ON THE OO7 BENCHMARKS
April 26, 1993

We have made a copy of our results available to the Internet community. You
can access this information through anonymous ftp from ftp.odi.com in the
file /pub/oo7/results.ps.

The report includes the "official" tests done for ObjectStore by the
University of Wisconsin, and our internal execution of all the tests using
ObjectStore Release 2.0.1, the current production version.  As the report
shows, our internal execution carefully followed the agreed-upon procedures
for running OO7, and we believe the numbers that were produced accurately
represent ObjectStore's performance.

        For further information contact oo7info@odi.com.


>37  Graph service

From: north@ulysses.att.com (Stephen C. North)
Subject: free samples of directed graph layouts by mail
Keywords: graph layout, DAG, embedder
Date: 25 Jun 93 18:28:29 GMT
Organization: AT&T Bell Laboratories, Murray Hill

I have created an experimental service for remote users to try some of
our graph layout programs through Internet mail, for research or
educational purposes.  I'm looking for a few friendly users to try this
service.  The programs are:

    dag (directed graphs, old, program, works with some USL C++ utilities.
                This may have unintentionally sparked the apparently misdirected 
                discussion of "DAG classes" in one newsgroup recently.)
    dot (directed graphs, newer algorithms, better layouts, more features)
    neato (undirected graphs, compatible with dot, Kamada-Kawai spring embedder)

You can ftp PostScript files of documentation from dist/drawdag/*.Z on
research.att.com

To draw graphs, send a graph file to drawdag@toucan.research.att.com
and give the command line in the Subject header.  For example,

    From cs.Princeton.EDU!north Thu Jun 24 11:45:28 0400 1993 remote from toucan
    Date: Thu, 24 Jun 1993 11:45:28 -0400
    From: Stephen North <north@cs.Princeton.EDU>
    To: drawdag@toucan.research.att.com
    Subject: dot -Tps 

    digraph G { a -> b }

File arguments are disabled for obvious reasons.  Please let me know if
you hit any snags.  There is a reasonable limit on graph size and probably
number of invocations from a given site/account. (If you use it that much,
AT&T's Intellectual Property Division sells binary executables; their number
is 800-462-8146).

Stephen North, AT&T Bell Laboratories, Murray Hill NJ, (908) 582 7392
Parturiunt montes, nascetur ridiculus mus!


>38  C++SIM (Simula-like Sim Pkg)

From: M.C.Little@newcastle.ac.uk (Mark Little)
Subject: C++SIM Release 1.0 Announcement
Organization: Computing Laboratory, U of Newcastle upon Tyne, UK NE17RU
Keywords: C++, SIMULA, simulation, object-oriented
Date: Mon, 14 Jun 1993 15:02:33 GMT

C++SIM 1.0 Release Announcement.

This is to announce the release of version 1.0 of C++SIM, a simulation
package written in C++. C++SIM provides discrete process based
simulation similar to that provided by the simulation class and
libraries of SIMULA. The linked list manipulation facilities provided
by SIMSET are also included in the package.

Inheritance was used throughout the design to an even greater extent
than is already provided by SIMULA. This has allowed us to add new
functionality without affecting the overall system structure, and hence
provides for a more flexible and expandable simulation package.

A paper is included which describes the design and implementation of
C++SIM and includes a worked example of how to use the package. The
paper describes the class hierarchy which we have created, and
indicates how it can be used to further refine the simulation package.

The simulation package requires the use of a threads package and
currently only works with Sun's lightweight process library or the Gnu
thread package (which *is* included in the distribution). The package has
been used on Sun workstations, and, with the exception of the thread
library requirement, contains no system specific code which should make
porting to other systems relatively easy. The code has been compiled
with Cfront 2.1 and Cfront 3.0.1 and g++ 2.3.3

From ankh.iia.org!babbage.ece.uc.edu!news.kei.com!bloom-beacon.mit.edu!senator-bedfellow.mit.edu!faqserv Wed Nov 23 21:57:36 1994
Path: ankh.iia.org!babbage.ece.uc.edu!news.kei.com!bloom-beacon.mit.edu!senator-bedfellow.mit.edu!faqserv
From: Bob Hathaway <rjh@geodesic.com>
Newsgroups: comp.object,comp.answers,news.answers
Subject: Comp.Object FAQ Version 1.0.7 (10-27) Part 9/10
Supersedes: <object-faq/part9_782395740@rtfm.mit.edu>
Followup-To: comp.object
Date: 29 Oct 1994 11:42:35 GMT
Organization: Geodesic Systems
Lines: 1489
Approved: news-answers-request@MIT.Edu
Distribution: world
Expires: 12 Dec 1994 11:40:18 GMT
Message-ID: <object-faq/part9_783430818@rtfm.mit.edu>
References: <object-faq/part8_783430818@rtfm.mit.edu>
NNTP-Posting-Host: bloom-picayune.mit.edu
Summary: Frequently Asked Questions (FAQ) List and Available Systems For Object-Oriented Technology
X-Last-Updated: 1994/10/28
Originator: faqserv@bloom-picayune.MIT.EDU
Xref: ankh.iia.org comp.object:7434 comp.answers:4424 news.answers:13683

Archive-name: object-faq/part9
Last-Modified: 10/27/94
Version: 1.0.7

If you find any bugs or make modifications (e.g., ports to other thread
packages) or port it to other systems, then please let me know so I can
keep the sources up-to-date for other users.

The package is available via anonymous ftp from arjuna.ncl.ac.uk


>39  commercial on cd-rom

From: jimad@microsoft.com (Jim Adcock)
Subject: Re: Non-defense Ada applications - answering several requests
Date: 11 Jun 93 18:56:55 GMT
Organization: Microsoft Corporation

 >...

1) Get a copy of the Computer Select Database.  [I notice the company
is offering free trial copies [the database is CD-ROM based]]

2) Select "Section: Software Product Specifications"

3) Select "Find: C++"

Behold!  A list of 734 commercially available software packages written
in C++, including some of the best known names in the software industry.


>40  C++ Signatures (subtyping)

From: gb@cs.purdue.edu (Gerald Baumgartner)
Newsgroups: comp.object,comp.lang.c++
Subject: signature implementation for G++ 2.5.2 and tech report available
Date: 4 Nov 1993 12:03:00 -0500
Organization: Department of Computer Sciences, Purdue University

Announcing the paper

	Signatures: A C++ Extension for
	Type Abstraction and Subtype Polymorphism

	by Gerald Baumgartner and Vincent F. Russo.
	Tech report CSD-TR-93-059, Dept. of Computer
	Sciences, Purdue University, September 1993.
	Submitted to Software Practice & Experience.

and a beta release of our implementation of

	signatures for GCC 2.5.2.


 How to Get that Stuff?
 ----------------------

You can get both the paper and the implementation by ftp from

	host:		ftp.cs.purdue.edu	(128.10.2.1)

	login:		anonymous

	password:	your e-mail address

	directory:	pub/gb

	files:		COPYING			Copyright notice.

			README			This file.

			Signatures.{dvi,ps}.gz	DVI and Postscript versions
						of the paper.

			gcc-2.5.2.sig.diff.gz	Patch to upgrade GCC 2.5.2.

			test.tar.gz		Test files and script to run
						the tests.

To make GCC 2.5.2 understand signatures, just copy the context diff
file into the GCC source directory, type

	gunzip gcc-2.5.2.sig.diff.gz
	patch < gcc-2.5.2.sig.diff

and rebuild and install `gcc,' `cc1plus,' the man pages, and the manual.

For compiling C++ code containing signatures, you need to use the
command line option

	-fhandle-signatures

We tested our extension on Sun 4 only, but since there are no changes
to the compiler backend, it is expected work on other architectures as
well.  To test whether it works on your architecture, unpack the file
`test.tar.gz' and run the shell script

	Test

It compiles the test programs and runs them.  If everything works
correctly, all the test programs (all 40 of them) should print

	Hello World.


 What are Signatures anyway?
 ---------------------------

Roughly, signatures are type abstractions or interfaces of classes.
They are related to ML's signatures, categories in Axiom, definition
modules in Modula-2, interface modules in Modula-3, and types in
POOL-I.

The main language constructs added are signatures and signature pointers.
For example, the signature declaration

	signature S
	{
	  int foo (void);
	  int bar (int);
	};

defines a new abstract type `S' with member functions `int foo (void)'
and `int bar (int).'  Signature types cannot be instantiated since they
don't provide any implementation.  Only signature pointers and signature
references can be defined.  For example,

	C obj;
	S * p = &obj;

defines a signature pointer `p' and initializes it to point to an object
of class type `C,' where `C' is required to contain the public member
functions `int foo (void)' and `int bar (int).'  The member function call

	int i = p->foo ();

executes then `obj.foo ().'

Class `C' is called an implementation of the abstract type `S.'  In
this example, we could have made `S' an abstract virtual class and `C' a
subclass of `S,' and we would have had the same effect.  The advantages
of signatures over abstract virtual classes are

	- you can build a type hierarchy separate from the class inheritance
	  (implementation) hierarchy,
	- subtyping becomes decoupled from inheritance, and
	- signatures can be used with compiled classes, while you cannot
	  retrofit an abstract virtual class on top of compiled class
	  hierarchies.

For more information, please, see the paper.


 What's Implemented and what's not?
 ----------------------------------

Signature declarations and signature pointers are implemented and
working.  For examples of what's working and how to use them you can
have a look at the test files.

The following bugs are known:

      - The destructor of objects cannot be called though signature pointers.
      - A signature pointer cannot point to an object of a class defined
	by multiple inheritance.
      - The signature conformance check does not work if the signature
	contains other signature declarations or class declarations.
      - Operator and conversion operator member functions of signatures
	can only be called with function call syntax, such as
	`p->operator+(17),' but not with operator or conversion syntax.

The following language constructs and features are not yet implemented:

      - constants in signatures,
      - signature references,
      - signature inheritance,
      - the `sigof' (signature of a class) construct,
      - views (not even the parsing is done),
      - signature templates, and
      - exception specifications in signature member function declarations.

The following optimization is not implemented:

      - Looking up a virtual class member function through a signature
	pointer/reference requires double indirection.  This can be optimized
	by memoizing, so that only the first lookup of a member function
	requires double indirection and further lookups require only single
	indirection.

The items above are roughly in the order in which they will be implemented.

Besides bug fixes, the main features that have been implemented since the
last release are default implementations of signature member functions
and opaque types.


 Feedback
 --------

Please, send your questions, comments, suggestions, and complaints to

	gb@cs.purdue.edu

--
Gerald Baumgartner
Dept. of Computer Sciences, Purdue University,  W. Lafayette, IN 47907
Internet: gb@cs.purdue.edu, UUCP: ...!{decwrl,gatech,ucbvax}!purdue!gb


>41 The Texas Persistent Store

  The Texas Persistent Store, version 0.1

Texas is a simple, portable, high-performance and (best of all) FREE
persistent store for C++ using "pointer swizzling at page fault time"
to translate persistent addresses to hardware-supported virtual addresses.

Texas is built on top of a normal virtual memory, and relies on the
underlying virtual memory system for caching.  It uses user-level virtual
memory protections to control the faulting of data from a persistent storage
file into virtual memory.

All addresses in a page are translated from a persistent format to
actual virtual addresses when the page is brought into virtual memory,
and subsequent memory references (including pointer traversals) are
just as fast as for non-persistent data.

Texas is easy to use, and is implemented as a UNIX library.  It is small
and can be linked into applications.  It requires no special operating 
system privileges, and persistence is orthogonal to type---objects may be 
allocated on either a conventional transient heap, or on the persistent
heap, as desired.

Texas supports simple checkpointing of heap data.  A log-structured storage
module is under development, and will provide fast checkpointing of small
transactions.

Texas is beta software, and the current prerelease version supports only
simple single-machine operation.  Future releases will support client-server
operation, a flexible access control scheme, and transaction support.

Texas currently runs under SunOS and ULTRIX, using Sun CC or GNU C++.
Porting to other modern systems (e.g., OS/2, WNT, Mach) should be easy---it
requires only mprotect(), signal(), and sbrk() calls (or their equivalent)
to control virtual memory protection setting and trap handling.

Papers about the pointer swizzling scheme and Texas itself (referenced
below) are available via anonymous ftp from cs.utexas.edu (IP address
128.83.139.9), as postscript files swizz.ps and texaspstore.ps in the
directory pub/garbage.

The source code for Texas is also available, in the directory
pub/garbage/texas.

References:

Paul R. Wilson and Sheetal V. Kakkad, "Pointer Swizzling at Page Fault
Time: Efficiently and Compatibly Supporting Huge Address Spaces on Standard
Hardware," Proc. Second Int'l. Workshop on Object Orientation in Operating
Systems, Sept. 1992, Dourdan, France, pp. 364--377.

Vivek Singhal, Sheetal V. Kakkad, and Paul R. Wilson, "Texas: an Efficient,
Portable Persistent Store", Proc. Fifth Int'l. Workshop on Persistent Object
Systems, Sept. 1992, San Miniato, Italy, pp. 11-33.


>42 OSE C++lib

OSE is a collection of programming tools and class libraries for C++. The
core of the environment is the C++ class libraries, of which three are
provided. These are:

  OTCLIB - A library of generic components, including support for error
  handling, error message logging, error recovery, program debugging,
  memory management, resource management, generic collections, text
  manipulation, operating system interfacing and event driven systems.

  OUXLIB - A library of components which primarily extends classes in the
  OTCLIB library to support features specific to the UNIX operating
  system.

  OTKLIB - A library of components which builds on the OTCLIB and OUXLIB
  libraries to allow integration of the TCL/TK library into applications
  using the event driven systems framework provided by the OTCLIB
  library.

The C++ libraries are portable to a wide range of C++ compilers on the UNIX
platform. Supported C++ compilers include those from USL (CFRONT), DEC, HP,
IBM, Lucid, SGI, SUN, CenterLine and ObjectStore, as well as the freely
available GNU C++ compiler. If your C++ compiler does not support
templates, it is possible to use a template preprocessor which is supplied
with OSE. Portability to all the major variants of UNIX has been achieved.
Supported platforms include BSD, HPUX, IRIX, Linux, OSF, SCO, Solaris,
SunOS, SYSV and Ultrix. In addition to being available under UNIX, the
OTCLIB library is portable to DOS and OS/2 using Borland and Watcom C++
compilers.

OSE was winner of CODA'94, the ComputerWorld Object Developer Awards which
is held in conjunction with ObjectWorld in Sydney, Australia. The category
in which OSE was a winner was "Best implementation of a reusable development
environment for company deployment".

OSE can be obtained via anonymous ftp from:

  Europe:

    ftp.th-darmstadt.de [130.83.55.75]
    directory pub/programming/languages/C++/class-libraries/OSE

  United States

    straylight.acs.ncsu.edu [152.1.65.11]
    directory /pub/ose

  Australia:

    csis.dit.csiro.au [192.41.146.1]
    directory pub/SEG/ose

Documentation for OSE is available online via WWW at:

  http://www.tansu.com.au/Docs/ose/doc/ose-home.html

Questions about OSE can be directed to the author (Graham Dumpleton) at:

  ose@nms.otc.com.au

A mailing list for discussion of OSE, and a mail server providing a list of
known problems and fixes is also available.


>43 Traces,kiczales,MOP,DI

From: gregor@parc.xerox.com (Gregor Kiczales)
Subject: Re: Dynamic Objects
In-Reply-To: rjh@geodesic.com's message of 25 Aug 93 21:52:56 GMT
Message-ID: <GREGOR.93Sep3093506@calvin.parc.xerox.com>
Organization: Xerox Palo Alto Research Center
References: <16C357BF0.MFARMER@utcvm.utc.edu> <1993Aug25.215256.8031@midway.uchicago.edu>
Date: 3 Sep 93 09:35:06

Earlier in this series of messages, Craig Chambers and others mentioned
his ECOOP'93 paper on predicate classes, which provide a powerful handle
on some of the problems that have been mentioned in this series of
messages, specifically, how dynamic changes to an object or its context
can be harnessed to reliably effect the object's (message receipt)
behavior.  As I see it, predicate classes are a key step towards solving
one of the most frustrating problems of OO programming: the struggle
over whether to encode some difference among objects in the value of a
slot (that is one of its parts) or in the object's `method table' (class
or that which it is one-of).

A closely related problem, that has also come up in this series of
messages, is how so-called factory objects can dynamically select the
behavior of the objects they create.  We have developed a new OO
language concept called Traces, that can be used to make much more
powerful factory objects, as well as handle some of the things predicate
classes do.  The two ideas are similar in that they both make behavior
selection a much more dynamic phenomena.

My ISOTAS'93 paper presents the concept of Traces and shows it
application to some problems.  This paper is available for anonymous FTP
from ftp.parc.xerox.com, in the /pub/mops directory.  The file is
traces.ps.

Gregor

Following is the abstract from the paper:
  
Object-oriented techniques are a powerful tool for making a system
end-programmer specializable.  But, in cases where the system not only
accepts objects as input, but also creates objects internally,
specialization has been more difficult.  This has been referred to as
the ``make isn't generic problem.''  We present a new \oo{} language
concept, called traces, that we have used successfully to support
specialization in cases that were previously cumbersome.
  
The concept of traces makes a fundamental separation between two kinds
of inheritance in \oo{} languages: inheritance of default implementation
-- an aspect of code sharing; and inheritance of specialization, a
sometimes static, sometimes dynamic phenomenon.


>44 C++ coding standard

From: metz@iam.unibe.ch (Igor Metz)
Subject: Re: C++ coding standard
Organization: Dept. of CS, University of Berne, Switzerland
Date: Tue, 7 Sep 1993 07:08:21 GMT

euagate.eua.ericsson.se   (Internet Address: 134.138.134.16)
~ftp/pub/eua/c++/rules.ps.Z

[Also an archive site.  E.g. Coplien includes a dir of C++ examples]


>45 Kala Archive

From: sss@world.std.com (Sergiu S Simmel)
Subject: Kala White Paper now available via anonymous ftp
Message-ID: <CD4MyB.Hsn@world.std.com>
Organization: Penobscot Development Corporation, Cambridge MA
Date: Fri, 10 Sep 1993 07:18:11 GMT

An 8-page paper providing an overview of what Kala is and what Kala is
for is now available, in PostScript format, in the Kala Archive. The
file is accessible, via anonymous FTP, at the following location:

          anonymous@world.std.com:/pub/kala/TechDocs/Overview.ps

The outline is the following

        1 What is Kala For?
        2 Software Infrastructure
                Persistent Data and Persistent Stores
        3 Data Transfer
        4 Data Visibility
                Changing Visibility
                Sharing Visibility
                Transactions
                Versions
        5 Runtime and Architectural Models
        6 Relationship to Other Technologies

This paper is targeted towards those who don't know anything about
Kala and would like to find out a bit in 10 pages or less.

Enjoy!

P.S. For those of you who do not have FTP access and would like to
     obtain this file, please send a brief e-mail message to
     info@Kala.com, requesting that the file be e-mailed to you.
     Beware that the file is approximately 425Kbytes long (the paper
     contains 13 illustrations!).


>46 BeBOP(seq,par,LP,OO,meta)

From: ad@munta.cs.mu.OZ.AU (Andrew Davison)
Subject: BeBOP v.1.0 Available
Message-ID: <9325614.15552@mulga.cs.mu.OZ.AU>
Organization: Department of Computer Sci, University of Melbourne
Follow-Up: comp.parallel
Date: Mon, 13 Sep 1993 04:08:41 GMT

 BeBOP and bp Version 1.0 now available
 ======================================

 What is BeBOP?
 ==============
The language BeBOP is a unique combination of sequential 
and parallel Logic Programming (LP), object oriented 
programming and meta-level programming. 

The LP component offers both don't know non-determinism
and stream AND-parallelism, a combination not possible 
with concurrent LP languages. 

BeBOP's object oriented features include object IDs, 
encapsulation, message passing, state updating, and 
object behaviour modification. 

The meta-level capabilities are based on the treatment 
of Prolog theories as first order entities, which 
enables them to be updated easily, and for fragments 
to be passed between objects in messages.

BeBOP is implemented by translation down to NU-Prolog,
and its parallel extension, PNU-Prolog. An unusual
aspect of this is the way that object IDs are utilized 
as a communication mechanism between objects.

 What is bp?
 ===========
The bp interactive interpreter supports BeBOP programming 
by allowing the flexible invocation of objects, and 
offering the means for setting up communication links 
between objects at any time. An incidental benefit is 
the ability to use `global' variables in queries. Since 
bp is an augmentation of the NU-Prolog np system, objects 
and Prolog goals can be combined, and a by-product is 
that the floundering of Prolog queries is avoided.


 Where are they?
 ===============
The BeBOP system (BeBOP and bp), and the PNU-Prolog 
preprocessor pnp, can be found at the anonymous ftp 
site munnari.oz.au (128.250.1.21), in the directory 
pub as the file bebop.tar.Z. Remember to use binary 
mode when copying it.

The release comes with a user manual, several papers 
(in Postscript format), sample programs, and source code.


 System requirements
 ===================
The BeBOP system requires the following:

* The NU-Prolog system, compiler and interpreter
* The pnp preprocessor 
  (this is included as part of the BeBOP system release)
* GCC or similar compiler
* Yacc (or Bison) and Lex


 For more details, contact:
 ==========================
        Andrew Davison
        Dept. of Computer Science
        University of Melbourne
        Parkville, Victoria 3052
        Australia

Email:  ad@cs.mu.oz.au
Fax:    +61 3 348 1184
Phone:  +61 3 287 9172 / 9101
Telex:  AA 35185


>47 Knowledge Media, Massive cd-rom, lots of freeware

A "Resource Library" of cd-rom discs .  CDs for language/OS, graphics, multi-
media, mega-media (3), and audio.  "Gathered from the resources of the
Internet, CompuServe, Genie, BIX, and other BBS's".  Some shareware.  Should be
available at your local software store.

From the back of the Languages CD:

  'Over 100 Languages'
        ...

This is the largest collection of compilers, interpreters, libraries, and
source code for standard and experimental computer languages and operating
systems ever assembled.  A must for anyone interested in computer programming,
this disc is just right for everyone, whether he or she is a researcher,
student, or an interested hobbist.

Knowledge Media Inc.
Paradise, CA  95969 USA


>48 u++, C++ Trans. and Concry RTS

From: nat@nataa.frmug.fr.net (Nat Makarevitch)
Subject: Re: 'Concurrent Objects' - Suggestions needed
Date: 10 Oct 1993 02:41:15 GMT
Organization: LIVIA

       u++ - uC++ Translator and Concurrency Runtime System

DESCRIPTION
The u++ command introduces  a  translator  pass  over  the
specified source files after the C preprocessor and before
the actual C++ compilation.  The translator converts  sev-
eral  new  uC++  constructs  into C++ statements.  The u++
command also provides  the  runtime  concurrency library,
which must be linked with each uC++ application.

                                                                 
REFERENCES                                                       
uC++:  Concurrency in the Object-Oriented Language C++, by      
P.A.  Buhr,  G.  Ditchfield,  R.A.   Stroobosscher,   B.M.
Younger, C.R.  Zarnke;   Software-Practise and Experience,
22(2):137--172, February 1992.  This paper describes  uC++
v2.0, which has been significantly extended.

The  uC++  system is available via anonymous FTP
from watmsg.UWaterloo.ca:pub/uSystem.  A license agreement
is required to use uC++.


>49 Real Time

From: dstewart+@cs.cmu.edu (David B Stewart)
Subject: Re: Object-Oriented Systems and Realtime
Organization: The Robotics Institute, Carnegie Mellon University
Date: Mon, 11 Oct 1993 16:51:19 GMT

In article <1993Oct11.082519.23058@cs.tcd.ie>,
Chris Zimmermann <czimmerm@cs.tcd.ie> wrote:
>Hi community:
>
>What is the state of the art concerning real time in 
>object-oriented systems (if any)? By this, I mean the
>marriage of more or less traditional real time systems
>(including systems concerned with "soft" real time aspects
>like multimedia) with the OO paradigm.
>[...]

We've done significant work in that area.  Check out the following tech
report:

D. B. Stewart, R. A. Volpe, and P. K. Khosla, "Design of Dynamically
    Reconfigurable Real-Time Software using Port-Based Objects," 
    Carnegie Mellon University Tech Report #CMU-RI-TR-93-11, July 1993.

	Abstract: The current development of applications for sensor-based
	robotic and automation (R&A) systems is typically a `one-of-a-kind'
	process, where most software is developed from scratch, even though
	much of the code is similar to code written for other applications.
	The cost of these systems can be drastically reduced and the capability
	of these systems improved by providing a suitable software framework
	for all R&A sys tems. We describe a novel software framework, based on
	the notion of dynamically reconfigurable software for sensor-based
	control systems. Tools to support the implementation of this framework
	have been built into the Chimera 3.0 Real-Time Operating System. The
	framework provides for the systematic development and predictable
	execution of flexible R&A applications while maintaining the ability to
	reuse code from previous applications. It combines object-oriented
	design of software with port-automaton design of digital control
	systems. A control module is an instance of a class of port-based
	objects. A task set is formed by integrating objects from a module
	library to form a specific configuration. An implementation using
	global state variables for the automatic integration of port-based
	objects is presented. A control subsystem is a collection of jobs
	which are executed one at a time, and can be programmed by a user.
	Multiple control subsystems can execute in parallel, and operate
	either independently or cooperatively. One of the fundamental concepts
	of reconfigurable software design is that modules are developed
	independent of the target hardware. Our framework defines classes of
	reconfigurable device driver objects for proving hardware independence
	to I/O devices, sensors, actuators, and special purpose processors.
	Hardware independent real-time communication mechanisms for
	inter-subsystem communication are also described. Along with providing
	a foundation for design of dynamically reconfigurable real-time
	software, we are also developing many modules for the control module,
	device driver, and subroutine libraries. As the libraries continue to
	grow, they will form the basis of code that can eventually be used by
	future R&A applications. There will no longer be a need for developing
	software from scratch for new applications, since many required modules
	will already be available in one of the libraries.  

This report is available via anonymous FTP as follows:

	% ftp IUS4.IUS.CS.CMU.EDU	(128.2.209.143)
	Name:       anonymous
	Password:   yourname@yourmachine
	ftp> binary
	ftp> cd /usr/chimera/public
	ftp> get CMU_RI_TR_93_11.ps.Z
	ftp> quit
	% uncompress CMU_RI_TR_93_11.ps.Z
	% lpr CMU_RI_TR_93_11.ps	(must be a postscript printer)

For more information, 'finger chimera@cmu.edu'.

>50 Ada-9x (compiler, GNU)

From: stt@spock.camb.inmet.com (Tucker Taft)
Subject: Re: which language to use ...?
Organization: Intermetrics, Inc.
Date: Mon, 1 Nov 1993 23:22:42 GMT

 >[...]

Also, there is a preliminary release of a GNU-GCC-based Ada 9X
compiler available from NYU on cs.nyu.edu in pub/gnat/...
The front end is written in Ada itself; the back end
is the usual GCC back end (enhanced as appropriate).

S. Tucker Taft  stt@inmet.com
Intermetrics, Inc.
Cambridge, MA  02138


>51 OO Course Slides

From: wellerd@ajpo.sei.cmu.edu (David Weller)
Subject: Re: Slides on OOP or OMT wanted
Organization: Sigma Software Engineering, Inc.
Date: Fri, 5 Nov 1993 11:01:44 EST

In article <2bdot7$3nr@news-rocq.inria.fr> ziane@lolita.inria.fr (Mikal Ziane (Univ. Paris 5 and INRIA) ) writes:
>
>Hello netters,
>
>Is anybody aware of public domain slides available on an ftp site ?
>I'd like slides on OO programming or OO design methods (esp. OMT).
>I know I am crazy to ask for that but someone told me he saw
>a very good C++ course on some ftp site ! (he does not remember which one 
>unfortunatemy)
>

It's true!  On WUArchive (wuarchive.wustl.edu) there is a series of
slides developed in Microsoft's PowerPoint.  The course material
includes lesson plans, tests, and workbooks, along with full notes
accompanying each slide.

There's one _little_ catch -- it's in the Public Ada Library.  Now,
the OOP course (there's three courses, one on OOD, OOP, and Software
Engineering) covers both C++ and Ada.  It was designed to let the
students work in both languages to get an objective opinion of the
pluses and minuses of each language (gee, what a concept!).

The OOD slides do NOT cover OMT.  Some material is used from Booch's
OOD book, but not the notation.  From looking at the slides, it appears
very easy to insert your own notation.  The important part for students
is communicating the concepts, which (for the price) these slides do
a DAMN good job of. <- (Safire's Violation #45: "A perposition is a 
bad thing to end a sentence with." :-)

Ah, but WHERE on WUArchive are they?  If you look under 
languages/ada/crsware, I believe you'll find them.  Good luck!

dgw
-- 
type My_Disclaimer is new Standard.Disclaimer with record
	AJPO, SEI : Cognizance := Disavow_All_Knowledge;
end record;--)


>52 GTE Distrib Reports

From: em02@gte.com (Emon)
Subject: Reports Available From The Distributed Object Computing Department
Date: 5 Nov 93 18:10:15 GMT
Organization: GTE Laboratories, Inc.

                        REPORTS AVAILABLE FROM
             THE DISTRIBUTED OBJECT COMPUTING DEPARTMENT
                     GTE LABORATORIES INCORPORATED
                        40 Sylvan Road, M/S 62
                     Waltham, Massachusetts 02254


For over six years, the primary focus of the Distributed Object Computing
Department within GTE Laboratories has been the Distributed Object
Management (DOM) project. The DOM project conducts research into
object-oriented technology for integrating heterogeneous, autonomous,
distributed (HAD) computer systems/resources. Major research areas include:
interoperable object models; interoperable, distributed object
architectures; heterogeneous, extended transaction models; and information
requests in HAD environments. We are experimenting in these areas using our
prototype DOM system which we have developed over the past five years. This
technology is based on ideas from a number of technical areas including
distributed, object-oriented, databases, multi-database systems, operating
systems, and programming languages.

Permission is granted at this time for the operations and uses listed
below. However, this permission is non-transferable and is subject to
revocation on a report-by-report basis, due to possible copyright transfers
that are normal in the publication process. Any additional copyright
restrictions are noted in the reports themselves. Default permissions are
for anonymous ftp, electronic viewing, and single-copy printing.
Permissible uses are research and browsing. Specifically prohibited are
SALES of any copy, whether electronic or hardcopy, of any of these reports
for any purpose. Also prohibited is copying, excerpting or extensive
quoting of any report in another work without the written permission of one
of the report's authors.

Reports marked with a "*" can be retrieved in postscript(ascii) form via
anonymous ftp from ftp.gte.com (132.197.8.2) in the "pub/dom" subdirectory.
 
 >>>>>>>>> 1994

[GEOR94a]*   Georgakopoulos, D., M. Rusinkiewicz, and W. Litwin,
"Chronological Scheduling of Transactions with Temporal Dependencies," to
appear in the VLDB journal, January 1994 (submitted in December 1990). 

[GEOR94b]*   Georgakopoulos, D., M. Hornick, P. Krychniak, and F. Manola,
"Specification and Management of Extended Transactions in a Programmable
Transaction Environment," to appear in the Proceedings of the 10th
International Conference on Data Engineering, Houston, Texas, February
1994. Also published as TC-0207-02-93-165, GTE Laboratories Incorporated,
February 1993.


 >>>>>>>>> 1993

[BROD93a]*   Brodie, M.L., "The Promise of Distributed Computing and the
Challenge of Legacy Information Systems," in Hsiao, D., E.J. Neuhold, and
R. Sacks-Davis (eds), Proc. IFIP TC2/WG2.6 Conference on Semantics of
Interoperable Database Systems, Lorne, Australia, November 1992, Elsevier
North Holland, Amsterdam 1993.

[BROD93b]*   Brodie, M.L. and M. Stonebraker, "DARWIN: On the Incremental
Migration of Legacy Information Systems," DOM Technical Report,
TR-0222-10-92-165, GTE Laboratories Inc., March 1993.

[GEOR93a]*   Georgakopoulos, D., M. Hornick, and P. Krychniak, "An
Environment for Specification and Management of Extended Transactions in
DOMS," to appear in Proceedings of the 3rd International Workshop on
Interoperability in Multidatabase Systems, Vienna, Austria, April 1993.

[GEOR93c]*   Georgakopoulos, D., M. Rusinkiewicz and A. Sheth, "Using
Ticket-based Methods to Enforce the Serializability of Multidatabase
Transactions," to appear in the IEEE Transactions on Data and Knowledge
Engineering December 1993 (submitted in February 1992).

[GEOR93e]*   Georgakopoulos, D., M. Hornick, F. Manola, M. Brodie, S.
Heiler, F. Nayeri, and B. Hurwitz, "An Extended Transaction Environment for
Workflows in Distributed Object Computing," in IEEE Data Engineering, pp.
24-27, vol. 16, no. 2, June 1993.

[MANO93a]   Manola, F., "The Need for Object Model Interoperability,"
Workshop Report, Workshop on Application Integration Architectures, Dallas,
Texas, February 1993

[MANO93c]*   Manola, F. and S. Heiler, "A 'RISC' Object Model for Object
System Interoperation: Concepts and Applications," TR-0231-08-93-165, GTE
Laboratories, Inc., August 1993.

[MITC93a]   Mitchell, G., "Extensible Query Processing in an
Object-Oriented Database," PhD Thesis, Brown University Technical Report
No. CS-93-16, May 1993. Available in hard copy from Brown University,
Computer Science Department, and postscript format via anonymous ftp from
wilma.cs.brown.edu as file techreports/93/cs93-16.ps.Z

[NAYE93c]*   Nayeri, F., and B. Hurwitz, "Experiments with Dispatching in a
Distributed Object System," GTE Laboratories, Inc., TR-0236-09-93-165, July
1993.

[NAYE93d]*   Nayeri, F., "Addressing Component Interoperability in the OMG
Object Model," position paper submitted to ORB Implementors' Workshop, San
Francisco, June 1993.

[NICO93a]   Nicol, J., T. Wilkes, and F. Manola, "Object Orientation in
Heterogeneous Distributed Computing Systems," IEEE Computer, pp. 57-67,
Vol. 26, No.6, June 1993.

[VENT93]*   Ventrone, V. and S. Heiler, "Some Practical Advice for Dealing
with Semantic Heterogeneity in Federated Database Systems," Submitted to
USENIX.


 >>>>>>>>> 1992

[BGR92]*   Batra, R., D. Georgakopoulos, and M. Rusinkiewicz, "A
Decentralized Deadlock-free Concurrency Control Method for Multidatabase
Transactions," in Proceedings of 12th International Conference on
Distributed Computing Systems, Yokohama, Japan, June, 1992.

[BRO92b]*   Brodie, M.L. and J. Mylopoulos , "Artificial Intelligence and
Databases: Dawn, Midday, or Sunset?," Canadian Information Processing
/Informatique Canadienne, July/August 1992.

[BROD92c]*   Brodie, M.L. and S. Ceri, "On Intelligent and Cooperative
Information Systems," in International Journal of Intelligent and
Cooperative Information Systems 1, 2 September 1992. 

[BUCH92]   Buchmann, A.P., M.T. Ozsu, M. Hornick, D. Georgakopoulos, F.A.
Manola, "A Transaction Model for Active Distributed Object Systems," in
Database Transaction Models for Advanced Applications, A.K. Elmagarmid,
(ed.), Morgan Kaufmann, San Mateo, CA, Spring 1992.

[GEOR92]*   Georgakopoulos, D., "A Framework for Dynamic Specification of
Extended Multidatabase Transactions and Interdatabase Dependencies,"
Proceedings of Third Workshop on Heterogeneous Databases and Semantic
Interoperability, Boulder, February, 1992.

[HEIL92]   Heiler, S., S. Haradhvala, B. Blaustein, A. Rosenthal, and S.
Zdonik, "A Flexible Framework for Transaction Management in Engineering
Environments," in Database Transaction Models for Advanced Applications,
A.K. Elmagarmid (ed.), Morgan Kaufmann, San Mateo, CA, Spring 1992.

[MANO92]*   Manola, F., S. Heiler, D. Georgakopoulos, M. Hornick, M.
Brodie, "Distributed Object Management," International Journal of
Intelligent and Cooperative Information Systems 1, 1 March 1992.

[MANO92a]*   Manola, F. and S. Heiler, "An Approach To Interoperable Object
Models," Proceedings of the International Workshop on Distributed Object
Management, Edmonton, Canada, August 1992 (also in Distributed Object
Management, M.T. Ozsu, U. Dayal, and P. Valduriez (eds.), Morgan Kaufmann,
San Mateo, CA, 1993).


 >>>>>>>>> 1991

[BROD91]   Brodie, M., "Distributed Object Management Research,"
Proceedings of the Second Telecommunications Information Networking
Architecture (TINA) Workshop, pp. 297-303, Chantilly, France, March 1991.

[BROD91a]*   Brodie, M. and M. Hornick, "An Interoperability Development
Environment For Intelligent Information Systems," Proceedings of the
International Workshop on the Development of Intelligent Information
Systems, Niagara-on-the-Lake, April 1991.

[BUCH91]*   Buchmann, A.P., M. Tamer Ozsu, and D. Georgakopoulos, "Towards
a Transaction Management System for DOM," TR-0146-06-91-165, GTE
Laboratories Incorporated, June 1991.

[GEOR91a]*   Georgakopoulos, D., M. Rusinkiewicz, and A. Sheth, "On
Serializability of Multidatabase Transactions Through Forced Local
Conflicts," Proceedings of the 7th International Conference on Data
Engineering, Kobe, Japan, April 1991.

[GEOR91b]*   Georgakopoulos, D., "Multidatabase Recoverability and
Recovery," Proceedings of the First International Workshop on
Interoperability in Multidatabase Systems, Kyoto, Japan, April 1991.

[GRL91]   Georgakopoulos, D., M. Rusinkiewicz, and W. Litwin,
"Chronological Scheduling of Transactions with Temporal Dependencies," in
the VLDB journal, available draft also as a Technical Report from the
Department of Computer Science at the University of Houston, UH-CS-91-03,
February, 1991.

[HEIL91]*   Heiler, S., "Extended Data Type Support in Distributed DBMS
Products: A Technology Assessment and Forecast," TR-170-12-91-165. GTE
Laboratories Incorporated, December 1991.

[HORN91]*   Hornick, M.F., J.D. Morrison, and F. Nayeri, "Integrating
Heterogeneous, Autonomous, Distributed Applications Using the DOM
Prototype," TR-0174-12-91-165. GTE Laboratories Incorporated, December
1991.

[MANO91]   Manola, F. and U. Dayal, "An Overview of PDM: An Object-Oriented
Data Model," in K.R. Dittrich, U. Dayal, and A.P. Buchmann (eds.), On
Object-Oriented Database Systems, Springer-Verlag, 1991.

[MANO91a]*   Manola, F., "Object Data Language Facilities for Multimedia
Data Types," TR-0169-12-91-165. GTE Laboratories Incorporated, December
1991.

[MANO91b]   Manola, F., "The Third-Generation/OODBMS Manifesto, Commercial
Version," SIGMOD Record, Vol. 20, No. 4, December 1991.

[RUSI91]   Rusinkiewicz, M. and D. Georgakopoulos, "Multidatabase
Transactions: Impediments and Opportunities," Compcon Spring '91 Digest of
Papers, San Francisco, February 1991.

[VENT91]   Ventrone, V. and S. Heiler, "Semantic Heterogeneity as a Result
of Domain Evaluation," SIGMOD Record Special Issue: Semantic Issues in
Multidatabase Systems, Vol. 20, No. 4, December 1991.


 >>>>>>>>> 1990

[BREI90]   Breitbart, Y., D. Georgakopoulos, and M. Rusinkiewicz, A.
Silberschatz, "Rigorous Scheduling in Multidatabase Systems," Proceedings
of Workshop in Multidatabases and Semantic Interoperability, Tulsa, pp.
658-667, November 1990.

[BROD90]*   Brodie, M.L., F. Bancilhon, C. Harris, M. Kifer, Y. Masunaga,
E.D. Sacerdoti, K. Tanaka, "Next Generation Database Management Systems
Technology," in Deductive and Object-Oriented Databases, W. Kim, J-M
Nicolas, S. Nishio, (eds.), Elsevier Science Publishers, 1990.

[HEIL90]   Heiler, S., F. Manola and S. Zdonik, "An Object-Oriented
Database Approach to Federated Systems," (unpublished paper), 1990.

[MANO90]   Manola, F., "Object-Oriented Knowledge Bases," AI Expert, 5(3),
5(4), March and April 1990.

[MANO90a]*   Manola, F. and A. Buchmann "A Functional/Relational
Object-Oriented Model for Distributed Object Management: Preliminary
Description" TM-0331-11-90-165. GTE Laboratories Incorporated, December
1990.

[MANO90b]*   Manola, F., M. Hornick, and A. Buchmann "Object Data Model
Facilities for Multimedia Data Types" TM-0332-11-90-165, GTE Laboratories
Incorporated, December 1990.

[MYLO90]*   Mylopoulos, J. and M. Brodie, "Knowledge Bases and Databases:
Current Trends and Future Directions," Lecture Notes in Computer Science,
Vol. 474: Information Systems and Artificial Intelligence: Integration
Aspects, D. Karagiannia, (ed.), Springer-Verlag, New York, 1990.

[RUSI90]   Rusinkiewicz, M., D. Georgakopoulos, and R. Thomas, "RDS: A
Primitive for the Maintenance of Replicated Data Objects," Proceedings of
Second IEEE Symposium on Parallel and Distributed Processing, Dallas, pp.
658-667, December 1990.

[SILB90]   Silberschatz, A., M. Stonebraker, and J.D. Ullman (eds.), M.L.
Brodie, P. Buneman, M. Carey, A. Chandra, H. Garcia-Molina, J. Gray, R.
Fagin, D. Lomet, D. Maier, M.A. Niemat, A. Silberschatz, M. Stonebraker, I.
Traiger, J. Ullman, G. Wiederhold, C. Zaniolo, and M. Zemankova, P.A.
Bernstein, W. Kim, H.F. Korth, and A. van Tilborg, (co-authors), "Database
Systems: Achievements and Opportunities," ACM SIGMOD Record, 19, 4,
December 1990; also appeared in Communications of the ACM, Vol. 34, No.10,
pp. 110-120, October 1991.

[STON90]   Stonebraker, M. , L.A. Rowe, B. Lindsay, J. Gray, M. Carey, M.L.
Brodie, P. Bernstein, and D. Beech, "Third-Generation Data Base System
Manifesto," ACM SIGMOD Recored 19, 3, September 1990.

[ZERT90]   Zertuche, D.R. and A.P. Buchmann, "Execution Models for Active
Database Systems: A Comparison," TM-0238-01-90-165, GTE Laboratories
Incorporated, January 1990.


 >>>>>>>>> 1989

[BROD89]   Brodie, M., D. Bobrow, V. Lesser, S. Madnick, D. Tsichritzis,
and C. Hewitt, "Future Artificial Intelligence Requirements for Intelligent
Database Systems" Expert Database Systems: Proceedings From the Second
International Conference, L. Kerschberg (ed.), Benjamin/Cummings, Menlo
Park, CA, 1989.

[BROD89a]   Brodie, M. , J. Mylopoulos, "Future Intelligent Information
Systems: AI and Database Technologies Working Together," in M. Brodie, J.
Mylopoulos, (eds. and contributors), Readings in Artificial Intelligence
and Databases, Morgan Kaufmann, San Mateo, CA, 1989.

[MANO89]*   Manola, F., "Applications of Object-Oriented Database
Technology in Knowledge-Based Integrated Information Systems," GTE
Laboratories Incorporated, April 1989.

[MANO89a]*   Manola, F., "Object Model Capabilities For Distributed Object
Management," TM-0149-06-89-165, GTE Laboratories Incorporated, June 1989.

[MANO89b]*   Manola, F., "An Evaluation of Object-Oriented DBMS
Developments," TR-0066-10-89-165, GTE Laboratories Incorporated, October
1989.

[WELC89]   Welch, J.L. and A.P. Sistla, "Object-Based Concurrency Control
and Recovery Mechanisms," TM-0150-06-89-165, GTE Laboratories Incorporated,
June 1989.


 >>>>>>>>> 1988

[MANO88]*   Manola, F., "Distributed Object Management Technology,"
TM-0014-06-88-165, GTE Laboratories Incorporated, June 1988.


 >>>>>>>>> 1987

[MANO87]   Manola, F., "A Personal View of DBMS Security," Database
Security: Status and Prospects, C.E. Landwehr (ed.), Elsevier Science
Publishers B.V., North Holland, 1988, 23-34; TN CS1.1, GTE Laboratories
Incorporated, December 1987.



_[GEOR94a]* _[GEOR94b]*
_[BROD93a]* _[BROD93b]* _[GEOR93a]* _[GEOR93c]* _[GEOR93e]*
_[MANO93a]  _[MANO93c]* _[NAYE93c]* _[NAYE93d]* _[NICO93a] 
_[VENT93]*
_[BGR92]    _[BRO92b]*  _[BROD92c]* _[BUCH92]   _[GEOR92]*
_[HEIL92]   _[MANO92]*  _[MANO92a]* 
_[BROD91]   _[BROD91a]* _[BUCH91]*  _[GEOR91a]* _[GEOR91b]*
_[GRL91]    _[HEIL91]*  _[HORN91]*  _[MANO91]   _[MANO91a]* 
_[MANO91b]  _[RUSI91]   _[VENT91] 
_[BREI90]   _[BROD90]*  _[HEIL90]   _[MANO90]   _[MANO90a]* 
_[MANO90b]* _[MYLO90]*  _[RUSI90]   _[SILB90]   _[STON90] 
_[ZERT90] 
_[BROD89]   _[BROD89a]  _[MANO89]*  _[MANO89a]* _[MANO89b]*
_[WELC89] 
_[MANO88]* 
_[MANO87]


>53  KEOBJ, OO DSP micro-kernel

From: clb@softia.com (Chris Bidaut)
Subject: Object kernel for DSP & RISC processors
Date: Mon, 15 Nov 1993 22:48:46
Organization: Softia, Inc.

This is an announcement for KEOBJ, an object-oriented micro-kernel for Digital
Signal Processors (DSP) and RISC processors.  This is also a request for 
comments from the Internet community. Feedback on the architecture and 
programming interface will be appreciated and incorporated into the next
release.


1 DESCRIPTION
-------------

KEOBJ is an object-oriented micro-kernel optimized for advanced embedded 
applications, and it particularly targets Digital Signal Processors (DSP) 
and RISC processors in multimedia environments.

Its main features are object-orientation, real-time behavior, signal processing
support, micro-kernel architecture and scalability.

1.1 Object-orientation

The kernel is a collection of system classes exported to the applications
(e.g Process, Thread, Memory, ...).
An object name space provides a way to locate any public object (e.g. IPC, 
memory) using a symbolic path.
The kernel is written in C++ and is easily portable.

1.2 Real-time behavior

The design stresses fast response time and predictability to qualify for the 
real-time label. The kernel is reentrant and preeemptable.

1.3 Signal processing support

Besides providing an architecture appropriate for most general purpose 
applications, the kernel incorporates dedicated features for signal processing
applications. This includes two phases interrupt processing, time-deadline
scheduling, Inter Process Communications, multiple memory pools, awareness of
the constraints due to a single data type (word).

1.4 Micro-kernel architecture

Probably the most important feature of the kernel is the ability to be
extended at run-time with new services such as devices drivers, public
classes (IPC, file systems, windowing systems). Applications and system
services are dynamically loaded by a COFF compatible loader.

The core kernel is customizable at run-time through a personality mechanism 
to emulate other environments (Operating systems) or to tailor the processes
environments. 

1.5 Scalability

The API supports physical and virtual memory organizations with the same 
semantics.

Applications source code will be portable across DSP and RISC processors.

The architecture supports symmetric multiprocessing and distribution (Available
by mid-1994).


2 WHERE TO FIND THE PACKAGE
---------------------------

A set of documentation about KEOBJ is available via anonymous ftp on the 
following Internet server:
		netcom.com (192.100.81.100) in file /pub/softia/keobj.zip


If you do not have access to Internet, contact me for other delivery media at:
Chris Bidaut			clb@softia.com
Telephone (408) 262-6520	Fax (408) 262-7210


>54  MindFrame for Windows

From: gcl@netcom.com (Geoff Lee)
Subject: "MindFrame for Windows" (freeware) application is available for ftp
Date: Tue, 16 Nov 1993 21:07:28 GMT

	MindFrame for Windows 1.0 Release Note
	======================================

mndframe.zip (MindFrame for Windows) is available for anonymous ftp
on ftp.cica.indiana.edu. It is currently in /pub/pc/win3/uploads.

"MindFrame for Windows" is a freeware application developed to
teach an object modeling approach presented in the
book: "Object-Oriented GUI Application Development" Geoff Lee,
Prentice-Hall, 1993, ISBN 0-13-363086-2.

This application is useful in many other areas as well, for
example, in Bible studying (metaphors, parables, prophecies,
types), neural modeling, ecological modeling, and task modeling.
There are 20 sample applications covering these areas. There
are also description of each of the sample application in the
on-line Help. Read "About MindFrame..." help topic for more
information.

This is a copyrighted software, but you can freely redistribute if
you keep the release intact.

The following is the content of mdnframe.txt file in the .zip file:

1. Installation Procedure:
   DOS> mkdir MndFrame
   DOS> cd MndFrame
   DOS> copy b:MndFrame.zip   (or where you kept the mndframe.zip file)
   DOS> unzip -d mndframe.zip  (extract files into subdirectories)
   DOS> copy grid.vbx \windows\systems (your local Windows system directory)

2. Running the application:
   . In Windows, open your "File Manager"
   . Go to \MndFrame directory
   . Find the MndFrame.exe file
   . Drag the MndFrame.exe file icon into a "Program Manager" window
   . Open the MndFrame.exe program

3. Sample applications:
   Once you are in the MindFrame application, open files in the 
   \MndFrame\Samples subdirectories. There are 20 sample files organized
   according to areas of application (e.g., object modeling, neural
   modeling, bible studying). You can also find description of each of
   these samples in the On-Line Help file.

4. On-line help:
   Use the "About MindFrame..." menu item in the "Help" menu to learn more
   about this application. There is an on-line help provided for this
   application. Read through the help topics to learn about using this
   application.

5. Files in this release:
   mndframe.txt: this file.
   mdnframe.exe: the executable file of "MindFrame for Windows" freeware.
   mndframe.hlp: the on-line help file for "MindFrame for Windows".
   biblnote.ps:  the PostScript file of help text on using this application
   	         to study metaphors, parables, types, and prophecies in the
   	         Holy Bible.
   grid.vbx:     the visual basic grid control that is necessary to run this
   	         application. It must be copied into your local "system"
   	         directory for Windows (\windows\system in most cases).
   samples\*:    in this directory, there are 20 samples (*.frm files) in 
   	         the subdirectories for each application area 
   	         (e.g., objmodel, ecology, neural, parable).

New MindFrame anonymous FTP Directory:

It has been moved to a more permanent directory: /pub/pc/win3/programr.

>55  ACE Lib, C++ Networking

From: schmidt@liege.ics.uci.edu (Douglas C. Schmidt)
Subject: Re: C++ and Semaphores
Date: 22 Nov 1993 19:27:00 -0800
Organization: University of California at Irvine: ICS Dept.

       THE "ADAPTIVE COMMUNICATION ENVIRONMENT" (ACE) LIBRARY:

	  A Collection of C++ Network Programming Components
	  --------------------------------------------------

	The ACE library is available for anonymous ftp from the
ics.uci.edu (128.195.1.1) host in the gnu/C++_wrappers.tar.Z file
(approximately .4 meg compressed).  This release contains contains the
source code, documentation, and example test drivers for a number of
C++ wrapper libraries and higher-level network programming foundation
classes developed as part of the ADAPTIVE transport system project at
the University of California, Irvine.

	. The C++ wrappers encapsulate many of the user-level BSD and
	  System V Release 4 IPC facilities such as sockets, TLI,
	  select and poll, named pipes and STREAM pipes, the mmap
	  family of memory-mapped file commands, System V IPC (i.e.,
	  shared memory, semaphores, message queues), and explicit
	  dynamic linking (e.g., dlopen/dlsym/dlclose) using
	  type-secure, object-oriented interfaces. 

	. The higher-level network programming foundation classes
	  integrate and enhance the lower-level C++ wrappers to
	  support the configuration of concurrent network daemons
	  composed of monolithic and/or stackable services

	Many of the C++ wrappers and higher-level components have been
described in issues of the C++ Report, as well as in the proceedings
of (1) the 2nd Annual C++ World conference held in Dallas, Texas in
October, 1993, (2) the 11th Annual Sun Users Group Conference held in
San Jose, CA in December, 1993, and (3) the 2nd International Workshop
on Configurable Distributed Systems held at CMU in Pittsburgh, PA in
March, 1994.  A relatively complete set of documentation and extensive
examples are included in the release.  A mailing list is available for
discussing bug fixes, enhancements, and porting issues regarding ACE.
Please send mail to ace-users-request@ics.uci.edu if you'd like to
become part of the mailing list.

CONTENTS OF THE RELEASE

	The following subdirectories are included in this release:

	. apps    -- complete applications written using the ACE wrappers
	. bin	  -- utility programs for building this release such as g++dep
	. build	  -- a separate subdirectory that keeps links into the main
		     source tree in order to facilitate multi-platform
		     build-schemes
	. include -- symbolic links to the include files for the release
	. lib	  -- object archive libraries for each C++ wrapper library
	. libsrc  -- the source code for the following C++ wrappers:
			ASX -- higher-level C++ network programming foundation classes
			Get_Opt -- a C++ version of the UNIX getopt utility
			IPC_SAP -- wrapper for BSD sockets
			IPC_SAP_FIFO -- wrapper for FIFOS (named pipes)
			IPC_SAP_SPIPE -- wrapper for SVR4 STREAM pipes and connld 
			Log_Msg -- library API for a local/remote logging facility
			Mem_Map -- wrapper for BSD mmap() memory mapped files 
			Message_Queues -- wrapper for SysV message queues
			Reactor -- wrapper for select() and poll()
			Semaphores -- wrapper for SysV semaphores
			Server_Daemon -- a wrapper for dynamically linking
			Shared_Memory -- wrapper for SysV shared memory
			Shared_Malloc -- wrapper for SysV/BSD shared mallocs
			TLI_SAP -- wrapper for SVR4 TLI 
	. tests -- programs that illustrate how to use the various wrappers

	Please refer to the INSTALL file for information on how to
build and test the ACE wrappers.  The BIBLIOGRAPHY file contains
information on where to obtain articles that describe the ACE wrappers
and the ADAPTIVE system in more detail.

	Also, please note that there is a companion tar file called
C++_wrappers_doc.tar.Z, which is approximately 1.5 Meg compressed.
This file is in the same ftp/gnu directory as the source code
distribution.  In this file is the following:

	. doc	  -- LaTeX documentation (in both latex and .ps format)
	. papers  -- postscript versions of various papers describing ACE

COPYRIGHT INFORMATION

	You are free to do anything you like with this code.  However,
you may not do anything to this code that will prevent it from being
distributed freely in its original form (such as copyrighting it,
etc.).  Moreover, if you have any improvements, suggestions, and or
comments, I'd like to hear about it!  It would be great to see this
distributed evolve into a comprehensive, robust, and well-documented
C++ class library that would be freely available to everyone.
Natually, I am not responsible for any problems caused by using these
C++ wrappers.

	Thanks,
	
		Douglas C. Schmidt
		(schmidt@ics.uci.edu)
		Department of Information and Computer Science
		University of California, Irvine
		Irvine, CA 92717
		Work #: (714) 856-4105
		FAX #: (714) 856-4056

ACKNOWLEDGEMENTS
	
	Special thanks to Paul Stephenson for devising the recursive 
Makefile scheme that underlies this distribution.  Also thanks to Olaf
Kruger for explaining how to instantiate templates for shared
libraries on SunOS 4.
-- 
Douglas C. Schmidt
Department of Information and Computer Science
University of California, Irvine
Irvine, CA 92717. Work #: (714) 856-4105; FAX #: (714) 856-4056


>56  Teaching Intro to OO Slides, T. Budd

From: budd@daimi.aau.dk (Tim Budd)
Subject: Re: Slides on OOP or OMT wanted
Date: 8 Nov 1993 07:46:08 GMT
Organization: DAIMI, Computer Science Dept. at Aarhus University

>...

I also have a series of slides that I have developed for use with my
text ``an introduction to object-oriented programming'' (timothy budd,
addison-wesley publishers).  These can be found at cs.orst.edu
directory pub/budd/oopintro/slides/*, or there is a mail server
called almanac@cs.orst.edu and if you say
	send oopintro slides chapter1
and so on you can get them via e-mail.  Warning, it yields a lot of
e-mail, so do it one at a time.
--tim


>57  Value Dependence Graphs

From: Michael D. Ernst <mernst@research.microsoft.com>
Subject:  Value dependence graphs paper available
Date: Tue, 9 Nov 1993 00:59:36 GMT

The paper "Value Dependence Graphs: Representation Without Taxation",
which describes a new intermediate representation which is particularly
amenable to optimization, is available.  (This version corrects typos and
clarifies a few minor points that may not have been completely clear in
the version which will appear in the POPL 94 proceedings.)  You can get a
copy in three ways:

1.  Via anonymous ftp, obtain file research.microsoft.com:/pub/papers/vdg.ps
    (or file vdg.ps635 if you have a HP LaserJet 4 printer).
2.  Reply to mernst@research.microsoft.com requesting PostScript by email,
    and I will send you the PostScript file of your choice.  (The files are
    483K and 1018K bytes, respectively.)
3.  Reply to mernst@research.microsoft.com sending me your physical mail
    address, and I will mail you a hardcopy.

The abstract is:

The value dependence graph (VDG) is a sparse dataflow-like representation
that simplifies program analysis and transformation.  It is a functional
representation that represents control flow as data flow and makes
explicit all machine quantities, such as stores and I/O channels.  We are
developing a compiler that builds a VDG representing a program, analyzes
and transforms the VDG, then produces a control flow graph (CFG) [ASU86]
from the optimized VDG.  This framework simplifies transformations and
improves upon several published results.  For example, it enables more
powerful code motion than [CLZ86, FOW87], eliminates as many redundancies
as [AWZ88, RWZ88] (except for redundant loops), and provides important
information to the code scheduler [BR91].  We exhibit a fast, one-pass
method for elimination of partial redundancies that never performs
redundant code motion [KRS92, DS93] and is simpler than the classical
[MR79, Dha91] or SSA [RWZ88] methods.  These results accrue from
eliminating the CFG from the analysis/transformation phases and using
demand dependences in preference to control dependences.

The paper's full citation is:

@InProceedings{WeiseCES94,
  author = 	 "Daniel Weise and Roger F. Crew and Michael Ernst and
  		  Bjarne Steensgaard",
    title = 	 "Value Dependence Graphs:  Representation Without Taxation",
    booktitle =	 POPL94,
    pages = 	 "297-310",
    year =	 1994,
    month =	 jan,
    address =	 "Portland, OR"
}

>58  Various on OO

I think our ftp-site should be mentioned under the PAPERS section of
appendix E of the comp.object FAQ. There are a number of interesting
papers about Object-Orientation, in particular about a new object-oriented
model, called 'Composition Filters'. Here is the uuencoded compressed
version of a postscript document that contains abstracts of the papers
which are available via ftp (ftp.cs.utwente.nl - /pub/doc/TRESE) or
WWW (http://www_trese.cs.utwente.nl - Recent Publications of the TRESE
project). You may also view this document from our WWW-site.

Greetings,

Richard.
---
TRESE project
Email: stadt@cs.utwente.nl
TRESE WWW Server: http://www_trese.cs.utwente.nl

>59  ILU OMG CORBA

From:	Bill Janssen <janssen@parc.xerox.com>

ILU is a module system / object RPC system / CORBA implementation for
programming that supports object interfaces to modules.  It supports
inter-calling between modules written in different languages
(currently only C++, C, Modula-3 and Common Lisp are supported), as
well as inter-calling between modules running in different address
spaces.  It provides an implementation of object RPC compatible with
the OMG CORBA 1.2 spec (it will compile OMG IDL and generate OMG
compliant code for OMG-specified languages), as well as being
compatible with Sun RPC (existing Sun RPC services can be described as
ILU modules) and other RPC systems.  It is written in ANSI C, and
includes a metaobject protocol for configuration and flexibility.  The
source code is freely available.  More information is available at
ftp://parcftp.parc.xerox.com/pub/ilu/ilu.html.

Bill

>60 Internet Info CDROM, including FAQs

Walnut Creek CDROM announces the release of the Internet Info CDROM.
This CDROM contains 12,000 documents about computers and networks:

        * Answers to Frequently Asked Questions (FAQs).
        * Internet RFCs and IENs.  
        * Computer security Documents.  
        * Internet Network maps.  
        * Usenet technical discussion Archives.
        * Ftp sites lists and descriptions of the archives they hold.
        * Extensive bibliographies and technical book reviews.
        * documents and standards from IEEE, ISO, NIST, ANSI and others.

The price is $39.95.  S&H is $5 for US/Canada/Mexico, and $10 for overseas.
If you live in California, please add sales tax.  You can pay by cash, check,
money order or Visa/MC/Dis/Amex.  This CDROM is fully guaranteed, if you are
dissatisfied with this disc for any reason whatsoever, you can return it for
an exchange or refund.

        Walnut Creek CDROM
        1547 Palos Verdes Mall, Suite 260
        Walnut Creek, CA  94596

        1 800 786-9907
        1 510 674-0783
        1 510 674-0821 FAX

        orders@cdrom.com

The disc is available for FREE to anyone that has contributed any of their
own work.  This includes FAQ maintainers, RFC authors, etc.  Just email me
your name, address, and the name of the files(s) that you wrote.  Overseas
addresses are ok.

If you would like a more detailed list of other CDROM titles published by
Walnut Creek CDROM, you can ftp the latest list from
ftp.cdrom.com:/pub/cdrom/catalog, or send email to info@cdrom.com.

>61  Metrics

From: dcp@icd.teradyne.com (Dan Proskauer)
Subject: Re: Wanted: Data on McCabe and Halstead Comple
Organization: Teradyne, Inc. Boston MA
Date: Sat, 18 Dec 1993 20:58:33 GMT

	There is some publically available McCabe and Halstead analysis
software for C in gatekeeper.dec.com /pub/usenet/com.sources.unix/volume20/metrics.
I believe there is some explanation of the metrics along with it.  Some other
references are:

	The Art of Software Testing, Myers

	"An Internal Approach to Testing Horizontally Reusable
	 Software", Proceedings of the 5th Annual STC Conference, 93
		Goldfedder (Overall of where McCabe fits in to A testing
		process) 

From ankh.iia.org!babbage.ece.uc.edu!news.kei.com!bloom-beacon.mit.edu!senator-bedfellow.mit.edu!faqserv Wed Nov 23 21:57:37 1994
Path: ankh.iia.org!babbage.ece.uc.edu!news.kei.com!bloom-beacon.mit.edu!senator-bedfellow.mit.edu!faqserv
From: Bob Hathaway <rjh@geodesic.com>
Newsgroups: comp.object,comp.answers,news.answers
Subject: Comp.Object FAQ Version 1.0.7 (10-27) Part 10/10
Followup-To: comp.object
Date: 29 Oct 1994 11:43:19 GMT
Organization: Geodesic Systems
Lines: 951
Approved: news-answers-request@MIT.Edu
Distribution: world
Expires: 12 Dec 1994 11:40:18 GMT
Message-ID: <object-faq/part10_783430818@rtfm.mit.edu>
References: <object-faq/part9_783430818@rtfm.mit.edu>
NNTP-Posting-Host: bloom-picayune.mit.edu
Summary: Frequently Asked Questions (FAQ) List and Available Systems For Object-Oriented Technology
X-Last-Updated: 1994/10/28
Originator: faqserv@bloom-picayune.MIT.EDU
Xref: ankh.iia.org comp.object:7435 comp.answers:4425 news.answers:13686

Archive-name: object-faq/part10
Last-Modified: 10/27/94
Version: 1.0.7

>62  Amadeus, persistence

From: aoife@mordred.st.nepean.uws.edu.au (Aoife Cox)
Subject: Re: In Search of Persistence
Date: 14 Dec 1993 20:04:38 +1100
Organization: University of Western Sydney

>I have been searching the net trying to find any locations for papers about
>implementation of persistence object systems or about persistence and OOPL.  As
>yet, I have not found anything remotely related.

>Are there any ftp sites with such papers that someone can direct me to?
There should be some papers on the Amadeus system, developed by the
Distributed Systems Group at Trinity College, Dublin, ftp-able from
ftp.cs.tcd.ie. Look in the /pub/tcd/tech-reports directory....

Hope this helps.

Aoife


>63  Chorus,Dist,RT,MicroK

From Marc Maathuis (mm@chorus.fr):

You may want to take a look at CHORUS, a distributed real-time
microkernel that can be combined with the CHORUS/MiX subsystem, which
is a modular, fully compatible UNIX System V (R3.2 or R4.0)
implementation.  There is also an OO subsystem named COOL (CHORUS
Object Oriented Layer). CHORUS runs on i386/i486, 680x0, SPARC,
transputer and on several other processors.

CHORUS is available as a source technology. In Jan 94, SCO and Chorus
will release a *binary* product for the PC market: "CHORUS/Fusion for
SCO UNIX" is binary compatible with SCO UNIX and offers real-time
functionality (POSIX 1003.1b and .1c, i.e. the former .4 and .4a
interfaces) and clustering functionality.

COOL provides a distributed OO programming environment for
C++.  COOL supports a set of system calls that allow the creation of
dynamic objects. These objects can be sent messages in a location
transparent way, they can be migrated between address spaces and sites
and they can be stored in a persistent store; this is done in a
transparent way, as an extension of the C++ language.

There are several technical reports (in PostScript format) on CHORUS
and on COOL available via anonymous FTP from Chorus systemes, France:
ftp.chorus.fr [192.33.15.3], directory pub/chorus-reports. See the file
"index" for an overview.

There is also a set of ~90 slides on Chorus and CHORUS available in
the directory pub/chorus-slides/CS-TR-92-64 (PostScript, versions 1-up
and 2-up).

If VTT is a public research lab, then you might be interested by the fact
that Chorus systemes has special programs for universities. For more
information on offering, conditions, etc, ftp to ftp.chorus.fr and get
the following ASCII files
   - pub/README
   - pub/academic/README
   - pub/academic/offerings
If you have questions, you may contact Didier Irlande <di@chorus.fr>
for license issues or Xavier Galleri <xg@chorus.fr> for technical
issues.


>64  Self Opt.

From: urs@cs.stanford.edu (Urs Hoelzle)
To: self-interest@otis.Stanford.EDU
Subject: thesis available for ftp
Date: Fri, 2 Sep 94 11:15:29 PDT
Reply-To: urs@cs.stanford.edu

Dear self-interesters,

My thesis is now available via ftp and Mosaic (see below).  Yes, I
have graduated!  Though many things will change, I'm planning to keep
on working on Self at UCSB; my new e-mail address is urs@cs.ucsb.edu.
However, I am no longer maintaining the self-interest list, for
questions/requests please contact self-request@self rather than
writing directly to me.

-Urs

---------------

Urs Hoelzle. "Adaptive Optimization for Self: Reconciling High
Performance with Exploratory Programming." Ph.D. thesis, Computer
Science Department, Stanford University, August 1994.

The report is available in PostScript form via ftp from
self.stanford.edu:/pub/papers/hoelzle-thesis.ps.Z or via Mosaic from
http://self.stanford.edu.  In a few weeks, it should be available in
printed form as a Stanford CSD technical report and as a Sun
Microsystems Laboratories technical report.

Abstract: Crossing abstraction boundaries often incurs a substantial
run-time overhead in the form of frequent procedure calls.  Thus,
pervasive use of abstraction, while desirable from a design
standpoint, may lead to very inefficient programs.  Aggressively
optimizing compilers can reduce this overhead but conflict with
interactive programming environments because they introduce long
compilation pauses and often preclude source-level debugging. Thus,
programmers are caught on the horns of two dilemmas: they have to
choose between abstraction and efficiency, and between responsive
programming environments and efficiency. This dissertation shows how
to reconcile these seemingly contradictory goals by performing
optimizations lazily.


>65 ORBELINE: CORBA

PostModern Computing is making its CORBA-compliant ORBeline product
available free of charge to the academic community for teaching and
research purposes.  ORBeline is available via anonymous ftp from
labrea.stanford.edu under pub/pomoco.

We are making the SunOS 4.x, Solaris 2.3, and OSF/1 versions of
ORBeline available.  We will consider making other platforms available
as well if there is enough interest.

Suresh Challa
PostModern Computing
suresh@pomoco.com

What follows is the README file of this release: 

-------------------------------------------------------------------------------

                                ORBELINE
                                --------

                    The SMART Object Request Broker


ORBeline is a complete implementation of OMG's Common Object Request
Broker Architecture (CORBA).  ORBeline goes beyond the standard 
specification to provide a SMART communication framework allowing
you to easily develop large distributed applications that are robust,
scalable, flexible and maintainable.  ORBeline incorporates PostModern's
proven communication framework that links thousands of nodes.

Highlights
----------

ORBeline's SMART Agent dynamically tracks the communication taking place
between all objects and their clients:

   o Smart Binding and Protocol Selection

     ORBeline automatically picks the best communication mechanism as
     soon as you try to access an object.  If the object is in your process,
     it bypasses the ORB and the network altogether.  When the object is on
     a remote node, ORBeline's SMART and efficient on-the-wire protocol
     is selected.  When the object is implemented using another vendor's
     ORB, that vendor's on-the-wire protocol is used.

   o Built-in Fault Tolerance

     ORBeline's SMART Agent monitors communication between objects and their
     clients.  In case of a failure, the SMART agent and ORBeline cooperate
     to reestablish connections between processes or their replicas.

   o Dynamic Directory Service

     ORBeline's Dynamic Directory Service tracks all registered and active
     objects, providing a high degree of efficiency, total location
     transparency and easy administration.  There is no need for 
     cumbersome configuration files, and no need for heavyweight object
     migration and replication mechanisms.

   o Platforms

     ORBeline runs on all classes of computers ranging from Cray 
     supercomputers, to workstations, to personal computers and
     embedded systems.

Complete CORBA implementation
-----------------------------

ORBeline is the most complete ORB implementation currently on the
market.  It features the following:

   o IDL Compiler implementing the entire Interface Definition 
     Language.

   o Static and Dynamic Invocation Interfaces

   o Complete Interface and Implementation Repositories.

   o Support for Object Activation.

   o Complete set of object administration tools.


Features
--------


   o High Performance and Low Overhead

     ORBeline provides high performance while adding little overhead
     to your application.  ORBeline is the only ORB product available
     on the market today suitable for running on real-time, embedded
     systems.

   o Flexible and Easy to Use

     With ORBeline it is easy to develop, deploy and maintain large
     distributed applications.  ORBeline provides a high degree of 
     flexibility and takes care of cumbersome details allowing 
     developers to focus on their applications.

   o WAN Connectivity

     ORBeline uses PostModern's proven communication technology to 
     connect wide area networks.

   o Scalability

     ORBeline's smart use of network resources and communication protocols
     allows applications to scale to networks of thousands of nodes.

   o Object Migration and Replication

     ORBeline's SMART agent and Dynamic Directory Service allow easy object
     migration and replication.


Platforms
---------

We are making the SunOS 4.x, Solaris 2.3, and OSF/1 versions of
ORBeline available free of charge to the academic community.  
We will consider making other platforms available as well if there
is enough interest.  

The following compilers are supported in this release:

Solaris 2.3:    Sun C++ 4.0 (native), SparcWorks 3.0
SunOS 4.x:      Sun C++ 3.0 (cfront), SparcWorks 2.0.1
OSF/1 1.3:      DEC C++

If there is enough interest, we can make versions compatible with
other compilers available as well.


LICENSING
---------

ORBeline is provided free of charge to the academic community for
teaching and research purposes.  After installing ORBeline, call us at
(415) 967-6169 or send e-mail to info@pomoco.com and we will send you
a perpetual license for your site.

If you are interested in ORBeline for commercial purposes, contact us
and we can provide a limited time evaluation license.


ACKNOWLEDGEMENTS
----------------

We would like to thank Stanford University for providing us with
a high-speed ftp site from which to distribute this ORBeline
release.



                    PostModern Computing Technologies, Inc.
                            1897 Landings Drive
                          Mountain View, CA  94043
                             Tel: (415) 967-6169
                             Fax: (415) 967-6212
                               info@pomoco.com


>66 OO Designer CASE Tool

	   **************** Object Oriented Designer ***************

		    Prof. Taegyun Kim [ktg@taejo.pufs.ac.kr]
		      Pusan University of Foreign Studies
				  Pusan, Korea

			     Version : Version 1.3.1
			     Revised : October 6 1994

	   *********************************************************

Let me introduce myself. I am an assistant professor working at Department of
Computer Engineering in Pusan University of Foreign Studies which resides in
Pusan, Korea. My major interest is in software engineering especially in the
area of object oriented methodologies. In teaching courses in systems analysis
and software engineering I found a need for a good case tool that could be used
by my students. Unfortunately, commercial case tools are too expensive for a
university to purchase so I developed OOD. I have spent 17 man months building
OOD. Because this is my first project combining object oriented methods, Motif,
and C++, some of the source code may be a little clumsy. However, it does work
well and it is still evolving.  This project is very hard but is also very
interesting. Let's enjoy it together.

P.S.: I am anxious for your criticism or comment on this product. So, if it
works on your system, please respond to me with even a one line (very short)
message.  It will give me some encouragement. Moreover please inform me your
status (student, professor etc.) if possible.

-Taegyun Kim

		     --------------- Contents --------------
                     0. Summary
                     1. System Environment
                     2. Building OOD
                     3. Initializing the Working Environment
                     4. Functions
                     5. Examples
                     6. Reference Books
                     7. Cautions
                     8. FAQ
		    ----------------------------------------

0. Summary
----------

The Object Modeling Technique [OMT] by James Rumbaugh et al. is a methodology
for object oriented development with a graphical notation for representing
object oriented concepts.  Object Oriented Designer [OOD] is a case tool for
constructing the object diagrams defined in OMT. In order to use OOD it is
necessary to understand OMT and its graphical notation. See reference (2).

Why "OMT"? OMT evolved from the Extended Entity Relationship [EER] model which I
have studied since the mid 80's. There are a number of other approaches to
expressing object oriented concepts but I believe that OMT is superior to most
of these. Yourdon's Object Oriented Analysis [OOA] notation, for example, is
another excellent approach to the problem but has some limits in functionality,
particularly with respect to data modeling, that are present in OMT.

Currently, OOD has following primary functions:

    - general graphics editor (with limited functionality)

    - object diagram layout (with some additions w.r.t. original OMT notation)

    - C++ code skeleton generation (header file + source file)
      The comments and codes for individual member functions can be documented,
	  or edited within OOD directly.
      The C++ code generator supports inheritance. 

I have attempted to make OOD as user-friendly as possible. My students learn to
use it in a day even without a manual. The user-friendliness of OOD is due to my
own object oriented, user interface mechanisms.

Currently OOD generates a C++ code skeleton from an object diagram.  I have a
short term final goal to develop an object oriented "environment" with
flexibility and portability. I think that about additional 20 man months effort
could lead me to the final goal. Because I am currently working very hard to
enhance its functionality, I am not especially concerned with system portability
issues at the moment so building OOD on your particular platform may require a
little work on your part. Please inform me of any changes that you need to make
to build OOD on your system.


1. System Environment
---------------------
OOD was built on a SPARC station running OS4.1.x, X11-R5 and Motif-1.2 and
C++-2.0. OOD has also been successfully built on a SPARC using gcc-2.5.8 and
libg++-2.5.3. It should build on most UNIX systems with X11-R5, Motif-1.2 and a
"reasonable" C++ compiler.

2. Building OOD
---------------------
	1) In ood directory edit the Makefile to reflect your environment
	2) run "make depend"
	3) run "make"

3. Initialize Working Environment
--------------------------------
OOD requires the user to select a working repository in which to store various
output files. If this is the first time you are running OOD:

	1) point at the top-menu,
	2) select "Environment",
	3) select "Setup",
	4) define your working repository.

If a working repository has been previously defined, select it:

	1) point top-menu
	2) select "change to"
	3) set your working repository 

  ...


>67 OOTher OO CASE Tool

From: conrozi@kk90.ericsson.se (Roman Zielinski TT/TSM)
Subject: CASE OOTher 1.06f released (free/shareware)
Organization: Ericsson
Date: Tue, 20 Sep 1994 07:15:09 GMT

Product:
	OOTher
	OO Documentation & CASE Tool Release 1.06f

Environment:
	MS-Windows 3.1

Short description:
	The tool is a complete documentation development package for
 	the following methods/notations:
	- Peter Coad's OOA method (Coad/Yourdon)
	- State Machine diagrams using a subset of SDL
	- allocation of objects to processors and processes
	- Use Case diagrams and Object Interaction diagrams
	  as proposed by Ivar Jacobson in his OOSE book

	The tool also performs verification of consistency between the 
	diagrams, and by direct coupling assures for consistent naming
	of objects and methods/services.

	The tool is build around 5 easy to use graphic editors and is 
	capable of documenting all objects, their attributes, services 
	and also associations between objects. 

	Each service may have a state machine (FSM) diagram.
	C++ Headers may be generated automatically from the OOA diagram -
	it assures consistent naming of member functions and attributes.
	The applied mark-up notation for C++ headers should be powerful 
	to give compiler ready headers for at least 80% of applications.

	For a better integrability with other windows applications and to
	allow esthetical control, the tool allows free font selection and
	a copy-paste transfer of diagrams via clipboard in meta file format 
	to e.g. Word for Windows 2.0.

	The resulting file is ASCII with open & documented format,
	i.e. it's easy to add own utilities for data extraction.

	Complete user documentation is attached in form of a hypertext
	windows-help file.

	The tools distributed as:
	- freeware for students, schools and home users
	- as shareware for others (USD $170 for corporate 1-5 user license).
	- free upgrade form 1.0x to 1.06f for registered users if they
	  fetch files from e.g. SimTel Software Repository
	- free evaluation in 4 weeks

	- an evaluation copy may be ordered from the author (USD $70, 
	  rest of the license fee if/when you register)
		Roman M. Zielinski
		Tre Kaellors Vaeg 7
		S-145 65 Norsborg
		Sweden
	  (You may also reach me at conrozi@KK.ericsson.se until July-94)

*****   Version 1.06f contains bug corrections and updates of zoom-handling.
				Roman M. Zielinski
				[author]

----------------------------------------------------------------------
SimTel id:
pub/msdos/windows3/
oot-106f.zip    OOTher OO Doc Tool 1.06f CASE OOA+OOSE
----------------------------------------------------------------------
mail a message 
To: listserv@vm1.nodak.edu       (***se below, for other internet server names***)
Subject: SimTel-request
Body:
/PDGET MAIL /SimTel/msdos/windows3/oot-106f.zip uuencode

(some TRICKLE-servers don't like the arguments 'MAIL' and 'UUENCODE', so
thay may need to be omitted. Thay also may need the old path specification, 
example for the Swedish TRICKLE:
/PDGET <msdos.windows3>oot-106f.zip
)

You may also use Archie to find sites storing OOTher. 
Instructions for archie and paths for OOTher can be fetched via e-mail 
from e.g. archie@archie.doc.ic.ac.uk
with a body:

Help
find oot

[... On Simtel Retrieval ...]

or fetch via anonymous ftp or ftpmail from OAK.Oakland.Edu
/SimTel/msdos/windows3

or its mirrors:

St. Louis, MO:  wuarchive.wustl.edu (128.252.135.4)
  /systems/ibmpc/msdos
Corvallis, OR:  archive.orst.edu (128.193.2.13)
  /pub/mirrors/oak.oakland.edu/simtel20/msdos
Falls Church, VA:  ftp.uu.net (192.48.96.9)
  /systems/ibmpc/msdos/simtel20
Australia:  archie.au (139.130.4.6)
  /micros/pc/oak
England:  src.doc.ic.ac.uk (146.169.2.1)
  /pub/packages/simtel20
Finland:  ftp.funet.fi (128.214.6.100)
  /pub/msdos/SimTel-mirror
Germany:  ftp.uni-paderborn.de (131.234.2.32)
  /msdos
Israel:  ftp.technion.ac.il (132.68.1.10)
  /pub/unsupported/dos/simtel
Switzerland:  ftp.switch.ch (130.59.1.40)
  /mirror/msdos
Taiwan:  NCTUCCCA.edu.tw (140.111.1.10)
  /PC/simtel
Thailand:  ftp.nectec.or.th (192.150.251.32)
  /pub/mirrors/msdos

----------------------------------------------------------------------
To run ftpmail send e-mail to e.g. ftpmail@doc.ic.ac.uk
with the message body:

connect ??hostname??
binary
uuencode
cd pub/msdos/windows
get oot-106f.zip
quit
----------------------------------------------------------------------


>68 OS Papers (OO?)

From: axb@defender.dcrl.nd.edu (Arindam Banerji)
Newsgroups: comp.object
Subject: The Paper Trail database
Date: 21 Sep 1994 14:39:20 GMT
Organization: University of Notre Dame

			THE PAPER TRAIL

The "Paper Trail" - an experimental database of ftp'able OS papers
is now available through http://pclsys64.dcrl.nd.edu/papers. This
database allows users to find and access papers that are available for
ftp on the internet. We have initially populated this database with
about 5500 entries. Most of these entries reflect our own area of
interest, that is Operating Systems and related areas. We'll add
entries to the database from time to time. However, it'll probably
be very difficult to keep this up-to-date without help from other
users of this database. Hence, the database provides any user the added
facility to submit entries.

We hope that the xmosaic interface to this database is intuitive and
simple. If you have any suggestions and criticisms, please do let us
know - including how this compares with other such services.  


-----------------------------------------------------------------------------
Arindam Banerji                             Michael Casey
		    384 FitzPatrick Hall
	       Dept. of Computer Science and Engineering
		  University of Notre Dame
(219)-631-5772    Notre Dame, IN 46556       (219)-631-5273
axb@cse.nd.edu                        mrc@cse.nd.edu


>69 Trellis

From: bruno@tk.telematik.informatik.uni-karlsruhe.de (Bruno Achauer)
Subject: Trellis compiler available
Date: 23 Oct 1994 00:16:02 GMT
Organization: Telematics Department, Karlsruhe University, Germany

The beta release of version 0.2 of the TNT Trellis system is now
available for anonymous ftp from tk.telematik.informatik.uni-karlsruhe.de.

Enclosed is ANNOUNCE file from the distribution:

What are Trellis and TNT
~~~~~~~~~~~~~~~~~~~~~~~~

Trellis is an object-oriented language developed within Digital
Equipment Corp. The language features compile-time type checking,
multiple inheritance, parametrized types, exception handling and
iterators.


TNT is a new implementation of Trellis, consisting of a compiler, a
library of predefined types and a (rudimentary) run time system:

  - The compiler implements the language as defined by the reference
    manual (except for a few esoteric constructs), plus a few minor
    extensions.

  - Predefined types are standard types such as integers, strings,
    arrays etc. (in Trellis, no type is built into the language!),
    an IO system and a (rudimentary) hierarchy of collection types.

  - The run time system is pretty incomplete right now; in particular,
    neither garbage collection nor threads are implemented yet.

The system is available for several architectures:

  - the Digital Alpha (running OSF/1),
  - the HP Precision Architecture (under HP-UX),
  - the Intel 386 (under Linux),
  - Digital's Mips workstations,
  - Sun's Sparc workstations (running SunOS).

Both source code and prebuilt kits are available.

Further work will concentrate on supporting transparently distributed
objects a la DOWL.


Changes since last version
~~~~~~~~~~~~~~~~~~~~~~~~~~

* The HP-PA, Linux and Sparc ports.

* Building the compiler no longer requires the SFIO library.

* The compiler now can use the GNU assembler to generated object files;
  at least on small MIPS machines, this will speed up compilation
  considerably.

* Several minor bugs have been fixed.


Requirements
~~~~~~~~~~~~

The prebuilt kits require disk space ranging from 800 KB (Linux) to
2.4 MB (OSF/1); a C compilation system (assembler, linker and the C
library) must be installed. In addition, the Mips and HP-PA versions
will benefit if the GNU assembler is present.

Building the system from scratch requires from 5.2 MB (Linux) to 16 MB
(Alpha). You will also need some auxiliary tools and libraries:

  - Cocktail V9208 (the Karlsruhe Compiler toolbox),
  - GNU make V3.68 or later,
  - patch,
  - makedepend.

Most of these should be available on a nearby ftp site (makedepend is
part of the X distribution; GNU make and patch are distributed by the
FSF).

Cocktail is available from several ftp sites, but most of the versions
floating around will not work on the Alpha. A patched version is
available on tk.telematik.informatik.uni-karlsruhe.de (see below).

If you plan to build the MIPS or the SPARC version, you will also need
the GNU C compiler.


How to get it
~~~~~~~~~~~~~

A source kit is available via anonymous FTP from

    tk.telematik.informatik.uni-karlsruhe.de (129.13.3.200)
    file directory /pub/tnt/tnt-0.1.tar.gz.

There are also some additional kits in the same directory:

    * doc	-- PostScript versions of DEC-TR-372 (language
		   reference manual) and DEC-TR-373 (language primer).

    * prebuilt	-- binary kits.

    * tools	-- source kits for Cocktail.


Please direct bug reports, requests, comments etc to

    tnt@tk.telematik.informatik.uni-karlsruhe.de.


Acknowledgements
~~~~~~~~~~~~~~~~

The development of TNT has been supported by Digital Equipment's
Campus-based Engineering Center in Karlsruhe.

Special thanks to Jean Fullerton and Lutz Heuser at Digital for
making the technical reports available.


Copyright
~~~~~~~~~

Copyright  1994, Universitt Karlsruhe, Germany; parts Copyright  1994
Digital Equipment Corp, Maynard, Mass.

The TNT Trellis software, both binary and source (hereafter, Software) is
copyrighted by Universitt Karlsruhe, Germany (UKA), and ownership
remains with the UKA. Parts of the software are copyrighted by Digital
Equipment Corp., Maynard, Mass.

The UKA grants you (hereafter, Licensee) a license to use the Software
for academic, research and internal business purposes only, without a
fee.  Licensee may distribute the binary and source code (if released)
to third parties provided that the copyright notice and this statement
appears on all copies and that no charge is associated with such
copies.

UKA MAKES NO REPRESENTATIONS ABOUT THE SUITABILITY OF THIS SOFTWARE FOR
ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT EXPRESS OR IMPLIED
WARRANTY.  THE UKA SHALL NOT BE LIABLE FOR ANY DAMAGES SUFFERED BY THE
USERS OF THIS SOFTWARE.

--
--Bruno.

---------------------------------------------------------------
| Bruno Achauer, U of Karlsruhe, Telecooperation              |
| Kaiserstr. 12, D-76128 Karlsruhe, Germany                   |
| bruno@tk.telematik.informatik.uni-karlsruhe.de              |
| Phone +49-721-6084792, Fax +49-721-388097                   |
---------------------------------------------------------------

>70 CooL-SPE

From: Gerhard.Mueller@sietec.de (Dr. Gerhard Mller)
Subject: Announcement of the CooL Software Production Environment
Date: Tue, 25 Oct 1994 11:42:28 UNDEFINED
Organization: Sietec Systemtechnik

		ANNOUNCEMENT

The CooL-Software Production Environment - a new object-
oriented development environment in Public Domain

The CooL-SPE is a modern software production environment 
for the development of object-oriented application systems 
supporting grafical user interfaces and relational database 
technology. In the landscape of existing software production 
technologies the CooL-SPE is more closely settled to 4GL 
environments than to the usual C++ environments, mostly 
more dedicated to system programming. The CooL-SPE was 
developed by Siemens Nixdorf Informationssysteme (SNI) 
within the ESPRIT project ITHHACA and is used since in a 
number of large projects.

Allthough the CooL-SPE as a programming environment is 
functional quite rich, it is also very lean and thus comparable 
fast to learn and reliable tu use. In one project, which we sup-
ported recently, we could learn that newly assigned engineers 
to a fairly large project (400 classes with some 100.000 lines 
of code) were able to learn the environment, to understand the 
application and to become productive within a month - and 
that without any practical experience on object-oriented pro-
gramming before.

The system has product quality and is implemented in major 
parts in itself.

The CooL-SPE is available for Linux 1.0.1, Solaris 2.3 and 
SINIX 5.41. You may receive the system (sources and docu-
mentation) via ftp.fu-berlin.de in the directoy /pub/unix/lan-
guages/cool.The file itself is named cool-2.1.tar.Z.

>71 Contra-/Co- Variance

From: castagna@oeillet (Giuseppe Castagna)
Subject: Paper on covariance and contravariance
Date: 25 Oct 1994 17:09:51 GMT
Organization: Ecole Normale Superieure

                            PAPER ANNOUNCEMENT
                            ==================

The following short (13 pages long) note


        "COVARIANCE AND CONTRAVARIANCE: CONFLICT WITHOUT A CAUSE"
                                     
                            Giuseppe Castagna
                Laboratoire d'Informatique de l'ENS, Paris


is available by anonymous ftp at ftp.ens.fr in the file
 /pub/reports/liens/liens-94-18.A4.dvi.Z

ADVERTISEMENT: This paper tries to explain
-------------

1. What covariance and contravariance serve for.

2. Why covariance and contravariance are not opposing views but both
   *must* be integrated in a *type-safe* formalism. I.e.: don't choose
   just one of them.

3. Where the "objects as records" analogy hides covariance.

4. How to type binary methods in the models based on the analogy "objects
   as records" (i.e. how to have ColorPoint < Point even if they respond
   to a message "equal")

5. How to have multiple dispatch when objects are modeled by (recursive)
   records.

6. Why all the previous points are strictly related one to each other.
 
                                 ABSTRACT

In type theoretic research on object-oriented programming the ``covariance
versus contravariance  issue'' is a  topic of continuing  debate.  In this
short note  we   argue that covariance  and   contravariance appropriately
characterize  two distinct  and  independent  mechanisms.    The so-called
contravariance  rule correctly captures   the {\em  substitutivity\/},  or
subtyping relation (that establishes which  sets of codes can replace {\em
in every context\/} another   given set).  A covariant relation,  instead,
characterizes the {\em specialization\/} of  code (i.e.\ the definition of
new code that replaces   the old one  {\em  in some particular  cases\/}).
Therefore,  covariance  and contravariance  are  not  opposing  views, but
distinct  concepts that each have   their place in object-oriented systems
and that  both   can  (and  should)  be type    safely  integrated in   an
object-oriented language.

We  also show  that   the  independence of    the two  mechanisms  is  not
characteristic of  a  particular model  but is  valid  in  general,  since
covariant specialization is present also  in  record-based models, but  is
hidden by a deficiency of all calculi that realize this model.

As an aside, we show that  the lambda&-calculus can  be taken as the basic
calculus both for an  overloading-based and for  a record-based model.  In
that  case, one not only obtains  a more uniform vision of object-oriented
type  theories but, in   the case of  the  record-based approach, one also
gains  multiple dispatching,  which   is  not  captured by   the  existing
record-based models.



APPENDIX F  MAGAZINES, JOURNALS AND NEWSLETTERS
===============================================

ACM
---
  OOPSLA - Association For Computing Machinery's yearly conference on Object-
    Oriented Programming Systems, Languages, and Applications.
    Addison-Wesley
    Order Dept.
    Jacob Way
    Reading, MA 01867
    (800) 447-2226
  ACM OO Messenger    - Quarterly on Object-Oriented Languages and Systems
  ACM SigPlan Notices - Special Interest Group on Programming Languages
    Publications Office
    ACM, 1515 Broadway
    NY, NY 10056
    (212)869-7440, FAX: (212)869-0481
  Additional information can be obtained from ACMpubs@acm.org.

American Programmer (Yourdon's Newsletter)
------------------------------------------
Monthly Newsletter on Software Engineering including quality, the CMM, object-
oriented technology, and etc.  $395/year.  Send for complementary copy.
  American Programmer, Inc.
  Dept. 13
  161 West 86th Street
  New York, NY  10024-3411

CASE Trends Magazine
--------------------
Sorry, still no reference.

The Coad Letter
---------------
From Peter Coad (pronounced "Code"), of Coad/Yourdon OOA/D fame.
  Object International, Inc.
  3202 W. Anderson Lane, Suite 208-724
  Austin, TX  78757-1022
  Tel: 800-926-9306, 512-795-0202
  Fax: 512-795-0332

The C+@ Quarterly
-----------------
On the C+@ language (pronounced "Cat").
Unir Technology, Inc.
184 E. Shuman Blvd.
Naperville, IL 60563

DE FACTO - The ami Newsletter
-----------------------------
Reports on the progress of ami (application of metrics in industry).
  ami User Group
  Centre for Systems and Software Engineering
  South Bank University
  103 Borough Road, London SE1 OAA
  Phone: +44 71 815 7504
  Fax:   +44 71 928 1284

The Guerilla Programmer
-----------------------
For the practicing professional programmer.
  New, by Ed Yourdon.
  Phone:  800-964-8702 or 617-648-9702
  Fax:    800-888-1816 or 617-648-1950

HOTT-LIST - FREE NEWSLETTER
---------------------------
Free, electronic newsletter features article summaries on new generation
computer and communications technologies from over 100 trade magazines
and research journals; key U.S. & international daily newspapers, news
weeklies, and business magazines; and, over 100 Internet mailing lists &
USENET groups.  Each monthly issue includes listings of forthcoming &
recently published technical books and forthcoming shows & conferences. 
Bonus: Exclusive interviews with technology pioneers.  E-mail
subscription requests to: listserv@ucsd.edu  (Leave the "Subject" line
blank.)  In the body of the message, type: SUBSCRIBE HOTT-LIST (do not
include first or last names).  For a person: hott-list-relay@ucsd.com.

Object-Oriented Systems (New)
-----------------------------
EMail: journal@chall.mhs.compuserve.com
http://www.cs.ucl.ac.uk/coside/oos/index.html  (new)
    Russel Winder <R.Winder@cs.ucl.ac.uk>

  USA/Canada:
  Journals Promotion Dept., Chapman & Hall, 29 West 35th
  Street, New York, NY 20001-2299, USA.
  Tel: (212) 244 3336
  Fax: (212) 244 3426
  EMail: 71201.1651@compuserve.com

  EC/RoW:
  Journals Promotions Dept., Chapman & Hall, 2-6 Boundary Row, London
  SE1 8HN, UK.
  Tel: +44 (0)71 865 0066
  Fax: +44 (0)71 522 9623

SIGS Publications (9/yr)
------------------------
These publications have staff writers from among the most popular OO authors
and methodologists.
  Object Magazine        - Manager's Guide to Object Technology        $39
  Journal of Object-Oriented Programming - For Progs/Devls using OO    $59
  C++ Report             - Get most out of C++                         $69
  The Smalltalk Report   - How-To Advice for Smalltalk Users           $79
  Report on Object Analysis and Design - Lang Ind/Arch on OOA/D/Mdling $99

  SIGS Publications, Inc.
  P.O. Box 2027
  Langhorne, PA 19047
  Fax:   215-785-6073
  Phone: 215-785-5996

