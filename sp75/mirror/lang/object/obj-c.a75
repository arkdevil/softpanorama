From: tiggr@es.ele.tue.nl (Tiggr)
Newsgroups: comp.lang.objective-c,comp.answers,news.answers
Subject: comp.lang.objective-c FAQ, part 1/3: Answers
Date: 17 Nov 1994 17:00:03 GMT
Organization: Eindhoven University of Technology, the Netherlands
Message-ID: <answers_785091602@es.ele.tue.nl>
Reply-To: tiggr@es.ele.tue.nl (Tiggr)

Archive-name: Objective-C/answers
Version: $Id: answers,v 2.15 1994/11/06 10:59:54 tiggr Exp $


				 Answers to

			 FREQUENTLY ASKED QUESTIONS

			   concerning Objective-C


This is the first in a series of three informational postings concerning
comp.lang.objective-c.  This first part answers FAQs; the second part lists
available class libraries and the third part is a simple sample Objective-C
program.

This posting answers the following questions:

 1   What is Objective-C?
 2   What is the difference between Objective-C and C++?
 3   What exactly is it that makes Objective-C have `classes similar to
     Smalltalk', and what are the resulting capabilities of Objective-C?
 4   What are the `nice features' of Objective-C?
 5   What are some of the common problems of the language and how can I work
     around them?
 6   What object encapsulation does Objective-C provide?
 7   What are Protocols?
 8   How can garbage collection be applied to Objective-C?
 9   What is the difference between the NeXTSTEP, Stepstone and GNU CC
     versions of Objective-C?
 10  What written information concerning Objective-C is available?
 11  What kind of Objective-C support is provided by Stepstone?
 12  What kind of Objective-C support is provided by NeXT?
 13  What kind of Objective-C support is provided by GNU?
 14  What kind of Objective-C support is provided by BPG.
 15  What are the newsgroups to read or mailing lists to subscribe to in order
     to stay up-to-date on developments for GNU Objective-C?
 16  Are there any FTP sites with Objective C code?  Where?
 17  For more information...

(To find a question search on the question number starting a line.)

1   What is Objective-C?

    Objective-C is an object oriented computer programming language.  It is
    a superset of ANSI C and provides classes and message passing similar to
    Smalltalk.

    Objective-C includes, when compared to C, a few more keywords and
    constructs, a short description of which follows.  For a comlete example
    of the application of the constructs, see part 3 of this FAQ.

    `@interface' declares a new class.  It indicates the name of the class,
    the name of its superclass, the protocols adhered to (see Q7), the
    layout of the instance variables (similar to the definition of a struct,
    but including encapsulation information (see Q19)) and declares the
    methods implemented by this class.  A class' interface usually resides
    in a file called `<classname>.h'.

    `@implementation' defines a class.  The implementation is no more than a
    collection of method definitions.  Without an implementation, a class
    does not exist at run time.  The implementation of a class usually
    resides in a file called `<classname>.m'.

    A `@category' is a named collection of method definitions which are
    added to an existing class.  A category is not allowed to redefine a
    class' existing methods.

    Objective-C includes the predefined type `id' which stands for a pointer
    to some object.  Thus, `id obj;' declares a pointer to an object.  The
    actual class of the object being pointed to is almost irrelevant, since
    Objective-C does run-time type checking.

    `-message;' declares a method called `message'.  The `-' indicates that
    the message can be sent to objects.  A `+' instead indicates the message
    can be sent to class objects.  A method is similar to a function in that
    it has arguments and a return value.  The default return type is `id'.
    If a method has nothing useful to return, it returns `self', which is a
    pointer to the object to which the message was sent (similar to `this'
    in C++).

    [obj message], [obj message: arg1] and [obj message: arg1 with: arg2]
    are examples of sending a message to the object OBJ with 0, 1 and 2
    arguments respectively.  The name of the message is called the selector.
    In this example, the selectors are: `message', `message:' and
    `message:with:', respectively.

3   What is the difference between Objective-C and C++?

    C++ follows the Simula 67 school of OO programming, where Objective-C
    follows the Smalltalk school.  In C++ the static type of an object
    determine whether you can send it a message, in Objective-C the dynamic
    type determine it.  The Simula 67 school is safer, in that more errors
    are detected at compile time.  The Smalltalk school is more flexible, as
    some valid programs will execute correctly in Smalltalk, where they
    would be rejected by Simula 67.

    Stepstone's Objective-C allows you to chose between the dynamic and
    static binding, GNU and NeXT do not.  ANSI C++ allows you to use dynamic
    binding, but discourages you from doing so.

    In many ways, the difference between C++ and Objective-C is more a
    question of mindset than technical barriers.  Are you willing to offer
    some flexibility for some safety?  Advocates for the Simula 67 school
    claims that a well designed program doesn't need the extra flexibility
    (a lie), while advocates for the Smalltalk school claims that the errors
    are no problem in practice (another lie).

    Pragmatic differences between Objective-C and C++ include:

	C++ has operator overloading.  Some consider this to be `syntactic
	sugar', and it is, but it can be a quite handy bit of sugar.

	C++ has multiple inheritance.  There are several ways to `get
	around' this in Objective-C (see below).

	The added syntax and semantics of C++ is huge, while Objective-C is
	C plus just a small number of new features.

3   What exactly is it that makes Objective-C have `classes similar to
    Smalltalk', and what are the resulting capabilities of Objective-C?

    Objective-C is as close to Smalltalk as a compiled language allows.  The
    following is a list of the features `taken' from Smalltalk:

      * Objective-C is compiled---Smalltalk is only partially compiled.  The
	current Objective-C implementations are all *much* faster than any
	Smalltalk.  For example ParcPlace Smalltalk-80/4 is at least 3 times
	slower than both the GNU and NeXT Objective-C's.  (This was measured
	using the Self/Smalltalk benchmark suite available by FTP from
	`self.stanford.edu:pub/Self-2.0.1'.)

	The big difference of course is that Objective-C does hybrid typing:
	one can choose to represent a string as a `char *' or as an object,
	whereas in Smalltalk, everything is an object.  This is a reason for
	Objective-C being faster.  On the other hand, if every bit of
	information in an Objective-C program would be represented by an
	object, the program would probably run at a speed comparable to
	Smalltalk and it would suffer from not having optimizations
	performed on the basic classes, like Smalltalk can do.

      * You may add or delete methods and classes at runtime.  (On GNU and
	NeXT one can load new classes and categories.  On Stepstone, which
	lacks categories, the only way to add methods is to load a subclass
	which then does a `+poseAs:' of the class to have methods added.
	This is less flexible, but it sort-of does the trick of just adding
	methods.)

      * Much of the syntax, i.e. Smalltalk uses method names like
	`a:method:name:', as does Objective-C.  In Objective-C, the message
	sending construct is enclosed in square brackets, like this:
	`[anObject aMessage: arg]' whereas Smalltalk uses something like
	`anObject aMessage: arg'.

      * The basic class hierarchy, that is, having class `Object' in the very
	top, and letting most other classes inherit from it.

      * Most method names in class object is the same.  E.g. `respondsTo:'.
	What is called `doesNotUnderstand:' in Smalltalk is called
	`doesNotRecognize:' in Objective-C.

      * Smalltalk normally uses `doesNotUnderstand:' to implement
	forwarding, delegation, proxies etc.  In Objective-C, these tasks
	are different:

	    forwarding/delegation: `forward::' can be overridden to
	    implement forwarding.  On the NeXT, `forward::' is even used
	    when passing to super.

	    proxies: (Next) An instance of the NXProxy class forwards all
	    methods and their arguments to the remote object via Mach
	    messages.

      * Objective-C has meta classes mostly like Smalltalk.

      * Objective-C does not have class variables like Smalltalk, but pool
	variables and globals are easily emulated via static variables.

4   What are the `nice features' of Objective-C?

	The possibility to load class definitions and method definitions
	(which extend a class) at run time.

	Objects are dynamically typed: Full type information (name and type
	information of methods and instance variables and type information
	of method arguments) is available at run time.  A prime example of
	application of this feature is `-loadNibSection:owner:' method of
	NEXTSTEP's Application class.

	Persistence [...].

	Remote objects [...].

	Delegation and target/action protocols [...].

5   What are some of the common problems of the language and how can I work
    around them?

    There are some `common problems':

	There is no innate multiple inheritance (of course some see this as
	a benefit).

	    To get around it you can create a compound class, i.e. a class
	    with instance variables that are ids of other objects.
	    Instances can specifically redirect messages to any combination
	    of the objects they are compounded of.  (It isn't *that* much of
	    a hassle and you have direct control over the inheritance
	    logistics.)  [Of course, this is not `getting around the problem
	    of not having multiple inheritance', but just modeling your
	    world slightly different in such a way that you don't need
	    multiple inheritance.]

	    Protocols address the absence of multiple inheritance (MI) to
	    some extent: Technically, protocols are equivalent to MI for
	    purely "abstract" classes (see the answer on `Protocols' below).

	    [How does Delegation fit in here?  Delegation is extending a
	    class' functionality in a way anticipated by the designer of
	    that class, without the need for subclassing.  One can, of
	    course, be the delegate of several objects of different
	    classes.  ]

	There are no class variables.

	    You can get around this by defining a static variable in the
	    implementation file, and defining access methods for it.  This
	    is actually a more desirable way of designing a class hierarchy,
	    because subclasses shouldn't access superclass storage (this
	    would cause the subclass to break if the superclass was
	    reimplemented), and allows the subclass to override the storage
	    (if the classes access all their own variables via methods).

	    [The question remains what the exact syntax of class variables
	    should be: Should a class object A be seen as an instance of its
	    meta-class MA, which has a super class MB being the meta-class
	    of A's super, B, and, as such, should A have seperate instances
	    of class variables defined for B?  Or not?]

6   What object encapsulation does Objective-C provide?

    Object encapsulation can be discerned at two levels: encapsulation of
    instance variables and of methods.  In Objective-C, the two are quite
    different.

    Instance variables:

	The keywords @public, @private and @protected are provided to secure
	instance variables from prying eyes to some extent.

		@public		anyone can access any instance variable.
		@protected	only methods belonging to this object's
				class or a subclass thereof have access to
				the instance variables.
		@private	only methods of this class may access the
				instance variables.  This excludes methods
				of a subclass.

	If not explicitly set, all instance variables are @protected.
	Note: Instance variable encapsulation is enforced at compile-time.
	At run-time, full typing information on all instance variables is
	available, which sort-of makes all variables @public again.  This
	information is for instance used to do instance variable lookup by
	NeXTSTEP's `loadNibSection:owner:' method, making it completely
	safe.

    Methods:

	To the Objective-C runtime, all methods are @public.  The programmer
	can only show his/her intention of making specific methods not
	public by not advertising them in the class' interface.  In
	addition, so-called private methods can be put in a category with a
	special name, like `secret' or `private'.

	However, these tricks do not help much if the method is declared
	elsewhere, unless one reverts to indicating the object's type at
	compile time.  And the runtime doesn't care about all this and any
	programmer can easily circumvent the tricks described.  Thus, all
	methods really are always @public.

7   What are Protocols?

    Protocols are an addition to Objective-C that allows you to organize
    related methods into groups that form high-level behaviors.  Protocols
    are currently available in NeXTSTEP (since 3.0) and GCC (since 2.4).

    Protocols address the MI issue.  When you design an object with multiple
    inheritance, you usually don't want *all* the features of both A and B,
    you want feature set X from A and feature set Y from B.  If those
    features are methods, then encapsulating X and Y in protocols allows you
    to say exactly what you want in your new object.  Furthermore, if
    someone changes objects A or B, that doesn't break your protocols or
    your new object.  This does not address the question of new instance
    variables from A or B, only methods.

    Protocols allow you to get type-checking features without sacrificing
    dynamic binding.  You can say "any object which implements the messages
    in Protocol Foo is OK for this use", which is usually what you want -
    you're constraining the functionality, not the implementation or the
    inheritance.

    Protocols give library builders a tool to identify sets of standard
    protocols, independent of the class hierarchy.  Protocols provide
    language support for the reuse of design, whereas classes support the
    reuse of code.  Well designed protocols can help users of an application
    framework when learning or designing new classes.  Here is a simple
    protocol definition for archiving objects:

	@protocol Archiving
	-read: (Stream *) stream;
	-write: (Stream *) stream;
	@end

    Once defined, protocols can be referenced in a class interface as
    follows:

	/* MyClass inherits from Object and conforms to the
	   Archiving protocol.  */
	@interface MyClass: Object <Archiving>
	@end

    Unlike copying methods to/from other class interfaces, any incompatible
    change made to the protocol will immediately be recognized by the
    compiler (the next time the class is compiled).  Protocols also provide
    better type checking without compromising the flexibility of untyped,
    dynamically bound objects.

	MyClass *obj1 = [MyClass new];

	// OK: obj1 conforms to the Archiving protocol.
	id <Archiving> obj2 = obj1;

	// Error: obj1 does not conform to the TargetAction protocol.
	id <TargetAction> obj3 = obj1;

    Another use of protocols is that you can declare an ID to conform to
    some protocol in order to help the compiler to resolve method name
    conflicts:

	@interface Foo: Object
	-(int) type;
	@end

	@protocol Bar
	-(const char *) type;
	@end

	-blah1: d
	{
	  id t = [d someMethod];
	  do_something_with ([t type]);
	}

	-blah2: d
	{
	  id <Bar> t = [d someMethod];
	  do_something_with ([t type]);
	}

    In this example, there are two kinds of the `-type' method.  In the
    method `-blah1:', the compiler doesn't know what return type to expect
    from `[t type]', since it has seen both declarations of `-type'.  In
    method `-blah2:', it knows that `t' conforms to the `Bar' protocol and
    thus that `t' implements the `-type' method returning a `const char *'.

8   How can garbage collection be applied to Objective-C?

    Currently, there are two implementations of garbage collection which can
    be used in Objective-C programs [that I'm aware of].  Both methods use a
    radically different approach.

	Garbage Collection in an Uncooperative Environment

	    This implements garbage collection of chunks of memory obtained
	    through (its replacement of) malloc(3).  It works for C, C++,
	    Objective-C, etc.

	    @article{bw88,
	    title="Garbage Collection in an Uncooperative Environment",
	    author="Hans J\"urgen Boehm and Mark Weiser",
	    journal="Software Practice and Experience",
	    pages=807-820,volume=18,number=9,month=sep,year=1988}

	    It used to be available as `iesd.auc.dk:/pub/ObjC/gc3.0.tar.z'.
	    Its current location is unknown.

	Garbage Collection through Class Abstraction

	    This implements garbage collection through class abstraction
	    (and hence is Objective-C specific).  Anything to be garbage
	    collectible must be an object (instance of a subclass of a
	    specific class) or have such an object for a wrapper.

	    Available as `ftp.es.ele.tue.nl:/pub/tiggr/tobjc.tar.gz'

    Apart from the obvious radical difference, another difference currently
    is also noteworthy: The first method automatically protects objects
    pointed to from the stack, bss or data segments; the second doesn't.

9   What is the difference between the NeXTSTEP, Stepstone and GNU CC
    versions of Objective-C?

    NeXT extended Stepstone's definition of the language to include new
    constructs, such as protocols, which are touted to deal with some
    aspects of multiple inheritance.

    Stepstone supports static _binding_, whereas NeXTSTEP and GNU CC don't.
    All implementations do support static _typing_.

    Stepstone has a standard set of Foundation class libraries that work
    across all supported machines, including NeXTSTEP.  NEXTSTEP comes with
    its own set of libraries (called `kits').  GNU libobjc.a currently only
    includes the `Object' class, though people are busy on a Real library
    (see part two of this FAQ (The ClassWare Listing) for details).

    The `Object' class of all implementations differ.

    NeXTSTEP and GNU CC support Categories, Stepstone doesn't.

    NeXT has a native language debugger, Stepstone and GNU don't.  [This is
    not really true, since NeXT's debugger is gdb, the GNU debugger, and
    their extensions are available.  I think I've seen them on the Fall 1992
    Edu CD.  Their extensions haven't appeared in the official FSF
    distribution yet.]

    NeXTSTEP (from version 3.0) and GCC (from version 2.4) support protocols
    and forward declarations of classes, Stepstone currently does not.

10  What written information concerning Objective-C is available?

    Books:

	Brad J. Cox, Andrew J. Novobilski: Object Oriented Programming: An
	Evolutionary Approach.  Addison-Wesley Publishing Company, Reading,
	Massachusetts, 1991.  ISBN: 0-201-54834-8.

	abstract:	The first book on Objective-C, which actually is a
	                book on object oriented system development using
	                Objective-C.
	                

	Lewis J. Pinson, Richard S. Wiener: Objective-C: Object Oriented
	Programming Techniques.  Addison-Wesley Publishing Company, Reading,
	Massachusetts, 1991. ISBN 0-201-50828-1.

	abstract:       Includes many examples, discusses both Stepstone's
	                and NeXT's versions of Objective-C, and the
	                differences between the two.


	Timothy Budd: An Introduction to Object-Oriented Programming.
	Addison-Wesley Publishing Company, Reading, Massachusetts.
	ISBN 0-201-54709-0.

	abstract:       An intro to the topic of OOP, as well as a comparison
	                of C++, Objective-C, Smalltalk, and Object Pascal


	Simson L. Garfinkel, Michael K. Mahoney: NeXTSTEP Programming Step
	ONE: Object-Oriented Applications.  TELOS/Springer-Verlag, 1993
	(tel: (800)SPR-INGE).

	abstract:       It's updated to discuss NeXTSTEP 3.0 features
	                (Project Builder, new development environment)
	                but doesn't discuss 3DKit or DBKit.


	NeXTSTEP Object Oriented Programming and the Objective C Language.
	Addison-Wesley Publishing Company, Reading, Massachusetts, 1993.
	ISBN 0-201-63251-9.

	abstract: 	This book describes the Objective-C language as it
			is implemented for NeXTSTEP.  While clearly targeted
			at NeXTSTEP, it is a good first-read to get to learn
			Objective-C.

    Articles

	`Why I need Objective-C', by Christopher Lozinski.
	Journal of Object-Oriented Programming (JOOP) September 1991.

	Abstract:	This article discusses the differences between C++
			and Objective-C in great detail and explains why
			Objective-C is a better object oriented language.

	`Concurrent Object-Oriented C (cooC)', by Rajiv Trehan et. al.
	ACM SIGPLAN Notices, Vol. 28, No 2, February 1993.

	Abstract:	This article discusses cooC, a language based on the
			premise that an object not only provides an
			encapsulation boundary but should also form a
			process boundary.  cooC is a superset of
			Objective-C.

	`Porting NEXTSTEP Applications to Microsoft Windows',
	by Christopher Lozinski.  NEXTWORLD EXPO Conference Proceedings,
	San Francisco, CA, May 25-27, 1993.  Updated version of the article
	available from the author.  Contact lozinski@cup.portal.com

	Abstract:	This article describes how to develop Objective-C
			applications for both Microsoft Windows and
			NEXTSTEP.

    GNU Documentation

	The GNU project needs a free manual describing the Objective-C
	language features.  Because of its cause, GNU cannot include the
	non-free books in the GNU system, but the system needs to come with
	documentation.

	Anyone who can write good documentation, please think about giving
	it to the GNU project.  Contact rms@gnu.ai.mit.edu.

11  What kind of Objective-C support is provided by Stepstone?

	Compilers and runtime for: Apple Macintosh (running Mac Programmers
	Workshop), DEC Stations (ULTRIX), Data General AViiON (DG/UX),
	HP9000/300,400,700,800 (HP-UX), IBM RISC System/6000 (AIX), MIPS,
	NeXT, PC-AT (MS-DOS), PS/2 (AIX or OS/2), SCO/NCR UNIX SYS V, Sun 3, 4,
	SPARCstations (SunOS or Solaris), Silicon Graphics INDIGO and VAX(VMS).
	Other ports available by market demands or consulting services.

	ICpak101 Foundation Class Library is avaliable on all the above.
	ICpak201 GUI Class Library is available on platforms that support
	XWindows, Motif, OpenWindows and SunView.

   	The Stepstone Corporation
	(203) 426-1875 - (800) BUY-OBJEct voice / (203) 270-0106 fax
	75 Glen Road
	Sandy Hook, CT 06482

12  What kind of Objective-C support is provided by NeXT?

	The Objective-C compiler and libraries come bundled with the
	NEXTSTEP Developer CD.  The compiler essentially is GNU CC.  For
	information on the Kits which are part of NEXTSTEP, see the
	ClassWare Listing (part 2 of this FAQ).

	Products are:

	    NEXTSTEP 3.2 for NeXT or Intel Computers

	    ObjectWare Catalogue (lists available classes, both commercial
	    and those freely available).

	NeXT Computer, Inc.
	900 Chesapeake Drive
	Redwood City, CA 94063
	tel: 800 848 NEXT
	fax: 415 780 2801
	email: NeXTanswers@NeXT.COM

	[Note: The World of NEXTSTEP is moving rapidly: HP-PA NEXTSTEP has
	been demoed (available mid 94), Sparc NEXTSTEP is being worked on
	(available late 94?).  OpenStep has been defined and made available.
	This specification includes Objective-C, DPS, PDO, PB/IB.  OpenStep
	will be available on Solaris (when?).]

13  What kind of Objective-C support is provided by GNU?

    GNU CC, since version 2, comes with an Objective-C compiler.  The
    current distribution of GNU CC (version 2.5.8) includes an Objective-C
    compiler and runtime library.  The latter includes the `Object' class.
    Some people are working on GNU libraries, see part two of this FAQ (The
    ClassWare Listing) for details.

    If you haven't switched to a GNU CC as recent as 2.4 yet, here's one
    reason to do so: The new runtime (as of 2.4) is more than 3 times as
    fast as the old runtime (pre 2.4) w.r.t. method invocation.

	Free Software Foundation
	675 Massachusetts Avenue
	Cambridge, MA  02139
	+1-617-876-3296

    General questions about the GNU Project can be asked to
    gnu@prep.ai.mit.edu.

	GNU CC comes with an Objective-C compiler and runtime library which
	includes the Object class.

    Most GNU software is packed using the new `gzip' compression program.
    Source code is available on most sites distributing GNU software.

    For information on how to order GNU software on tape, floppy, or
    cd-rom, check the file etc/ORDERS in the GNU Emacs distribution or in
    GNUinfo/ORDERS on prep, or e-mail a request to: gnu@prep.ai.mit.edu

    By ordering your GNU software from the FSF, you help us continue to
    develop more free software.  Media revenues are our primary source of
    support.  Donations to FSF are deductible on US tax returns.

    The following sites all carry mirrors of the GNU software at prep.
    Please try them before prep.ai.mit.edu!   thanx -gnu@prep.ai.mit.edu
	ASIA: ftp.cs.titech.ac.jp, utsun.s.u-tokyo.ac.jp:/ftpsync/prep,
	    cair.kaist.ac.kr:/pub/gnu, ftp.nectec.or.th:/pub/mirrors/gnu
	AUSTRALIA: archie.au:/gnu (archie.oz or archie.oz.au for ACSnet)
	AFRICA: ftp.sun.ac.za:/pub/gnu
	MIDDLE-EAST: ftp.technion.ac.il:/pub/unsupported/gnu
	EUROPE: irisa.irisa.fr:/pub/gnu, ftp.univ-lyon1.fr:pub/gnu,
	    ftp.mcc.ac.uk, unix.hensa.ac.uk:/pub/uunet/systems/gnu,
	    ftp.denet.dk, src.doc.ic.ac.uk:/gnu, ftp.eunet.ch,
	    nic.switch.ch:/mirror/gnu,
	    ftp.informatik.rwth-aachen.de:/pub/gnu,
	    ftp.informatik.tu-muenchen.de, ftp.win.tue.nl,
	    ftp.funet.fi:/pub/gnu, ftp.stacken.kth.se, isy.liu.se,
	    ftp.luth.se:/pub/unix/gnu, ftp.sunet.se:/pub/gnu,
	    archive.eu.net
	SOUTH AMERICA: ftp.unicamp.br:/pub/gnu
	WESTERN CANADA: ftp.cs.ubc.ca:/mirror2/gnu
	USA: wuarchive.wustl.edu:/systems/gnu, labrea.stanford.edu,
	    ftp.digex.net:/pub/gnu, ftp.kpc.com:/pub/mirror/gnu,
	    f.ms.uky.edu:/pub3/gnu, jaguar.utah.edu:/gnustuff
	    ftp.hawaii.edu:/mirrors/gnu, ftp.cs.widener.edu,
	    vixen.cso.uiuc.edu:/gnu, mrcnext.cso.uiuc.edu:/pub/gnu,
	    ftp.cs.columbia.edu:/archives/gnu/prep,
	    col.hp.com:/mirrors/gnu, gatekeeper.dec.com:/pub/GNU,
	    ftp.uu.net:/systems/gnu

14  What kind of Objective-C support is provided by BPG.

    BPG provides the Borland Extensions to Objective-C which allows the
    Objective-C translator to be used with the Borland Compiler, and makes
    it easy to develop Objective-C application for Microsoft Windows.

    BPG provides the Smalltalk Interface to Objective-C which makes
    Objective-C objects look like Smalltalk Objects.  It can be used to
    build Graphical User Interface on portable Objective-C objects, or to
    sell Objective-C libraries to Smalltalk developers.

    BPG provides the Objective-C Message Bus which sends Objective-C messages
    across heterogeneous computer platforms.

    BPG has a library of objects for modelling Objective-C programs.  A browser
    application has been built on this library.  Other potential applications
    include adding class variables to Objective-C, adding runtime information
    about instance variables, and method argument types, generating object
    versions, and eventually building a browser/translator.

	Christopher Lozinski
	BPG
	35032 Maidstone Court
	Newark, CA 94560
	Tel: (510) 795-6086
	fax: (510) 795-8077
	email: lozinski@cup.portal.com

15  What are the newsgroups to read or mailing lists to subscribe to in order
    to stay up-to-date on developments for GNU Objective-C?

    Read comp.lang.objective-c, which is bound to discuss current events.
    There is also a mailing list, gnu-objc@gnu.ai.mit.edu, discussing this
    very topic.  To subscribe to this list, send a mail with your request to
    `gnu-objc-request@gnu.ai.mit.edu.'

    Furthermore, the various kits that are being developed each come with
    their own mailing list.  See part 2 of this FAQ for more information.

16  Are there any FTP sites with Objective C code?  Where?

	ftp.cs.rochester.edu:/pub/objc
	sonata.cc.purdue.edu		(NEXTSTEP)
	cs.orst.edu			(NEXTSTEP)
	ftp.stack.urc.tue.nl		(NEXTSTEP)
	ftp.informatik.uni-muenchen.de
	ccrma-ftp.stanford.edu		(MusicKit)

    See also part 2 of this FAQ.

17  For more information...

    See part 2 of this FAQ, Objective-C/classes a.k.a. the ClassWare
    Listing, for an overview of available Objective-C classes and libraries.

    See part 3 of this FAQ, Objective-C/sample a.k.a. the Simple Sample
    Program, for an example Objective-C program.

The early version of this FAQ was compiled by Bill Shirley, with the aid of
many people.  The current version is being maintained by Tiggr, aided by a
lot of people, including: Per Abrahamsen, Paul Burchard, Brad Cox,
Christopher Lozinski, Mike Mahoney, Jon F. Rosen, Paul Sanchez, Lee Sailer,
Bill Shirley, Subrata Sircar, Ted Slupesky, Richard Stallman and Kersten
Krab Thorup,

A World Wide Web hypertext version of this FAQ is maintained by Brian Harvey
(theharv@csld.ucr.edu) and can be found at:
    http://csld.ucr.edu/NeXTSTEP/objc_faq.html

Any text in between `[' and `]' is a comment.  Comments indicate `problems'
with this FAQ, which should be solved.  Send your suggestions, additions,
bug reports, comments and fixes to `tiggr@es.ele.tue.nl'.

    The information in this file comes AS IS, WITHOUT ANY WARRANTY.  You may
    use the information contained in this file or distribute this file, as
    long as you do not modify it, make money out of it or take the credits.

From: tiggr@es.ele.tue.nl (Tiggr)
Newsgroups: comp.lang.objective-c,comp.answers,news.answers
Subject: comp.lang.objective-c FAQ, part 2/3: ClassWare Listing
Date: 17 Nov 1994 17:00:06 GMT
Organization: Eindhoven University of Technology, the Netherlands
Message-ID: <classes_785091602@es.ele.tue.nl>
Reply-To: tiggr@es.ele.tue.nl (Tiggr)

Archive-name: Objective-C/classes
Version: $Id: classes,v 2.15 1994/11/06 10:59:54 tiggr Exp $



				Objective-C

			     ClassWare Listing



This is the second of three FAQ postings for comp.lang.objective-c.  This
posting lists available kits and classes, to aid the reader in answering the
question `to re-use or to re-invent?'.  In order to keep this list up to date
and as interesting and diverse as possible, send your additions, deletions
and suggestions to tiggr@es.ele.tue.nl.

The available classes and kits are categorized as follows:

	Stepstone	Stepstone libraries,
			for use with Stepstone's environment
	NeXT		NeXT kits, for use with NEXTSTEP
	FSF		FSF maintained/released classes
			for use with GNU CC
	Third Party	commercial classes
	GPL		classes released under the GPL
	Public Domain	public domain classes---no GPL


Stepstone

    Bundled with the compiler is ICpak 101 Foundation Class Library.  This
    library provides twenty classes and more than three hundred methods
    including such things as Collections (OrdCltn, Stack, Set, Dictionary,
    SortCltn), Arrays (IdArray, IntArray), String, Sequences, Automatic
    Object I/O (ASCII Filer), etc.

    The ICpak 201 Graphical User Interface library is used to build iconic
    multi window user interfaces for workstation applications.  The library
    consists of 58 classes and over 1,100 methods.  Classes include such
    things as Controllers, Menu's, Menu Items, Icons, Windows(StdLayer),
    Timers, Buttons, Text, etc, etc.  ICpak 201 is ported to X Windows,
    OpenWindows, Motif and SunView and provides a consistent user interface/
    look-and-feel between all platforms.

    Contact

	The Stepstone Corporation
	75 Glen Road
	Sandy Hook, CT 06482
	tel: +1 203 426-1875
	fax: +1 203 270-0106
	telex: 506127

NeXT

    Common Classes

	Several classes provided with NeXTSTEP do not belong to a specific
	kit: Object (core of the runtime system, root of the general class
	hierarchy), Storage, List (an abstract array), HashTable (to store
	(key, object) associations), StreamTable (to write data to streams)
	and NXStringTable (to store (key, string) associations).

    Application Kit

	The Application Kit defines a set of Objective-C classes and
	protocols, C functions, and assorted constants and data types that
	are used by virtually every NeXTSTEP application.  The pith of the
	Kit are the tools it provides for implementing a graphical,
	event-driven user interface:

	    The Application Kit provides classes---most notably Window and
	    View---that make drawing on the screen exquisitely succinct.
	    Much of the unromantic work that's involved in
	    drawing---communicating with hardware devices and screen
	    buffers, clearing areas of the screen before drawing,
	    coordinating overlapping drawing areas---is taken care of for
	    you, letting you concentrate on the much more gratifying task of
	    supplying code that simply draws.  And even this task is
	    assisted by many of the other classes and a number of C
	    functions that provide drawing code for you.

	    The Application Kit makes event handling extremely simple.  The
	    Responder class, from which many of the Kit's classes inherit,
	    defines a mechanism by which the user's actions are passed to
	    the objects in your application that can best respond to them.
	    The Application class, which inherits from Responder,
	    establishes the low-level connections that makes this system
	    possible.  It provides methods that inform your application of
	    watershed events, such as when the user makes the application
	    active and inactive, and when the user logs out or turns off the
	    computer.

	By using these tools, you bless your application with a look and
	feel that's similar to other applications, making it easier for the
	user to recognize and use.

	(Introduction from the NeXTSTEP General Reference, "Application Kit"
	reprinted with permission.  Copyright (c) 1993 NeXT Computer, Inc.
	All rights reserved.)

    Database Kit

	The Database Kit provides a comprehensive set of tools, classes, and
	protocols for building applications that use a high-level
	entity-relationship model to manipulate database servers such as
	those provided by Oracle or Sybase.  The kit provides services that
	include:

	    Communication with client-server databases.

	    Modeling properties (attributes and relationships) of each
	    database.

	    Record management and buffering.

	    Data flow between record managers and the application user
	    interface.

	    User interface objects for display and editing.

	(Introduction from the NeXTSTEP General Reference, "Database Kit"
	reprinted with permission.  Copyright (c) 1993 NeXT Computer, Inc.
	All rights reserved.)

    Distributed Objects

	The Distributed Objects system provides a relatively simple way for
	applications to communicate with one another by allowing them to
	share Objective-C objects, even amongst applications running on
	different machines across a network.  They are useful for
	implementing client-server and cooperative applications.  The
	Distributed Objects system subsumes the network aspects of typical
	remote procedure call (RPC) programming, and allow an application to
	send messages to remote objects using ordinary Objective-C syntax.

	The Distributed Objects system takes the form of two classes,
	NXConnection and NXProxy.  NXConnection objects are primarily
	bookkeepers that manage resources passed between applications.
	NXProxy objects are local objects that represent remote objects.
	When a remote object is passed to your application, it is passed in
	the form of a proxy that stands in for the remote object; messages
	to the proxy are forwarded to the remote object, so for most intents
	and purposes the proxy can be treated as though it were the object
	itself.  Note that direct access to instance variables of the remote
	object isn't available through the proxy.

	(Introduction from the NeXTSTEP General Reference, "Distributed Objects"
	reprinted with permission.  Copyright (c) 1993 NeXT Computer, Inc.
	All rights reserved.)

    Indexing Kit

	The Indexing Kit is a set of programmatic tools for managing data,
	especially the large amounts of data characteristic of information
	intensive applications.  Much as the Application Kit provides a
	framework for a graphical interface, the Indexing Kit provides a
	framework for data management.

	The Indexing Kit supplies facilities for building custom databases
	and for searching the UNIX file system.  Key benefits include
	guaranteed data integrity, excellent performance, thread-safe
	operation, tight integration with the NeXTSTEP programming
	environment, and the ability to efficiently store and retrieve
	Objective-C objects and unstructured data like text, sound, and
	images.

	The Indexing Kit consists of:

	    A transaction-oriented foundation for storing and retrieving
	    persistent data, using virtual memory mapping for efficient
	    random access to parts of a file without reading or writing the
	    entire file. Transactions guarantee data integrity on persistent
	    storage media, and are also used to manage concurrent access to
	    shared data.

	    Fast sequential and associative access to stored data.
	    Associative access is untyped, in that the programmer defines
	    the data types of keys and their ordering by means of a
	    comparison function or a format string.

	    A simple data management capability based on the Objective-C
	    run-time system.  Records can be moved efficiently between
	    working memory and the storage substrate in the form of
	    Objective-C objects.  Multiple indexes can be built over
	    programmer-defined attributes, so that records can be ordered
	    and retrieved by the values of their indexed attributes.

	    A general query processing facility, including a declarative
	    query language and its interpreter.  Queries can be applied to
	    individual objects, to collections of objects, or to the
	    attribute/value lists produced by Indexing Kit's customizable
	    text processing tools.

	    High-level file system searching facilities based on the
	    supporting layers described above, including fast literal
	    searching of file contents.

	(Introduction from the NeXTSTEP General Reference, "Indexing Kit"
	reprinted with permission.  Copyright (c) 1993 NeXT Computer, Inc.
	All rights reserved.)

    Mach Kit

	The Mach Kit provides an object-oriented interface to some of the
	features of the Mach operating system.  At this time, it is most
	useful to applications that make use of the Distributed Objects
	system, since these applications rely upon Mach's message sending
	abilities to transport objects, ports, and data between processes.
	The Mach Kit may also be useful for drivers and multi threaded
	applications.  The Mach Kit provides several classes and protocols,
	listed below.

	(Introduction from the NeXTSTEP General Reference, "Mach Kit"
	reprinted with permission.  Copyright (c) 1993 NeXT Computer, Inc.
	All rights reserved.)

    NetInfo Kit

	The NetInfo Kit is a collection of classes and a single function
	used to provide a connection to and interface with NetInfo domains.
	The NetInfo Kit provides classes for basic interface with a domain
	as well as specialized panels.

	(Introduction from the NeXTSTEP General Reference, "NetInfo Kit"
	reprinted with permission.  Copyright (c) 1993 NeXT Computer, Inc.
	All rights reserved.)

    3D Kit

	The 3D Graphics Kit enables NeXTSTEP applications to model and
	render 3-dimensional scenes.  Much as the Application Kit's 2D
	graphics capabilities are based on the Display PostScript
	interpreter, the 3D Kit's capabilities are based on the Interactive
	RenderMan renderer.  There are both similarities and differences in
	the inner workings of the two implementations.

	One similarity is that both are implemented with a client-server
	model, in which client applications send drawing code to the Window
	Server, which does the actual drawing.  Another similarity is that
	N3DCamera---the 3D Kit's View---generates all drawing code, both 2D
	and 3D, when its drawSelf: method is invoked.  This keeps the
	Application Kit's display mechanism intact for both PostScript and
	RenderMan drawing.

	One difference in the implementations is in the code generated for
	drawing. For 2D drawing, a View sends PostScript code to the Window
	Server's Display PostScript interpreter.  For 3D drawing, a View
	sends RenderMan Interface Bytestream (RIB) code to the Window
	Server's Interactive RenderMan renderer.

	(Introduction from the NeXTSTEP General Reference, "3D Graphics Kit"
	reprinted with permission.  Copyright (c) 1993 NeXT Computer, Inc.
	All rights reserved.)

    Sound Kit

	The Sound Kit is designed to provide both low- and high-level access
	to sound hardware on workstations running NeXTSTEP, including
	support for a wide variety of sound formats, real-time mixing and
	compression.  The Sound Kit consists of five general categories of
	objects:

	    Sound Device Objects
	
		Sound Device objects, like NXSoundIn and NXSoundOut,
		wrap the low-level hardware and sound drivers into
		simple, extensible packages.

	    Sound Streams

		Sound Stream objects, like NXPlayStream or NXRecordStream,
		allow the sound output of many simultaneous programs to be
		mixed, scaled, and processed before being sent out the Sound
		objects.

	    The Sound Object

		The Sound object is NeXTSTEP's fundamental sound data
		storage and playback/recording facility.

	    The SoundView Object

		NeXTSTEP's Sound View is a graphical display of sound data
		that interacts well with the NeXTSTEP GUI.

	    The Sound Meter Object

		The Sound Meter displays the current running amplitude of a
		playing or recording sound (in mono), much like volume
		meters on amplifiers or tape decks.

	In addition to this library, NeXT provides two sets of sound driver
	and sound access functions.

    NXLiveVideoView

	The NXLiveVideoView class provides API for interactive display of
	live video on the screen of a NeXTdimension Computer.  The
	NXLiveVideoView class specification provides a complete discussion
	of the NeXTdimension Computer's video capabilities and the API
	provided by NXLiveVideoView.

	(Introduction from the NeXTSTEP General Reference, "Video"
	reprinted with permission.  Copyright (c) 1993 NeXT Computer, Inc.
	All rights reserved.)

    Applications

	There are several classes which solely exist to enable the
	programmer to add functionality to specific existing NEXTSTEP
	applications:

	    IBPalette, IBInspector

		These classes allow developers to expand the functionality
		of the Interface Builder application, creating their own
		palettes of objects that can be dragged into an interface,
		and inspectors to set and view the attributes of those
		objects.

	    Layout

		This class allows developers to add their own modules to the
		Preferences application.

	    WMInspector

		This class allows developers to add their own file contents
		inspectors to the Workspace Manager application.

    Other

	Before NeXTSTEP 3.0, MusicKit was distributed as part of NEXTSTEP.
	MusicKit is now maintained and made available by CCRMA (see the
	entry under `Public Domain Kits').  Also until the advent of
	NeXTSTEP 3.0, PhoneKit was part of NeXTSTEP.  PhoneKit classes
	provided easy to ISDN connections.

    Contact

	NeXT Computer, Inc.
	900 Chesapeake Drive
	Redwood City, CA 94063
	tel: +1 800 848 NEXT
	fax: +1 415 780 2801
	email: NeXTanswers@NeXT.COM

FSF

    Object

	Object is the root class which comes as part of the Objective-C
	runtime library provided with the GNU CC compiler.

    GNU Objective-C Class Library

	The GNU Objective C Class Library (libobjects) is a library of
	general-purpose, non-graphical Objective C objects written by
	R. Andrew McCallum.  What `libg++' is to GNU's C++, `libobjects' is
	to GNU's Objective C.

	The library features collection objects for maintaining groups of
	objects and C types, streams for I/O to various destinations, coders
	for formating objects and C types to byte streams, ports for network
	packet transmission, distributed objects (remote object messaging),
	pseudo-random number generators, and time handling facilities.

	* The heirarchy of collection objects are similar in spirit to
	  Smalltalk's collections.  A deep inheritance heirarchy provides
	  good uniformity of method names across different collection
	  classes.  All collections can hold simple C types (such as int's
	  and floats) as well as Objects.  The collection classes include
	  simple collections (Set, Bag), collections with contents
	  accessible by unordered keys (Dictionary, MappedCollector),
	  collections with ordered contents (Array, LinkedList, Stack,
	  Queue, Heap, BinaryTree, RBTree, SplayTree, GapArray).  There is
	  also a DelegatePool object that can forward messages it receives
	  to an arbitrary number of delegate objects.

	* Stream objects provide a consistent interface for reading and
	  writing bytes.  `StdioStream' objects work with files, file
	  descriptors, FILE pointers and pipes to/from
	  executables. `MemoryStream' objects work with memory buffers that
	  grow automatically as needed.  For all Stream objects there are
	  methods for writing/reading arbitrary n-length buffers,
	  newline-terminated lines, and printf-style strings.

	* Coders provide a formatted way of writing to Streams.  After a
	  coder is initialized with a stream, the coder can encode/decode
	  Objective C objects and C types in an architecture-independent
	  way.  The currently available concrete coder classes are
	  `BinaryCoder', for reading and writing a compact stream of
	  illegible bytes, and `TextCoder', for reading and writing
	  human-readable structured textual representation (which you can
	  also process with `perl', `awk', or whatever scripting language
	  you like).

	  Coders and streams can be mixed and matched so that programmers can
	  choose the destination and the format separately.

	* The distributed object support classes are `Connection', `Proxy',
	  `ConnectedCoder', `Port' and `SocketPort'.  This version of the
	  distributed objects only works with sockets.  A Mach port back-end
	  should be on the way.

	  [NOTE: The GNU distributed object facilities have the same
	  ease-of-use as NeXT's; be warned, however, that they are not
	  compatible with each other.  They have different class
	  heirarchies, different instance variables, different method names,
	  different implementation strategies and different network message
	  formats.  You cannot communicate with a NeXT NXConnection using a
	  GNU Connection.  NXConnection creates NXProxy objects for local
	  objects as well as remote objects; GNU Connection doesn't need and
	  doesn't create proxies for local objects.  NXProxy asks it's
	  remote target for the method encoding types and caches the
	  results; GNU Proxy gets the types directly from the local GNU
	  "typed selector" mechanism and has no need for querying the remote
	  target or caching encoding types.  The NXProxy for the remote root
	  object always has name 0 and, once set, you cannot change the root
	  object of a NXConnection; the GNU Proxy for the remote root object
	  has a target address value just like all other Proxy's, and you
	  can change the root object as many times as you like.  See the
	  "lacking-capabilities" list below for a partial list of things
	  that NXConnection can do that GNU Connection cannot.]

	  Here is a partial list of what the current distributed objects
	  system can do:

          * It can pass and return all simple C types, including char*, float
            and double, both by value and by reference.
          * It can pass structures by value and by reference, return
            structures by reference.  The structures can contain arrays.
          * It obeys all the type qualifiers: oneway, in, out, inout, const.
          * It can pass and return objects, either bycopy or with proxies.
            An object encoded multiple times in a single message is properly
            decoded on the other side.
          * Proxies to remote objects are automatically created as they are
            returned.  Proxies passed back where they came from are decoded
            as the correct local object.
          * It can wait for an incoming message and timeout after a
            specified period.
          * A server can handle multiple clients.
          * The server will ask its delegate before making new connections.
          * The server can make call-back requests of the client, and keep
            it all straight even when the server has multiple clients.
          * A client will automatically form a connection to another client
            if an object from the other client is vended to it. (i.e. Always
            make a direct connection rather than forwarding messages twice,
            once into the server, from there out to the other client.)
          * The server will clean up its connection to a client if the client
            says goodbye (i.e. if the client connection is freed).
          * When the connection is being freed it will send a invalidation
            notification message to those objects that have registered for
            such notification.
          * Servers and clients can be on different machines of different
            architectures; byte-order and all other architecture-dependent
            nits are taken care of for you.  You can have SPARC, i386, m68k,
            and MIPS machines all distributed-object'ing away together in
            one big web of client-server connections!

	  Here is a partial list of what the current distributed objects
	  system does *not* do:

          * Run multi-threaded.
          * Detect port deaths (due to remote application crash, for example)
            and do something graceful.
          * Send exceptions in the server back to the client.
          * Return structures by value.
          * Use Mach ports, pass Mach ports, pass Mach virtual memory.
          * Send messages more reliably than UDP.  It does detect reply
            timeouts and message-out-of-order conditions, but it's reaction
            is simply to abort.
          * Claim to be thoroughly tested.

	Getting It, and Compiling It

	    The library is available by anonymous ftp at URL:
	     ftp://prep.ai.mit.edu/pub/gnu/libobjects-0.1.0.tar.gz
	    Since `prep' is heavily loaded, you are
	    encouraged to use GNU mirror sites.

	    The most recent (not necessarily tested) snapshots of the
	    library will be placed at `ftp://alpha.gnu.ai.mit.edu/gnu'.

	    The library requires gcc 2.6.1 or higher.  The library does not
	    work with the NEXTSTEP 3.2 compiler because that version of
	    NeXT's cc cannot handle nested functions.  Until a later release
	    from NeXT, NEXTSTEP users will have to install gcc.  Also,
	    temporarily, the library does not work with the NeXT Objective C
	    runtime library.

	    The library has been successfully compiled and tested with the
	    following configurations: mips-sgi-irix5.2 sparc-sun-sunos4.1.3
	    m68k-next-nextstep3.0.

	    Some previous snapshots of the library worked with these
	    configurations, but they haven't been tested recently:
	    i386-unknown-linux i386-sun-solaris2.4 i386-unknown-sysv4.0
	    sparc-sun-solaris2.3.

	    It is known not to work with: alpha-dec-osf.

	Now and Future

	    The current version is 0.1; the low number indicates that the
	    library is still in flux.  A version coming soon will include
	    String objects and better allocation/dealocation conventions.

	GNUStep, NEXTSTEP and OpenStep

	    The libobjects library already contains many of the "Common
	    Classes" in NeXTSTEP: List, HashTable, Storage, NXStringTable.
	    In the future it will also contain classes compatible with the
	    OpenStep Foundation Kit. Progress is already being made on this
	    front.

	Contact

	    Andrew McCallum
	    mccallum@gnu.ai.mit.edu

    Contact

	Free Software Foundation
	675 Massachusetts Avenue
	Cambridge, MA  02139
	+1-617-876-3296


Third Party Kits

    Hot Technologies

	BARCODEKIT

	    BarCodeKit is a comprehensive collection of object palettes for
	    creating international standard bar codes.  BarCodeKit allows
	    both developers and organizations to quickly add bar coding to
	    custom NEXTSTEP applications.  By combining the power of object
	    orientation and PostScript into a comprehensive library of bar
	    code symbologies, BarCodeKit represents the state of the art in
	    bar code technology.  Developers can seamlessly add bar coding to
	    an existing application in a matter of minutes by using any of
	    the 35 pretested and reusable objects in the BarCodeKit library
	    of palettes.  Previously, adding bar coding to an application
	    meant weeks or months of development, incompatibility with
	    different bar code readers and the use of costly proprietary bar
	    code printers.

	    The BarCodeKit features a full range of bar code symbologies
	    including Code 3 of 9, Code 39 Extended, UPC-A, UPC-E, HRI, NDC,
	    EAN-8, EAN-13, JAN-8, JAN-13, ISBN, ISSN, SICI, SISAC, POSTNET,
	    ABC, FIM, BRM, Interleaved Two of Five, MSI, Codabar, Code 11,
	    Code 93, Code 128, Code 16K and Code 49.  It complies to
	    international, national, military and commercial bar coding
	    standards including EAN, JAN, CEN, ANSI, MIL, USS and HIBCC.
	    Furthermore, it provides developers with flexibility; bar codes
	    created using the kit can be scaled and rotated to fit a
	    specific area on a label or document and saved in EPS, EPSI (EPS
	    with interchange bitmap preview for non Display PostScript
	    computers), or TIFF formats.  BarCodeKit is an excellent
	    complement to NEXTSTEP's Application Kit and Database Kit It was
	    nominated for a Best of Breed Award by the editors of NeXTWORLD
	    Magazine.

	SERIALPORTKIT

	    SerialPortKit is a fundamental class library and palette that
	    makes communication with serial peripherals easy to add into
	    your custom NEXTSTEP applications without any of the drawbacks
	    of other solutions.  You can use SerialPortKit to communicate
	    with a variety of serial peripherals such as modems, printers,
	    terminals, audio/video equipment, bar code readers, magnetic
	    stripe readers, controllers and data acquisition devices.  The
	    SerialPortKit contains a single SerialPort class which
	    interfaces to our SerialPortServer. Additional classes for
	    specific peripherals are available in our SerialPeripheralsKit
	    or through our consulting service.

	    You can easily incorporate the SerialPortKit into your custom
	    applications due to its professionally designed and truly
	    object-oriented programming interface. The included Interface
	    Builder palette, source code examples, on-line indexed reference
	    manuals and tutorial further removes the tedious task of
	    traditional serial port programming.  Requires SerialPortServer
	    or SerialPortServer Lite which are available also from Hot
	    Technologies.

	Contact

	    Hot Technologies
	    75 Cambridge Parkway, Suite E-504
	    Cambridge, MA 02142-1238 USA
	    tel: + 1 617 252 0088
	    fax: + 1 617 876 8901
	    email: info@hot.com (NeXTmail)

    Berkeley Productivity Group

	BPG BLOCKS

	    BPG BLOCKS is an open extensible manufacturing framework which
	    supports a variety of applications including factory definition,
	    real-time tracking, real-time scheduling, short-term planning,
	    shift scheduling, production planning and capacity analysis.
	    BPG BLOCKS creates a virtual reality which represents the real
	    factory including the people, machines, material, processes,
	    their dynamics and interactions.  BPG BLOCKS is based on an easy
	    to understand design where every software object represents
	    either a real-world entity, or an important concept in the
	    manufacturing domain.  BPG BLOCKS' object-oriented manufacturing
	    model mirrors the real world, captures numerous manufacturing
	    details accurately, supports commonly used abstractions, and
	    allows decisions to be made based on aggregate information.  BPG
	    BLOCKS forms the basis for building custom applications which
	    meet the unique needs of your particular manufacturing
	    facility.

	Objective-C Views

	    Objective-C Views is a user interface class library for
	    Microsoft Windows.

	Contact

	    Christopher Lozinski
            BPG
            35032 Maidstone Court
            Newark, CA 94560
            tel: +1 510 795-6086
            fax: +1 510 795-8077
            email: lozinski@cup.portal.com


    M. Onyschuk and Associates Inc.

	OBJECT:Math

	    OBJECT:Math is a comprehensive set of tools and 23 Objective-C
	    classes used to add extensible math and string handling to your
	    custom and commercial applications:

		Compiler---The OBJECT:Math Compiler converts math and string
		expressions (as might be typed into a spreadsheet cell,
		plotting package, etc.) into Objective-C objects.

		Unbundler---The OBJECT:Math Unbundler object allows
		end-users to extend their OBJECT:Math applications with
		custom-built or third-party OBJECT:Math function bundles.

		User Interface Objects---OBJECT:Math comes complete with a
		Lotus Improv style function picker, a variable editor, and
		objects used to display OBJECT:Math expression trees and
		other tree structures.

	    As product sources are available the product may even be of
	    interest to non-NeXT Objective-C programmers.

	Contact

	    Mark Onyschuk
	    M. Onyschuk and Associates Inc.
	    tel: +1 416 462 3954
	    email: ask-oa@plexus.guild.org


    Stream Technologies Inc.

	Store

	    Store is an Object Oriented User Level Virtual File System.
	    It is described extensively in `Store - Object Oriented Virtual
	    File System' by Timo Lehtinen, which is available by anonymous
	    FTP from ftp.sti.fi:/pub/sti/doc/papers/store.ps.

	Contact

	    Stream Technologies Inc.
	    Valkj\"arventie 2
	    SF-02130 Espoo
	    Finland
	    tel: +358 0 4357 7348
	    fax: +358 0 4357 7340
	    email: info@sti.fi


GPL Kits

   objcX

	An alpha version of an GNU Objective-C class library for X/Motif
	Windows is available via anonymous ftp from

	    ftp.slac.stanford.edu:pub/sources/objcX-0.82.tar.gz.

	For lack of a good witty name, the library is called objcX.

	The library requires the List class from the Collection Library for
	GNU Objective-C (libcoll).

	Because we built this library to support porting NeXTSTEP
	applications to X/Motif and because our GUI programming experience
	has been with NeXTSTEP, this class library has a strongly
	resemblance to NeXT's AppKit.  However, it is only a Objective-C
	wrapper to Motif widgets and does not support Display PostScript,
	rich text, pasteboard, drag and drop, services or many other things
	associated with the NeXTSTEP environment that are not available
	under X windows.

	From version 0.8, the nib translator is part of the objcX
	distribution, as well as some examples of using objcX.

	These announcements are also a call for help.  The library and the
	translator program could use much more work in two areas...

	 - first the library could be flushed out with more features to
	   support larger applications

	 - second, I would like to contribute the library to the GNU
	   project. But it is based on Motif widgets which is not free
	   software.  Thus, work is needed to replace Motif widgets with
	   widgets based on free software.

	To stay informed, join the mailing list gnustep-l@netcom.com by
	sending a subscription email to gnustep-l-request@netcom.com.

	Contact

	    Paul F. Kunz	Paul_Kunz@slac.stanford.edu (NeXT mail ok)
	    Stanford Linear Accelerator Center, Stanford University
	    Voice: (415) 926-2884   (NeXT) Fax: (415) 926-3587


    Tcl/Objective-C Interface Library

	A library of Objective-C objects and support functions for
	communication between Objective-C and Tcl/Tk.  From Tcl you can send
	messages to Objective-C objects and get textual representations of
	what's returned.  Thus it provides a way to interactively type
	messages and see the results, all inside the rich structure of the
	Tcl scripting language---almost an Objective-C interpreter.  The
	library also provides an Objective-C object that will forward all of
	its messages to the Tcl interpreter in textual format.

	The library does NOT provide:
	  * Handling arguments of non-atomic C types.
	  * Tk widgets based NeXTSTEP AppKit objects.
	  * The ability to create new Objective-C classes
	    or methods from Tcl.

	The library is available by anonymous ftp at
	    ftp.cs.rochester.edu:pub/libcoll/libtclobjc-1.0.tar.gz

	The library requires gcc (2.5.8 or higher) or NeXT's cc and tcl-7.3.
	If you have tk-3.6, the library can be configured to use it.  If you
	have libreadline, the library can be configured to use it.  Gcc and
	libreadline are available at any of the GNU archive sites; tcl and
	tk are available at ftp.cs.berkeley.edu.

	Contact

	    R. Andrew McCallum            ARPA: mccallum@cs.rochester.edu
	    Computer Science Department   UUCP: uunet!cs.rochester.edu!mccallum
	    University of Rochester       VOX: (716) 275-2527
	    Rochester, NY  14627-0226     FEET: CSB  Rm. 625

    Tiggr's Objective-C Library

	Tiggr's Objective-C Library, or tobjc for short, is a basic
	Objective-C library, whose functionality is based on Lisp.

	tobjc provides the following classes: LispObject, LispVector,
	Cons, Double, Integer, String, AVLTree, THashTable, StringTable,
	Trie, Lex, LexC and LexDFG.  Furthermore, tobjc includes a
	program to extract documentation from Objective-C source files.

	All classes are a subclass of LispObject.  The LispObject class
	provides its allocation routines and garbage collection (through
	class abstraction) to its subclasses.

	tobjc was undergoing continuous development.  Test releases can
	be obtained by anonymous FTP to `ftp.es.ele.tue.nl' as
	`/pub/tiggr/tobjc-x.xx.tar.gz', where `x.xx' is some version
	indication.  It is by no means finished yet, but certainly
	useful (I have used it for developing a VHDL->ASCIS DFG compiler),
	or at least interesting.

	I have been working on a new version which can handle messages sent
	to nil by setting something called the `objc_nil_class'.  This means
	that that particular class can receive messages while `self == nil',
	i.e. it is possible to make `[nil listp]' return YES.  If you're
	interested, mail me for a copy (it is not good enough to be released
	through ftp yet).

	Contact

	    Pieter J. `Tiggr' Schoenmakers
	    email: tiggr@es.ele.tue.nl
	    tel: +31 40 123484
	    fax: +31 40 128616


Public Domain Kits

    Various authors

	MiscKit

	    The MiscKit is a collection of over sixty objects which extend
	    the NEXTSTEP Objective-C development environment in various
	    ways.  It includes palletized subclasses of AppKit controls,
	    foundation objects, and a variety of useful special purpose
	    objects.

	    Objects include strings, basic data structures, and kits for
	    building swapping views and inspectors.  There are also
	    frameworks for building Info menus and a generic document
	    handling architecture.  Palettized objects include a logarithmic
	    and circular sliders, a tri-state button, a combined Slider and
	    TextField, and a read-only NXColorWell.  There are other
	    objects, functions, and useful macros in the kit as well.

	    Documentation, examples, tutorials, and complete source code are
	    distributed with the MiscKit.  The kit itself is the product of
	    over 25 Usenet personalities and is available free of cost for
	    use in any project.  The only restriction is that you
	    acknowledge use of the kit in your project.

	    Misckit 1.2.6 can be obtained from the usual NEXTSTEP ftp sites:

	    cs.orst.edu:/pub/next/sources/objects/MiscKit1.2.6.tar.gz
	    sonata.cc.purdue.edu:/pub/next/submissions/MiscKit1.2.6.tar.gz
	    ftp.et.byu.edu:/pub/next/misckit/MiscKit1.2.6.tar.gz
            ftp.informatik.uni-muenchen.de:/pub/comp/platforms/next/
				Developer/objc/misckit/MiscKit1.2.6.s.tar.gz

	Contact

	    For more information or to be placed on the MiscKit discussion
	    list, contact the kit administrator, Don Yacktman, by sending
	    e-mail to misckit-request@byu.edu.

    CCRMA

	MusicKit

	    The Music Kit provides tools for designing music
	    applications. These tools address three topics: music
	    representation, performance, and synthesis (digital sound
	    generation and processing).  The Objective-C classes defined in
	    the Music Kit fall neatly into these three areas.

	    The design goal of the Music Kit is to combine the interactive
	    gestural control of MIDI with the precise timbral control of
	    MUSIC 5-type systems in an extensible, object-oriented
	    environment. To this end, the Music Kit is capable of fully
	    representing MIDI.  The Music Kit accepts MIDI in and can send
	    MIDI out through the two serial ports at the back of the
	    computer. Nonetheless, the Music Kit isn't limited by the MIDI
	    specification; for example, its resolution of frequency and
	    amplitude is much finer than MIDI's highly quantized values.

	    The Music Kit generates sounds by sending synthesis instructions
	    to the DSP.  The generality of the synthesis software far
	    surpasses that of commercial synthesizers.  While most
	    synthesizers employ only one type of synthesis-the Yamaha DX-7
	    uses only frequency modulation, for example-the Music Kit can
	    implement virtually any sound synthesis strategy.  And since the
	    synthesis engine (the DSP) and the control stream are brought
	    together in a single high-performance computer, the Music Kit
	    makes possible an unprecedented level of expressive control.
	    (from Documentation/MusicKit+DSP/General/SoundMusicDSP.rtfd)

	    MusicKit used to be supplied by NeXT as part of NeXTSTEP (pre
	    3.0).  It is now maintained by CCRMA and available by FTP from
	    ccrma-ftp.stanford.edu.  There are two packages:

		pub/MusicKit_4.0.pkg.tar

		    Class library, header files, documentation, programming
		    examples, and a suite of applications (size = 9MB).

		pub/MusicKitSource_4.0.pkg.tar
		    Source of the MusicKit class library (size = 7MB).

	Contact

	    email: musickit@ccrma.stanford.edu


ADMINISTRATIVIA

    The information in this file comes AS IS, WITHOUT ANY WARRANTY.  You may
    use the information contained in this file or distribute this file, as
    long as you do not modify it, make money out of it or take the credits.

    All trademarks appearing in this file are owned by their respective
    owner.  To increase the information content in this file, any indication
    to that effect is not present in the FAQ other than in this paragraph.

The first version of this FAQ was written by Bill Shirly, helped by the
feedback and information given to him by a lot of people.  The current
version is maintained by Tiggr, supported by feedback from Glen Diener,
Christopher Lozinski, Sean Luke and a lot of other people.  Mail your bug
reports, comments, suggestions and additions to tiggr@es.ele.tue.nl.

A World Wide Web hypertext version of this FAQ is maintained by Brian Harvey
(theharv@csld.ucr.edu) and can be found at:
    http://csld.ucr.edu/NeXTSTEP/objc_faq.html

From: tiggr@es.ele.tue.nl (Tiggr)
Newsgroups: comp.lang.objective-c,comp.answers,news.answers
Subject: comp.lang.objective-c FAQ, part 3/3: A Sample Program
Date: 17 Nov 1994 17:00:08 GMT
Organization: Eindhoven University of Technology
Message-ID: <sample_785091602@es.ele.tue.nl>
Reply-To: tiggr@es.ele.tue.nl (Tiggr)

Archive-name: Objective-C/sample
Version: $Id: sample.preamble,v 2.4 1994/06/14 08:05:26 tiggr Exp $


		A simple sample
		Objective-C program


This is the third part in a series of three informational postings
concerning comp.lang.objective-c.  This article presents a simple program
written in Objective-C.  The program consist of several files which are
contained in a shar file (see instructions below on how to unpack).  [Note,
from version 2.3 of this file, the sample has been changed in order to
reduce the number of compiler warnings (down to 1, which is in there for
explanatory purposes) and to reflect the use of `+alloc' and `-init' instead
of `+new'.]

The early version of this FAQ was compiled by Bill Shirley, with the aid of
many people.  The current version is being maintained by Tiggr, aided by a
lot of people, including Paul Sanchez and Bill Shirley.

A World Wide Web hypertext version of this FAQ is maintained by Brian Harvey
(theharv@csld.ucr.edu) and can be found at:
    http://csld.ucr.edu/NeXTSTEP/objc_faq.html

Send your suggestions, additions, bug reports, comments and fixes to
`tiggr@es.ele.tue.nl'.


#---------------------------------- cut here ----------------------------------
# This is a shell archive.  Remove anything before this line,
# then unpack it by saving it in a file and typing "sh file".
#
# Wrapped by Pieter Schoenmakers <tiggr@viper> on Tue Jun 14 10:10:08 1994
#
# This archive contains:
#	objc-sample	
#
# Existing files will not be overwritten.
# Error checking via wc(1) will be performed.

LANG=""; export LANG
PATH=/bin:/usr/bin:$PATH; export PATH

echo mkdir - objc-sample
mkdir objc-sample

if test -f objc-sample/README
then
	echo Ok to overwrite existing file objc-sample/README\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f objc-sample/README
	if test -f objc-sample/README
	then
		echo Error: could not remove objc-sample/README, aborting
		exit 1
	fi
fi
echo x - objc-sample/README
cat >objc-sample/README <<'@EOF'
This directory contains the complete code for the "Simple Sample Objective-C
program" described in the comp.lang.objective-c FAQ.  If you have a suitable
compiler, use the supplied Makefile.  Otherwise, program output can be found
in the file "output".

You should probably read "main.m" first.  It is very heavily annotated.

Also note and read the file COPYRIGHT.
@EOF
set `wc -lwc <objc-sample/README`
if test $1$2$3 != 855366
then
	echo ERROR: wc results of objc-sample/README are $* should be 8 55 366
fi

chmod 644 objc-sample/README

if test -f objc-sample/Char.h
then
	echo Ok to overwrite existing file objc-sample/Char.h\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f objc-sample/Char.h
	if test -f objc-sample/Char.h
	then
		echo Error: could not remove objc-sample/Char.h, aborting
		exit 1
	fi
fi
echo x - objc-sample/Char.h
cat >objc-sample/Char.h <<'@EOF'
#import <objc/Object.h>

@interface Char: Object
{
  int value;
}

-init: (int) x;
-report;

@end
@EOF
set `wc -lwc <objc-sample/Char.h`
if test $1$2$3 != 111498
then
	echo ERROR: wc results of objc-sample/Char.h are $* should be 11 14 98
fi

chmod 644 objc-sample/Char.h

if test -f objc-sample/Node.h
then
	echo Ok to overwrite existing file objc-sample/Node.h\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f objc-sample/Node.h
	if test -f objc-sample/Node.h
	then
		echo Error: could not remove objc-sample/Node.h, aborting
		exit 1
	fi
fi
echo x - objc-sample/Node.h
cat >objc-sample/Node.h <<'@EOF'
#import <objc/Object.h>

@interface Node : Object
{
  id next;
  id data;
}

-init: anItem;		// create a Node and store anItem in it
-free;			// free a Node and return the item in it
-next;			// report the id of the next node after this one
-setNext: aNode;	// make the next node be aNode

@end
@EOF
set `wc -lwc <objc-sample/Node.h`
if test $1$2$3 != 1456295
then
	echo ERROR: wc results of objc-sample/Node.h are $* should be 14 56 295
fi

chmod 644 objc-sample/Node.h

if test -f objc-sample/Node.m
then
	echo Ok to overwrite existing file objc-sample/Node.m\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f objc-sample/Node.m
	if test -f objc-sample/Node.m
	then
		echo Error: could not remove objc-sample/Node.m, aborting
		exit 1
	fi
fi
echo x - objc-sample/Node.m
cat >objc-sample/Node.m <<'@EOF'
#import <objc/Object.h>
#import "Node.h"

@implementation	Node: Object

-init: anItem
{
  self = [super init];
  next = 0;
  data = anItem;
  return self;
}

-free
{
  id tmp = data;
  [super free];
  return tmp;
}

-next
{
  return next;
}

-setNext: aNode
{
  next = aNode;
  return self;
}

@end
@EOF
set `wc -lwc <objc-sample/Node.m`
if test $1$2$3 != 3249299
then
	echo ERROR: wc results of objc-sample/Node.m are $* should be 32 49 299
fi

chmod 644 objc-sample/Node.m

if test -f objc-sample/Queue.h
then
	echo Ok to overwrite existing file objc-sample/Queue.h\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f objc-sample/Queue.h
	if test -f objc-sample/Queue.h
	then
		echo Error: could not remove objc-sample/Queue.h, aborting
		exit 1
	fi
fi
echo x - objc-sample/Queue.h
cat >objc-sample/Queue.h <<'@EOF'
#import <objc/Object.h>
#import "Node.h"

@interface Queue: Object
{
  id head;
  id tail;
  unsigned qsize;
}

-empty;			// clear out all contents of the Queue
-put: anItem;		// put anItem on the Queue
-get;			// return the item on top of the Queue
-(unsigned int) size;	// tell us the current size of the Queue

@end
@EOF
set `wc -lwc <objc-sample/Queue.h`
if test $1$2$3 != 1655319
then
	echo ERROR: wc results of objc-sample/Queue.h are $* should be 16 55 319
fi

chmod 644 objc-sample/Queue.h

if test -f objc-sample/Queue.m
then
	echo Ok to overwrite existing file objc-sample/Queue.m\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f objc-sample/Queue.m
	if test -f objc-sample/Queue.m
	then
		echo Error: could not remove objc-sample/Queue.m, aborting
		exit 1
	fi
fi
echo x - objc-sample/Queue.m
cat >objc-sample/Queue.m <<'@EOF'
#import "Queue.h"

@implementation	Queue

-empty
{
  while([self size])
    [[self get] free];
  return self;
}

-put: anItem
{
  if (tail)
    tail = [[tail setNext : [[Node alloc] init: anItem]] next];
  else
    head = tail = [[Node alloc] init: anItem];
  ++qsize;
  return self;
}

-get
{
  id contents;
  id old_head = head;

  head = [head next];
  contents = [old_head free];
  if (--qsize == 0)
    tail = head;
  return contents;
}

-(unsigned) size
{
  return qsize;
}

@end
@EOF
set `wc -lwc <objc-sample/Queue.m`
if test $1$2$3 != 3975486
then
	echo ERROR: wc results of objc-sample/Queue.m are $* should be 39 75 486
fi

chmod 644 objc-sample/Queue.m

if test -f objc-sample/Stack.h
then
	echo Ok to overwrite existing file objc-sample/Stack.h\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f objc-sample/Stack.h
	if test -f objc-sample/Stack.h
	then
		echo Error: could not remove objc-sample/Stack.h, aborting
		exit 1
	fi
fi
echo x - objc-sample/Stack.h
cat >objc-sample/Stack.h <<'@EOF'
#import <objc/Object.h>
#import "Node.h"

@interface Stack: Object
{
  id stack;
  unsigned int stack_size;
}

-empty;				// clear out all contents of the Stack
-put: anItem;			// put anItem on the Stack
-get;				// return the item on top of the Stack
-(unsigned) size;		// tell us the current size of the Stack

@end
@EOF
set `wc -lwc <objc-sample/Stack.h`
if test $1$2$3 != 1553318
then
	echo ERROR: wc results of objc-sample/Stack.h are $* should be 15 53 318
fi

chmod 644 objc-sample/Stack.h

if test -f objc-sample/Stack.m
then
	echo Ok to overwrite existing file objc-sample/Stack.m\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f objc-sample/Stack.m
	if test -f objc-sample/Stack.m
	then
		echo Error: could not remove objc-sample/Stack.m, aborting
		exit 1
	fi
fi
echo x - objc-sample/Stack.m
cat >objc-sample/Stack.m <<'@EOF'
#import "Stack.h"

@implementation	Stack

-empty
{
  while([self size])
    [[self get] free];
  return self;
}

-put: anItem
{
  stack = [[[Node alloc] init: anItem] setNext : stack];
  ++stack_size;
  return self;
}

-get
{
  id contents;
  id old_stack = stack;

  stack = [stack next];
  contents = [old_stack free];
  --stack_size;
  return contents;
}

-(unsigned) size
{
  return stack_size;
}

@end
@EOF
set `wc -lwc <objc-sample/Stack.m`
if test $1$2$3 != 3557407
then
	echo ERROR: wc results of objc-sample/Stack.m are $* should be 35 57 407
fi

chmod 644 objc-sample/Stack.m

if test -f objc-sample/output
then
	echo Ok to overwrite existing file objc-sample/output\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f objc-sample/output
	if test -f objc-sample/output
	then
		echo Error: could not remove objc-sample/output, aborting
		exit 1
	fi
fi
echo x - objc-sample/output
cat >objc-sample/output <<'@EOF'
Output from demo, excluding Char class:

Include the Char class in the demo? (y/n): n
queue:   5, stack:-5.0
queue: 4.0, stack:  -4
queue:   3, stack:-3.0
queue: 2.0, stack:  -2
queue:   1, stack:-1.0
queue: 0.0, stack:   0
queue:  -1, stack: 1.0
queue:-2.0, stack:   2
queue:  -3, stack: 3.0
queue:-4.0, stack:   4
queue:  -5, stack: 5.0

Output from demo, including Char class:

Include the Char class in the demo? (y/n): y
queue:   5, stack:   h
queue:   q, stack:-4.0
queue:   3, stack:   j
queue:   o, stack:-2.0
queue:   1, stack:   l
queue:   m, stack: 0.0
queue:  -1, stack:   n
queue:   k, stack: 2.0
queue:  -3, stack:   p
queue:   i, stack: 4.0
queue:  -5, stack:   r
@EOF
set `wc -lwc <objc-sample/output`
if test $1$2$3 != 29111679
then
	echo ERROR: wc results of objc-sample/output are $* should be 29 111 679
fi

chmod 644 objc-sample/output

if test -f objc-sample/Char.m
then
	echo Ok to overwrite existing file objc-sample/Char.m\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f objc-sample/Char.m
	if test -f objc-sample/Char.m
	then
		echo Error: could not remove objc-sample/Char.m, aborting
		exit 1
	fi
fi
echo x - objc-sample/Char.m
cat >objc-sample/Char.m <<'@EOF'
#import <stdio.h>
#import "Char.h"

@implementation Char
{
  int value;
}

- init: (int) x
{
  [super init];		// In case the parent class is doing
  			// something special in its init...
  value = x;
  return self;
}

- report
{
  printf("   %c", value);
  return self;
}

@end
@EOF
set `wc -lwc <objc-sample/Char.m`
if test $1$2$3 != 2347279
then
	echo ERROR: wc results of objc-sample/Char.m are $* should be 23 47 279
fi

chmod 644 objc-sample/Char.m

if test -f objc-sample/main.m
then
	echo Ok to overwrite existing file objc-sample/main.m\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f objc-sample/main.m
	if test -f objc-sample/main.m
	then
		echo Error: could not remove objc-sample/main.m, aborting
		exit 1
	fi
fi
echo x - objc-sample/main.m
cat >objc-sample/main.m <<'@EOF'
/* main.m - comp.lang.objective-c simple sample Objective-C program.  */

// This is a comment, just like the previous line.  Everything to the right
// of a double slash is ignored.

/* Classes are the one real extension which Objective-C adds to C.  A class
   is a description of a collection of data, like a C structure, and the
   methods by which that data may be accessed or manipulated.  Instances of
   a class are called objects, and methods are invoked by sending messages
   to either the class itself, to produce objects, or to those objects.  The
   recipient of a message is called a "receiver".  The form of a message is:

	[receiver method andMaybeSomeArguments]

   the receiver and method components are mandatory, as are the square
   brackets surrounding the message.  Additional arguments may or may not be
   present, depending upon the method definition.  Messages may appear
   anywhere a statement is allowed in C.

   The first thing we do is bring in some include files, as in C.  On the
   NeXT, it is customary to use the "import" statement which guarantees that
   the file isn't included more than once.  Using GNU CC this is not all
   that nice sinds it generates a huge warning for every file being
   compiled.  So, since it does not really matter, we'll stick to
   `#include'.  */

#import <stdio.h>
#import <objc/Object.h>
#import "Queue.h"
#import "Stack.h"

/* That brought in class definitions for Objects, Queues, and Stacks.  The
   Object class is the basis for all other classes, which is why it gets
   brought in first.  It provides basic functional behavior which is
   inherited by all derived classes.  All user created classes normally have
   Object somewhere in their ancestry.

   Queue and Stack are classes of our own construction, and provide FIFO and
   LIFO storage capabilities, respectively.  I'm not going to go into
   implementation details here.  It's irrelevant how they work, all that is
   important is that they both respond to 'put:' and 'get'.  If you want to
   inspect them, look into the Queue.m, Stack.m, Queue.h and Stack.h files.

   A simple Class definition follows.  It inherits directly from the base
   class "Object".  This gives it lots of nice properties, not the least of
   which is the ability to be referenced by any pointer of the generic
   object type "id".  All objects can be pointed to by any id variable, and
   the default return type from methods is id.  This allows messages to be
   embedded in other messages, either as receivers or arguments.

   An Int object allocates space for a single integer.  The "report" message
   causes it to report its value.  Everything between the @implementation
   and the @end is part of the class definition.

   Note - It is *highly* unusual to have a class implementation in your main
   program.  Since the object is fully defined before it gets used, no
   interface description is required.  There is nothing illegal about doing
   things this way, but it is so unusual that the compiler will produce a
   warning for this class.  The Int class implementation is here solely for
   expository purposes.  */

@implementation Int: Object	// Int is derived from Object
{
    int value;		// This is the data portion.  Like a struct.
}

/* The following are the method definitions.  A `+' prefix means it is a
   factory method, i.e., how to manufacture instances of the class.  The
   body of the method is between braces, like a C function.

   This class doesn't define any factory methods.  It relies on the +alloc
   method defined in class Object.  For examples of factory methods, look at
   the +new method defined in the Stack or Queue implementations.

   Self is a special variable, which refers to the object currently being
   manipulated.  Super refers to the parent class of self.  The following
   method asks the parent class (Object) to hand us a new instance, which
   becomes self.  Then we update the instance variables and return a pointer
   to the new object.

   It is standard for methods that do not need to return any special value
   to instead return self.  This allows for a nested syntax of method calls.

   The "-" in front of init means that it's an instance method, i.e.,
   something a particular object should respond to.  */

-init: (int) i
{
  /* We're overriding the `-init' of our superclass, but we add
     functionality instead of replacing it.  Therefore, first call the
     `-init' of our superclass.  */
  [super init];
  value = i;
  return self;
}

-report
{
  printf ("%4d", value);
  return self;
}

@end

/* We have implemented Float and Char classes more traditionally, using
   separate files for the interface (.h) and implementation (.m).  The Float
   and Char objects are like the Int object, but with the obvious difference
   that they work with floats and characters.  We include the interface
   definitions at this point.  */

#import "Float.h"
#import "Char.h"

/* If you inspect those files, note polymorphism -- methods have same
   names as in the Int class.  */

int main (void)
{
    /* First create instances of "Stack" and "Queue" data structures.  */
    id queue = [[Queue alloc] init];
    id stack = [[Stack alloc] init];
    int i, reply;
    
    fprintf (stderr, "Include the Char class in the demo? (y/n): ");

    /* Anything not matching `y.*' means no.  */
    reply = getchar ();

    for (i = 5; i > -6; --i)
      {
	/* Depending on which version of the demo we're running, we
	   alternately put Ints and Floats onto the queue and stack, or
	   Ints, Floats, and Chars.  */
	if (reply == 'y')
	  {
	    /* If I is odd we put an Int on the queue and a Char on the
	       stack.  If I is even we put an Char on the queue and a Float
	       on the stack.

	       Since there is more than one method `-init:' and since
	       `+alloc' returns a plain, typeless, `id', the compiler
	       doesn't know the type of the object returned by alloc.  An
	       explicit cast (i.e. static type indication) ensures that the
	       compiler knows which `init:' is invoked---the one accepting a
	       char or the other one accepting an int.

	       Another solution, which avoids the static type indication, is
	       to put typing information on the method in the method's name.
	       This is done for the Float class.  */
	    id my_char = [(Char *) [Char alloc] init: 'm' + i];

	    if (i & 1)
	      {
		[queue put: [(Int *) [Int alloc] init: i]];
		[stack put: my_char];
	      }
	    else
	      {
		[queue put: my_char];
		[stack put: [[Float alloc] initFloatValue: i]];
	      }
          }
	else
	  {
	    /* If I is odd we put an Int on the queue and a Float on the
	       stack.  If I is even we put a Float on the queue and an Int
	       on the stack.  */
            [queue put: ((i & 1)
			 ? [(Int *) [Int alloc] init: i]
			 : [[Float alloc] initFloatValue: i])];
            [stack put: ((i & 1)
			 ? [[Float alloc] initFloatValue: i]
			 : [(Int*) [Int alloc] init: i])];
	}
    }

    while ([queue size] && [stack size])
      {
	/* The following illustrates run-time binding.  Will report be
	   invoked for a Float object or an Int object?  Did the user elect
	   for Char objects at run time?  We don't know ahead of time, but
	   with run-time binding and polymorphism it works properly.  The
	   burden is on the class implementer rather than the class user.

	   Note that the following lines remain unchanged, whether we are
	   using the Char class or not.  The queue and stack hand us the
	   next object, it reports itself regardless of its type, and then
	   it frees itself.  */

	printf ("queue:");
	[[[queue get] report] free];
	printf (", stack:");
	[[[stack get] report] free];
	putchar('\n');
      }
  return 0;
}
@EOF
set `wc -lwc <objc-sample/main.m`
if test $1$2$3 != 19712617780
then
	echo ERROR: wc results of objc-sample/main.m are $* should be 197 1261 7780
fi

chmod 644 objc-sample/main.m

if test -f objc-sample/Makefile
then
	echo Ok to overwrite existing file objc-sample/Makefile\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f objc-sample/Makefile
	if test -f objc-sample/Makefile
	then
		echo Error: could not remove objc-sample/Makefile, aborting
		exit 1
	fi
fi
echo x - objc-sample/Makefile
cat >objc-sample/Makefile <<'@EOF'
# This Makefile assumes you have GNU gcc 2.3 or better and a suitable
# runtime library with object support.  It also works on a NeXT.
# Don't know about Stepstone.

.SUFFIXES: .o .m
.m.o:
	$(CC) -c $(CFLAGS) $<

# Use this on a NeXT
#CC=		cc
#LIBS=		
# Use this with GNU CC on a non-NeXT,
# and avoid the GCC moaning on using #import.
CC=		gcc -Wno-import
LIBS=		-lobjc
LDFLAGS=	-L/usr/local/lib -L/usr/gnu/lib

CFLAGS=		-Wall -g
OFILES=		main.o Node.o Queue.o Stack.o Float.o Char.o

demo: $(OFILES)
	$(CC) $(CFLAGS) $(LDFLAGS) -o demo $(OFILES) $(LIBS)

clean:
	rm -f $(OFILES) demo
	
Char.o : Char.m Char.h 

Float.o : Float.m Float.h 

Node.o : Node.m Node.h 

Queue.o : Queue.m Queue.h Node.h 

Stack.o : Stack.m Stack.h Node.h 

main.o : main.m Queue.h Node.h Stack.h Float.h
@EOF
set `wc -lwc <objc-sample/Makefile`
if test $1$2$3 != 37127783
then
	echo ERROR: wc results of objc-sample/Makefile are $* should be 37 127 783
fi

chmod 644 objc-sample/Makefile

if test -f objc-sample/Float.m
then
	echo Ok to overwrite existing file objc-sample/Float.m\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f objc-sample/Float.m
	if test -f objc-sample/Float.m
	then
		echo Error: could not remove objc-sample/Float.m, aborting
		exit 1
	fi
fi
echo x - objc-sample/Float.m
cat >objc-sample/Float.m <<'@EOF'
#import <stdio.h>
#import "Float.h"

@implementation Float
{
  float value;
}

-initFloatValue: (float) x
{
  [super init];
  value = x;
  return self;
}

-report
{
  printf ("%4.1f", value);
  return self;
}

@end
@EOF
set `wc -lwc <objc-sample/Float.m`
if test $1$2$3 != 2231215
then
	echo ERROR: wc results of objc-sample/Float.m are $* should be 22 31 215
fi

chmod 644 objc-sample/Float.m

if test -f objc-sample/COPYRIGHT
then
	echo Ok to overwrite existing file objc-sample/COPYRIGHT\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f objc-sample/COPYRIGHT
	if test -f objc-sample/COPYRIGHT
	then
		echo Error: could not remove objc-sample/COPYRIGHT, aborting
		exit 1
	fi
fi
echo x - objc-sample/COPYRIGHT
cat >objc-sample/COPYRIGHT <<'@EOF'
This copyright notice applies to all source files distributed in the
comp.lang.objective-c FAQ: `A Simple Sample Objective-C program'.

Copyright (C) 1993 Paul J. Sanchez and Bill Shirley
Copyright (C) 1994 Pieter J. Schoenmakers

The `simple sample Objective-C program' is free software; you can
redistribute it and/or modify it under the terms of the GNU General Public
License as published by the Free Software Foundation; either version 2, or
(at your option) any later version.

The `simple sample Objective-C program' is distributed in the hope that it
will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty
of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General
Public License for more details.

You should have received a copy of the GNU General Public License
along with GNU Emacs; see the file COPYING.  If not, write to
the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
@EOF
set `wc -lwc <objc-sample/COPYRIGHT`
if test $1$2$3 != 19150944
then
	echo ERROR: wc results of objc-sample/COPYRIGHT are $* should be 19 150 944
fi

chmod 644 objc-sample/COPYRIGHT

if test -f objc-sample/Float.h
then
	echo Ok to overwrite existing file objc-sample/Float.h\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f objc-sample/Float.h
	if test -f objc-sample/Float.h
	then
		echo Error: could not remove objc-sample/Float.h, aborting
		exit 1
	fi
fi
echo x - objc-sample/Float.h
cat >objc-sample/Float.h <<'@EOF'
#import <objc/Object.h>

@interface Float: Object
{
  float value;
}

-initFloatValue: (float) x;
-report;

@end
@EOF
set `wc -lwc <objc-sample/Float.h`
if test $1$2$3 != 1114113
then
	echo ERROR: wc results of objc-sample/Float.h are $* should be 11 14 113
fi

chmod 644 objc-sample/Float.h

chmod 755 objc-sample

exit 0


