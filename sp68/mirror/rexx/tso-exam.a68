Newsgroups: comp.lang.rexx
Message-ID: <REXXLIST%94101412230874@UGA.CC.UGA.EDU>
Date: Fri, 14 Oct 1994 09:04:00 PDT
From: John Andrisan <A004773%LBVM1.profs@LBGWY.MDC.COM>
Subject: Forwarded by SMTP Network Mailer

  Here's a TSO Rexx exec that looks thru MVS control blocks for cpu ids,
  etc. Enjoy... /john

     Rexx makes looking through MVS control blocks a lot easier than
  using Assembler or PL/I.  Below is an example that I wrote to show
  the cpu serial number and model number for systems programmers who
  have to deal with program product time-bombs that use these numbers
  as part of their encoding process.  I added some other output that
  seemed interesting to me at the time.

     When using addresses in Rexx, keep in mind that if the system
  you are using is an XA or ESA system, you should zero out the high
  order bit before using the address to fetch the data.  When you are
  on other 360 or 370 systems, you have to zero out the high order byte.
  The code shown below has only been tried out on a system running
  MVS/ESA x.x.x.

     When comparing addresses in Rexx, as in the statement,

      if PCCA=='00000000'x then iterate i      /* avoid empty entry */

  you must use the == (identical) form of compare, otherwise you may
  encounter a false equal condition because Rexx may interpret the
  data as floating point numbers.

     Here is output from a batch run of the exec:

       exec cpuid exec

       SMF id: L1LU

       nr cpus currently alive: 4
       4 available for jobs
       4 available for srbs
       1 currently alive

       cpu number: 00  cpuid: 4  cpu serial: 05052  cpu type: 5990
       PSA vaddr: 8000F340  PSA raddr: 00094E70
       status: jobs srbs not-alive

       cpu number: 01  cpuid: 5  cpu serial: 05052  cpu type: 5990
       PSA vaddr: 8000EED0  PSA raddr: 00017890
       status: jobs srbs not-alive

       cpu number: 02  cpuid: 6  cpu serial: 05052  cpu type: 5990
       PSA vaddr: 8000EE60  PSA raddr: 000163A0
       status: jobs srbs not-alive

       cpu number: 03  cpuid: 7  cpu serial: 05052  cpu type: 5990
       PSA vaddr: 4800EE40  PSA raddr: 00012810
       status: jobs srbs not-alive

     I suspect that the "alive" and "not-alive" results shown above
  probably reflect the fact that my job was seeing the counts and
  status bits while they were being changed as my job ran or waited
  to run, depending on the MVS scheduling process.

     Here is the CPUID exec:

  /* a TSO REXX exec to get information about the cpus from        */
  /* MVS control blocks: CVT, SMCA, CSD, PCCAVT, and PCCA          */
  /* then show the cpu number, id, serial number, type, SMF        */
  /* id letter, and anything else that looks interesting           */
  /* 06/11/92 - John Andrisan                                      */
  /*                                                               */
  /* The control block chain that I want to follow:                */
  /*   location 10x --> CVT                                        */
  /*                    CVT+C4x  --> SMCA                          */
  /*                                 SMCA+16  contains the SMF id  */
  /*                    CVT+294x --> CSD                           */
  /*                                 CSD+4, +8 and +10 contain     */
  /*                                 some interesting cpu counts   */
  /*                    CVT+2FCx --> PCCAVT                        */
  /*                                 PCCAVT+0  --> PCCA for cpu 0  */
  /*                                 PCCAVT+4  --> PCCA for cpu 1  */
  /*                                 etc.                          */
  /*                                 PCCAVT+60 --> PCCA for cpu 15 */
  /*                                 PCCA+4  contains the cpu id,  */
  /*                                         serial nr, and type   */
  /*                                 PCCA+24 --> virtual PSA       */
  /*                                 PCCA+28 --> real PSA          */
  /*                                                               */
  arg what .
  if what='?' then do                  /* offer the user some help */
     say 'use: cpuid'
     say 'No parms are required.'
     say 'You will be shown the SMF id letter defining this system,'
     say 'the cpu id, serial number, and cpu type of each cpu,'
     say 'and some other information that may be useful.'
     say 'This exec only works on TSO.'
     exit 4
     end
  if address()_='TSO' then do
     say 'this exec only works in MVS/TSO'
     exit 4
     end

  call init                              /* set up some constants */

  CVT=storage('10',4)                       /* start with the CVT */
  CVT=bitand(CVT,'7FFFFFFF'x)                    /* zero high bit */

  SMCA=storage(d2x(c2d(CVT)+x2d('C4')),4)        /* get to SMCA   */
  SMCA=bitand(SMCA,'7FFFFFFF'x)                  /* zero high bit */
  SMCASID=storage(d2x(c2d(SMCA)+16),4)
  say 'SMF id:' SMCASID
  say ' '

  CSD=storage(d2x(c2d(CVT)+x2d('294')),4)        /* get to CSD    */
  CSD=bitand(CSD,'7FFFFFFF'x)                    /* zero high bit */
                /* the counts shown next may change while you run */
  nr_cpus=c2d(storage(d2x(c2d(CSD)+10),2))    /* get nr cur alive */
  say 'nr cpus currently alive:' nr_cpus      /* whatever that is */
  job_avail_cpus=x2b(c2x(storage(d2x(c2d(CSD)+4),2)))
  say count_bits(job_avail_cpus) 'available for jobs'
  srb_avail_cpus=x2b(c2x(storage(d2x(c2d(CSD)+8),2)))
  say count_bits(srb_avail_cpus) 'available for srbs'
  cur_alive_cpus=x2b(c2x(storage(d2x(c2d(CSD)+10),2)))
  say count_bits(cur_alive_cpus) 'currently alive'
  say ' '

  PCCAAVT=storage(d2x(c2d(CVT)+x2d('2FC')),4)    /* get to PCCAVT */
  PCCAAVT=bitand(PCCAAVT,'7FFFFFFF'x)            /* zero high bit */

  do i=0 to 60 by 4
    PCCA=storage(d2x(c2d(PCCAAVT)+i),4)       /* get to ith PCCA  */
    PCCA=bitand(PCCA,'7FFFFFFF'x)                /* zero high bit */
    if PCCA=='00000000'x then iterate i      /* avoid empty entry */
    info=storage(c2x(PCCA),32)
    say 'cpu number:' right(i%4,2,'0') ' cpuid:' substr(info,7,1),
        ' cpu serial:' substr(info,8,5) ' cpu type:' substr(info,13,4)
    say 'PSA vaddr:' c2x(substr(info,24,4)),
       ' PSA raddr:' c2x(substr(info,28,4))
                /* the status shown next may change while you run */
    if substr(job_avail_cpus,i%4+1,1)='1' then jobs='jobs'
    else jobs='no-jobs'
    if substr(srb_avail_cpus,i%4+1,1)='1' then srbs='srbs'
    else srbs='no-srbs'
    if substr(cur_alive_cpus,i%4+1,1)='1' then alive='alive'
    else alive='not-alive'
    say 'status:' jobs srbs alive
    say ' '
    end

  exit 0

  /* subroutines: */
  count_bits:
  arg bit_string .
  bit_sum=0
  do bit=1 to length(bit_string)
     if substr(bit_string,bit,1)='1' then bit_sum=bit_sum+1
     end
  return(bit_sum)

  /* X2B is a function for hex to binary string conversion */
  X2B:
  arg arg .
  bitout=''
  do i=1 to length(arg)
     t=substr(arg,i,1)
     bitout=bitout||hex.t
     end
  return bitout

  init:
  /* constants needed in X2B */
  hex.0='0000'
  hex.1='0001'
  hex.2='0010'
  hex.3='0011'
  hex.4='0100'
  hex.5='0101'
  hex.6='0110'
  hex.7='0111'
  hex.8='1000'
  hex.9='1001'
  hex.A='1010'
  hex.B='1011'
  hex.C='1100'
  hex.D='1101'
  hex.E='1110'
  hex.F='1111'
  return
 --- end ---

