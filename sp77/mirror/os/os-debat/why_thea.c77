From: hanrahan@best.com
Newsgroups: comp.os.os2.advocacy
Subject: A note on concurrency
Date: 6 Jun 1995 17:59:17 GMT
Organization: BEST Internet (415) 964-2378
Reply-To: hanrahan@best.com
X-Newsreader: IBM NewsReader/2 v1.09

It seams to me that a large part of the Windows 95 debate centers around how
well (or how poorly Windows 95) multitasks. Let us assume that the user is
limited to Win32 apps so as to allow Windows 95 to exibit its fully prementive
behavior.

Concurrency is the the OS's ability to simulate simultaneus execution of 2 or
more programs. Acutual simultaneus execution is not possible on a uni-processor
(read single pipeline) system because all instuctions must be processed serially.

The illusion of cuncurrency is dependant on the length of time between
context switches. For example: an arbitratry context latency is what you have
in DOS (one program must complete before another can be started), OS's such
as OS/2, Windows NT, UNIX, ... have a maximium fixed latency (That is, all
processes are garanteed to service in a fixed time.). To garantee the maximum
lantency limit, the OS has is to prempt any thead that exceeds it.

The price one pays for concurrency is the cycles surrendered to the OS to
perform the context switch. Cycles that could have been used to do useful work.
The trade-off is where do you strike the balance. For example: You could make
the context lantency larger and there by freeing the CPU to do more work but
if you make it too large the illusion of concurrency evaporates. Conversely, you
could make the context lantency smaller to improve concurency, but you
don't allow enough free cycles for the CPU to get much work done.

The reason Windows 95 appears to do well in benchmarks is its context lancy
is large there by allowing the CPU to spend more time on the benchmark and less
time context switching. Run an equivlent benchmark under DOS and it will do even
better because all CPU time is allocated to the benchmark. Games are written to
run under DOS for this reason. The point to remember is that: Scaler
(single threaded) programs perform better under OS's with larger context
latencies. The exception to this rule is that: If a program is not doing anything
useful, CPU cycles are wasted until a context switch occurs.

That is why mutithreaded programs are useful. The programer can use the OS's
ability to minimize the wasted CPU cycles (through context switching) and get
more work done than had the program only be single threaded.

You can simulate the wasted cycles (found in many 'real world' applications)
 in a benchmark by inserting a sleep function. If this is done and mutiple copies
of the the benchmark are run the OS with a shorter context latency will perform
better because fewer cycles will be wasted on servicing the sleep function.

Not withstanding all that has been written the only true measure of OS
performance is to run real applications and determine if by the end of the day
more work has been done.

I hope this helps.

Regards
Terence Hanrahan
Software Applications Inc.
San Francisco CA



