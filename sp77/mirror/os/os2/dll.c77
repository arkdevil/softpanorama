From: sangria@inlink.com (Sangria)
Newsgroups: comp.os.linux.advocacy,comp.sys.mac.advocacy,comp.os.os2.advocacy,comp.sys.amiga.advocacy
Subject: Re: MS Bloatware (was Re: Let's do something about Microsoft)
Date: 27 Jun 1995 23:25:15 GMT
Organization: Sangria

In article <3sp4dv$sn7@library.erc.clarkson.edu>, Mark Komarinski, komarimf@craft.camp.clarkson.edu
says...

>I may be wrong, but my understanding was that DLL files were a variation
>on the dynamic links found in Linux and other OSs (Dynamic Link Library?)

Nope, you're quite correct.

>Don't VB applications need a VBRUN???.DLL

Yes.
VB 3 apps need VBRUN300.DLL, VBRUN200.DLL and VBRUN100.DLL are
for the VB 2 and 1.

>What's to prevent MS (or Borland or etc) from creating a DLL that has common
>C functions and using that?  It's not like it'll slow down Windows much.

Nothing.
Infact, that's the correct way to do it.
Write .DLLs using C, make as fast as possible and compile it
into a .DLL and use it from VB or Access or whatever.  Makes
slow-poke applications (like the ones written in VB or Access)
a bit faster.

-- Sang.
*************************************************************
* Sang K. Choe   sangria@inlink.com                         *
*                http://www.inlink.com/~sangria/index.html  *
*************************************************************


From: sangria@inlink.com (Sangria)
Newsgroups: comp.os.linux.advocacy,comp.sys.mac.advocacy,comp.os.os2.advocacy,comp.sys.amiga.advocacy
Subject: Re: MS Bloatware (was Re: Let's do something about Microsoft)
Date: 28 Jun 1995 18:33:59 GMT
Organization: Sangria
Mime-Version: 1.0
Content-Type: Text/Plain; charset=ISO-8859-1

In article <GERHARD.GRUBER.95Jun27072116@atusel16.aut.alcatel.at>,
Gerhard.Gruber@aut.alcatel.at says...

>Thats the theory behind it. Unfortunately the concept about the DLLs
>is not a good one. First, you can't specify where the DLLs are
>located,

Yes you can.

> second you never know (and have no reliable way) to tell wich
>DLLs are required for a particular program,

Yes you can.

> third (though this is a
>minor problem) every program comes along with his own DLLs( reminds me
>of the days when every program had hundreds of KB drivers).

No.  That's the case because each program has a different set of
functionality--you don't expect a word processor to behave the
same as a DTP package do you?  Natrually, each requires unique
functionality.  However, the common functionality are encapsulated
in common .DLLs--these are the ones that each program checks to see
if it's already installed or not before attempting to copy it's
version over.

>Problem one and two are closely related. You can either have the DLLs
>all in one directory. Problem with this, You don't know which programs
>need which DLLs and if you copy or remove some programs from the HD
>you can never be sure which DLLs you have to move or delete as well.

Not True.
You can keep application specific .DLLs in the same directory as the
application.  However, with common .DLLs, becasue they must be used
by other applications as well, it has to be somewhere it is globally
visible--that's why it's often dropped in the /WINDOWS/SYSTEM/ directory.

>If you keep the DLLs within the directory of the program (to be sure
>you got all DLLs for this particular program) then the benefit of
>shared code and less HD space usage is gone.

Again, you assume that these are the only two choices you have.
That's not the case.  Obivously for common .DLLs you do not want
to keep in the application's directory.  And even when you do
remove the application, you don't want to remove the common .DLLs
since other programs may require them--so putting them in a
global directory is actually a good thing.

BTW, check out the setting for Start Up Directory in the properties
box under NT.

>In OS/2 (maybe NT as well) this is solved SLIGHTLY better. You can
>specify a path where to search the DLLs. Problem with this (and this
>is what I meant with the minor changes and then reboot), you have to
>set an environment variable and to make it known throughout the system
>you have to reboot.

If you mean NT, you're very much mistaken.
First off, you do not reboot after changing the path.
Second there are two PATH variables available--one that is global.
And one that is local to the user only.  In neither case, does it
require a reboot.

> If you want this DLL path added only for one
>program you can't specify it, unless you start up a commandshell and
>change the path before starting the actual program.

Again, you're assuming two things.
One that for some strange reason, a commonly used functionality
would be kept in a application specific .DLL (which is never the
case) and two, that you could not do this under NT.  In both cases,
your assumptions are poor ones.

>I understand the benefits perfectly well, since there are other
>computers which have also a shared library concept. I must admit that
>SOME principles behind the DLLs are superior to shared libraries I
>knew of, but the concept how to use them on the PC is crippled, though
>the basic idea behind it, was quite good.

In what way is it crippled?
Basically, the programming methods would be as follows:

I create a program that requires calls into common .DLLs and
my program specific .DLLs--I try to minimize the latter and
rely more on the former.  During installation, I move the
common .DLLs to the system directory--if there already exist
a copy, I check which has the most recent version date, replace
the older one with the newer one.  I keep my program specific
.DLL in my own directory.

Which part of this is crippled?
Since the .DLL in my program's directory is specific only to
my program, I don't want it visible to any other program except
mine.  As for the common .DLLs, the newer version of the .DLL
is always perferred.

In both cases, my .EXE remains small, the functionality required
is loaded only when the need is there and since each section can
be paged out, the overall RAM footprint of my program remains
small.  Crippled?  Hardly.

>>Why would you need to reboot your machine to change a .DLL?
>>Just replace the old one with the new one and restart your
>>program.
>
>I didn't mean the DLL with this sentence. See above.

Under NT, you still don't need to reboot after changing a system
variable--I do this quite often since right now I have several
utilities that I want accessible from the CLI.  However since
these utilities have different functions, I perfer to keep
them in different directories--so each time I get a new utility,
I change my local (or global, don't really matter) PATH variable.

>If there are any misspellings in my postings, (and I'm sure there
>are :) ), feel free to email me. Since I'm not a native English
>speaker I'd appreciate someone pointing out my mistakes.

Heck, I spell worse than you do.  And I live in this country...

:-)

-- Sang.
**************************************************************
* Sang K. Choe  -  sangria@inlink.com                        *
*               -  http://www.inlink.com/~sangria/index.html *
**************************************************************


From: sangria@inlink.com (Sangria)
Newsgroups: comp.os.linux.advocacy,comp.sys.mac.advocacy,comp.os.os2.advocacy,comp.sys.amiga.advocacy
Subject: Re: MS Bloatware (was Re: Let's do something about Microsoft)
Date: 28 Jun 1995 18:41:22 GMT

In article <GERHARD.GRUBER.95Jun27072506@atusel16.aut.alcatel.at>,
Gerhard.Gruber@aut.alcatel.at says...

>Thats another annying point with the concept of the DLLs. The basic
>idea (to reduce programm size and HD space usage) is void if every
>program has to come along with his own set of DLLs, because nobody
>know what the thousands of other DLLs are doing.

That's the whole point of programming to a particular API
set.  You can always rewrite all the functionality of the
various API calls by yourself--but why would you?

The whole point of .DLLs is to encapsulate functionality that
is specific to just your program.  Obviously, there are situations
where two programs may actuall have the same functionality
but link to different libraries--but this is the case with
any OS/application development.

By providing the commonly used functions within common .DLLs,
it would greatly minimize the programming time and increase
code reuse.

>But I can't see
>a better solution until the DLLs are documented.

The common .DLLs are documented.
And unless you're a programmer (not to mention one that signs
NDAs), you shouldn't be looking at application specific .DLLs.

.DLLs offer _a_ solution to this, not THE solution.  It is far
from being a crippled method.

-- Sang.
**************************************************************
* Sang K. Choe  -  sangria@inlink.com                        *
*               -  http://www.inlink.com/~sangria/index.html *
**************************************************************


