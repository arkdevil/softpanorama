    DВMS                                    June 1991

Dan Ehrmann - президент компании Kallista Inc.

              Библиотеки процедур

Процедуры позволяют создавать программный код, который,
имея модульную структуру, одновременно более быстр и
управляем. Paradox лучше всего работает именно тогда,
когда его приложения полностью расписаны по процедурам.
Однако для большой по размеру программы такая полная
"процедурализация" создает определенные проблемы, а
именно: если все процедуры должны быть определены в
памяти к тому моменту, когда будет запущена собственно
программа, то результатом будет не только замедленное
исполнение этой программы, но ей может просто не хватить
места в памяти! Это отностися и к защищенному режиму
Paradox 3.5.
К счастью, в Paradox эти проблемы легко разрешимы -
процедуры можно записать в библиотеки. Из чего очевидно,
что их придется каждый раз создавать заново. В тот
момент, когда по ходу исполнения программы какая-либо
процедура необходима, можно либо "вручную" считать ее в
память, либо Paradox сделает это сам, загружая и
освобождая процедуры из памяти, когда это требуется.
Такая автоматическая перекачка называется Virtual Memory
Management (управление виртуальной памятью). Этот процесс
инициализируется только тогда, когда используемые
процедуры хранятся в библиотеках. В пакет Paradox входит
один из лучших менеджеров виртуальной памяти. Он дает
возможность запускать прикладные программы, размер
которых значительно больше размера оперативной памяти;
при этом программисту не приходится беспокоится о том,
что происходит "за кулисами" работающей программы.

              Создание библиотеки процедур

Для примера, создадим библитеку с именем CUSTOMER:

При этом Paradox создает "пустую" библиотеку, в которую
можно включить до 50 процедур. Специальный параметр
позволит увеоичить это число до 300.
Как только процедура определена в памяти, можно записать
ее в библиотеку:

где  - это список имен процедур, разделенных запятыми. Те
же самые команды можно включить в текст программы для
создания библиотеки.
Всякий раз, набирая , вы производите регенерацию
библитеки . На листинге показано, как это происходит
(вместо самих процедур указаны только их имена).



Каждая процедура описана с помощью команд  . Вы
записываете процедуру в библитеку  , а затем освобождаете
ее из памяти. При этом на экране появится точка,
говорящая о том, что процедура "жива". Таким образом,
каждая точка, появляющаяся на экране, соответствует
процедуре - определенной в памяти, записанной в библитеку
и, наконец, освобожденной из памяти.
Если записываемая в библитеку процедура с таким именем
уже существует, то оригинал помечается как ****, а новая
версия дописывается в конец библитеки. С течением времени
библиотека будет увеличиваться в размерах, даже если она
периодически пересоздается из *****.
В моей практике был такой случай. Финансовому отделу
некой корпорации срочно потребовалась консультация:
прикладная программа, автором которой был человек, давно
покинувший фирму, за последние 2-3 года заметно замедлила
свою работу. При ближайшем рассмотрении оказалось, что на
диске содержится библиотека процедур Paradox размером 15
Мб! Выяснилось, что всякий раз, когда пользователь
запускал программу, она создавала несколько процедур,
записывала их в библиотеку, а затем исполняла их. При
этом ни разу сама библитека не пересоздавалась заново, и
Paradox каждый раз просматривал 15 Мб **** пространства
для того, чтобы в самом конце найти последние версии
процедур. Пришлось вставить в начало текста программы
команду пересоздания библитеки ****, и библитека
сократилась до 40 Кб, при этом скорость выросла на
порядок.

           Просмотр содержимого библитеки

В меню Paradox не включена команда просмотра содержимого
библиотеки процедур. Для этого используется команда на
языке PAL:
InfoLib "CUSTOMER". Тем самым будет сгенерирована таблица
Paradox с именем LIST, в которой содержатся имена
процедур указанной библитеки и их размер. Процедуры
Paradox занимают в два раза больше места, чем текст их
программ. Это не так эффективно, как в других языках, но
в последних версиях Paradox сделаны улучшения в
направлениии скорости работы и размера кода.
Для того, чтобы память использовалась наилучшим образом,
размер процедур не должен превышать 6-8 Кб. Это
соответствует 150-200 строкам PAL-программы.

          Загрузка процедур в память

Имеется два способа для считывания процедур из библитеки
в оперативную память для исполнения. Команда PAL:

считывает указанные в списке ProcLib процедуры из
библитеки CUSTOMER в оперативную память.
Считывание процедур само по себе не означает их
исполнения. Происходит только перемещение ******,
описывающих данную процедуру, из библитеки в
соответствующее место оперативной памяти. Paradox
регистрирует имя процедуры и ее адрес, делая ее доступной
для исполнения в момент вызова основной программой.
Команда **** в значительной степени утратила свою
популярность с тех пор, как программисты смогли передать
свои заботы менеджеру виртуальной памяти. Имеет смысл
позволить Paradox самостоятельно считывать процедуры в
память по мере необходимости. Именно поэтому опытные
программисты для Paradox используют AutoLib.
AutoLib - это системная переменная Paradox, аналогичная
системной переменной Path среды DOS. Она позволяет задать
список задействованных библиотек (через запятую). В тот
момент, когда основная программа вызывает процедуру, для
ее поиска по порядку просматриваются библитеки из AutoLib
- слева направо.
После завершения исполнения процедуры не требуется
освобождать ее из памяти в явном виде - Paradox сделает
это автоматически, если не будет хватать места в памяти.
Тем не менее, имеется прямая команда для освобождения
процедур из памяти:

где  - список процедур, находящихся в оперативной памяти
(через запятую). Эта команда унаследована из ранних
версий, в которых отсутствовал менеджер виртуальной
памяти.
Для автоматического освобождения процедур из памяти
Paradox использует алгоритм LRU ("least recently used").
Первой освобождается та процедура, которая использовалась
ранее всех остальных. При этом те сервисные процедуры,
которые используются часто, остаются в памяти, а те,
которые запускаются единожды, быстро высвобождаются из
памяти.

         Установка точки начала перекачки

В обычной ситуации Paradox начинает перекачку процедур
только в тот момент, когда размер доступной памяти
окажется равным 0. Это слишком поздно, так как процедура
требует некоторого пространства памяти и для своего
исполнения. Например, при редактировании одной таблицы
требуется переключение на многотабличную форму с 4-5 ****
и 2-3 ***** таблицами. На это запросто может
потребоваться дополнительно 15-20 Кб. Очевидно, что для
таких случаев следует задать лимит памяти. Когда размер
незанятой памяти достигнет этого предела, Paradox начнет
перекачку процедур.
Это предел устанавливается командой SetSwap. По умолчанию
SetSwap = 0. Значения SetSwap ниже 4000 - по сути тот же
0. Обычно присваиваются значения от 35 до 45 тысяч. Если
же прикладная программа использует сложные запросы или
большие многотабличные формы, то уровень SetSwap может
быть установлен и значительно выше. При этом следует
учитывать, что программа работает тем медленнее, чем
больше объем производимых Paradox перекачек. Если
требуется большой объем памяти только для какой-либо
части прикладной программы, то можно установить высокий
уровень SetSwap непосредственно для нее, а затем вернуть
его к обычному значению.

             Написание программы-драйвера

Представим себе, что некоторая прикладная задача состоит
из набора библиотечных процедур. Регенерация библиотеки
не приведет к запуску самой задачи. Для того, чтобы
началось ее исполнение, требуется еще одна команда.
Программа-драйвер загружает требуемые процедуры из
библитеки и запускает первую из них. По аналогии с
другими языками эту программу можно было бы назвать
MAIN.SC.



Приведенная выше программа очищает экран и выдает
пользователю сообщения о том, что происходит, затем ****
все лишние переменные из памяти и производит перезагрузку
системы ???? Эта ***** кроме того вычищает все ****** из
рабочей области и снимает все существующие "замки" на
таблицах. Следующая команда осуществляет переход в
каталог, в котором содержится сама программа-драйвер.
Иногда заранее неизвестно, где именно будет храниться
прикладная программа. В таком случае это будет любой
подходящий подкаталог.
Разработчики часто используют пакетный файл или
программу-меню из DOS для загрузки и запуска прикладной
задачи Paradox. Если Paradox находится в каталоге DOS, то
она может быть загружена командой:

Вообще говоря, жесткое включение имени подкаталога в тело
прикладной задачи - не очень правильное решение, так как
неизвестно наверняка, в каком подкаталоге находится
пользователь в момент запуска задачи. Функция PAL -
SDir(), возвращает имя подкаталога, из которого была
загружена текущая программа. Если вызов драйвера
происходит из командной строки Paradox, то SDir()
позволяет прикладным задачам "разместить" самих себя и
перейти в соответствующий подкаталог. С другой стороны,
вы сможете убедиться в том, что библиотека с указанным
именем действительной существует. Наконец, драйвер задает
AutoLib и запускает первую процедуру.

                 За и против

Подход, состоящий в том, что для запуска процедур из
библиотеки создается специальная программа-драйвер, имеет
свои преимущества и недостатки.
Сначала о преимуществах. Во-первых, не приходится
включать в библиотеку исходный текст процедур. Нужно
только имя самой библитеки и программа-драйвер для
запуска задачи. Так как библиотеки состоят не из исходных
текстов, а из ******, тем самым обеспечивается полная
защита текстов. Во-вторых, если программа-драйвер
включает также пароль, то разработка оказывается
защищенной полностью. У пользователя даже отсутствует
возможность нажать [Ctrl-Break] для выхода из задачи. В-
третьих, процесс управления памятью полностью передается
менеджеру виртуальной памяти, который использует
перекачку процедур и локальные переменные.
Вместе с тем, появляются и недостатки. Во-первых, пароль
может содержатся в явном виде в тексте программы, и его
необходимо зашифровать. Во-вторых, если во время прогона
происходит ошибка, то обычно Paradox перехватывает ее и
позволяет войти в режим отладки и получить доступ к
исходному тексту. Для защиты программы придется ввести в
нее перехват и обработку ошибок.



      Проблема: автоматическая перекачка может быть
заблокирована

Paradox будет осуществлять перекачку процедур из
библитеки в память и обратно только в том случае, если
соблюдаются определенные условия вызова процедур. При
нарушении этих правил перекачка может быть заблокирована.
Рассмотрим следующие примеры:


Во всех примерах происходит одно и то же: выбор таблицы
из списка и ее просмотр. Любой из приведенных вариантов
допустим в Paradox. Но случаи 1 и 2 ***** перекачку
процедур. Вызов процедуры ***** производится либо прямо,
либо через простое присвоение возвращаемого функцией
значения. В случаях 3 и 4, где вызов процедуры происходит
внутри команды или выражения PAL, перекачка именно для
данного вызова не происходит. В том случае, если в этот
момент память будет переполнена, произойдет прерывание по
ошибке.
