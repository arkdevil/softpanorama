
Вопросы и ответы по поводу компилятора Turbo Pascal 6.0. Официальный
представитель корпорации Borland International: концерн "Новинтех"
#
     1. Почему у меня возникли трудности при работе с драйве-
ром  мыши в Turbo Debugger и Turbo Profiler? Со всеми прочими
программами он работает нормально.
     Такие продукты  Borland,  как  Turbo  Debugger  и  Turbo
Profiler широко используют расширенные функциональные возмож-
ности,  которых не было в ранних версиях драйверов мыши. Дело
в том, что разработчики мыши постоянно модифицирут  драйверы,
чтобы  максимально  использовать  все возможности устройства.
Последние версии наиболее распространненых драйверов такие:
- Microsoft  7.04
- Logitech   5.00
- Genius     9.06
     Если у вас есть более старая версия одного из этих драй-
веров, то вы можете легко ее заменить, иногда даже без допол-
нительной оплаты. Это зависит от производителя продукта.
     Иногда трудности при работе с Turbo debugger могут  воз-
никать  даже  если  у вас самая последняя версия. Как правило
это связано с видео-картой. В этом случае  попробуйте  загру-
зить  отладчик  с параметром -ds. Этот параметр устанавливает
отдельный образ экрана для отладчика и для отлаживаемой прог-
раммы. Хотя при этом Turbo Debugger работает значительно мед-
леннее, зато функциональные возможности мыши используются на-
и более полно.
     2. Почему процедура EXEC не выполняет мои подпрограммы?
     Это может происходить по  нескольким  причинам,  поэтому
внимательно посмотрите переменную DosError сразу после вызова
EXEC, чтобы принять правильное решение.
     Посмотрим  наиболее часто встречающиеся причины, начиная
с самых легко устранимых.
     Во-первых, проверьте указали ли вы имя элемента DOS.
     Во-вторых, проверьте заключили ли  вы  в  апострофы  имя
программы  и  следующие за ним аргументы. Синтаксис процедуры
     Exec должен быть таким:
     Exec('path\progname.ext','arguments');
     Некоторые утилиты DOS не требуют указания в  явном  виде
пути  доступа.  Однако, работая с некоторыми из них, Вам при-
дется это сделать. Кроме того, если в программе нет  аргумен-
тов, то следует указать нулевую строку в качестве второго па-
раметра.  Если вы пытаетесь выполнить встроенную команду DOS,
то для этого надо загрузить COMMAND.COM,  а  затем  выполнить
команду с ключом
     /C:
     Exec('C:\COMMAND.COM','/C DIR*.PAS');
     И,  наконец, причина невыполнения EXEC может быть в том,
что у вас просто нехватило памяти. Чтобы  убедиться  в  этом,
установите максимальный размер динамической памяти. Это можно
сделать  с  помощью  дерективы  $M  или  выбрав  из  меню IDE
Options/Memory Size. Предпочтительнее $M,  т.к.  такой  режим
гарантирует  правильное размещение памяти независимо от того,
как скомпилирована ваша программа.
     3. Что такое Turbo Vision Collection?
     Коротко - это объект, который хранит  набор  объектов  и
обеспечивает  методы для работы с ними. Он хранит ряд различ-
ных объектов, которые могут иметь различные формы. Это равно-
сильно тому, что у вас есть область записей различных  типов,
и вы можете читать и писать эти записи из файла.
     Из-за  того,  что  Collection - это группа указателей, у
вас нет возможности проверить тип. Поэтому очень  легко  оши-
биться  в  типе при чтении или записи. Пользователь сам несет
ответственность за то, чтобы указатель ссылался на правильный
тип.
     Вы можете также хранить элементы,  которые  не  являются
объектами,  но при этом вы дожны быть ОЧЕНЬ внимательны. Нап-
ример, у вас в коллекции есть элемент PString, вы должны  пе-
реопределить значения элемента в GetItem, PutItem и FreeItem.
Эти функции предполагают, что тип элемента - TObject.
     4.  При  попытке скомпоновать несколько модулей вместе с
Turbo C++ или Borland  C++  компоновщик  выдал  сообщение  об
ошибке "fixup overflow". Что означает эта ошибка?
     При  компиляции программы компилятор генерирует ссылки к
каждой функции. Позже эти ссылки  заполняются  адресами  этих
функций,  которые  неивестны до выполнения компоновщика. Если
вы используете простые, короткие или  компактные  модули,  то
эти  ссылки по умолчанию устанавиливаются на "ближний" (near)
вызов (2 байта). Если вы компилируете  средние,  большие  или
очень большие функции, то по умолчанию ссылки будут "дальние"
(far) (4 байта), так как функции могут располагаться в разных
сегментах. Единственным исключением являются функции, которые
явно описаниы как "ближние" или "дальние" в описании и прото-
типе функции. Если вы делаете попытки связать модули, которые
были откомпилированы в разных моделях памяти, компоновщик вы-
даст  сообщение  об  ошибке.  Если компоновщик сталкивается с
ближней, двух-байтовой ссылкой к объекту, который  располага-
ется  в  другом  сегменте,  то  он оказывается не в состоянии
уместить 4-х байтовый адрес в эти 2 байта и выдает  сообщение
об ошибке "fixup overflow".
     Для  Turbo  C++ или Borland C++ это чаще всего означает,
что вы смешали объектные модули, откомпилированные  в  разных
моделях  памяти,  например привязываете объектный файл из ма-
ленькой модели к файлу из большой модели. Для разрешения этой
проблемы проще всего перестроить оба  эти  объекта  (получить
файлы .OBJ) на одной и той же модели памяти.
     Заметим также, что это сообщение вы можете получить, ес-
ли вы заменяете размеры указателей по умолчанию на явные, ис-
пользуя  ключевые слова near и far. Однако в большинстве слу-
чаев проблема связана с вызовом функции.
     В любом случае в сообщении "fixup overflow" будет указа-
но, какая функция вызывалась и в каком  модуле  осуществлялся
этот  вызов,  таким образом будет нетрудно определить причину
ошибки.
     5. Как привязать библиотечный модуль из  Turbo  C++  или
Borland C++ к моей программе?
     Чтобы привязать внешний файл .OBJ или .LIB к вашей прог-
рамме  необходимо  создать  проектный  файл (.PRJ). Это можно
сделать, выбрав из меню  Turbo  C++  или  Borland  C++  опции
Project/Open Project. В имени проекта наберите то, что вы хо-
тите создать. Сделайте активным окно Project Window и нажмите
ввод.  Введите  в проектный файл все файлы .С и .СРР, которые
должны быть откомпилированы, а также  все  те  файлы  .OBJ  и
.LIB,  которые  должны быть присоединены. Затем сохраните ре-
зультирующий файл типа Project.
     После того как вы введете все ваши файлы, откомпилируйте
ваш проект с помощью Compile/Make. IDE откомпилирует  ваш  .С
файл  и по завершению компиляции присоединит к .EXE файлу все
файлы .OBJ и/или .LIB.
     ЗАМЕЧАНИЕ: Не включайте в ваш проект файлы с расширением
.Н - это обязательно приведет к ошибке! Если  вы  добавите  в
проектный  файл  .Н-файл,  то  он будет откомпилирован в файл
.OBJ, затерев при этом соответствующий файл .OBJ  из  .C  или
.СРР.
     Когда  вы  получаете сообщение об ошибке компоновщика, в
котором говорится, что функции или  переменные  неопределены,
это  происходит  как правило из-за того, что вы не включили в
проект исходный модуль или библиотеку. Кроме того  это  может
случиться из-за неаккуратного указания головного файла, кото-
рый  имеет  то же имя, что и исходный .С или .СРР файл. Адми-
нистратор проекта знает, что исходный файл должен быть  пере-
компилирован,  если были внесены изменения в головной файл (с
помощью #include), информация об этом автоматически  попадает
в файл .OBJ.
     6. Я работаю с Turbo Vision и хотел бы проверять данные,
которые  пользователь  заполняет  в  строке для ввода. Куда я
должен поместить для этого вводимые данные?
     Чтобы иметь возможность сохранить и изменять то, что на-
бирал на клавиатуре пользователь, нужно создать "потомок" для
строки TinputLine и заменить им HandleEvent. С помощью нового
HandleEvent вы сможете отслеживать отдельные клавиши, исполь-
зуя Event.CharCode. После этого вы можете модифицировать вве-
денную строку, котррая является полем  типа  DATA,  описанным
внутри структуры TinputLine.
     7.  Почему  я  не  могу использовать Memavail и Maxavail
чтобы описать память для Turbo Debugger?
     Turbo Debugger использует вызов 'C' для функций Memavail
и Maxavail. Чтобы получить правильный результат из  этих  ин-
формативных функций, надо обращаться к ним так:
       MEMAVAIL()
       MAXAVAIL()
     Если  не указать такой синтаксис, то Turbo Debugger вер-
нет вам адрес функции, а не ее значение.
     8. Моя программа выдает сообщение "Stack Overflow".  Что
это за стек и как избежать этой ошибки?
     Стек  - это область памяти, в которую заносятся значения
при вызове функции. Все аргументы и  адрес  возврата  функции
помещаются  в  стек при вызове этой функции, а кроме того все
динамические переменные, объявленные  внутри  функции,  также
записываются в стек. Регистр указателя стека (SP) в CPU пред-
назначен  для обеспечения доступа к этим значениям. Аргументы
функции восстанавливаются из стека в процессе выполнения фун-
кции. Когда выполнение функции завершается, происходит  возв-
рат  по адресу, указанному при вызове этой функции. Таким об-
разом значения из стека выбираются по принципу  последнимпри-
шел-первым-ушел.
     Сообщение  о  переполнении  стека  означает, что в вашей
программе определено больше локальных переменных,  чем  можно
поместить  в стек. Это может быть из-за того, что функции вы-
зываются слишком часто или слишком большая  глубина  вложения
функций.  Есть  несколько  способов разрешения этой проблемы.
Во-первых, надо выяснить где (в какой  функции)  используется
стековое   пространство.   В  этом  вам  может  помочь  Turbo
Debugger. Затем попробуйте убрать из стека одну или более ло-
кальных переменных. Если функция не рекурсивная, или если она
рекурсивная, но каждый новый вызов функции не требует  обнов-
ления  переменных,  попробуйте объявить эти переменные стати-
ческими. Это сделает переменные  принадлежащими  только  этой
функции,  т.е.  к ним не будет доступа из других частей прог-
раммы, но эти переменные будут храниться вместе с глобальными
переменными в динамической области программы.
     Можно также воспользоваться Malloc, чтобы взять перемен-
ные из динамической области и разместить их в начале функции.
Эти переменные надо очистить перед тем как функция  завершит-
ся.  Однако  если функция вызывается часто, нет необходимости
фрагментировать динамическую область. Размещение динамической
области - это наилучшее решение, если вы имеете дело с  боль-
шими  локальными  переменными.  Если имеются массивы, которые
должны быть определены внутри  функции,  попытайтесь  сделать
массив  указателем  к  базовому типу и распределяемой области
(обязательно освободите распределенную область перед  возвра-
том).  Можно  также объявить массив как глобальную переменную
вне тела функции, но это не очень хороший способ программиро-
вания. Такой способ съедает динамическое пространство  вместо
программного  стека.  В  то время как стек - это ограниченное
пространство, динамическая  область  представляет  собой  все
доступное пространство памяти в любой модели памяти - от ком-
пактной до самой большой.
     И,  наконец,  вы можете увеличить размер стека. При этом
следует иметь в виду, что это отнимает пространство у динами-
ческой области памяти.
     
     Источник:  Информация принята по телефонному каналу связи
                30 октября 1991 года
                      
     
     В: В чем главные отличия Turbo Pascal 6.0 от предыдущих
версий?
     О: Главных отличий два:
          - новая интегрированная оболочка (IDE);
          - Turbo Vision (произносится: "турбо вижн").
     Новая интегрированная оболочка отличается возможностями:
          - усовершенствованная поддержка "мыши";
          - перекрывающиеся окна;
          - условные остановы при отладке;
          - многофайловое редактирование;
          - оперативная обучающая компонента;
          - гипертекстная помощь с возможностью копирования
            примеров;
          - встроенный ассемблер.
     Turbo Vision (можно перевести как "турбо-взгляд"):
          - первая в мире унифицированная объектно-ориентиро-
            ванная диалоговая оболочка приложений.
     
     В: Что такое Turbo Vision ?
     О: TV - это "пустая" диалоговая оболочка приложений, она
содержит  все необходимое для построения современных диалого-
вых программ. Любая программа, созданная на основе TV,  авто-
матически  наследует все объекты, обеспечивающие ее интерфейс
с пользователем, а также некоторые функциональные  особеннос-
ти.
     TV  позволяет  создавать  сложные диалоговые программы -
работать с мышью, вызывать, перемещать и изменять  окна,  ис-
пользовать  контекстночувствительную  подсистему  помощи. Она
включает автоматический обработчик событий, объектно-ориенти-
рованный потоковый ввод/вывод, который обеспечивает  сохране-
ние произвольных объектов на диске. Например, текущее состоя-
ние приложения тоже может быть сохранено и затем восстановле-
но.
     Все это, в сущности, бибилиотека классов, которая позво-
лит Вам сберечь сотни и сотни часов программирования при раз-
работке диалоговых мониторов Ваших приложений.
     
     В: Легко ли освоить Turbo Pascal 6.0, человеку, не знаю-
щему объектно-ориентированного программирования (ООП)?
     О:  Да,  этот  язык  разрабатывался специально для того,
чтобы облегчить вхождение в ООП. Поставляемое с языком  Руко-
водство  пользователя показывает, как осуществить постепенный
перход от структурного к объектно-ориентированному программи-
рованию. Вообще, для тех кто использовал Turbo Pascal раньше:
новая версия совместима снизу-вверх с  версиями  4.0,  5.0  и
5.5.
     
     В:  Можно  ли  создавать  на  Turbo Pascal по-настоящему
большие программы?
     О: Конечно! Пакет Turbo Pascal 6.0 поставляется вместе с
отдельным компилятором, который работает на основе  специали-
зированного  монитора  управления  памятью - Turbo Drive. Это
позволяет создавать очень  большие  приложения,  использующие
реальный режим работы процессора.
     
      Телефон:  (095) 442-57-92, 442-34-44
      Факс:     (095) 442-57-92
     

     Источник:  Информация принята по телефонному каналу связи
                27 сентября 1991 года
      
      
