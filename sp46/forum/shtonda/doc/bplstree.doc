
           Элементы теории структур данных типа B+ дерева
                      (краткое изложение)
          -----------------------------------------------

     Разработчики программного  обеспечения  используют  термин  "база
данных" настолько часто, что его смысл в каждом  конкретном  контексте
часто остается неясным. В данной статье   мы  используем  этот  термин
для  обозначения   некоторой   совокупности   данных,   хранимых   для
использования в  прикладной  программе,  не  уточняя,  в  какой  форме
находится эта совокупность. Мы формально определяем  термин  "Файловый
блок" для  обозначения  комбинации  файла  данных,  индексного  файла,
хранящего  ключи  к  нему,  и  другой  информации,  используемой   для
управлением доступа к этим  файлам.  С  учетом  этой  терминологии  мы
можем перейти к общим понятиям данных и ключей.

                        Данные и ключи
                        --------------

     Существует два базовых метода поиска  в  базе  данных  конкретной
информации:

     - последовательный доступ к данным;
     - индексно-последовательный доступ к данным, также известный  как
прямой доступ.

     Поиск при последовательном доступе сводится к  чтению  данных  от
начала к концу файла,  причем  производится  сравнение  каждой  записи
данных с желаемым значением. В  случае  больших  наборов  данных  этот
метод является  медленным  и  неэффективным.  Для  прямого  доступа  к
данным   требуется   знать   позицию   желаемой   записи   данных    в
последовательном  файле  данных.  Зная  эту  позицию,  можно  за  одно
обращение прочесть нужную запись.

     Информация,  которая  необходима  для   поиска   записи   данных,
доступна благодаря информации  об  индексном  ключе.  Данные  и  ключи
хранятся в двух независимых файлах, файле данных и индексном файле.

     Файл данных состоит из  записей  данных  фиксированного  размера,
хранимых  одна  за  другой.   Каждая   запись   данных   соответствует
некоторому номеру, являющемуся адресом записи данных, и  определяющему
позицию записи данных в файле данных. Например, адрес 1  ссылается  на
самую первую запись файла данных, адрес  2  определяет  вторую  запись
файла, доступные  для  пользователя.  Когда  запись  вводится  в  файл
данных , возвращается адрес записи  данных  в  файле  данных,  который
затем может быть добавлен в индексный файл с  соответствующим  ключом.
Индексный файл  содержит  ключи  и  значения  адресов  соответствующих
записей в файле данных.

     Для поиска конкретной записи  данных  в  индексном  файле  ищется
ключ (для чего служит одна из подпрограмм TURBO PASCAL  ACCESS  SYSTEM
- FindKey). Если ключ найден, запись данных может быть  прочитана (при
помощи процедуры - GetRec)  по номеру адреса, возвращенному процедурой
поиска. Если ключ не найден, то такая запись данных  действительно  не
существует в БД.

            Организация структур данных типа В+ дерева
            ------------------------------------------

     Структуры данных  типа  В+  дерева  представляют  собой  наиболее
исследованными в инфориатике. Многие думают, что  В+  дерево  означает
"бинарное дерево", однако это не так. Буква "В"  -  это  первая  буква
фамилии  "Bayer",  который  является  одним  из   изобретателей   этой
структуры данных. В+ дерево -  это  гораздо  более  богатая  структура
данных, нежели двоичное дерево, которая  специально  была  разработана
для оптимизации  поиска  записей  в  больших  базах  данных.  Основное
отличие между B+ деревом и  двоичным  деревом  такое,  что  на  каждом
уровне разрешены более чем две  дочерние  вершины.  Остальные  разделы
определяет терминологию В+ деревьев в  целом,  затем  описывют,  каким
образом В+ деревья применяются для реализации баз данных. В  следующем
разделе рассматриваются базовые алгоритмы В+ дерева,  применяемые  для
поиска по дереву, а также для удаления и добавления к нему элементов.

                    Терминология В-дерева
                    ---------------------

     Термин  "древовидная  структура"   происходит   от   аналогии   с
изображением  перевернутого  дерева.  "Узел"  В+  дерева  представляет
собой  совокупность  одного  или  более  индексных  ключей.   "Ветви",
соединяющие  узлы,  определяют  последовательность  поиска  для  того,
чтобы найти конкретное значение ключа. Ветви дерева  направлены  вниз,
начиная с "корня", и кончая узлами, из  которых  уже  новые  ветви  не
выходят. Такие узлы называются "листьями" дерева. (См. Рис.1 ниже.)

     Высота дерева  определяется  максимальным  числом  ветвей,  через
которое нужно "пройти" от корня до любого листа. Корень имеет  уровень
1, его прямые ветви имеют уровень 2, в свою очередь их прямые  потомки
имеют уровень 3, и т.д. Все узлы-листья, т.е.  все  узлы,  не  имеющие
потомков, в случае структуры В-дерева заканчиваются на одном и том  же
уровне.


  ^                     ┌─────────────┐
  │                     │    Корень   │
  │                     └─┬─────────┬─┘
  │                   ┌───┘         └───┐ <───────- Ветвь
  │                   │                 │   
  │              ┌────┴─┐             ┌─┴────┐
Высота           │ Узел │             │ Узел │
  │              └┬────┬┘             └┬────┬┘
  │             ┌─┘    └─┐           ┌─┘    └─┐
  │             │        │           │        │
  │         ┌───┴──┐  ┌──┴───┐   ┌───┴──┐  ┌──┴───┐
  v         │ Лист │  │ Лист │   │ Лист │  │ Лист │
            └──────┘  └──────┘   └──────┘  └──────┘

          Рис.1.  В-дерево порядка 2 и высоты 3.

     Число ветвей, выходящих из данного  узла,  называется  "степенью"
узла;  максимальная  степень  определяет  степень  дерева.   Например,
двоичное дерево имеет степень два, поскольку  каждый  узел  имеет  две
ветви. Деревья со многими ветвями, например, В+ дерево, имеет  степень
выше   двух (   в  TURBO   PASCAL   ACCESS   SYSTEM   степень   дерева
устанавливается  неявно,  через  константу  <PageSize>,   в   значение
<PageSize>+1).

     "Порядок" дерева определяется как минимальное  число  ветвей  для
любого узла. Каждый узел В+ дерева, за исключением корня, должен  быть
как минимум наполовину заполнен;  следовательно,  каждый  узел,  кроме
корня, должен иметь не менее <PageSize>/2+1  ветвей.  Это  приводит  к
эффективному использованию памяти.

     "Сбалансированным"   является   дерево,   для   которого   уровни
узлов-листьев отличаются максимум на  единицу.  В+  дерево  простирает
эту оптимизацию далее, требуя, чтобы все дистья-узлы имели один и  тот
же уровень. Это подразумевает, что  безразлично,  по  какому  маршруту
идет путь от корня, так как число шагов до  любого  узла-листа  всегда
одинаково.

     Конструкция  В+  дерева,  по  контрасту   с   бинарным   деревом,
использует больше памяти, но гарантирует меньше обращений  к  диску  и
следовательно, доступ к данным происходит значительно быстрее.

                      В+ деревья для баз данных
                      -------------------------

     В+ дерево организовано как "дерево поиска", т.е.  ключи  хранятся
в дереве в определенном порядке. Ключи,  используемые  для  доступа  к
записям в файле данных, хранятся в узлах этого дерева.

     Элементарные  индексы  хранятся   в   каждом   узле   в   порядке
возрастания. Первый элементарный индекс содержит наименьший  ключ  для
данного узла;  последний  элементарный  индекс  содержит  максимальный
ключ для данного узла.

     Элементарные  индексы   определяются   как   записи,   содержащие
следующие поля:

     - соответствующий ключ
     - ссылка (адрес) к записи данных
     - ссылка к узлу вперед

     Ссылка к узлу  (указатель  в  прямом  направлении)  указывает  на
узел, содержащий ключ, имеющий большее значение, чем то, что  хранится
в текущем элементе инжекса. (См. Рис.2 ниже.)


                                         ╒═════╕
                                   ┌──-> │ 'A' │
     ╒════════════════════════╕    │     │ 'B' │
 ┌───┤ Счетчик                │    │     │ 'C' │
 │   │ Указатель назад        ├────┘     │  ░  │
 │   ╞════════════════════════╡          └─────┘
 │   │                    'D' │          ╒═════╕
 │   │                        │    ┌──-> │ 'E' │
 │   │                        │    │     │ 'L' │
 │   │                        ├────┘     │  ░  │
 │   ├────────────────────────┤          │  ░  │
 │   │                    'M' │          └─────┘
 │   │                        │          ╒═════╕
 │   │                        │    ┌──-> │ 'N' │
 │   │                        │    │     │ 'P' │
 │   │                        ├────┘     │ 'Q' │
 │   ├────────────────────────┤          │ 'S' │
 └─->│ Ключ               'X' │          └─────┘
     │ Ссылка (адрес) к данным│          ╒═════╕
     │ Указатель вперед       ├───────-> │ 'Y' │
     │                        │          │ 'Z' │
     │                        │          │  ░  │
     ├────────────────────────┤          │  ░  │
     │░░░░░░░░░░░░░░░░░░░░░░░░│          └─────┘
     │░░░░░░░░░░░░░░░░░░░░░░░░│
     │░░░░░░░░░░░░░░░░░░░░░░░░│
     ╘════════════════════════╛

     Рис.2:  Внутренняя структура В+дерева.


     Сам узел объявлен как запись и содержит:

     -  целое  число,  содержащее   фактическое   число   элементарных
индексов, хранимых в данном узле;
     - обратная ссылка к узлу назад (указатель назад), указывающая  на
узел, содержащий ключи, меньшие любого ключа в данном узле;
     - массив собственно элементарных индексов.

     В+  дерево  позволяет  перемещаться  по  нему  от  узла  к  узлу,
благодаря использованию обратных указателей,  что  позволяет  находить
меньшие ключи, и прямых указателей для поиска больших ключей.

     Наименьший ключ В+ дерева является первым элементом в  узле-листе
в левом краю дерева (который не имеет обратного  указателя,  поскольку
не существует меньших ключей),  а  наибольший  ключ  -  это  последний
элемент в самом правом узле-листе (который не имеет указателя  вперед,
поскольку не существует больших ключей). Маршрут  поиска  (начиная  от
корня)  для  нахождения  наименьшего   и   наибольшего   ключа   имеет
одинаковую длину, поскольку все листья-узлы В+  дерева  должны  лежать
на одном уровне.

     Каждый узел содержит минимум <PageSize/2> и  максимум  <PageSize>
элементарных индексов. Корень  составляет  единственное  исключение  в
том смысле, что он может  содержать  менее  <PageSize/2>  элементарных
индексов.

     Выбор значения <PageSize> требует некоторого  компромисса.  Поиск
ключей в  больших  страницах  требует  меньше  обращений  к  диску,  и
следовательно, работает быстрее, чем в случае меньших  страниц.  Поиск
в странице идет сравнительно быстрее, чем загрузка страницы  с  диска.
(Однако, большее значение <PageSize>  увеличивает  требования  системы
TURBO PASCAL ACCESS SYSTEM к памяти, а также увеличивает время  чтения
страницы). Требуется задать значение <PageSize>. Ha  основе тщательных
экспериментов  (фирмы  TurboPower  Software)  рекомендуется   выбирать
значение равное 62.  Эта  величина  гарантирует  оптимум  для  времени
доступа и использования памяти.

     Максимальная   высота   В+   дерева   определяется     константой
<MaxHeight>. При значении <MaxHeight>=8 В+ дерево не будет  заполнено,
пока туда не будет  добавлено  10^14  ключей.  Поскольку  2^32  ключей
меньше, чем 10^10, опасности переполнения В+ дерева не существует!

                     Ключи в индексном файле
                     -----------------------

     Как уже было описано выше, ключи в индексном  файле  обеспечивают
связь с записями данных в файле данных. Каждый раз  при  вводе  записи
данных должен  быть  добавлен  соответственный  ключ,  таким  образом,
чтобы запись данных могла быть найдена индексным методом доступа.

     Поскольку файлы индексов и данных хранятся  раздельно,  с  каждым
из  них   возможны   отдельные   манипуляции.   При   удалении   ключа
соответственная запись  данных  автоматически  не  удаляется.  В  этом
случае  запись  данных  не  может  быть  найдена  методом   индексного
доступа.  Индексный  доступ  также  невозможен,  если  запись   данных
вводится в файл данных без одновременного добавления в индексный  файл
элементарного ключа. (Следовательно, для  правильного функционирования
системы TURBO PASCAL ACCESS SYSTEM важно  одновременно  манипулировать
файлами индекса и данных.)

     Индексные ключи должны иметь тип String. Если  в  качестве  ключа
должно использоваться число, оно должно сначала быть  преобразовано  в
строку  символов.  Значение  каждого  элемента   в   строке   является
величиной  ASCII.  При  построении  строк  следует   быть   осторожным
(например,  при  использовании  заглавных  и  строчных  букв),   чтобы
обеспечивалось правильное сравнение ключей.

     Существует два  типа  ключей,  которые различаются следующим
образом:

     - первичные ключи: ключи, уникальные в базе данных
     - вторичные ключи: ключи, которые можно вводить многократно.

     Первичные ключи не могут быть дублированы в индексном файле  (это
требование устанавливается  подпрограммами  индексации  системы  TURBO
PASCAL  ACCESS  SYSTEM).

     Вторичные  ключи  используются   для   не-уникальных   элементов.
(Cистема TURBO PASCAL ACCESS SYSTEM хранит внутри  себя  эти  возможно
дублирующиеся ключи раздельно, комбинируя уникальные ссылки  к  записи
данных  с   каждым   ключом.    Процесс   комбинирования   выполняется
логически, не требуя дополнительной памяти для хранения ключа).

     Максимальная длина  ключа  определяется  константой  <MaxKeyLen>,
которая может лежать в диапазоне от 1 до 255.

     Каждый ключ соответствует в точности одной  записи  данных,  хотя
множество ключей может указывать  на  запись  данных.  В  базе  данных
ключом может являться любое поле записи.

                          Управление ключами
                          ------------------

     Как мы увидим ниже, добавление или удаление  одного  ключа  может
потребовать существенной реорганизации В+ дерева, чтобы сохранить  его
требуемые свойства (см. программу TRAINER.EXE).

                            Поиск ключа
                            -----------

     Поиск ключа в В+  дереве  всегда  начинается  с  корневого  узла.
Корень, как и любой другой  загружаемый  узел,  просматривается  путем
двоичного  поиска.  Число  элементарных  индексов,  в  текущий  момент
хранимое в узле, делится пополам, и берется средний индекс. Затем  его
ключевой элемент сравнивается с искомым ключом.  Если  они  идентичны,
то поиск закончился успешно.

     Если элементарный ключ не  совпал  с  искомым  ключом,  то  поиск
должен продолжаться. Поскольку ключи в узле всегда хранятся в  порядке
возрастания,  то  сравнение  текущего  ключа   с   искомым   указывает
направление  для  дальнейшего  поиска.  Если  сравненный  ключ  меньше
искомого, то поиск идет вправо. Если же он больше искомого,  то  поиск
идет влево. Если ключ найден где-либо в  текущем  узле,  то  поиск  на
этом оканчивается.

     В противном случае для  нахождения  следующего  узла  могут  быть
использованы прямые и обратные указатели. Прямой указатель  последнего
элементарного индекса, ключ которого меньше желаемого ключа,  ведет  к
новому узлу с ключами, большими последнего элемента, и  меньшими,  чем
следующий элемент исходного  узла.  Затем  поиск  повторяется  в  этом
новом узле, который может находиться уже в  оперативной  памяти,  либо
потребовать для доступа к нему обращения к диску. Только  когда  поиск
приводит к узлу,  где  наименьший  элементарный  индекс  больше  ключа
поиска, используется обратный указатель. Далее  поиск  продолжается  в
этом узле, где ключи меньше искомого. Поиск завершается успешно,  если
найден заданный ключ, либо  при  неудачном  завершении  поиска,  когда
достигнут узел-лист дерева, а соответствие обнаружено не было.

     В+  дерево  позволяет  также  доступ  к  записям  базы  данных  в
отсортированном   последовательном   порядке.   Начиная   с   заданной
стартовой точки прямой указатель текущего индексного элемента ведет  к
следующему ключу в отсортированной последовательности. При  достижении
узла-листа  алгоритм  возвращается  на  предыдущий  уровень   узла   и
продолжает  со   следующего,   большего   индексного   элемента.   Это
эквивалентно  первому  по  глубине  траверсированию   В+ дерева.   Для
обозначения  конкретного  адреса  в  В+  дереве  используется   термин
"последовательный указатель".  Фактически  последовательный  указатель
представляет собой массив записей, каждая  из  которых  содержит  одно
число, определяющее узел, и второе, указывающее на активный элемент  в
узле. Последовательный  указатель  можно  рассматривать  как  маршрут,
ведущий  от  корня  к  узлу,  содержащему  текущий   элемент.   Другие
подпрограммы  переопределяют  указатель,  присваивая   ему   временное
значение. Описания подпрограмм содержат и описание воздействие  их  на
последовательный указатель.

                         Добавление ключа
                         ----------------

     Если в  индексный  файл  должен  быть  добавлен  новый  ключ,  то
сначала  В+  дерево  просматривается  описанным  выше  методом,  чтобы
убедиться, что такого ключа до сих пор не было. Если ключ  существует,
то генерируется ошибка. (Помните,  что  дублирующиеся  ключи  делаются
уникальными путем включения адресных номеров их записей данных).  Если
ключ не существует, то поиск заканчивается в узле-листе  с  негативным
результатом. По этому адресу  добавляется  новый  ключ.  Если  в  этом
узле-листе есть место еще для одного ключа, то добавление  выполняется
добавлением  нового  ключа  в  отсортированную  позицию  в   индексном
массиве узла. Однако,  если  узел-лист  заполнен  -  там  уже  имеется
<PageSize> ключей, - то В+ дерево  должно  быть  модифицировано  таким
образом, чтобы создать место для хранения  нового  ключа.  (См.  рис.3
ниже.)

     Требуемая область хранение создается  расщеплением  данного  узла
на два. Индексные  элементы,  меньшие  чем  <PageSize>/2,  остаются  в
старом узле, а большие помещаются  в  новый  узел.  Средний  индексный
элемент, меньший, чем индексные  элементы  нового  узла,  используется
для указания на этот новый узел, путем ввода его в узел на  предыдущем
уровне дерева.

     Если узел, в который  должен  вводиться  этот  средний  индексный
элемент, также  полон,  то  происходит  расщепление  следующего  узла.
Рекурсивные применения этого метода могут привести  к  "делению"  всех
узлов до корневого уровня. Даже сам  корень  при  необходимости  может
быть  расщеплен.  В  таком  случае  средний   индексный   элемент   из
последнего деления станет новым корнем,  а  дерево  вырастет  на  один
уровень. Это единственный случай, когда высота  дерева  увеличивается.
Данное правило добавления ключей сохраняет  четкую  характеристику  В+
дерева, состоящую в том, что все узлы-листья должны  лежать  на  одном
уровне.


                      ┌─────┬─────┐
                      │  J  │     │
                      └─────┴─────┘
                     /       \               Исходное состояние
               ┌─────┬─────┐  ┌─────┬─────┐
               │  J  │     │  │  M  │     │
               └─────┴─────┘  └─────┴─────┘

                      ┌─────┬─────┐
                      │  J  │     │
                      └─────┴─────┘
                     /       \               Добавление P
               ┌─────┬─────┐  ┌─────┬─────┐
               │  J  │     │  │  M  │  P  │
               └─────┴─────┘  └─────┴─────┘

                      ┌─────┬─────┐
                      │  J  │  P  │
                      └─────┴─────┘
                     /      │       \        Добавление Q
       ┌─────┬─────┐  ┌─────┬─────┐  ┌─────┬─────┐
       │  F  │     │  │  M  │     │  │  Q  │     │
       └─────┴─────┘  └─────┴─────┘  └─────┴─────┘

           Рис.3. Добавление ключей в В+ дерево.

     При   реализации   расщепления   узлов   используется   следующее
дальнейшее усовершенствование базовой теории В+ дерева.

     Перед  расщеплением  узла  делается  попытка  выполнить   "баланс
страницы", который делает свободнее некоторые узлы. Здесь  проверяется
число индексных элементов соседнего узла.  Если  там  число  элементов
меньше, чем <PageSize>,  индексные  элементы  из  переполненных  узлов
перемещаются в более свободные. Это позволяет избежать лишних  делений
узлов.

     Этот метод лучше в том плане,  что  он  позволяет  заполнить  все
узлы  ключами,  экономя  тем  самым   память.   Это   дает   следующие
преимущества:

     - уменьшается время поиска
     - уменьшается размер индексного файла
     - в памяти можно держать больше ключей одновременно.

     При использовании непрерывно растущих,  имеющих  последовательные
значения ключей,  размер  индексного  файла  может  быть  уменьшен  на
30-50%.

                          Удаление ключа
                          --------------

     Если ключ должен  быть  удален,  сначала  должен  быть  определен
адрес ключа в дереве. Это выполняется описанным выше способом.

     Как  и  при  добавлении  ключа,  ключ,  найденный  в  узле-листе,
удалить  легко.  Для  этого  достаточно  удалить  элемент  из  массива
индексов этого узла.

     Если после  удаления  узел  имеет  менее  <PageSize>/2  индексных
элементов ("недостача"), можно  предпринять  одно  из  двух  действий.
Либо из соседнего узла туда могут  быть  помещены  индексные  элементы
("баланс страницы"), как описано выше  для  добавления  новых  ключей.
Либо, в случае, когда соседний узел  также  страдает  от  "недостачи",
две страницы могут быть объединены в одну ("слияние узлов",  операция,
обратная   расщеплению).   Страница,   являющаяся   родительской   для
объединившихся узлов, также уменьшается  на  один  индексный  элемент.
Если она также будет страдать от "недостачи", а  балансировка  страниц
невозможна, то опять повторится объединение с соседней страницей.  При
некоторых  обстоятельствах  этот  процесс  дойдет   до   корня.   Если
произойдет удаление единственного индексного  элемента,  составляющего
корень, то дерево сожмется до одного уровня.  Это  единственный  путь,
когда В+ дерево может потерять высоту.

     Снова отметим, что файлы индексов и  данных  хранятся  раздельно.
Если индексный элемент удаляется без удаления  соответственной  записи
данных, то такая запись остается "сиротой" в  файле  данных,  т.е.  ее
больше нельзя найти по индексной ссылке.

     Если ключ должен быть удален из другого адреса, нежели  узел-лист
дерева, прямой указатель, указывающий  на  узел  с  большими  ключами,
также будет потерян при удалении  такого  ключа,  и  структура  дерева
будет  испорчена.  Чтобы   предотвратить   это,   берется   следующий,
наибольший по величине ключ в дереве, и помещается по адресу,  который
занимал удаленный ключ. Вследствие упорядоченности  ключей  он  всегда
будет  находиться  в  листе-узле.  Таким  образом,  прямой   указатель
удаленного ключа останется достоверным. После  того,  как  новый  ключ
скопирован в позицию, ранее  занимаемую  удаленным  ключрм,  он  также
должен быть удален из своей бывшей позиции. Это выполняется по той  же
схеме, по которой ключ удаляется из узла-листа. В случае,  если  узел,
из  которого  был  удален  ключ,  имеет  теперь   менее   <PageSize>/2
элементов, то происходит его корректировка методами  балансировки  или
слияния узлов.
