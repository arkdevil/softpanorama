           TURBO PASCAL ACCESS SYSTEM (Borland Int.,1987)
           ==============================================
   
    Система   доступа   ТURBO   PASCAL   представляет   собой    метод
эффективного хранения и выборки  информации,  содержащейся  в  больших
файлах данных. Подсистема TURBO  PASCAL  ACCESS  (  пакет  подпрограмм
доступа) выбирает информацию методом прямого доступа по ключу  (вместо
номера записи).
    TURBO  PASCAL  ACCESS  ускоряет   обычно   медленные,   трудоемкие
процессы поиска записи  посредством  использования  ключевых  строк  в
виде отношений между файлами данных  и  индексными  файлами.  Ключевые
строки хранятся независимо  от  данных  и  обычно  представляют  собой
идентификационный  элемент  информации,  которая  была  записана   или
разыскивается.
    Так как вашей программе не  требуется  проводить  поиск  по  всей
базе  данных  в  последовательном  порядке,  то  вы   сможете   быстро
находить, вставлять или удалять запись, когда это потребуется.
    Метод  индексации,  используемый  системой  доступа  TURBO  PASCAL
ACCESS,  базируется  на  использовании  B+  дерева.  Более   подробную
информацию по B+ деревьям можно найти  в  файле  BPLSTREE.DOC.  Однако
нет необходимости понимать  B+  деревья,  чтобы  успешно  пользоваться
системой доступа TURBO PASCAL ACCESS.

           Справочник по системе доступа Turbo Pascal Access
           -------------------------------------------------

1.Константы, Типы и Переменные системы Turbo Pascal Access.
-----------------------------------------------------------
    Этот раздел содержит подробную информацию  о  константах  и  типах
используемые Turbo Pascal Access, следующий раздел предлагает  краткий
справочник программ Turbo Pascal Access и последний  раздел  описывает
все функции и процедуры системы.

    Следующие файла относятся к системе Turbo Pascal  Access:

      TACCESS.PAS исходный текст модуля Access;
      TAHIGH.PAS  исходный текст программ верхнего уровня Access;


    Модуль  TACCESS.PAS  объявляет   следующие   глобальные   типы   и
переменные:

              DataFile    Этот идентифинатор типа объявляет переменные
                          файла данных. Все файлы данных Turbo Pascal
                          Access объявляются с этим идентификатором,
                          хотя их записи имеют другой тип и размер.

              Index File  Этот идентифинатор типа объявляет переменные
                          индексного файла.

              OK          Булева переменная используемая для позвращения
                           состояния некоторых программ Turbo Pascal
                           Access.

              TAErrorProc  Переменная типа ProcPtr используемая для
                           хранения адреса пользовательской программы
                           обработки ошибок

              Duplicates  Используется для параметра статуса в процедурах
                           OpenIndex и MakeIndex для индикации того, что в
                           индексный файл будет допускать дублирование
                           ключей.

              NODuplicates Используется для параметра статуса в процедурах
                           OpenIndex и MakeIndex для индикации того, что в
                           индексный файл не будет допускать дублирование
                           ключей.

              Также, модуль TAHIGH.PAS объявляет следующие переменные:

              ExactMatch  Используется для для того, чтобы задать
                           критерий полного соответствия в обращении к
                           TARead.

              PartialMatch Используется для для того, чтобы задать
                           критерий частичного соответствия в обращении к
                           TARead.

              TARecNum    Переменная типа longint которая содержит номер
                           записи данных к которой проводился последний
                           доступ вызовами верхнего уровня.

     Следующий раздел определяет  и  описывает  в  алфавитном  порядке
константы используемые системой Turbo  Pascal  Access;  все  константы
содержатся в модуле  TACCESS.PAS.  Изменение  значений  этих  констант
влияет на скорость поиска и количество  используемой  памяти  системой
Turbo Pascal Access. Вы  можете  использовать  программу  TABuild  для
установки значений констант.

Описание:  const  MaxDataRecSize   =   {   целое,   18...32767,   дает
максимальный размер записи данных}

Назначение:  MaxDataRecSize  определяет  максимальный  размер   записи
данных и устанавливает размер (в байтах) самой большой  записи  данных
обрабатываемой  вашей  программой.  Например,  если   ваша   программа
обрабатывает два файла данных с размерамии записей в 72  и  140  байт,
то MaxDataRecSize должен быть установлен в 140.

Замечания: Лучшим способом определения размера  ваших  записей  данных
является  написание  небольшой  программы  для  печати  SizeOf  каждой
записи анных. Например:

                        type
                          MyRec = Record
                                    Status : integer;
                                    Fild1  : string[40]; {40 байт}
                                    Fild2  : string[80]; {80 байт}
                                  end;
                         begin
                           Writeln('Размер записи MyRec : ',SizeOf(MyRec);
                         end.

      В этом случае, выведенное  значение  будет  124;  размер  записи
равен 124 байта. При использовании  этого  метода  для  каждой  записи
данных ваша программа будет определять  MaxDataRecSize.  При  создании
или открытии  файла  данных  (с  использованием  процедур  MakeFile  и
OpenFile,  вы  можете  использовать  SizeOf(Ваша  запись)  в  качестве
параметра в программы которым необходима эта информация.
      MaxKeyLen  и   MaxDataRecSize   устанавливаются   в   наибольшее
возможное  значение  для  каждого  типа,  так  как  та  же  внутренняя
структура используется для обработки каждого  из  различных  индексных
файлов и файлов данных. Таким  образом,  внутренняя  структура  должна
быть достаточно большой для помещения туда  самого  большого  ключа  и
записи.

Описание:   const MaxHeight = {целое, см. текст}

Назначение: MaxHeight  определяет  максимальную  высоту  структуры  B+
дерева.   эта   константа   применима   ко   всем   индексным   файлам
обрабатываемым вашей  программой.  Она  не  влияет  на  действительную
структуру  B+  дерева,  однако  используется   в   каждой   переменной
индексного   файла.   MaxHeight   в   основном    используется     для
последовательного  (вперед  или  назад)  просмотра  B+   дерева.   Как
вычислять MaxHeight см. ниже. Сеществует несколько  выражений  которые
позволяют вам предсказывать  размер  и  эффективность  конкретного  B+
дерева; вы можете также оценить пространство на  диске  которое  будет
использовано индексным файлом. Максимальное количество  страниц,  K  ,
просматриваемых для нахождения определенного ключа в  индексном  файле
с E ключами приблизительно равно:

            K = Log(E) / Log(PageSize x 0.5)

Таким образом, чем  больше  PageSize,  тем  меньше  число  просмотров.
Большие страницы требуют меньшего обращения к диску  и  соответственно
меньше времени. Время требуемое для осуществления поиска по  странице,
когда она считана в память, сравнимо со  временем  чтения  страницы  с
диска. Параметр MaxHeight требуемый  TACCESS.PAS  соответствует  целой
части K плюс 1, (trunc(k)+1). Таким образом, когда  вы  устанавливаете
PageSize и максимальное число  записей  данных  в  вашей  базе  данных
вычисляйте MaxHeight следующим образом:

             MaxHeight=Int(Log(E)/Log(PageSize x 0.5))+1

Заметим, что большие значения MaxHeight  требуют  очень  мало  внешней
памяти  (4  байта  на  каждый  инкремент   MaxHeight).   Поэтому   вам
рекомендуется добавлять 2 или 3, вместо 1

Описание:  const MaxKeyLen = { цнлое, 1...255};

Назначение: MaxKeyLen определяет максимальную длину  ключа.  MaxKeyLen
устанавливает размер (в байтах) самой большого  ключа  обрабатываемого
вашей программой.  Например,  если  ваша  программа  обрабатывает  три
индексных файла с длиной ключей в 16,  10  и  25  байт,  то  MaxKeyLen
должен  быть  установлен  в  25.  (Обратите   внимание,   что   строка
объявляемая как string[25], имеет максимальную длину 25 а не  26,  так
как  нас  интересует  длина   правее   размера).   Программа   TABuild
использует для вычисления размера ключа выражение SizeOf(MyKey)-1.

Замечания: MaxKeyLen и  MaxDataRecSize  устанавливаются  в  наибольшее
возможное  значение  для  каждого  типа,  так  как  та  же  внутренняя
структура используется для обработки каждого  из  различных  индексных
файлов и файлов данных. Таким  образом,  внутренняя  структура  должна
быть достаточно большой для помещения туда  самого  большого  ключа  и
записи.

Описание:     const Order = { целое, 2...127 = PageSize/2)};

Назначение: Order равен  половине  значения  PageSize  и  представляет
собой  минимально  допустимое  число  элементов  данных  на   странице
B+дерева, исключая корневую страницу.

Описание:     const PageSize = { челое, 4...254 };

Назначение: PageSize определяет максимально допустимое число  ключевых
записей на каждой странице B+дерева. PageSize должен  быть  одинаковым
для всех индексных файлов обрабатываемых  вашей  программой  и  должен
принимать значения от 4 до 254.

Замечания:  Количество  байт,  N,  занимаемое   каждой   страницей   в
индексном файле находится следующим образом:

            N=(KeySize + 5 ) x PageSize +3

       Где: KeySize длина ключа для индексного файла.

Количество  байт,  D,  занимаемое  индексным файлом :

            D = N x E / (PageSize x 0.5)

       Где: E количество индексных записей.

      Комбинируя  эти  два  уравнения,  можно  видеть,  что   основная
определяющая размера индексного файла это KeySize:

            D= 2 x E x (KeySize + 5) + ((6xE)/PageSize)

      Это уравнение показывавет, что индексный файл примерно равен  (2
x KeySize) x количество индексируемых записей.
      Предыдущие два уравнения применимы в случае, когда все  страницы
заполнены только на половину. В среднем случае, PageSize  будет  иметь
фактор мультипликации 0.75 ( то есть заполнены на три  четверти).  Это
количество следующее:

             D= 1.5 x E x (KeySize+5)+((4xE)/PageSize)

Описание:      const PageStackSize = { целое, 3...254};

Назначение:   PageStackSize   задает   размер   буфера   страницы    -
максимальное число страниц B+ дерева которое можно  держать  в  памяти
одновременно; причем минимальное число - три.

Замечания: В общем, увеличение PageStackSize повышает скорость  работы
системы, так как вероятность что необходимая страница будет  в  памяти
увеличивается. Обычно, PageStackSize принимается от 16 до 32,  однако,
ресурсы вашей системы могут потребовать  других  значений.  Количество
байт M, занимаемых в памяти буфером страниц Turbo Pascal Access будет:

           M= ((MaxKeyLen+5)xPageSize+10)xPageStackSize

      Где:  MaxKeyLen  наибольшая   длина  ключа
            используемая обрабатываемыми нндексными файлами, и
            PageStackSize  максимальное  число страниц которые
            можно  держать  в  памяти  одновременно.  (Причем
            минимальное число - три.)

     Очень трудно предложить общий метод  для  вычисления  оптимальных
значений PageSize и PageStackSize. PageSize обычно принимается  равным
значению от 16 до 32, в зависимости от максимального размера  ключа  и
количества ключей в  индексном  файле.  Меньшие  значения  приводят  к
более плохой работе из за большого времени поиска, и большие  значения
требуют слишком много памяти для стека буфера страницы.
     Минимальным  разумным   значением   для   PageStackSize   являеся
значение MaxHeight. Если PageStackSize меньше чем  MaxHeight,  одну  и
ту  же  страницу  придется  читать  несколько  раз  для  того,   чтобы
просмотреть B+ дерево последовательно.  Вообще,  PageStackSize  должен
быть  как  можно  большим  (насколько  позволяют  ресурсы  памяти).  В
частности, если PageStackSize намного больше  чем  MaxHeight,  система
доступа Turbo Pascal Access может хранить в памяти  корневую  страницу
и содержимое первого уровня B+ дерева, уменьшая  количество  обращений
к диску необходимое для поиска ключа.
     Значения для PageSize и  PageStackSize  зависят  от  значения  E,
общего количества элементов в дереве. Если есть E элементов в  дереве,
то количество просматриваемых страниц K, где

              K =  Log(E)/Log(PageSise  x  0.5).

     Например, если E равно 100000 и PageSise равно 16, K равно 5.  То
есть при поиске в память будет считано максимум 5 страниц. В  процессе
ввода, могут потребоваться дополнительные  страницы  из  за  разбиения
страниц, и потребуются значение большее чем K.
     Программа   TBUild   позволит   вам   варьировать   PageSize    и
PageStackSize  для  оценки  эффективности   использования   памяти   и
эффективности поиска.
     В следующем списке программы Turbo  Pascal  Access  сгруппированы
по  функциям  в  следующие  разделы:  Инициализация   набора   данных,
Модификация  набора  данных,  Извлечение  данных  из  набора   данных,
Инициализация файла данных, Модификация  файла  данных,  Инициализация
индексного файла, Модификация  индексного  файла,  Поиск  в  индексном
файле. Приводятся описание для каждой процедуры  и  номер  страницы  в
справочнике.

2.Процедуры и функции входящие в систему Turbo Pascal Access.
-------------------------------------------------------------

Описание:   procedure AddKey(var IndexF : ndexFile;
                             var DataRef: longint;
                             var Key);

Параметры: IndexF : индексный файл в который должен быть добавлен ключ
           DataRef: связанный с ключем номер записи данных
               Key: ключевая строка

Назначение:  AddKey  добавляет  ключевую  строку  в  индексный   файл.
DataRef обычно номер  записи  файла  данных  возвращаемый  AddRec.  На
выходе, флаг OK устанавливается в True если  ключевая  строка  успешно
добавлена. OK возвращает False усли вы пытаетесь добавить  дублирующий
ключ когда такие ключи  не  разрешены  (  это  бывает  когда  параметр
Status в вызове OpenIndex или MakeIndex равен 0)

Ограничения: Так как Key является параметром с  неопределенным  типом,
вы можете передавать в AddKey строковые переменные  любого  строкового
типа.  Однако,  вы  должны   гарантировать   что   параметр   является
параметром  строкового  типа;  константы  и  строковые  выражения   не
разрешены. Если параметр Key длиннее чем максималиная длина ключа  для
IndexF, он отсекается до максимальной длины.

Смотри также: AddRec,DeleteKey,FlushIndex,MakeIndex,OpenIndex

Пример: Эта  программа  включает  кодовую  строку  и  номер  записи  в
индексный файл CodeIndexF:

              var
                CodeIndex    : IndexFile;
                RecordNumber  : longint;
                CustCodeStr  : CodeStr;
              begin
              .{Программа для открытия IndexFile и добавления записи}
              .
              .
                AddKey(CodeIndex,RecordNumber,CustCodeStr);
              end;

Описание:  procedure AddRec(var DatF  : DataFile;
                            var DataRef : longint;
                            var Buffer);

Параметры: DatF: переменная файла данных в который добавляется запись
        DataRef: номер записи данных
        Buffer : переменная содержащая добавляемую запись данных

Назначение: AddRec добавляет новую запись в файл данных  Turbo  Pascal
Access.  Эта  процедура  возвращает   номер   записи   данных   нового
местоположения записи данных используя  переменный  параметр  DataRef.
DataRef должен быть  передан  в  процедуру  AddKey  когда  вы  вводите
значение ключа для записи данных.

Примечания:  Так  как  Buffer  является  параметром  с  неопределенным
типом, AddRec принимает на это место любую переменную. Вам  необходимо
быть уверенным, что передаваемая переменная надлежащего  типа.  AddRec
не возвращает переменную состояния  OK.  Она  возвращает  только  если
запись данных добавлена в файл  успешно.  Если  при  вв/вв  произойдет
ошибка, NfIOcheck возьмет управление и завершит выполнение  программы.
Если доступна какая нибудь ранее удаленная  запись,  то  до  того  как
расширить файл система автоматически заполнит это место новой записью

Смотри также: AddKey,DeleteRec,FlushFile,GetRec,FileLen

Пример: Эта программа записывает CustomerRecord в  файл  CustomerFile,
и возвращает местоположение записи в переменной RecordNumber:

                    var
                     CustomerFile  :  DataFile;
                     RecordNumber  :  longint;
                     CustomerRecord :  CustomerRecordType;

                    begin
                   .{Программа открывает файл данных и вводит информацию}
                   .
                   .
                      AddRec(CustomerFile,RecordNumber,CustomerRecord);
                    end;

Описание: procedure ClearKey(var IndexF : IndexFile);

Параметры IndexF: индексный файл который подготовлен для
                  последовательной обработки начинающейся с
                  начала или конца.

Назначение:  ClearKey  устанавливает  указатель  индексного  файла   в
начало или конец IndexF.

Примечания: Следующий за вызовом  ClearKey  вызов  NextKey  возвращает
первую запись индексного файла, и вызов  PrevKey  возвратит  последнюю
запись индексного файла. Когда  индексный  файл  Turbo  Paskal  Accass
обрабатывается последовательно,  имеет  место  следующаяя  циклическая
структура.  Когда  указатель  индексного  файла  находится   в   конце
последовательности,  запрос   на   чтение   следующей   записи   будет
возвращать первую запись в файле. Также,  когда  указатель  индексного
файла  находится  в  начале  последовательности,  запрос   на   чтение
предыдущей записи будет возвращать последнюю запись в файле.

Смотри также:  NextKey,PrevKey.

Пример: эта программа устанавливает уразатель  поиска  на  первую  или
последнюю запись в CodeIndex:

                            var
                              CodeIndex  : IndexFile;
                            begin
                              { программа инициализации}
                              ClearKey(CodeIndex);
                            end;

Описание: procedure  CloseFile(var DatF  : DataFile);

Параметры:    DatF:  файл данных который необходимо закрыть

Назначение:   CloseFile закрывает файл данных

Примечания: Если вы делаете какие либо изменения файла данных,  всегда
вызывайте CloseFile  для  этого  файла  до  того  как  ваша  программа
закончит работу. Иначе данные будут потеряны. Полезно  закрывать  файл
даже если он не был модифицирован.

Смотри также:  MakeFile,OpenFile

Пример: Эта программа закрывает файл данных базы данных Customer File:

                            var
                             CustomerFile  : DataFile
                            begin
                               { текст программы }
                             CloseFile(CustomerFile)
                             .
                             ..
                             end;

Описание:  procedure  CloseIndex(var IndexF  : IndexFile);

Параметры:  IndexF: индексный файл который необходимо закрыть

Назначение: CloseIndex закрывает индексеый файл

Примечания: Если вы делаете  какие  либо  изменения  индексного  файла
всегда  вызывайте  CloseIndex  для  этого  файла  до  того  как   ваша
программа закончит работу. Полезно закрывать файл даже если он не  был
модифицирован.

Смотри также:  OpenIndex

Пример:  Эта программа закрывает индексный файл CodeIndex:

                            var
                              CodeIndex  :  IndexFile;
                            begin
                             { текст программы main }
                             CloseIndex(CodeIndex);
                            end;

Описание: procedure DeletKey(var IndexF  :  IndexFile;
                             var DataRef :  longint;
                             var Key);

Параметры: IndexF: Индексный файл из которого удаляется ключ
          DataRef: номер записи данных связанный с удаляемым ключем
              Key: удаляемый ключ

Назначение: DeletKey удаляет ключ из индексного  файла  системы  Turbo
Pascal Accass. На выходе, OK устанавливается в True если  ключ  удален
успешно. OK будет  установлен  в  False  если  ключ  не  найден.  Если
дублирование ключей  разрешено,  OK  будет  установлен  в  False  если
соответствующий ключу номер  записи  не  найден,  даже  если  ключевая
строка существовует.

Ограничения: Если дублирование ключей в индексном файле не  разрешено,
не DataRef не нуждается  в  инициализации.  Если  дублирование  ключей
разрешено, DeletKey нуждается в записи данных для того чтобы  отличать
ключи друг от друга. Для того чтобы определить  номер  записи  данных,
вы  можете,  например,  использовать  SearchKey  вместе  с  NextKey  и
PrevKey. DataRef всегда  возвращает  номер  записи  данных  удаленного
ключа.

Ограничения: Параметр Key должен быть строковой  переменной.  Если  он
длиннее чем максимальная длина ключа  для  IndexF,  он  отсекается  до
максимальной длины.

Смотри также: DeleteRec,FlushIndex,NextKey,PrevKey,SearchKey

Пример: Эта программа удаляет  ключевую  строку  из  индексного  файла
Index:

                          var
                              CodeIndex  :  IndexFile;
                              RecordNumber:  longint;
                              CustCodeStr :  CodeStr;
                          begin
                             { программа удаления ключа}
                            DeleteKey(CodeIndex,RecordNumber,CustCodeStr);
                            if not OK then
                            riteln('Could not delete 'CustCodeStr);
                          end;

Описание:  procedure DeletRec(var DatF  : DataFile;
                                 DataRef: longint);

Параметры:    DatF:  Файл данных из которого удаляется запись
           DataRef:  номер записи данных

Назначение: DeletRec удаляет запись данных  из  файла  данных  системы
Turbo Pascal Accass.

Замечания: Номер  записи  DataRef  может  быть  получен  от  одной  из
следующих  процедур:  DelrteKey,  NextKey,  PrevKey,   SearchKey   или
FindKey. Запись включается список удаленных записей данных, для  того,
чтобы  процедура  AddRec  заполнила  место  удаленных  записей  новыми
записями до расширения файла данных.

Смотри также:  AddRec,DeleteRec,FlushFile

Пример:  Эта  прграмма  удаляет   запись   базы   данных   с   номером
RecordNumber из файла данных CustomerFile:

                           var
                           CustomerFile : DataFile;
                           RecordNumber : longint;
                           CodeFile : IndexFile;
                           CustCodeStr : CodeStr;
                           ....
                           begin
                            DeleteKey(CodeFile,RecordNumber,CustCodeStr);
                            if OK then
                              DeletRec(CustomerFile,RecordNumber);
                           end;

Описание:  procedure EraseFile (var DatF : DataFile);

Параметры: DatF: Переменная удпляемого файла

Назначение: Закрывает DatF и удаляет его.

Замечания: На ранних стадиях разработки  ваших  программ  обслуживания
базы данных, иногда удобно иметь свою программу удаления  испорченного
файла данных при фатальных ошибках.

Смотри также:  CloseFile,EraseIndex

Пример: Эта  прграмма  удаляет  открытый  файл  данных  системы  Turbo
Pascal Accass определенный как CustFile.

                            EraseFile(CustFile);

Описание: procedure EraseIndex (var IndexF : IndexFile);

Параметры:  IndexF : переменная удаляемого индексного файла

Назначение:  Закрывает IndexF и удаляет его.

Замечания: На ранних стадиях разработки  ваших  программ  обслуживания
базы данных, иногда удобно иметь свою программу удаления  испорченного
индексного  файла  при  фатальных  ошибках.  Эта   программа   удаляет
открытый индексный файл определенный как CodeIndex

Смотри также: CodeIndex,EraseFile

Пример:   EraseIndex(CodeIndex);

Описание:   function FileLen(var DatF : DataFile) : longint;

Параметры:  DatF - файл данных в котором определяется
                   количество записей

Назначение: FileLen возвращает количество записей  данных  находящихся
в файле заданном DatF.

Замечания:   Длина   возвращаемая    функцией     FileLen     включает
зарезервированную запись в начале файла  (  запись  0  ),  как  и  все
удаленные записи.

Смотри также:  AddRec,UsedRecs

Пример:  Эта  программа   присваивает   переменной   NumOfRecs   общее
количество записей в файле CustomerFile:

                        var
                       CustomerFile  :  DataFile;
                       CustomerRecord : record
                                Status : longint;
                                Name  : string;
                                     .
                                     .
                                     .
                                end;
                     begin
                      Write('файл данных содержит ');
                      Write(FileLen(CustomerFile)*SizeOf(CustomerRecord));
                      Writeln('байт');
                     end;

Описание:  procedure FindKey(var IndexF : IndexFile;
                             var DataRef  : longint;
                             var Key);

Параметры: IndexF - просматриваемый индексный файл.
          DataRef - номер записи данных связанной с найденным ключем.
              Key - Искомая ключевая строка.

Назначение: FindKey возвращает номер записи данных связанныой с ключем

Замечания: FindKey определяет местонахождение  содержимого  индексного
файла точно соответствующего строке переданной  в  качестве  ключевого
параметра. Если индексный файл содержит дублируюшиеся  ключи,  FindKey
всегда находит первый ключ. На выходе, OK устанавливается в True  если
соответствующий ключ найден. В противном случае OK  устанавливается  в
False. Поле ключа в процедуре FindKey является переменным  параметром.
Если вы ищете  покупателя  с  фамилией  Smith,  и  индекс  не  найден,
глобальная переменная OK устанавливается  в  False,  и  значение  Name
pазрушается ( фактически  устанавливается  значение  последнего  ключа
считанного  из  индексного  файла).   Всегда   используйте   временную
переменную в ваших программах поиска, если  вы  не  хотите  чтобы  она
изменилась.

Ограничения: Ключевой параметр должен быть строковой переменной.  Если
он длиннее чем максимальная длина ключа для IndexF,  он  будет  усечен
до MaxKeyLen.

Смотри также:  NextKey,PrevKey,SearchKey

Пример: Эта программа находит номер записи  RecordNumber  связанный  с
именем.

                            Write('Введите имя для поиска: ');
                            Read(Name);
                            Scratch := Name;  { временная переменная того
                                                      же типа что и Name}
                            FindKey(IndexF, DataRef, Scrath);
                            if not OK then
                            Writeln(' - Извините, Я не могу найти', Name);

Описание:  Procedure FlushFile(var DatF : DataFile);

Параметры: DatF: пополняемый новыми данными файл данных.

Назначение: Записывает последние  изменения  в  файле  данных  системы
Turbo Pascal Accass на диск.

Замечания:  Обычно,  большинство  текущих  изменений  в  файле  данных
системы Turbo Pascal Accass держится в памяти для скорости,  и  только
тогда  записывается  на  диск,  когда  файл  закрывается.  Если   ваша
программа вылетела по  ошибке  выполнения,  перезагрузке  системы  или
сбою  по  питанию  до  того  как  вы  закрыли  свои  файлы,  некоторые
изменения в файле могут быть не записаны на диск. Для разрешения  этой
проблемы, вы можете вызвать  FlushFile  после  совершения  каких  либо
изменений в вышем файле данных. Вы  можете  записать  на  диск  данные
после каждого изменения, после определенного количества изменений  или
через интервалы времени  в  зависимости  от  исполнения  и  требований
безопасности ваших приложений. Вы можете исполизовать FlushFile  после
обращений  к  следующим   процедурам   доступа:   AddRec,   DeleteRec,
MakeFile, PutRec.

Смотри также:  FlushIndex

Пример: Эта программа сбрасывает  изменения  в  файл  CustomerFile  на
диске.
              var
              CustomerFile : DataFile;
              ....
              brgin
              ....
              AddRec(CustomerFile, R, CustRec);
              FlushFile(CustomerFile);
              end;

Описание:   procedure FlushIndex(var IndexF : IndexFile);

Параметры: IndexF: пополняемый новыми данными индексный файл.

Назначение: Записывает последние изменения в индексном  файле  системы
Turbo Pascal Accass на диск.

Замечания: Обычно, большинство текущих  изменений  в  индексном  файле
системы Turbo Pascal Accass держится в памяти для скорости,  и  только
тогда  записывается  на  диск,  когда  файл  закрывается.  Если   ваша
программа вылетела по  ошибке  выполнения,  перезагрузке  системы  или
сбою  по  питанию  до  того  как  вы  закрыли  свои  файлы,  некоторые
изменения в файле могут быть не записаны на диск. Для разрешения  этой
проблемы, вы можете вызвать FlushIndex  после  совершения  каких  либо
изменений в вышем индексном файле. Вы можете записать  на  диск  после
каждого изменения, после определенного количества изменений или  через
интервалы  времени  в   зависимости   от   исполнения   и   требований
безопасности  ваших  приложений.  Вы  можете  исполизовать  FlushIndex
после обращений к следующим  процедурам  доступа:  AddKey,  DeleteKey,
MakeIndex.

Смотри также:  FlushFile.

              Пример       Эта программа сбрасывает изменения в файле
                            CodeIndex на диск:
              ...
              var
              CodeIndex : IndexFile;
              ...
              begin
              ...
              AddKey(CodeIndex, R, CodeKey);
              FlushIndex(CodeIndex);
              end;

Описание:  procedure GetRec( var DatF : DataFile;
                              DataRef : longint;
                             var Buffer);

Параметры:  DatF : файл данных из которого производится чтение
         DataRef : номер записи данных.
         Buffer  : переменная в которую производится считывание

Назначение:  GetRec считывает определенную запись данных в память.

Замечания: Так как Buffer является параметром с неопределенным  типом,
GetRec будет назначать на это место любую переменную.  Вам  необходимо
быть  уверенным,  что  передаваемая  переменная  является   переменной
надлежащего типа.

Внимание: Если Buffer меньше чем размер записи  в  DataF,  могут  быть
испорчены другие переменные или код .

Смотри также:  AddRec, DeleteRec, PutRec.

Пример:  Эта  программы  выгружает  запись  с  данными   базы   данных
CustomerRecord из CustomerFile:

              var
              CustomerFile  :  DataFile
              RecordNumber  :  longint
              CustomerRecord:  CustRecordType;

              begin
                Write('Введите номер записи ');
                Readln(RecordNumber);
                GetRec(CustomerFile,RecordNumber,CustRec);
              end;

Описание:  procedure MakeFile(var DatF : DataFile;
                                 FileN : string;
                                 RecLen: integer);

Параметры: DatF - файл данных который подготавливается к доступу
          FileN - строка содержашая определенное имя образуемого
                  файла данных.
         RecLen - длина записи в байтах.

Назначение: MakeFile создает новый файл данных  и  подготавливает  его
для обработки. На выходе OK устанавливается в True если  файл  успешно
создан. Если OK False, это значит, что  недостаточно  места  на  диске
или в директории для нового файла, или диск защищен от записи.

Ограничения: Минимальная длина записи для RecLrn 18 байт.  Используйте
функцию SizeOf(ваша переменная записи) при передаче параметра RecLen.

              Смотри также  CloseFile
                            FlushFile
                            OpenFile

Пример: Эта программа создает файл данных  базы  данных  для  хранения
записей типа и размера переменной CustomerRecord:

              var
               CustomerFile  : DataFile;
               CostomerRecord : CustRecType;
              begin
              MakeFile(CustomerFile,'CUSTFILE.DAT',SizeOf(CustomerRecord));
              if not OK then
                Writeln('Невозможно создать CUSTFILE.DAT');
              end;

Описание:  procedure MakeIndex(var IndexF : IndexFile;
                                    FileN : FileName;
                            KeyLen, Status: integer);

Параметры: IndexF - индексный файл который подготавливается к доступу
            FileN - строка содержашая определенное имя
                    образуемого индексного файла.
           KeyLen - макасимальная длина ключевой строки
                    хранимой в этом файле.
           Status - NoDuplicates (это константа системы Turbo Accass)
                    показывает, что дублированные ключи не разрешены;
                    Duplicates показавает, что дублирование ключей
                    разрешено.

Назначение: MakeFile создает новый  индексный  файл  и  подготавливает
его для обработки. На выходе  OK  устанавливается  в  True  если  файл
успешно создан. Если OK False, это значит, что недостаточно  места  на
диске или в директории для нового файла, или диск защищен от записи.

Смотри также: CloseIndex, FlushIndex, OpenIndex.

Пример: Эта программа создает индексный файл CodeIndex без  разрешения
дублирования   ключей.   Константа   Turbo     Accass     NoDuplicates
устанавливается в ноль.

              var
                CodeIndex  :  IndexFile;
                CodeString :  CustCodeStr;
              begin
                MakeIndex(CodeIndex,'CODEFILE.NDX',SizeOf(CodeString) -1,
                          NoDuplicates);
                if not OK then
                  Writeln('Невозможно создать файл CODEFILE.NDX');
              end;

Описание:  procedure NextKey(var IndexFile : IndexFile;
                             var DataRef: longint;
                             var Key);

Параметры: IndexFile : индексный  файл  который  был  подготовлен  для
                       последовательной обработки вызовами FindKey,
                       SearchKey или ClearKey
              DataRef: ссылка на данные связанные с ключем.
                 Key : ключ считанный из следующей записи индексного
                       файла.

Назначение:  NextKey  возвращает  ссылку  на   данные   связанные   со
следующим ключем в индексном файле. NextKey также возвращает  значение
ключа в  параметре  Key.  На  выходе,  OK  устанавливается  True  если
следующий индекс существует.  В  противном  случае  устанавливается  в
False ( 'Это бывает когда указатель в конце  индексного  файла),  если
процедура NextKey будет вызвана снова, то она возвратит первую  запись
в индексном файле.

Ограничения: До первого обращения  к  процедуре  NextKey  для  данного
индексного файла или после модификации  индексного  файла  процедурами
AddKey или DeleteKey, должна быть  вызвана  одна  из  других  процедур
поиска  (кроме  PrevKey).  Функции  поиска  устанавливают   внутренний
указатель  используемый  NextKey  и   PrevKey   для   последовательной
обработки.

Смотри также: AddKey,Clearey,DeletKey,FindKey,PrevKey,SearchKey.

Пример: Эта  программа  возвращает  номер  записи  и  ключевую  строку
следующего ключа при последовательном поиске:

                          var
                            CodeIndex   : IndexFile;
                            RecordNumber : longint;
                            CustCodeStr  : CodeStr;
                          begin
                            NextKey(CodeIndex,RecordNumber,CustCodeStr);
                          end;

Описание:    procedure OpenFile(var DatF  : DataFile;
                                    FileN : FileName;
                                   RecLen : integer);

Параметры:   DatF : Файл данных подготавливаемый к доступу.
            FileN : Строка определяющая  имя  файла  существующего  на
                    диске
           RecLen : длина записи в байтах

Назначение:   OpenFile   открывает   существующий   файл   данных    и
подготавливает его для  обработки  программами  системы  Turbo  Pascal
Access.

Ограничения: Длина записи RecLen  должна  быть  такой  же  что  и  при
создании файла. На выходе, OK устанавливается в True если файл  найден
и открыт успешно. В противном случае, OK устанавливается в False.

Смотри также: CloseFile,MakeFile.

Пример: Эта программа открывает файл данных базы данных  для  хранения
записи с типом и размером CustimerRecord:

              var
                CustomerFile  : DataFile;
                CustimerRecord: CustRecType;
              begin
               OpenFile(CustomerFile,'CUSTFILE.DAT',SizeOf(CustimerRecord));
               if not OK then
                Writeln('Невозможно открыть CUSTFILE.DAT');
              end;

Описание:   procedure OpenIndex(var IndexF  : IndexFile;
                                      FileN : FileName;
                                     KeyLen : integer;
                                     Status : integer);

Параметры: IndexF: индексный файл подготавливаемый к доступу.
            FileN: Строка определяющая имя файла существующего на диске.
           KeyLen: максимальная длина ключевых строк хранимых в этом
                   файле
           Status: NoDuplicates (это константа системы
                   Turbo Accass) показывает, что дублированные
                   ключи не разрешены; Duplicates показавает, что
                   дублирование ключей разрешено.

Назначение:  OpenIndex  открывает  существующий   индексный   файл   и
подготавливает его для  обработки  программами  системы  Turbo  Pascal
Access. На выходе, OK  устанавливается  в  True  если  файл  найден  и
открыт успешно. В противном случае, OK устанавливается в False.

Смотри также: CloseIndex,InitIndex,MakeIndex.

Пример:  Эта  программа  открывает  индексный   файл   Codeindex   без
разрещения     дублирования     ключей,     константа     NoDuplicates
устанавливается в ноль:

              var
              CodeIndex  : IndexFile;
              CodeString : CodeStr;
              begin
                OpenIndex(CodeIndex,'CODEFILE.NDX',SizeOf(CodeString) -1,
                          NoDuplicates);
              if not OK then
                Writeln('Невозможно открыть файл CODEFILE.NDX');
              end;

Описание:   procedure PrevKey(var IndexF : IndexFile;
                              var DataRef: longint;
                              var Key);

Параметры:  IndexF : индексный файл который был
                     подготовлен для последовательной обработки
                     вызовами FindKey, SearchKey или ClearKey
            DataRef: ссылка на данные связанные с ключем.
                Key: ключ считанный из предыдущей записи
                     индексного файла

Назначение: PrevKey возвращает ссылку на данные связанные с  прдыдущим
ключем в индексном файле. PrevKey также возвращает  значение  ключа  в
параметре Key.

Ограничения:  На  выходе,  OK  устанавливается  True  если  предыдущий
индекс существует. В противном случае устанавливается в False  (  'Это
бывает когда указатель в  начале  индексного  файла),  если  процедура
NextKey будет вызвана снова,  то  она  возвратит  последнюю  запись  в
индексном файле. До первого обращения к процедуре PrevKey для  данного
индексного файла или после модификации  индексного  файла  процедурами
AddKey или DeleteKey, должна быть  вызвана  одна  из  других  процедур
поиска  (кроме  NextKey).  Функции  поиска  устанавливают   внутренний
указатель  используемый  NextKey  и   PrevKey   для   последовательной
обработки.

Смотри также: ClearKey,FindKey,NextKey,SearchKey

Пример: Эта  программа  возвращает  номер  записи  и  ключевую  строку
следующего ключа при последовательном поиске:

                          var
                            CodeIndex   : IndexFile;
                            RecordNumber : longint;
                            CustCodeStr  : CodeStr;
                          begin
                            PrevKey(CodeIndex,RecordNumber,CustCodeStr);
                          end;

Описание:    procedure PutRec(var DatF  : DataFile;
                                DataRef : longint;
                              var Buffer);

Параметры:   DatF : Фвйл данных в которфй заносится запись
           DataRef: Номер записи данных
           Buffer : Переменная содержащая данные для записи

Назначение: PutRec пишет запись данных в  определенную  позицию  файла
данных.

Замечания: Так как Buffer является параметром с неопределенным  типом,
PutRec будет назначать на это место любую переменную.  Вам  необходимо
быть  уверенным,  что  передаваемая  переменная  является   переменной
надлежащего  типа.  Buffer  передается  как  переменный  параметр  для
сохранения памяти.

              Смотри также AddRec
                           DeleteRec
                           FlushRec
                           GetRec

Пример: Эта программа пишет CustomerRecord в  определенную  позицию  в
файле CustomerFile:

              var
              CustomerFile  :  DataFile
              RecordNumber  :  longint
              CustomerRecord:  CustRecordType;

              begin
                PutRec(CustomerFile,RecordNumber,CustomerRecord);
              end;

Описание:     procedure SearchKey(var IndexFile : IndexFile;
                                  var DataRef : longint;
                                  var Key);

Параметры:   IndexFile : индексный файл в котором производится поиск
               DataRef : ссылка на данные связанные с ключем.
                   Key : ключевая строка для поиска

Назначение: SearchKey  возвращает  номер  записи  данных  связанной  с
первой записью индексного файла которая равна или больше чем  заданное
ключевое значение. OK всегда устанавливается на  выходе  в  True  если
есть ключи большие или равеные ключу поиска. Если таких ключей нет  OK
устанавливается в False.

Замечания.   Процедура   SearchKey   может   быть   использована   для
определения местоположения записи в  индексном  файле  когда  известна
только первая часть ключевого значения. Если индексный  файл  содержит
дублированные ключи, процедура SearchKey всегда ноходит  первый  ключ.
Ключевое поле  процедуры  SearchKey  является  переменным  параметром.
Если вы ищете фамилию Smith

              SearchKey(IndexF,DataRef,Name);

и ключ не найден, клобальная переменная OK устанавливается в False,  и
значение Name разрущается (оно обычно  принимает  значение  последнего
ключа считанного из индексного файла).  Всегда  используйте  временную
переменную (или  параметр)  в  ваших  программах  поиска  если  вы  не
желаете изменения переменной.

Ограничения: Ключ должен быть строковой переменной. Если  она  длиннее
чем максимальной длины ключа для файла IndexF, она  будет  усечена  до
максимальной длины.

Смотри также:  AddKey,ClearKey,DeleteKey,FindKey,NextKey,PrevKey.

Пример: Эта программа находит все имена начинающиеся на S:

              repeat
                 Name:='S';
                 SearchKey(IndexF,DataRef,Name);
                 if OK then
                   Writeln(Name);
              until not OK;

Описание:    procedure TAClose(var DatSet : DataSet);

Параметры:   DatSet: закрываемый набор данных

Назначение:  TAClose закрывает ранее открытый набор данных.

Ограничения:  Очень  важно  до  завершения  работы   вашей   программы
закрывать набор данных который вы открыли. Если вы не сделаете  этого,
индексный файл может быть испорчен, и вы можете потерять данные.

Пример:      Taclose(Customers);

Описание:    procedure TACreate(var DatSet  : DataSet;
                                    DatFName: FileName;
                                   RecordLen: integer;
                                  IndexFName: FileName;
                                    KeyLen  : integer);

Параметры: DatSet: Открываемый набор данных. Этот параметр может  быть
                   использован для всех вызовов верхнего уровня.
         DatFName: Имя файла данных.
        RecordLen: размер записей в файле данных.
       IndexFName: Имя индексного файла.
           KeyLen: размер ключа.

Назначение:  TACreate создает и открывает набор данных
(то есть файл данных и связанный с ним индексный файл).

Смотри также: TAFlush.

              Пример TACreate(Customers,'CUSTOMERS.DAT', SizeOf(CustRec),
                             'CUSTOMERS.NDX', SizeOf(CodeStr) -1);

Описание:  procedure TADelete(var DatSet : DataSet; var Key);

Параметры:   DatSet: набор данных содержащий ключ и связанную с ним
                     запись данных подлежащий удалению.
                Key: ключ к записи которую вы желаетн удалить.

Назначение: TADelete удаляет указанный ключ и связанную с  ним  запись
данных. Если ключ не найден, OK устанавливается в False

Смотри также: TAFlush.

              Пример    TADelete(Customers,CustomerCode);
                         if OK then
                           Writeln('Запись и ключ удалены успешно.')
                         else
                           Writeln('Ключ не найден');

Описание:    procedure TAErase(var DatSet : DataSet);

Параметры:   DatSet: набор данных подлежащий удалению.

Назначение:  TAErase закрывает и удаляет открытый набор данных.

Пример:      TAErase(Customers);

Описание:    procedure TAFlush(var DatSet  : DataSet);

Параметры:   DatSet: Набор данных сохраняемый на диск.

Назначение: Записывает на  диск  текущие  изменения  в  наборе  данных
Turbo Pascal Access

Замечания: Обычно,  большинство  текущих  изменений  в  наборе  данных
системы Turbo Pascal Accass держится в памяти для скорости,  и  только
тогда записывается на диск, когда набор данных закрывается. Если  ваша
программа вылетела по  ошибке  выполнения,  перезагрузке  системы  или
сбою по питанию  до  того  как  вы  обратились  к  процедуре  TAClose,
некоторые изменения в файле  могут  быть  не  записаны  на  диск.  Для
разрешения этой проблемы, вы можете вызвать TAFlush  после  совершения
каких либо изменений в вышем наборе  данных.  Вы  можете  записать  на
диск данные после каждого изменения,  после  определенного  количества
изменений или через интервалы времени в зависимости  от  исполнения  и
требований  безопасности  ваших  приложений.  Вы  можете  исполизовать
TAFlush  после  обращений  к  следующим  процедурам  доступа  верхнего
уровня: TACreate,TADelet,TAInsert,TAUpdate,TAWrite.

Пример: Эта программа сбрасывает на диск все изменения в Customers:

              var
              Customers : DataSet;
              ....
              begin
              ....
              TAInsert(Customers, CustRec, SearchCode);
              TAFlush(Customers);
              end;

Описание:    procedure TAInsert(var DatSet : DataSet;
                                var CurRec,Key);

Параметры:   DatSet: набор данных в который вы добавляете ключ и запись.
             CurRec: добавляемая запись
                Key: ключ к записи которую вы желаете добавить.

Назначение: TAInsert записывает запись и  ключ  для  ссылки  к  набору
данных.  TAInsert  бедет  добавлять  запись  данных  только  если   не
существует ранее введенной записи с таким же ключем. Если  такой  ключ
существует, OK устанавливается в False.

Смотри также: TAFlush,TAUpdate,TAWrite.

Пример:
       TAInsert(Customers, CustRec, CustCode);
       if not OK then
         Writeln ('Нельзя добавить данные ,'CustCode' уже существует.');

Описание:    procedure TANext (var DatSet : DaraSet;
                               var CurRec,Key);

Параметры:   DatSet: ссылка на набор данных.
             CurRec: запись данных связанная со следующим ключем
                Key: возвращается процедурой TANext. Это новый
                     текущий ключ, первый ключ следующий за старым
                     текущим ключем.

Назначение: TANext продвигает указатель  файла  на  следующий  ключ  в
наборе данных, и возвращает новый ключ для ссылки  на  соответствующую
запись.  Если  OK  возвращает  False,  то  указатель   пересек   конец
индексного файла. Следующее обращение  к  TANext  будет  обращаться  к
началу файла.

Пример:
         TANext(Customers, CustRecord, CustomerCode);
         if not OK then Writeln('Достигнут конец базы данных.');

Описание: procedure TAOpen(var DatSet   : DataSet;
                              DatFName  : string;
                              RecordLen : integer;
                              IndexFName: string;
                               KeyLen   : integer);

Параметры: DatSet: набор данных  подлежащий  открытию.  Этот  параметр
                   может бать использован для всех последующих вызовов
                   верхнего уровня.
        DatFName : имя файла данных.
       RecordLen : размер записей в файле данных.
       IndexFName: имя индексного файла.
          KeyLen : длина ключей в индексном файле

Назначение:  TAOpen открывает ранее созданный набор данных.

Пример:

        TAOpen(Customers, 'CUSTOMERS.DAT', SizeOf(CustRec),
                              CUSTOMERS.NDX', SizeOf(CodeStr) -1);
        if not OK then Writeln('Невозможно открыть набор данных");

Описание:    procedure TAPrev (var DatSet : DaraSet;
                               var CurRec,Key);

Параметры:   DatSet: ссылка на набор данных.
             CurRec: запись данных связанная с предыдущим ключем
                Key: возвращается процедурой TAPrev. Это новый
                     текущий ключ, первый ключ до старого текущего
                     ключа.

Назначение: TAPrev продвигает указатель файла  на  предыдущий  ключ  в
наборе данных, и возвращает новый ключ для ссылки  на  соответствующую
запись.  Если  OK  возвращает  False,  то  указатель  пересек   начало
индексного файла. Следующее обращение  к  TANext  будет  обращаться  к
концу файла.

Пример:
      TAPrev(Customers, CustRecord, CustomerCode);
      if not OK then Writeln('Достигнуто начало базы данных.');

Описание:   procedure TARead(var DatSet  :  DataSet;
                             var CurRec, Key;
                               FindExact : boolean);

Параметры:  DatSet: просиатриваемый набор данных
            CurRec: возвращаемая запись.
               Key: ключ записи которую вы желаете считать.

Назначение:  FindExact  показавает  должен  ли  TARead  искать  точное
соответствие переданному ключу. Если FindExact установлен в False,  вы
можете использовать TARead возвращать  записи  когда  известна  только
первая часть ключа. FindExact просиатривает набор  данных  для  ключа.
Если  найден   ключ,   загружается   связанная   запись   данных.   OK
устанавливается в False если поиск оказался безуспешным.

Пример:
          LastNameKey := 'S';
          TARead(Names, CurRec, LastNameKey, PartialMatch);
          if not OK then
              Writeln('Не найдены фамилии начинающиеся на S');

Описание:    procedure TAReset(var DatSet : DataSet);

Параметры:   DatSet: набор данных

Назначение:  TAReset  перемещает  указатель  файла  в  начало   набора
данных. Следующее обращение к TAReset или к  TANext  возвратит  первую
запись набора данных, и обращение к TAPrev возвратит последнюю  запись
в наборе данных.

Пример:      TAReset(Customers);

Описание:      procedure TAUpdate(var DatSet : DataSet;
                                 var CurRec,Key);

Параметры:     DatSet: набор данных
               CurRec: хранит новую запись информации
                  Key: ключ для записи которую вы жалаете
                       модифицировать

Назначение: TAUpdate модифицирует запись  данных  связанную  с  ключем
Key в соответствующем наборе данных на  данные  хранящиеся  в  CurRec.
TAUpdate  модифицирует  только  существующие  записи.  Если  ключ   не
найден, OK устанавливается в False.

Смотри также:  TAFlush,TAInsert,TAWrite.

Пример:      SearchCode := CustCode;
             TAUpdate(Customers, CustRec, SearchCode);
             if not OK then
                 Write('Навозможно модифицировать эту запись,
                       'CustCode,'не найден.');

Описание:      procedure TAWrite(var DatSet : DataSet;
                                 var CurRec,Key);

Параметры:     DatSet: набор данных
               CurRec: хранит новую запись информации
                  Key: ключ для записи которую вы жалаете записать.

Назначение:  TAWrite  записывает  данные   хранящиеся   в   CurRec   в
соответствующий набор  данных  и  связывает  ее  с  ключем  Key,  если
необходимо добавляя  ключ  и  запись  в  набор  данных.  Если  TAWrite
выполняется и  ключ  уже  существует,  старая  запись  будет  заменена
новой. А если ключ не  существует,  запись  с  соответствующим  ключем
будет добавлена в набор данных.

Смотри также:  TAFlush,TAInsert,TAUpdate.

Пример:       TAWrite(Costomers, CustRec, CostomerCode);

Описание:  function UserRecs(var DatF : DataFile) : longint;

Параметры:    DatF : файл данных в котором вычисляется
                     количество записей.

Назначение:  UsedRecs  возвращает  количество  записей  в  файле  DatF
которое включает только полезные пользовательские данные.

Замечания:  В  отличие  от  FileLen,  эта  функция   не   включает   в
возвращаемое значение зарезервированные и удаленные данные.

Смотри также:  AddRec,DeleteRec,FileLen,GetRec,PutRec.

Пример:                 var
                          CustomerFile  : DataFile;
                        begin
                          {программа инициализации файла данных}
                          Write ('В базе данных ');
                          Write (UsedRecs(CustomerFile));
                          Writeln('пользовательских записей');
                        end;
