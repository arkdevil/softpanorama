         Методические материалы для разработки простейших
   систем управления данными на ПЭВМ в среде Turbo Pascal 4.0 - 6.х

----------------------------------------------------------------------
  Подготовил: Штонда Виктор, 252124,Киев-124,а/я 506; (044) 483-60-19.
----------------------------------------------------------------------

                   Содержание
                   ==========

            1. Введение.
            2. Поставляемые файлы.
            3. Как приступить к изучению методических материалов.
            4. Установка системы доступа TURBO  PASCAL  ACCESS.
            5. Некоторые соглашения.
            6. Разработка баз данных.
            7. Структура прикладных программ на Turbo Pascal.

1. Введение.
------------

     Не  будет   преувеличением,   если   сказать,   что   почти   все
программисты  сталкиваются  с  необходимостью  разработки  программных
средств работы с базами данных в  собственных  приложениях  на  языках
высокого уровня  (С,С++,Turbo  Pascal).  Существует  достаточно  много
инструментальных средств, которые позволяли  бы  быстро  и  эффективно
писать такие программы. (Например: для Turbo  Pascal  -  TURBO  PASCAL
Database Toolbox и Paradox  Engine  2.0  фирмы  Borland  Int.;  B-Tree
Filer фирмы TurboPower Software др.).

     Однако, cуществуют  и  определенные  требования  к  программисту,
который для разработки программных  средств  работы  с  базами  данных
должен  быть  знаком  с  основами  произвольного  доступа  к   файлам,
методами  индексации  данных  (для   обеспечения   прямого   доступа).
Рекомендуется также знакомство с  файловой  системой  MS-DOS.  Следует
отметить,  что  на  сегодняшний  день  почти  все  коммерческие   СУБД
реляционного  типа   используют   для   индексации   данных   алгоритм
Байера-Баума  (обычно   известного   как   В+   дерево),   программная
реализация которого сильно влияет  на  скорость  доступа  к  данным  и
быстродействие СУБД.

    На основании  вышеизложенного  представляет  интерес  рассмотрение
вопросов  практического  использования  алгоритма   Байера-Баума   при
создании  автономных  программных   средств   обработки   данных   для
организации  работы  с  базами  данных  на  языках  высокого   уровня.
Использование основных  результатов  теории  стуктур  данных  типа  В+
дерево   и   программнная    реализация     алгоритма     Байера-Баума
рассматривается  на  примере  пакета  TURBO  PASCAL  Database  Toolbox
(реализация алгоритма Байера-Баума именуется TURBO PASCAL ACCESS)  для
Turbo Pascal 4.0 - 6.x.

2. Поставляемые файлы.
----------------------

     B архивном файле DBPascal представлены следующие файлы:

    TAINST.EXE - Программа инсталяции подсистемы доступа TURBO  PASCAL
ACCESS;
    TABUILD.EXE -  программа  конфигурации  подсистемы  доступа  TURBO
PASCAL ACCESS;
    TASIZES.PAS  -  исходный  текст  для  программы,  которая  выводит
максимальный  размер  записи  м  максимальную  длину  ключа  программе
TABUILD;
    TACCESS.PAS - исходный  текст  для  модуля  доступа  TURBO  PASCAL
ACCESS;
    TRAINER.EXE - обучающая программа,  демонстрирующая  использование
B+ деревьев.
    TRAINER.CMD  -  файл   данных,   которые   программа   TRAINER.EXE
использует для построения примера B+ дерева.
    TADEMO.ARC - архивированный  файл,  содержащий  примеры  программ,
демонстрирующих вызовы нижнего уровня системы TURBO PASCAL ACCESS;
    TAHIGH.ARC -  архивированный  файл,  содержащий  примеры  программ
демонстрирующих вызовы верхнего уровня системы TURBO PASCAL ACCESS;
    BTREE.ARC - архивированный файл, содержащий  пример  использования
системы TURBO PASCAL ACCESS для  поддержки  баз  данных  c  элементами
оконного интерфейса.
       *.DOC - файлы с методическими  материалами  по  соответствующим
программам.

3. Как приступить к изучению методических материалов.
-----------------------------------------------------

     Для того, чтобы познакомится с структурой данных типа  B+  дерево
необходимо  запустить  TRAINER.EXE.  Информацию  по  работе   с   этой
программой можно найти в файле TRAINER.DOC.

     Далее,  если  Вы  программист  на   Turbo   Pascal,   Вы   можете
прочувствовать   свойства   B+   дерева   в   работе   (предварительно
откомпилировав примеры использования системы TURBO  PASCAL  ACCESS)  c
программами TADEMO.EXE (или TAHIGH.EXE) и BTREE.EXE.

     Наиболее любознательные программисы  (которые  любят  работать  с
исходным  кодом)  могут  обозреть  программную  реализацию   алгоритма
индексации Байера-Баума  на  примере  известного  (в  прошлом)  пакета
фирмы Borland Int. TURBO PASCAL Database Toolbox 4.0.

4.Установка системы доступа TURBO  PASCAL  ACCESS.
--------------------------------------------------

    Подсистема доступа  Turbo  Pascal  Access  является  инструментом,
который обеспечит вам быстрый доступ, просмотр и  управление  большими
файлами  данных,  используемых  Turbo  Pascal   4.0-6.x   программами.
Откомпилированные юниты - TACCESS.PAS и TAHIGH.PAS  выполняют  функции
управляющих  систем  для  Вашей  базы   данных.   Подсистемы   доступа
использует  ключи  для  быстрой   локализации   записей   данных   без
последовательного просмотра всего файла данных.

    Файлы данных системы доступа Turbo Pascal Access  могут  содержать
до 2  миллиардов  записей,  включая  зарезервированную  запись  и  все
удаленные записи. Только  одна  системная  запись  зарезервирована,  и
место удаленных записей будет повторно использовано до того  как  файл
будет  увеличен.  Это  эффективно  принимая  в  расчет  неограниченный
размер файлов. Размер записи, теоретически,  может  быть  до  64Кбайт.
Однако, такой размер  записи  позволит  хранить  на  жестком  диске  в
10Мбайт  только  150  записей  (без  индексных   файлов).   Жлательно,
стараться  минимизировать  размер  записи  данных  используя  коды   и
аббревиатуры. Хотя большой размер записи не влияет на  время  доступа,
они (большие записи) быстро  заполняют  диски.  Наименьшая  допустимая
запись данных - 18байт, и размер записи данных фиксирован  для  любого
данного файла  данных.  В  отличие  от  обычных  файлов  данных  Турбо
Паскаля, переменные файла данных системы Turbo  Pascal  Access  всегда
описываются   с   использованием   типа   DataFile   (определенном   в
TACCESS.PAS).

    Ваш первый шаг заключается в создании директории  ACCESS,  которая
должна содержать исходный код  утилиты  TACCESS.PAS,  загрузочный  код
процедур  TABuild  (программа  построения  турбо  доступа)  и   TAInst
(процедура  инсталяции  турбо  доступа),   программы   TASIZES.PAS   и
TAHIGH.PAS.

    Запустите  программу  инсталяции  пакета   Turbo   Pascal   Access
TAInst.exe для назначения ACCESS текущей  директорией  и  ввода  ее  в
path вашей директории TURBOPASCAL.  После  этого  добавьте  директорию
ACCESS в path для автоматического поиска каталогов загружаемых  файлов
( DOS Exec path). Добавьте также директорию TURBOPASCAL в  Exec  path,
если до сих  пор  вы  не  сделали  этого.  Это  даст  вам  возможность
вызывать программу конфигурации подсистемы доступа и Турбо Паскаль  из
любой директории вашей системы. Теперь вы можете  создавать  доступ  к
своей собственной базе данных.

5.Некоторые соглашения.
-----------------------

    Мы можем  ссылаться  на  набор  программ  в  TACCЕSS.PAS,  как  на
программы нижнего уровня подсистемы доступа Turbo Pascal Access.  Одни
из процедур и функций  этой  программы  оперируют  с  файлами  данных,
другие  с  индексными  файлами.  Это  предоставляет  высокую   степень
гибкости, так как программист может  организовать  базу  данных  таким
образом, чтобы имелся один файл данных и множество  индексных  файлов.
Это увеличивает гибкость, однако программисту необходимо  обеспечивать
правильную модификацию индексных файлов.

    С помощью вызовов нижнего уровня вы сделать  все  что  возможно  в
рамках системы доступа Turbo Pascal Access. Хотя  они  и  используются
вызовами высокого уровня  (описаны  далее),  есть  несколько  функций,
которые могут делать только вызовы нижнего уровня, такие как:
    - Использование нескольких индексных файлов  для  ссылки  на  один
файл данных;
    - Ассоциирование одного ключа с записями более чем одного файла;
    - Использование дублированных ключей;
    - Использование индексных файлов для указания  чего  нибудь  кроме
записи данных, например массивов.

    Процедуры и  функции  высокого  уровня  подсистемы  доступа  Turbo
Pascal  Access  содержатся  в  файле  TAHIGH.PAS.  Все  эти  программы
оперируют с наборами данных. Набор данных  -  это  логический  модуль,
который состоит из одного файла данных и связанного с  ним  индексного
файла. По существу это простая база данных. Эта модель достаточна  для
организации многих  баз  данных.  Вызовы  высокого  уровня  используют
вызовы нижнего уровня и гарантируют, что при  изменении  файла  данных
соответствующий   ему   индексный   файл   модифицируется   правильно.
Использование вызовов верхнего  уровня  сокращает  трудоемкость  вашей
работы, но  это  не  так  гибко,  как  непосредственное  использование
вызовов нижнего уровня.

6.Разработка баз данных.
------------------------

    Предположим, вы хотите создать специальную базу данных для  поиска
телефонных номеров и другой необходимой  информации.  Первое,  что  вы
должны решить, какая информация о  каждой  персоне  должна  храниться.
Например, вам необходимо хранить следующую информацию:

              Фамилия Имя Отчество
              Название компании
              Номер по списку
              Адрес
              Номер телефона
              Примечания

    Эта информация  образует  одну  запись  данных.  Каждый  отдельный
элемент информации представляет  собой  одно  или  несколько  полей  в
записи. Вы должны определить один или  несколько  ключей,  для  поиска
одной из этих записей. Например, ключ для приведенной  выше  записи  -
код  покупателя,  который  может  быть   представлен   номером   счета
покупателя.

    Желательно создавать  отдельную  директорию  для  каждого  проекта
базы данных, с которой вы  работаете,  поскольку  каждая  база  данных
будет  иметь  свои  собственные  файлы   TACCESS.TPU   и   TAHIGH.TPU.
Созданную директорию необходимо сделать текущей.

    Далее необходимо определить  размер  записей  данных,  которые  вы
собираетесь хранить, а также  размер  самого  большого  ключа  в  базе
данных, а так же некоторые константы, которые определяют требования  к
памяти модуля TACCESS.TPU, сконфигурированнного  для  этой  конкретной
базы данных.

    Для  этого   задайте   определения   типа   записи   и   ключа   в
include-файле. Этот  файл  будет  использован  программой  TABuild.exe
(описанной  в  TABUILD.DOC)  для   создания   как   ваших   специально
сконфигурированных  юнит  TACCESS.PAS  и  TAHIGH.PAS,  так   и   вашей
прикладной программой.

    Для нашей базы данных файл будет выглядеть примерно так:

type
  CodeStr = string[15];     {определение типа для вашего ключа}
  CustRec = record
     RecStatus : longint;  {используется системой доступа}
     CustCode  : CodeStr;  {только наш ключ базы данных}
     EntryDate : string[8];
     FirstName : string[15];
     LastName  : string[30];
     Company  : string[30];
     Addr1    : string[40];
     Addr2    : string[40];
     Phone    : string[40];
     PhoneExt  : string[5];
     Remarcs1  : string[40];
     Remarcs2  : string[40];
     Remarcs3  : string[40];
  end;

MaxDataType = CustRec; {определение типа наибольшей записи данных}
MaxKeyType  = CodeStr; {определение типа наибольшего ключа}

    Как показал пример, неплохая  мысль  устанавливать  свой  тип  для
каждого ключа в базе данных. В этом случае мы будем иметь только  одно
определение типа для всего кода.

    В  описании  записи  объявлено  поле  статуса  записи   RecStatus.
Желательно зарезервировать первые четыре байта в вашей записи  данных.
Это  позволит  вашей  программе  отличать  существующие  и   удаленные
записи, поскольку процедура DeleteRec использует первые  четыре  байта
записи для своих целей. Оставшиеся поля состоят из списка  информации,
которую вы желаете хранить.

    Как  установлено  ранее,  этот  файл  определений  типов  является
include-файлом, который используется программой TABuild.exe.  Так  как
эта программа не знает названий ваших  записей  и  типов  ключей,  вам
необходимо приравнять тип MaxDataType  типу  вашей  наибольшей  записи
данных, и тип MaxKeyType типу вашего наибольшего ключа.

    Теперь вы можете использовать описания записи и  ключа  для  того,
чтобы генерировать константы,  которые  требуются  подсистеме  доступа
для создания своих внутренних  структур  данных.  Вместо  того,  чтобы
считать байты в ваших  записях  и  ключах,  что  утомляет  и  является
источником ошибок,  вы  можете  использовать  программу  TABuild  (см.
TABUILD.DOC).

7. Структура прикладных программ на Turbo Pascal ( на примере вызова
   процедур системы Turbo Pascal  Access высокого уровня).
--------------------------------------------------------------------

    В   большинстве   случаев   ваша   прикладная   программа   будет
использовать систему Turbo Pascal  Access  для  реализации  одной  или
нескольких функций:

              - Добавление записи данных.
              - Извлечение записи данных.
              - Модификация записи данных.
              - Удаление записи данных.

    Кроме  того,  до  обработки  любых  данных,  прикладная  программа
должна  подготовить  (открыть)  необходимые  индексные  файлы  и  файл
данных, и при завершении работы закрыть эти файлы.

    Вызовы верхнего уровня используют вызовы нижнего уровня.  Основное
отличие между ними то, что вызовы  высокого  уровня  обрабатывают  два
файла ( файл данных и  индексный  файл)  одновременно,  таким  образом
отслеживая  присвоение  клчей  номерам  записей.  Все  номера  записей
скрыты вызовами верхнего уровня. В результате, вам  приходится  писать
меньше текста программ чем при непосредственном использовании  вызовов
нижнего уровня.  Все  программы  высокого  уровня  храняться  в  файле
TAHIGH.PAS. Этот модуль  зависит  от  юниты  TACCESS.PAS,  поэтому  вы
должны  сначала  конфигурировать  и  скомпилировать  TACCESS.PAS   как
описано выше. Процедура TABuild автоматически скомпилирует TAHIGH.PAS.

    Ниже приведен скелет демонстрационной  программы  (из  TAHIGH.ARC)
TAHIGH.PAS,  который  демонстрирует  использование  вызовов   высокого
уровня. Обратите внимание,  на  то  что  TAHigh  разрешает  выполнение
процедур низкого уровня.

   program HighLevelDemo;

   { Эта программа демонстрирует использование вызовов высокого
     уровня смстемы Turbo Pascal Access}

   uses Crt, Dos, TAccess, TAHigh;

   ........

   {$I TADEMO.TYP}  {Объявление типа для записи данных и ключа}
    var
        Finish:boolean;
        Customers: DataSet;

        (.............)

    begin
      TAErrorProc := @CleanUp {установка программы обработки
                           фатальных  ошибок для закрытия файлов БД}
      OpenDataSet(Customers);
      Finished := False;
      repeat
        case Menu of
          '1','L': ListCustomers(Customers);
          '2','F': FindCustomer(Customers,ExactMatch);
          '3','S': FindCustomer(Customers,PartialMatch);
          '4','N': NextCustomer(Customers);
          '5','P': PrevCustomer(Customers);
          '6','A': AddCustomers(Customers);
          '7','U': UpdateCustomers(Customers);
          '8','D': DeleteCustomers(Customers);
          '0','E': Finished := True;
            else Write('Coose 0-8;');
         end; {case}
         if not Finished then  Pause;
       until Finished;
       CleunUp;
    end.

    Вы можете установить указатель на одну из  ваших  программ,  таким
образом, чтобы они вызывались  сразу  после  того  как  модуль  Access
обнаружит фатальную ошибку. В этом примере это прпоцедура CleanUp:

              {$F+}
              procedure CleanUp;
              begin
                TAClose((Customers);
              end;
              {$F-}

     В этом случае процедура завершения работу только закрывает  набор
данных. При разработке ваших программ  вы  можете  написать  процедуру
удаления, которая обращаясь к TAErase удаляет наборы данных  в  случае
ошибки.
     После   установки   программы   обработки   ошибок,    необходимо
инициализировать   программу   используя   TAOpen     для     открытия
существующего набора данных или TACreate для  создения  нового  набора
данных.  В  следующем  примере,  эти  вызовы  объединены  в  процедуру
которая открывает набор дпнных если он существует и создает  его  если
он отсутствует.

              procedure OpenDataSet(var Customers : DataSet);
              begin
                TAOpen(Customers,'Customers.dat',SizeOf(CustRec),
                       'Customers.idx',SizeOf(CodeStr)-1);
                if not OK then
                TACreate(Customers,'Customers.dat',SizeOf(CustRec),
                        'Customers.idx',SizeOf(CodeStr)-1);
                if not OK then
                  Abort('Невозможно создать набор данных DataSet');
              end {OpenDataSet}

     Как TACreate так и TAOpen принимают пять аргументов:

              - переменная набора данных типа DataSet
              - имя имя файла данных
              - размер записи данных хранимой в файле данных
              - имя нидексного файла
              - длина ключа хранимого в индексном файле.

      Тип DataSet объявляется в  TAHIGH.PAS,  и  переменная  Customers
должна  быть  объявлена  в  вашей  программе.  Имя  файла   -   строка
удовлетворяющая  соглашению  ОС  о  нормальном   наименовании   файла.
Использование функции  SizeOf  -  лучший  способ  передачи  параметров
размера записи и  ключа  (Заметим  что  для  определения  длины  ключа
используется SizeOf(Key)-1 .
      Несмотря на то, что набор  данных  состоит  из  двух  файлов  на
диске, все последовательные вызовы верхнего уровня  будут  оперировать
только с набором  данных  в  целом,  и  программа  управления  верхним
уровнем будет надлежащим образом модифицировать оба файла  входящие  в
набор данных.
      После  обращения  к  OpenDataSet  оба  файла   открываются   или
создаются, или же программа останавливается с обращением  к  процедуре
Abort.
      После обращения к процедуре OpenDataSet,  ваша  программа  может
добавлять записи в файл данных  используя  процедуру  верхнего  уровня
TAIncert. Процедура TAIncert имеет три параметра:

              - переменная набора данных;
              - запись базы дпнных
              - ключ к записи

       Следующий  пример  показывает  как  добавлять  записи  в  набор
данных. InputInformation  -  процедура  разрабатываеиая  пользователем
которая позволяет вводить данные.
       После вызова TAInsert, булева переменная OK  устанавливается  в
False если в базе данных уже существует запись с таким ключем.
       AnswerYes - простая утилита в  TAHIGH.PAS,  которая  возвращает
True если пользователь ввел Y. Она используется во многих программах.

              procedure AddCustomer(var Customers: DataSet);
              {Ввод записей в определенный набор данных}
              begin
                repeat
                  InputInformation(CustRecord);
                  TAInsert(Customers,CustRecord,CustRecord.CustCode);
                  if not OK then
                    Write('Добавляем следующую запись?');
                  else
                    Write('Такой код уже есть. Вводим другой код?');
                    until not AnswerYes;

      После обращения к процедуре OpenDataSet,  ваша  программа  может
добавлять записи в файл данных  используя  процедуру  верхнего  уровня
TAIncert. Процедура TAIncert имеет три параметра:

              - переменная набора данных;
              - запись базы дпнных
              - ключ к записи

       Следующий  пример  показывает  как  добавлять  записи  в  набор
данных. InputInformation  -  процедура  разрабатываеиая  пользователем
которая позволяет вводить данные.
       После вызова TAInsert, булева переменная OK  устанавливается  в
False если в базе данных уже существует запись с таким ключем.
       AnswerYes - простая утилита в  TAHIGH.PAS,  которая  возвращает
True если пользователь ввел Y. Она используется во многих программах.

              procedure AddCustomer(var Customers: DataSet);
              {Ввод записей в определенный набор данных}
              begin
                repeat
                  InputInformation(CustRecord);
                  TAInsert(Customers,CustRecord,CustRecord.CustCode);
                  if not OK then
                    Write('Добавляем следующую запись?');
                  else
                    Write('Такой код уже есть. Вводим другой код?');
                    until not AnswerYes;
              end; { AddCustomer }

    Система доступа Turbo Pascal Access позволяет вам быстро  находить
записи с использованием ключей. Процедура верхнего уровня TARead  ищет
ключ в наборе данных и возвращает запись связанную  с  данным  ключем.
TARead принимат четыре аргумента:

              - переменная набора данных.
              - возвращаеиая запись базы данных
              - ключ к записи
              - булево  значение  устанавливается  в  True  если   вы
собираетесь проводитьпоиск на полное соответствие  ключу,  или  False,
если поиск проводится по части ключа.

     Если поиск ключа не увенчался успехом, TARead устанавливает OK  в
False.
     Следующая  процедура  запрашивает  у  пользователя  ввод  кода  в
качестве ключа для TARead. Если поиск успешен, OK  устанавливапется  в
True, и извлеченная запись  отображается.  DisplayCustomer  -  функция
разрабатываемая пользователем, которая распечатывает поля записи.
     Если  булев  параметр  Exact  установлен  в  False,   вы   можете
использовать  TARead  для  поиска  записи  по  части   ключа.   TARead
возвращает первую запись имеющую ключ, который начинается с той  части
ключа по которому производится поиск.
     TAHIGH.PAS также определяет две  булевы  константы  ExactMatch  и
PartialMatch,  которые  могут  быть   использованы   для   определения
критерия поиска для TARead.  Эти  константы  используются  в  основной
программе при обращении к FindCustomer.

              procedure FindCustomer(var Customers : DataSet;
                                         Exact    : boolean);
              var
                SearchCode : CodeStr;

              begin
                Write('Ввелите код к записи:');
                readln(SearchCode);
                TARead(Customers, CustRecord, SearchCode, Exact);
                if OK then
                   DisplayCustomer(CustRecord)
                else
               Writeln('Для данного ключа запись не найдена', SearchCode);
                end; {FindCustomer}

     После обращения к процедуре TARead система  Turbo  Pascal  Access
запоминает последний  ключ  по  которому  происходил  доступ,  поэтому
могут быть найдены соседние записи. Процедура верхнего  уровня  TAPrev
может  быть  использована   для   извлечения   записи   с   предыдущим
относительно последнего  доступа  ключем,  и  TANext  для  возвращения
записи с ключем следующим за ключем последнего доступа.  Эти  роцедуры
могут быть использованы для последовательного прохождения базы  данных
запись за записью.
     Процедуры TAPrev и TANext имеют три аргумента:

              - переменная набора данных;
              - возвращаемая запись данных;
              - возврвщаемый ключ.

     Следующая процедура показывает как передавать ключ и связанную  с
ним запись в базе данных используя TANext.

              procedure NextCustomer(var Customers : DataSet);
              {Отображает следующую запись данных}

              var
                CustomerCode : CodeStr;

              begin
                TANext(Customers,CustRecord,CustomerCode);
                if OK then
                  DisplayCustomer(CustRecord)
                else
                  Writeln('Дошли до конца базы данных.');
              end;{NextCustomer}

      При обработке  ключей  последовательно,  имеет  место  следующая
цикличечкая структура. Когда указатель индексного файла  находится  на
последнем ключе в файле, обращение к  TANext  установит  OK  в  False.
Следующее обращение к TANext возвратит первый ключ  индексного  файла.
С другой  стороны,  когда  указатель  индексного  файла  находится  на
первом ключе файла обращение к TAPrev установит OK в False.  Следующее
обращение  к  TAPrev  возвратит  последний  ключ  индексного  файла  и
передаст связанную с ним запись из файла данных.  Следующая  процедура
показывает как извлечь предыдущий ключ и  связанную  с  ним  запись  в
базе данных используя TAPrev:

              procedure PrevCustomer(var Customers : DataSet);
              {Отображает предыдущую запись данных}

              var
                CustomerCode : CodeStr;

              begin
                TAPrev(Customers,CustRecord,CustomerCode);
                if OK then
                  DisplayCustomer(CustRecord)
                else
                  Writeln('Дошли до конца начала базы данных.');
              end;{PrevCustomer}

     Для того чтобы точно позиционировать указатель индексного  файла,
используйте  процедуру  верхнего  уровня  TAReset.  Процедура  TAReset
принимает  один  аргумент  -  переменную  DataSet.  Теперь  вы  можете
использовать Tanext для последовательного доступа  ко  всем  ключам  и
записям в наборе данных.

              procedure ListCustomers(var Customers : DataSet);

              var
                Count : longint;
                CustomerCode : CodeStr;

              begin
                Count := 0;
                TAReset(Customers);

                repeat
                  TANext(Customers,CustRecord,CustomerCode);
                  if OK then
                  begin
                    DisplayCustomer(CustRecord);
                    Count := succ(Count);
                  end;
                until not OK;
                if Count > 0 then
                begin
                  Writeln;
                  Writeln(Count,'Общее число записей');
                end;
              end; { ListCustomers}

     Для удаления элемента из набора данных, вы должны  найти  ключ  к
записи, удалить  ключ,  и  затем  удалить  запись.  Одно  обращение  к
процедуре TADelete объединяет все  эти  шаги.  Если  ключ  не  найден,
TADelete устанавливает OK в False.
     TADelete принимает два аргумента:

              - переменную набора данных;
              - удаляемый ключ.

     Следующая процедура запрашивает у пользователя  ввода кода в
качестве ключа для TADelete.  Она информирует если елемент данных
и выставляет запрос на продолжение:

              procedure DeleteCustomers(var Customers : DataSet);

              var
                CustomerCode : CodeStr;

              begin
                repeat
                  Write('Введите код удаляемой записи:');
                  Readln(CustomerCode);
                  TADelete(Customers,CustomerCode);
                  if OK then
                    Write('Вводим следующий код?')
                  else
                    Write('Код не найден,Вводим следующий код?');
                until not AnswerYes;
              end; {DeleteCustomers}

     Иногда покупатель может изменить  свою  фамилию  или  адрес.  Для
того  чтобы  эффективно  выполнить  процедуру  модификации  вам  будут
необходимы некоторые  средства  для  отображения  имеющейся  в  данной
записи информации, а также средства позволяющие пользователю  заменить
или откорректировать ее. Для простоты  используйте  уже  разработанные
процедуры   DisplayCustomer   и   InputCustomer.   Мы   можем    также
предоставить пользователю возможность редактирования  каждого  поля  в
записи данных без необходимости повторного ввода полей,  информация  в
которых остается без изменений. За примером этого метода обратитесь  к
процедурам EditLine, InputCut, и Find используемым в BTREE.PAS .
     Процедура верхнего уровня TAUpdate предусмотрена для  модификации
записей которые уже существуют  в  базе  данных.  TAUpdate  берет  три
аргумента:

              - переменная набора данных;
              - новая информация записи данных;
              - ключ поиска.

      Так  как   TAUpdate   используется   только   для   модмификации
существующиз записей данных, TAUpdate устанавливает OK  в  False  если
ключ к записи не найден. (TAInsert используется для  добавления  новых
записей.)
      Следующая процедура запрашивает  у  пользователя  ввода  кода  в
квчестве ключа для TARead и передает запись на  редактирование.  После
редактирования записи убедитесь, что ключ к записи не изменился.  Если
ключ к записи не изменился просто  вызовите  TAUpdate  для  сохранения
изменений в записи. Если ключ изменился,  то  вам  потребуется  больше
работы для  сохранения  целостности  базы  данных.  При  использовании
вызовов   высокого   уровня,   для   каждой   записи   данных     есть
соответствующий ключ. Если ключ к  записи  был  измененен,  вы  должны
ввести другую копию записи в базу данных для нового  ключа  и,  затем,
стереть запись связанную со старым ключем.

              procedure UpdateCustomer(var Customers : DataSet);

              var
                SearchCode : CodeStr;

              begin
                Repeat
                  Write('Введите код модифицируемой записи:');
                  Readln(SearchCode);
                  TARead(Customers,CustRecord,SearchCode,ExactMatch);
                  if OK then
                  begin

                  DisplayCustomer(CustRecord);
                  InputUnformation(CustRecord);
                  if SearchCode = CustRecord.CustCode then
                     TAUpdate(Customers,CustRecord,SearchCode)
                  else
                  begin
              { Если ключ был изменен, добавляем запись с новым ключем и,
                в случае успеха, удаляем старую запись и ключ}
                  TAInsert(Customers,CustRecord,CustRecord.CustCode);
                  if OK then
                    TADelete(Customers,SearchCode)
                  else
                    Writeln('Такой ключ уже использовался');
                  end;
                  Writeln('Модифицируем следующую запись?');
                end
                else
                  Writeln('Код не найден. Вадим другой код?');
                until not AnswerYes;
              end; {UpdateCustomer}

     Теперь,  было  бы  хорошо,  быстро  написать  нашу  программу   и
привязать  ее  к  конкретной  ситуации.  Ранее   описанные   процедуры
демонстрируют скелетное кодирование  необходимое  для  настройки  базы
данных. Тексты этих программ могут  быть  найдены  на  диске  в  файле
TAHIGH.PAS. Для того чтобы скомпилировать TAHIGH.PAS:

     -  Инсталлируйте  Turbo Pascal  Access на вашей  системе;
     -  Создайте  рабочую  директорию,  назовите  ее  TAHIGH  и
        сделайте ее текущей; разархивируйте файл TAHIGH.ARC;
     -  Запустите:  TABuild.exe /W+ TADEMO.TYP;
     -  Cкомпилируйте TAHIGH.PAS.

     Вызовы  верхнего  уровня  в  утилите  TAHigh  представляют  собой
только пример того, как построить набор средств  для  работы  с  базой
данных  на  основе  TURBO  PASCAL  ACCESS.  (Вы   же   можете   делать
аналогичные модули в своих собственных программах,  которые  строятся,
например, на основе одного файла данных и двух индексных файлов или  с
разрешением  повторения  ключей.)  Хорошее  упражнение  для  этого   -
пристальное  изучение  исходного  текста  утилиты   TAHigh   с   целью
выяснения принципа ее работы.
     Вызовы нижнего и  верхнего  уровней  могут  быть  использованы  в
одной программе, но убедитесь, что вы отдаете себе отчет  в  том,  что
вы делаете. Вы можете всегда работать с  вызовами  нижнего  уровня  на
наборе данных открытом процедурой  верхнего  уровня,  но  не  наоборот
(что не всегда верно). Придерживайтесь следующих ограничений:

     - Набор данных создаваемый процедурой TACreate (верхний  уровень)
не разрешает дублирования ключей; файлы созданные процедурами  нижнего
уровня  могут  иметь  повторяющиеся  ключи.  Убедитесь,  что   вы   не
совершаете обращений к любой из процедур  верхнего  уровня  на  наборе
данных имеющем разрешение на дублирование ключей.
     - Вызовы нижнего уровня позволяют вам открывать  индексные  файлы
без открытия соответствующего файла данных и т.д. Если  вы  совершаете
любой из вызовов верхнего уровня на наборе данных который  был  открыт
из нижнего уровня, убедитесь, что открыты как индексный  файл,  так  и
файл данных.

     Файл  TAHIGH.PAS  предусматривает  переменную  TARecNum,  которая
содержит номер записи данных к  которой  проводился  последний  доступ
вызовами верхнего уровня. Это значение переменной TARecNum может  быть
использовано в качестве ссылки на  данные,  если  вы  хотите  добавить
второй ключ.
