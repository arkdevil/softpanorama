






	КОМПЛЕКС ПРОГРАММ ИНТЕРАКТИВНОЙ МАШИННОЙ ГРАФИКИ

			G R A P H

	   РАСШИРЕННАЯ ГРАФИКА НА ЯЗЫКЕ Си ДЛЯ ПЭВМ


	   Описание. Руководство пользователя.










Аннотация.


	Комплекс программ интерактивной машинной графики, расширяющий
возможности получившего широкое распространение языка программирования
Си, ориентирован на использование в качестве инструментального средства
реализации интерактивных программных систем, связанных с графическими
приложениями - графическое обеспечение САПР, АСУ, графические редакторы,
распознавание образов и обработка изображений, игровые и обучающие
программы.
	Наряду с традиционными процедурами управления работой видео-
дисплея и вывода графических примитивов включена поддержка различных
систем координат (математические, или, "мировые" координаты), движущихся
графических окон, дополнительных буферов экрана видеодисплея. Реализованы
дополнительные возможности для работы с клавиатурой, управления выводом
звукового генератора, поддержка работы с мышью (MicroSoft Mouse), со
спрайтами, вывод осей координат, графиков, гистограмм.
	Наличие исходных текстов графических программ на языке Си и
подробной документации позволяет пользователю быстро освоить и легко
адаптировать их для собственных задач, добиваясь требуемой эффективности
и быстродействия, или осуществить перенос пакета на другой тип видео-
дисплея или другую машину.




			СОДЕРЖАНИЕ



1.  НАЗНАЧЕНИЕ.

2.  ОПИСАНИЕ ПРОГРАММ.

2.1.  Работа с видеотерминалом.
2.2.  Инициация и завершение работы в графическом режиме.
2.3.  Работа с экраном.
2.4.  Основные графические примитивы.
    2.4.1.  Работа с точками.
    2.4.2.  Элементарные геометрические фигуры.
    2.4.3.  Маркеры.
    2.4.4.  Перемещаемые фигуры и маркеры.
    2.4.5.  Дополнительные графические возможности.
2.5.  Ввод и вывод символов.
2.6.  Работа с графическими окнами.
2.7.  Работа с мировой системой координат.
    2.7.1.  Определение системы координат.
    2.7.2.  Преобразование координат.
    2.7.3.  Графические примитивы в мировой системе координат.
    2.7.4. Определение границ активного мира.
2.8.  Штриховка и заполнение областей.
2.9.  Работа с текстом.
2.10. Двухмерная графика.
2.11. Вывод осей координат и графиков.
2.12. Работа со спрайтами.

3.  Работа с EGA-монитором.

	КОМПЛЕКС ПРОГРАММ ИНТЕРАКТИВНОЙ МАШИННОЙ ГРАФИКИ GRAPH.
	ГРАФИЧЕСКОЕ РАСШИРЕНИЕ ЯЗЫКА СИ ДЛЯ ПЭВМ.


	1. Назначение.
	--------------

	Современные ПЭВМ, обладая достаточно высоким быстро-
действием, значительными объемами оперативной и внешней памяти,
богатыми графическими возможностями, поддерживаемые развитыми
системами программирования, предоставляют широкие возможности
для реализации на их основе интерактивной машинной графики,
обработки изображений, разнообразных приложений, связанных
с представлением обрабатываемой информации в графическом виде.
Необходимым условием эффективной реализации таких программных
систем является языковая поддержка организации графического
отображения информации и взаимодейстия пользователя с ПЭВМ.
	Вниманию пользователей предлагается комплекс графичес-
ких программ на языке Си для ПЭВМ типа ЕС-1840, -1841 и других,
совместимых с IBM PC или PS/2. Требования к структуре, составу
и форме реализации графического пакета для языка Си определяются
характером задач, для решения которых предполагается его
использование в качестве инструментального средства, -
разработка интерактивнных графических систем для различного рода
приложений. В качестве основных требований выступают функцио-
нальная полнота пакета и интерактивность. Под функциональной
полнотой в данном случае понимается представление пользователю
необходимого набора средств, позволяющего реализоать практически
все возможности машинной графики на ПЭВМ. Интерактивность системы
определяется наличием развитых средств организации графического
взаимодействия пользователя с ПЭВМ: движущиеся графические
окна, перемещаемые фигуры и курсоры, разнообразные возможности
знакогенерации и вывода текстовой информации, смены цветовой
палитры и другие средства, повышающие графическую выразитель-
ность выводимой информации.
	Сравнительный анализ характеристик описываемого комплекса
графических программ и ряд вопросов, связанных с реализацией и
использованием пакета, рассматривается в работе "Комплекс
программ интерактивной машинной графики" (Б.Н.Гайфуллин, препринт
ИПТМ АН СССР, Черноголовка, 1988). Следует отметить, что одним
из основных достоинств пакета является возможность предоставления
пользователям исходных текстов программ. Как опытный, так и
начинающий пользователь, имея на руках исходные тексты, может
легко адаптировать пакет под свои нужды, добавляя нужное,
отсекая лишнее, комбинируя и развивая необходимые ему возмож-
ности и добиваясь требуемой эффективности. В настоящее время,
описываемый пакет является единственным из всех существующих
графических пакетов и библиотек для языка Си на IBM PC/XT/AT-
совместимых ПЭВМ, который предоставляет возможности для работы
со спрайтами, поддерживает программно дополнительный буфер
экрана видеодисплея, движущиеся графические окна, математичес-
кую систему координат, вывод осей координат, графиков и гисто-
грамм и может поставляться в исходных текстах.
	Дополнительные сведения о комплексе программ интерак-
тивной машинной графики можно получить по адресу:
142432, Черноголовка Московской обл., ИПТМ АН СССР,
Гайфуллин Б.Н..

	2. Описание программ.
	---------------------

	В этом разделе приведены описания основных программ
интерактивной машинной графики для языка Си на ПЭВМ, совмести-
мых с IBM PC, и представленных в виде функций языка Си. Каждое
описание состоит из имени функции (с возможным описанием типа
возвращаемого значения) со списком параметров и последующей
спецификацией типа параметров. Описание функций сопровождается
достаточно подробным комментирующим текстом. Более полная информа-
ция предоставляется пользователям вместе с исходными текстами
программ интерактивной машинной графики. Сведения по установке
комплекса программ интерактивной машинной графики и назначении
входящих в его состав файлов содержатся в файле README.GR,
находящемся на предоставляемой пользователям дистрибутивной
дискете.

	2.1. Работа с видеотерминалом
	-----------------------------

	SetMode(Mode)	устанавливает режим работы видеодисплея:
	int	Mode;

	   Mode                 режим

	    0             текстовый  40*25	символов
	    1               - // -   40*25	- // -
	    2               - // -   80*25	- // -
	    3               - // -   80*25	- // -
	    4             графический 320*200    4 цвета
	    5               - // -    320*200    - // -
	    6               - // -    640*200    2 цвета
	    13-16	  режимы работы с EGA

	Пользователям рекомендуется использовать для инициации
	графического режима использовать функцию InitGraphic()
	(см. п. 2.2), которая автоматически вызывает SetMode().

	int GetMode() возвращает целое значение равное номеру текущего
	              режима работы видеодисплея.

	SetPalette(Palette)	устанавливает заданную цветовую
				палитру (совокупность доступных
				для использования цветов)
	int	Palette;        номер палитры (0 - 1)

	int GetPalette() возвращает номер установленной палитры.

	SetBackGround(Color)	устанавливает цвет фона, изменяет
				множество доступных одновременно
				цветов графического вывода из
				имеющейся палитры (до 4 из 64 для
				CGA и до 16 из 256 для EGA)
	int	Color;		цвет фона

	int GetBackGround()	возвращает цвет фона.

	SetForeGround(Color)	устанавливает цвет графического
				вывода всех примитивов, маркеров
				и фигур
	int	Color; 		цвет вывода

	int GetForeGround() 	возвращает текущий цвет графического
				вывода.

	int EGAInstalled()	проверяет наличие EGA. Возвращает 1,
				если EGA присутствует, иначе - 0.

	Приведем в качестве примера небольшую программу, позволяющую
  изменять режим работы дисплея с помощью командной строки DOS.

	/*
	 * установка режима работы дисплея
	 */

	#include <stdio.h>
	main(argc,argv)
	int	argc;
	char	*argv[];
	{
	  if(argc==2) setmode(atoi(argv[1]));
	  else printf("Display Mode=%d\n",getmode());
	}

	Набрав эту программу в некотором файле, скомпилировав и скомпо-
  новав его с файлами графической библиотеки, вы получите программу,
  которая позволяет узнать или изменить текущий режим работы дисплея.

	2.2. Инициация и завершение работы в графическом режиме.
	--------------------------------------------------------

	InitGraphic(Mode)	инициирует работу в графическом
	int	Mode;  		режиме. Если Mode<0 то не выделяется
				память для дополнительного буфера
	видеоэкрана при работе с CGA. InitGraphic() выполняет
	начальные установки и определения цветов, фона, палитры,
	режима работы, графических окон и др. Параметр Mode
	аналогичен соответствующему параметру функции SetMode()
	(см. п. 2.1).

	CloseGraphic()		Завершает работу в графическом
				режиме, восстанавливает прежний
	режим работы видеодисплея, существовавший до обращения к
	функции InitGraphic().

	2.3. Работа с экраном
	---------------------
	В данной системе машинной графики для языка Си программно
  реализован второй (вспомогательный) экран в оперативной памяти (RAM),
  что предоставляет пользователю дополнительные функциональные возмож-
  ности при организации графического диалога: использование второго
  экрана в качестве буферной памяти; копирование и своппинг экранов;
  переключение графического вывода с одного экрана на другой; реализа-
  ция мультипликационного передвижения картинок и окон (см. соотв. раз-
  дел) с сохранением фона. Оба экрана можно очищать, инвертировать,
  запоминать на диске и т.п.

	SelectScreen(NScreen)	переключает графический вывод на
				экран видеодисплея (NScreen=1),
			либо на вспомогательный экран (NScreen=2).

	int GetScreen()		возвращает номер включенного экрана.

	ClrScreen()		очистка включенного экрана.

	CopyScreen()		копирует содержимое текущего экрана
				(если включен экран видеодисплея,
	то он копируется во вспомогательный экран, и, наоборот)

	SwapScreen()		обменивает содержимое видеодисплея
				и вспомогательного экрана (своппинг)

	InvertScreen()		инвертирует побитово изображение на
				экране

	SaveScreen(FileName)	сохраняет содержимое текущего экрана
	char	*FileName;	в файле с заданным именем.

	LoadScreen(FileName)	выводит запомненное в файле изображение
	char	*FileName;		на экран.

	2.4. Основные графические примитивы
	-----------------------------------

	Все описываемые в данном пункте функции используют цвет
  графического вывода (если он не задается явно одним из параметров),
  устанавливаемый с помощью функции SetForeGround().

2.4.1	Работа с точками
-------------------------

	DP(x,y) 	рисует точку установленного цвета.
	int	x,y;	координаты точки

	DPC(x,y,color)	рисует точку заданного цвета.
	int	x,y;	координаты точки
	int	color;	цвет

	IP(x,y)		инвертирует точку с заданными координатами.
	int	x,y;

	int PD(x,y)	возвращает цвет точки с заданными координатами.
	int	x,y;

	Наиболее простая вещь, которую можно сделать в графических
  программах, - изменение цвета в заданной точке экрана. Приведем пример
  программы, рисующей точку (с тем же успехом это мог быть отрезок, пря-
  моугольник и т.п.) на экране, имеющей три аргумента - координаты по
  горизонтали и вертикали и цвет.

	/* drawpt.c   выводит точку на экран	*/
	/* использование: drawpt x y color	*/
	/* пример:	  drawpt 160 100 1	*/

	main(argc,argv) int argc; char argv[];
	{
	  int	x,y,color;
	  if(argc!=4) return; else initgraphic(5);
	  x=atoi(argv[1]); y=atoi(argv[2]); color=atoi(argv[3]);
	  if(color>3) color=3;
	  if(color<0) color=1;
	  setforeground(color); dp(x,y); /* можно DPC(x,y,color) */
	  getkey(); closegraphic();
	}

	Эта программа, конечно, не имеет ценности с точки зрения практичес
  кого использования, но она позволяет продемонстрировать работу с основ-
  ными графическими примитивами, на которых строится все остальное програм-
  мирование машинной графики.

2.4.2	Элементарные геометрические фигуры
-------------------------------------------

	Line(x1,y1,x2,y2)	рисует отрезок соединяющий точки
	int  x1,y1,x2,y2;	с координатами (x1,y1) и (x2,y2).

	Box(x1,y1,x2,y2)	прямоугольник, заданный координатами
	int x1,y1,x2,y2;	диагональных точек.

	Bar(x1,y1,x2,y2)	окрашенный прямоугольник.
	int x1,y1,x2,y2;

	Circle(x,y,radius)	рисует окружность заданного радиуса
	int x,y,radius;		с центром в точке (x,y).

2.4.3	Маркеры
-----------------

	Аргументами всех функций, выводящих маркеры, являются коорди-
  наты центральной точки (x,y) и коэффициент масштабирования scale,
  позволяющий задавать размер маркера.

	Cross(x,y,scale)	перекрестье
	int	x,y,scale;

	CrossDiag(x,y,scale)	диагональное перекрестье
	int	x,y,scale;

	Star(x,y,scale)		звездочка
	int	x,y,scale;

	Wye(x,y,scale)		буква 'Y'
	int	x,y,scale;

	Diamond(x,y,scale)	ромб
	int	x,y,scale;

2.4.4	Перемещаемые (ribbon) фигуры
-------------------------------------

	Перемещение описыаемых в данном пункте фигур и маркеров
  осуществляется с использованием графического вывода в режиме
  XOR - "исключающего" ИЛИ.

	RBox(x1,y1,x2,y2)	перемещаемый прямоугольник
	int	x1,y1,x2,y2;

	DelBox()	удаление перемещаемого прямоугольника

	RLine(x1,y1,x2,y2)	перемещаемый отрезок
	int	x1,y1,x2,y2;

	DelLine()	удаление перемещаемого отрезка

	RCross(x,y,scale)	перемещаемое перекрестье
	int	x,y,scale;

	DelCross()	удаление перемещаемого перекрестья

	Пример использования функции RCross():
	------

  #include <stdio.h>

  main()
  {	int	i;
	. . .
	initgraphic(5);	/* инициация цветной графики в CGA */
	setcolor(1);
	. . .
	/* Вывод движущегося слева направо перекрестья */
	for(i=20;i<=300;++i) RCross(i,100,15);
	. . .
	DelCross();
	. . .
	closegraphic();
  }


2.4.5	Дополнительные возможности
-----------------------------------

	SetLineStyle(Style)	устанавливает один из предопределенных
				режимов рисования линий:
	int	Style;		Style=0    - непрерывный
				Style=1..4 - различные виды (пунктир-
				ный, точечный, штрих-пунктирный и т.п.)
				Style>4	- стиль задается пользователем,
				в Style - побитовый шаблон (задаваемый
				правыми восемью битами), ненулевые
	разряды которого определяют выводимые точки линии.

	int GetLineStyle()	возвращает установленный режим рисова-
				ния линии.

	SetAspect(Aspect)	задает отношение высоты и ширины для
	double	Aspect;         окружности.

	double GetAspect()	возвращает установленное отношение
				высоты к ширине для окружности.

	SetXORMode(Mode)	устанавливает рисование в режиме
	int	Mode;           "исключающего ИЛИ" (XOR) при Mode
				не равном нулю.

	int	GetXORMode()	возвращает 1, если установлен режим
				XOR, иначе - 0.

	SetClipping(Clip)	устанавливает режим "обрезания" вы-
	int	Clip;		водимого изображения по границам
				установленного окна (см. соотв. раздел)
	при Clip=1, при Clip=0 - отменяет.

	int GetClipping()	возвращает 1, если установлен режим
				обрезания изображения, иначе - 0.

	Приведем пример использования различных режимов рисования
  линий, задаваемых с помощью функции SetLineStyle():

  main()
  { int	i;
    initgraphic(6);	/* графика высокого разрешения для CGA */
    for(i=0;i<=4;i++){
       setlinestyle(i);			/* задание вида линии */
       line(20,10+i*30,600,10+i*30);	/* вывод линии */
    }
    getkey();		/* ожидание ввода с клавиатуры */
    closegraphic();
  }	/* main() */


	2.5. Ввод и вывод символов, генерация звука, и работа с "мышью".
	--------------------------------------------------------------

	Язык Си содержит достаточно удобные средства для ввода символ-
  ной информации с клавиатуры и форматного вывода на экран дисплея.
  Описываемые в данном разделе функции GetKey() и GotoXY() в сочетании
  с функциями из стандартной библиотеки языка Си предоставляют широкие
  возможности для организации диалогового режима работы. Эти функции
  предоставляют пользователю наглядные примеры того, как можно использо-
  вать прерывания для работы с BIOS (Basic Input/Output System).

	int GetKey()	возвращает введенный с клавиатуры код символа.
			Для большинства символов (буквы, цифры, знаки
	операций и препинания и т.п.) возвращается код ASCII. Коды
	для управляющих (CTRL), функциональных, дополнительных (ALT)
	и др. клавиш, а также их сочетаний, пользователь может полу-
	чить с помощью следующей небольшой программы, демонстрирующей
	работу с GetKey():

	main()
	{
	  do{
	    printf("код введенного символа = %d\n",getkey());
	  }while(1);
	}


	GotoXY(x,y)	устанавливает текущее положение текстового
	int x,y;	курсора в позицию с координатами (x,y).

	GetXY(px,py)	возвращает координаты текущей позиции курсора.
	int	*px,*py;

	Sound(Freq,Time)	управление громкоговорителем
	int	Freq,Time;	частота и продолжительность (в 0.1с).

	Mouse(Code,PButtons,PX,PY)	работа с мышью (Mouse)
	int	Code;
	int	PButtons,PX,PY;
		Программирование работы с устройством Mouse. Для пра-
	вильной работы требуется произвести необходимые действия при
	включении компьютера и загрузке операционной системе по уста-
	новке драйвера MicroSoft Mouse. В Code передается управляющая
	информация (0 - инициация работы, 3 - считывание информации),
	с помощью указателей PButtons, PX, PY возвращается информация
	о состоянии (кнопкам мыши соответствуют два крайних правых
	бита в *PButtons) и положении мыши.

	int EditString(String,Legal,MaxLength)	редактирование строки
	char	String[],	буфер для ввода строки
		Legal[];	допустимые символы
	int	MaxLength;	длина буфера
		EditString() позволяет пользователю отредактировать или
	ввести новую строку из допустимых символов с клавиатуры. Введен-
	ная строка передается в символьном массиве String, имеющем мак-
	симальную длину MaxLength. Legal содержит набор допустимых симво-
	лов (если Legal - пустая строка, то воспринимаются все символы).
	Строка считается введенной после нажатия ENTER, редактирование
	прекращается также после ESCAPE (при этом возвращается отрица-
	тельное значение). Редактирование и перемещение по строке осу-
	ществляется с помощью клавиш HOME, END, INS,DEL,BS,->,<-.


	2.6. Работа с графическими окнами
        -------------------------------

	DefWindow(n,x1,y1,x2,y2)	определяет прямоугольное окно
	int n,x1,y1,x2,y2;              для графического вывода с
					номером n. Горизонтальные коо-
	рдинаты (x1 и x2) выравниваются по границам байта в памяти экрана
	(что позволяет избежать работы с отдельными битами видеопамяти
	при операциях копирования и перемещения окон и, значит, сущест-
	венно сокращает время выполнения этих операций).

	SelectWindow(n)		включает работу с окном номер n. При
				этом осуществляется обрезание графичес-
	кого вывода по границам активного окна (отменить обрезание
	(clipping) можно с помощью функции SetClipping()) и переключение
	графического вывода в мировой системе координат (см. след. пункт)
	в новое активное окно.

	int GetWindow()		возвращает номер включенного окна.

	ReSetWindows()		отменяет все ранее сделанные определения

	ClrWindow()		очищает активное окно

	InvertWindow()		инвертирует поразрядно цвета внутренних
				точек активного окна

	WindowBorder()		рисует прямоугольную границу активного
				окна текущим цветом графического вывода

	int	WindowSize()	возвращает в байтах размер участка
				в памяти экрана, занимаемой окном.

	FillWindow()		заполняет фон окна заданной штриховкой

	CopyWindow(from,to,x,y)	копирует изображение из окна на экране
	int from,to,x,y;	с номером from в область экрана с номе-
				ром to c левым верхним углом x,y.
	Пользователь должен следить за тем, чтобы не пересекались
	области исходного и скопированного изображений и новое изображение
	не выходило за пределы экрана.

	MoveHor(delta,fill)	перемещение окна по горизонтали (влево
	int	delta,fill;	если delta<0, иначе вправо) на число
	точек равное abs(delta), выравненное по границам байта. При
	fill=1 восстанавливается изображение, по которому движется
	окно, при fill=0 движущееся окно затирает изображение на экране.

	MoveVer(delta,fill)	перемещение окна по вертикали (вверх
	int	delta,fill;	при delta<0), параметр fill аналогичен
				MoveHor().

	SaveWindow(n,FileName)	запоминает содержимое окна n в файле
	char	*FileName;	имя файла
	int	n;		номер окна

	LoadWindow(n,FileName)	включает окно n и загружает в него
				изображение из указанного файла. При
				этом осуществляется автоматическое
				переопределение параметров окна
	char	*FileName;	имя файла
	int	n;		номер окна

	Практический опыт работы с графическими библиотеками
показывает, что в ряде случаев полезным оказывается наличие функций
возвращающих координаты (границы) активного окна. Поэтому в GRAPH
также были включены следующие функции:

	int	GetX1();	возвращает левую границу окна

	int	GetX2();	возвращает правую границу окна

	int	GetY1();	возвращает верхнюю границу окна

	int	GetY2();	возвращает нижнюю границу окна


	2.7. Работа с мировой системой координат
	----------------------------------------

	Организация работы с окнами и мировой (пользовательской)
  системой координат является важным шагом в повышении уровня
  описываемого графического пакета. Мировая (иногда ее называют
  математической)  система координат позволяет пользователю,
  определив свой "прямоугольный мир" заданием его границ, работать
  в своей системе ещественных координат, которые будут автомати-
  чески преобразовываться в целые координаты экрана. Пользователь
  может описать несколько "миров" (world) и в процессе работы
  переключаться на работу с любым из них. Наличие нескольких
  графических "окон" (window) на экране дисплея позволяет пользова-
  телю переключать вывод с одного окна на другое. Пользователь
  может также использовать функции, возвращающие границы активного
  мира.

2.7.1	Определение системы координат
--------------------------------------

	DefWorld(n,x1,y1,x2,y2)	описывает систему координат с номером
	double n,x1,y1,x2,y2;	n, точка (x1,y1) располагается в левом
				нижнем углу.

	SelectWorld(n)		включает систему координат с номером n.
	int	n;

	ReSetWorlds()		отменяет все сделанные ранее описания.

2.7.2	Преобразование координат
---------------------------------

	int WindowX(x)		преобразует мировую горизонтальную
	double	x;		координату x в координаты экрана.

	int WindowY(y)		преобразует мировую вертикальную коорд.
	double	y;

	double WorldX(x)	преобразует горизонтальную координату
	int	x;		точки экрана в мировую координату

	double WorldY(y)	преобразует вертикальную экранную коорд.
	int	y;

2.7.3	Графические примитивы в мировой системе координат
----------------------------------------------------------

	Работая в мировой системе координат, можно пользоваться всеми
  графическими примитивами, определенными для работы с целыми коорди-
  натами экрана, предварительно преобразуя мировые координаты с помо-
  щью функций WindowX() и WindowY(). Наряду с этим реализован ряд фун-
  кций, осуществляющий вывод непосредственно в мировых координатах.

	DrawPoint(x,y)		вывод точки
	double	x,y;		координаты точки

	DrawLine(x1,y1,x2,y2)	отрезок
	double	x1,y1,x2,y2;

	DrawCircle(x,y,radius)	окружность
	double x,y,radius;

	DrawBar(x1,y1,x2,y2)	окрашенный прямоугольник
	double x1,y1,x2,y2;

	DrawBox(x1,y1,x2,y2)	прямоугольник
	double	x1,y1,x2,y2;

	DrawCross(x,y,scale)	перекрестье
	double	x,y;
	int	scale;

	DrawStar(x,y,scale)	звездочка
	double	x,y;
	int	scale;

	DrawWye(x,y,scale)	буква 'Y'
	double	x,y;
	int	scale;

	DrawDiamond(x,y,scale)	ромб
	double	x,y;
	int	scale;

	Рассмотрим пример работы с графическими примитивами в
  мировой системе координат. Приводимая ниже программа выводит
  на экране точки, позиция и цвет которых задаются с помощью
  датчика псевдослучайных чисел (функция rand()):

  main()
  { int	i,color;
    double	x,y;
    initgraphic(4);		/* инициация цветной графики в CGA */
    defworl(1,0.,0.,1.,1.);	/* описываем мировую систему координат*/
    selectworld(1);		/* включаем работу с миром */
    for(i=0;i<1000;++i){
       x=rand()/32767.; y=rand()/32767.;/* случайные координаты */
       color=rand()&3;                  /* случайный цвет */
       setforeground(color);		/* установка цвета */
       drawpoint(x,y);			/* вывод точки */
    }
    getkey();
    closegraphic();
  }	/* main() */

2.7.4. Определение границ активного мира
----------------------------------------

	double GetWX1();	возвращает левую границу мира

	double GetWX2();	возвращает правую границу мира

	double GetWY1();	возвращает нижнюю границу мира

	double GetWY2();	возвращает верхнюю границу мира


	2.8. Штриховка и заполнение областей
	------------------------------------

	DefHatchStyle(ByteArray)	определяет образец заполнения
	char	ByteArray[8][8];	фона (размера 8*8), задаваемый
					в массиве ByteArray.

	SetHatchStyle(Style)	устанавливает один из предопределенных
	int	Style;          способов заполнения (штриховки) фона
				(-1<Style<8)

	int	GetHatchStyle()	возвращает номер установленного способа
				заполнения фона.

	Fill(x,y)		заполняет установленным способом внут-
	int	x,y;		ренность выпуклой фигуры. Точка (x,y)
				принадлежит (задает) заполняемой области.

	FillBox(x1,y1,x2,y2)	зарисовывает прямоугольник заданным
	int	x1,y1,x2,y2;	фоном.

	FillWindow()		(см. работу с окнами)


	Вывести на экран предопределенные образцы заполнения фона
  можно с помощью следующей программы:

  /*
   *	Вывод образцов штриховки
   */

  main()
  { int	i;
    initgraphic(6);		/* инициация графики */
    for(i=0;i<=7;++i){
       sethatchstyle(i);	/* определение вида штриховки */
       fillbox(i*80+10,50,i*80+70,150);
    }
    getkey();
  }	/* main() */


	2.9. Работа с текстом
	---------------------

	LoadFont(FileName)	загружает образец шрифта из файла.
	char	*FileName;

	DrawAscii(x,y,size,symbol)	выводит символ в позиции, зада-
	int x,y,size,symbol;            ваемой левой нижней точкой (x,y)
					size - коэффициент увеличения
					(size > 0).

	SetText(Heigth,Width,Scale)	задает параметры выводимого
					текста
	int Heigth,Width,Scale;
			Scale - коэффициент увеличения символов
			Heigth и Width - высота и ширина рамки для
	одного символа, используемые для задания сетки размещения
	символов на экране

	DrawText(x,y,txt)	выводит текстовую строку txt, начиная
	int	x,y;  		с позиции, задаваемой точкой (x,y).
	char	*txt;

	В описываемой библиотеке GRAPH пользователю предоставляется
возможность самому описывать используемые текстовые шрифты. Для описа-
ния шрифтов применяются обычные текстовые файлы, которые можно подго-
товить с помощью обычного текстового редактора. Структура файла описаний
очень проста. В первой строке файла указываются ширина и высота шрифта
(в настоящей версии эти значения не могут быть больше 8, но дотошный
пользователь, имея на руках исходные тексты, легко может снять эти
ограничения). Затем идут в произвольном порядке описания шрифтов для
каждого символа. Каждое такое описание состоит из определения символа
в отдельной строке и последующей побитовой маске шрифта, где 1 обозна-
чается звездочкой ('*'), а 0 - обычной точкой. Символ определяется
либо просто своим обозначением, либо своим десятичным кодом следующим
за обратной косой чертой ('\' , эта возможность бывает удобной для
описания шрифтов, скажем, для управляющих символов)

	Пример определения образцов шрифта:
	------

  4  6		в первой строке файла указываются ширина и высота шрифта
  а		символ
  ....
  ***.
  ...*
  .***
  *..*
  .***

  . . .

  я       	символ
  ....
  .***
  *..*
  .***
  .*.*
  *..*
  <eof>		конец файла


	2.10. Двумерная графика
	-----------------------

	Двумерная графика в данной системе представлена следующими
  возможностями: задание геометрической фигуры в виде последовательности
  координат ее точек; различные преобразования координат фигуры, соот-
  ветствующие повороту, сдвигу, масштабированию и т.п.; определение
  мировой системы координат для графического отображения фигуры; вывод
  фигуры на экран в различных вариантах; рисование осей координат и др.
	Геометрические фигуры, состоящие из N точек, задаются вещест-
  венным (double) массивом из N координатных пар (x,y). Передача фигу-
  ры в качестве параметра функции осуществляется через указатели на
  такие массивы, имеющие тип:

		typedef double (*PlotArray)[2];

	Примечание: в описываемых функциях данного пункта предпола-
  гается, что нумерация массива начинается с 1 ! Это связано с
  тем, что в ряде приложений духмерной графики бывает необходимо
  в нулевом элементе массива хранить число элементов массива.

	RotatePAbout(Array,NPoints,Theta,x,y)	поворот фигуры
	PlotArray 	Array;  		массив точек
	int		NPoints;                количество точек
	double		Theta,                  угол поворота в градусах
			x,y;         		центр поворота

	RotatePolygon(Array,NPoints,Theta)	поворот вокруг геометри-
						ческого центра
	PlotArray	Array;			массив координат точек
	int		Points;			количество точек
	double		Theta;			угол поворота

	MovePolygon(Array,N,DeltaX,DeltaY)	сдвиг координат фигуры
	PlotArray	Array;			массив координат
	int		N;			количество точек
	double		DeltaX,DeltaY;		значения сдвига по X и Y

	ScalePolygon(Array,N,ScaleX,ScaleY)	масштабирование
	PlotArray	Array;			массив координат
	int		N;			количество точек
	double		ScaleX,ScaleY;		коэффициенты масштаби-
						рования по X и Y

	ScaleCPolygon(Array,N,ScaleX,ScaleY)	масштабирование коорди-
	PlotArray	Array;		нат относительно геометрического
	int		N;		центра фигуры.
	double		ScaleX,ScaleY;

	DrawPolygon(Array,I0,N,Line,Scale,Lines) вывод фигуры
	PlotArray	Array;			 массив точек
	int		I0,n;
	int		Line,Scale,Lines;

	DrawPolygon() выводит фигуру, задаваемую последовательностью
  точек массива Array с I0 по abs(N). Если N<0, то не производится
  обрезание выводимого изображения по границам окна. Line задает
  вид маркера в точках фигуры (0<abs(Line)<10); если Line<0, то рисуют-
  ся вертикальные отметки. Scale определяет размер маркеров. Lines не
  равное 0 задает соединение отрезком соседних точек.


2.11. Вывод осей координат и графиков функций.
----------------------------------------------

	Axis(x1,y1,x2,y2,mode)		вывод осей координат
	double	x1,y1,x2,y2;
	int		mode;

    Axis() рисует оси координат для прямоугольной области, задаваемой
  координатами x1,y1,x2,y2. Параметр mode используется для задания
  различных видов осей. В настоящее время реализованы режимы с 0 по 2.

    Draw(x,y,n,m,s)			вывод графика функции
	double	x[],y[];
	int		n,m,s;

    Draw() выводит график функции заданной координатами точек (x) и
  значениями (y) в этих точках. Количество точек равно n. В заданных
  точках можно вывести маркеры, номер которых устанавливается значением
  abs(m), а размер - параметром s. Если m<0, то точки функции не сое-
  диняются отрезками.

    Приведем пример вывода графика функции синуса:

  /*
   *	График синуса
   */
  #include <math.h>

  main()
  { double x[100],y[100],x0,x1,h;
    int	i,n=100;
    x0=0.; x1=6.2834; h=(x1-x0)/(n-1);
    for(i=0;i<n;++i){		/* вычисление значений синуса */
       x[i]=x0+i*h; y[i]=sin(x[i]);
    }
    initgraphic(5);		/* инициация графики */
    defworld(1,x0-3.,-1.5,x1+2.,1.5);	/* описание мира */
    selectworld(1);			/* включение мира */
    setforeground(2);		/* цвет осей */
    axis(x0,-1.,x1,1.,2);	/* вывод осей координат */
    setforeground(3);		/* цвет графика */
    draw(x,y,n,2,0);		/* вывод графика */
    getkey();			/* ожидание ввода с клавиатуры */
  }	/* main() */

    Меняя цвета, режимы вывода и вид маркеров графика и осей
  координат, пользователь может получить самые различные варианты
  представления графика на экране.


2.12. Работа со спрайтами.
---------------------------

    В настоящем пункте описываются функции, с помощью которых
  пользователь может по своему желанию создавать графические фигуры
  и образы и перемещать их (манипулировать ими).
    Как правило, в машинной графике под спрайтом понимается некоторый
  объект, определяемый пользователем, состоящей из совокупности точек,
  составляющей некоторый фрагмент изображения. Поддержка работы со
  спрайтами включает в себя реализацию возможности описания различных
  спрайтов, изменения их расположения на экране видеодисплея, удаление
  спрайтов и др. Аппарат спрайтов - простой в обращении и, одновременно,
  мощный инструмент интерактивной машинной графики, позволяющий
  создавать дижущиеся картинки и использовать мультипликационные
  эффекты ("оживление" изображений) для различного рода приложений.
    В описываемом графическом пакете пользователь может работать одно-
  ременно с несколькими спрайтами (максимальное число достигает 20).
  Прежде чем использовать спрайт, его необходимо описать (задать
  размеры, форму и цвет каждой точки - шаблон спрайта) с помощью функции:

  DefSprite(Num,Sprite,Nx,Ny)	определение шаблона спрайта
  int	Num;			номер спрайта
  char	Sprite[];		массив значений цветов точек спрайта
  int	Nx,Ny;			размер шаблона в точках по горизонтали
				и вертикали

    Каждому шаблону приписывается индекс, или, номер спрайта, который
  используется затем в операциях вывода или удаления спрайта на экране.
  Требуемая форма и цвета точек спрайта задаются последовательностью
  чисел из символьного одномерного массива Sprite (размером Nx*Ny
  элементов). Для каждой точки прямоугольного шаблона используется один
  байт, числа описывающие значения цветов точек должны располагаться по
  строкам. Наряду с допустимыми для выбранного режима работы работы
  видеодисплея значениями цветов точек пользователь может описать
  некоторые точки как "прозрачные", задав значение цвета равным -1
  (или 255). При этом в соответствующей позиции спрайта будет сохраняться
  цвет точек фонового изображения на экране.
    Номера описываемых спрайтов должны задаваться пользователем в порядке
  возрастания. Все символьные массивы с описанием шаблонов спрайтов
  не должны изменяться в процессе работы со спрайтами. Удалить описание
  спрайта можно только одновременно с удалением всех имеющихся описаний
  шаблонов с помощью функции:

  ClearSprite()		отмена всех описаний шаблонов спрайтов

    Вывести описанный спрайт в заданном месте экрана можно посредством
  функции PutSprite():

  PutSprite(Num,X,Y)	вывод спрайта
  int	Num;		номер спрайта
  int	X,Y;		координаты точки определяющей позицию
			левого верхнего угла спрайта

  При выводе спрайта на экран осуществляется предварительное автома-
  тическое запоминание содержимого области экрана, перекрываемой
  изображением спрайта, которая каждый раз восстанавливается при
  последующем перемещении или удалении спрайта. Следует отметить,
  что в качестве буфера для сохранения фрагментов фонового изображения
  используется память дополнительного экрана, поэтому его содержимое
  портится при работе со спрайтами. При работе с несколькими спрайтами
  пользователь должен учитывать и правильно обрабатывать возможные
  коллизии, связанные с пересечением или наложением спрайтов.
    Удалить изображение спрайта с экрана можно с помощью следующей
  функции:

  DelSprite(Num)	удаление изображения спрайта
  int	Num;		номер спрайта

    Приведем пример описания и использования спрайта, представляю-
  щего собой прямоугольник с прозрачной внутренностью:

  /*
   * простой пример работы со спрайтами
   */

   main()
   { int	i;
     char	sprite[5*4] = { 10, 10, 10, 10, 10, /* шаблон */
				10, -1, -1, -1, 10,
				10, -1, -1, -1, 10,
				10, 10, 10, 10, 10
		};
     initgraphic(16);		/* инициация графики для EGA */

     defsprite(0,sprite,5,4);	/* описание шаблона спрайта  */
     for(i=0;i<600;i+=2) putsprite(0,i+10,100);	/* перемещение */
     delsprite(0);		/* "стирание" спрайта */

     closegraphic();		/* завершение работы с графикой */
   }



	3. РАБОТА С EGA-МОНИТОРОМ.


    Видеодисплеи с EGA (Enhanced Graphic Adapter) поддерживают
  режимы работы с CGA (Color Graphic Adapter) в полном объеме и поэтому
  работая на них в режиме CGA, пользователь может воспользоваться
  всеми возможностями графического пакета на языке Си. Наряду с этим
  в описываемом графическом пакете на языке Си реализованы процедуры
  для работы с улучшенной графикой, поддерживаемой EGA. EGA-мониторы
  имеют повышенную разрешающую способность до (640 точек по горизонтали
  и до 350 точек по вертикали) и расширенную цветовую палитру (до 16
  цветов одновременно). Пользователям рекомендуется использовать 16
  режим работы видеодисплея, предоставляющий максимальные возможности
  в режиме EGA (640*350 точек, 16 цветов), задавая его вызовом
  функции InitGraphic(16).
    В отличие от EGA, CGA допускает непосредственную работу с видео-
  памятью, обеспечивая доступ к отдельным точкам изображения,
  представленным в виде отдельных или групп разрядов видеопамяти.
  Именно за счет непосредственного доступа к видеопамяти возможна
  эффективная реализация многих функций расширенной графики в CGA -
  поддержка движущихся графических окон, дополнительных буферов
  видеоэкрана и др.
    В EGA же непосредственный доступ имеется только к побитовой
  карте видеопамяти, в которой каждая точка экрана представлена
  отдельным разрядом. Задание цвета, режима записи цвета и т.п.
  обеспечиваются работой с регистрами EGA через порты ввода/вывода
  ПЭВМ. Различия в подходе к реализации графических режимов в CGA
  и EGA достаточно основательны, в связи с этим для обеспечения
  эффективности работы с графическим пакетом, версия для EGA-мони-
  тора реализована в виде отдельного набора графических программ,
  оформленных в виде отдельного файла GRAPHE.C (версия для CGA
  находится в файле GRAPH.C).
    В версии пакета для EGA реализованы новые функции распечатки
  экрана в режиме EGA на принтер (EPSON-совместимый) - PrEGAScr0()
  (выдача на половину машинописного листа без учета градаций цвета)
  и PrEGAScr1() (выдача на целый лист с черно-белой градацией цветов).
  Следует также отметить, что EGA аппаратно поддерживает различные
  виды наложения точек на изображение (OR - логическое ИЛИ, AND -
  логическое И, XOR - логическое исключающее ИЛИ). Все эти
  возможности можно использовать с помощью функции SetXORMode(Mode)
  задавая различные значения параметра Mode (0x10 - OR, 0x08 - AND,
  0x18 - XOR, 0 - обычный режим вывода с затиранием предыдущего
  цвета).
