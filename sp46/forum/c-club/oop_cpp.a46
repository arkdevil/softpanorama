PCM                                Sept 1991

      Объектно-ориентированное программирование в С++

         Cristopher Bush

Вокруг все чаще слышится - объектно-ориентированные языки,
объектно-ориентированная графика, объектно-ориентированные базы данных.
Пользователи и программисты просто заинтригованы - что же это такое -
объектно-ориегтированный подход к программированию?

Для примера возьмем язык С++. Он представляет собой ни что иное, как
объектно-ориентированное расширение стандартного С. Данная статья не
претендует на полноту охвата возможностей языка С++. Ее цель - разбудить
интерес к объектно-ориентированной технологии программирования и
сориентировать вас в правильном направлении.

Для краткости изложения, будем предполагать, что читатель знаком с
синтаксисом языка С.

              Объекты и классы

Сначала о концепции объектно-ориентированного программирования (ООП) в
целом. Когда-то давно упор в программировании делался на процедуры и
функции. Данные могли передаваться функциям в виде параметров или
аргументов. Сами функции производили определенные операции с данными или
простые вычисления. С появлением ООП функции и процедуры заменило нечто,
называемое "объектом".

В объекте слиты воедино данные и функции, которые ими манипулируют.
Обычно эти функции называют "методами". Каждый представитель какого-либо
класса обладает набором характеристик, которые роднят его с другими
объектами этого же класса. Это максимально приближено к нашим обычным
представлениям об окружающем мире. Обычно мы стараемся описать похожие
предметы или явления в более общих терминах, а именно, представить их
общность как класс, состоящий из отдельных объектов. Причем,
индивидуальные различия этих объектов будут приниматься во внимание
только по мере необходимости. Например, средства передвижения с четырьмя
колесами, двигателем на бензине, перемещающиеся по поверхности земли, мы
объединяем понятием (или классом) "автомобиль". Целью ООП является
перенесение этих представлений в технологию создания программ.

В качестве примера ООП в статье приводится программа перевода
десятеричных чисел в восьмеричное, двоичное или шестнадцатиричное
представление.

          Инкапсуляция и абстракция данных

Возможно, наиболее важным свойством ООП является инкапсуляция и
абстракция данных. Инкапсуляция - это объединение данных и функций в
новый тип данных - класс.

Абстракция данных дает возможность ограничить доступ к данным класса, и,
тем самым "спрятать" их.

Классы в С++ объявляются аналогично структурам данных в С. Класс может
быть объявлен с помощью любого из трех ключевых слов - struct, union или
class. Те различия, которые между ними существуют и делают инкапсуляцию
таким мощным инструментом, каким она является в С++.

Если в определении класса используется СТР, то все элементы класса будут
ПАБ по умолчанию. Что это значит? Это означает то, что остальные
элементы программы могут обращаться к этим данным (или методам) не
вызывая специальную функцию, элемент класса. Напротив, к
элементам-данным типа ПРИВ можно обращаться только через функцию-элемент
этого класса; а функции-элементы типа ПРИВ могут быть вызваны только
другими его функциями. Элементы СТР можно объявить ПРИВ, если это
необходимо.

Если для объявления класса используется ЮН, то все его элементы не
только будут ПАБ по умолчанию, но этот тип доступа нельзя изменить по
собственному желанию.

Ключевое слово КЛАСС действует противоположным СТР способом: делает все
элементы ПРИВ по умолчанию, с правом поменять этот тип доступа на ПАБ.
Это наиболее часто используемый в С++ способ определения класса. В нем
заключена суть инкапсуляции. Один тип данных, или класс, определяет и
структуру данных, и те функции, которые ей соответствуют. Данные
"невидимы" благодаря доступу ПРИВ, а значит их использование возможно
только через функции-элементы класса. Данные-"невидимки" это абстрактные
элементы класса. Программист, который использует данный класс не должен
знать что-либо о структуре данных класса, а только о функциях, которые
их используют.

                   Пример программы

Для начала определим класс с именем Number. Для простоты будем
переводить в альтернативное представление только целые числа. Опишем
раздел данных нашего класса:

    class Number {

          int Value;

};

Напомним, что, по умолчанию, элемент Value является ПРИВ. Значит, нам
следует определить некоторые функции для инициализации данных и
манипуляции ими. Теперь добавим к определению класса описание его
функций-элементов, которые объявим ПАБ в явном виде:

    class Decimal_Number {

          int Value;

    public:

          void Init_Value(int n);

          void Print_Value_In_Hex(void);

          void Print_Value_In_Octal(void);

          void Print_Value_In_Binary(void);

};

Теперь мы имеем несколько функций для оперирования данными класса: одну
для присвоения данным начального значения, и по функции для перевода
числа в каждое из представлений.

Вспомним, что определив класс, мы, тем самым получили новый тип данных.
Теперь требуется создать представителя (или объект) этого класса,
который будет на самом деле хранить и обрабатывать некоторые данные. Это
делается следующим образом, причем имя класса используется в этом
объявлении как название обычного типа данных:

        Decimal_Number Number;

Теперь у нас имеется объект с именем Number. Каким же образом можно ()
соответствующие методы для оперирования его данными? Для начала
инициализируем данные с помощью метода Init_Value. Используя синтаксис
аналогичный тому, которым пользуется язык С для доступа к элементам
структуры, присвоим Number значение 96:

        Number.Init_Value(96);

Такая инициализация данных называется "конструированием объекта"; а
описание метода конструирования объекта называется "конструктором
объекта". конструктор вызывается в момент объявления объекта класса.
Теперь перепишем определение класса и метод Init_Value, который
инициализирует его объекты, в таком виде:

     class Decimal_Number {

           int Value;

     public:

           Decimal_Number(int n);

           void Init_Value(int n);

           void Print_Value_In_Hex(void);

           void Print_Value_In_Octal(void);

           void Print_Value_In_Binary(void);

     };

Обратите внимание на то, что метод Init_Value теперь называется
Decimal_Number, так же как и сам класс. Конструктор класса и сам класс в
С++ всегда имеют одно и то же имя. Теперь, объявляя объект, мы
одновременно вызываем и конструктор класса, и, следовательно,
инициализируем данные этого объекта. Например, предложение

      Decimal_Number Number(96);

объявляет объект Number класса Decimal_Number и одновременно вызывает
конструктор класса, также с именем Decimal_Number, и передает ему
аргумент 96.

Итак, мы познакомились с тем, как определить простейший класс, объявить
объект этого класса и использовать конструктор класса для инициализации
данных этого объекта. Напомню, что мы только объявили методы класса, но
еще не описали их программным кодом, т.е. не определили эти методы.

Описать (определить) метод можно двумя способами - внутри и вне
определения класса. Те методы, которые могут быть определены внутри
класса, как правили представляют собой очень короткие и простые функции.
Так, в классе Decimal_Number можно определить конструктор внутри класса:

     class Decimal_Number {

           int Value;

     public:

           Decimal_Number(int n) { Value = n; }

           void Init_Value(int n);

           void Print_Value_In_Hex(void);

           void Print_Value_In_Octal(void);

           void Print_Value_In_Binary(void);

     };

Последний вариант определения класса отличается от предшествующего тем,
что здесь появился код (внутри фигурных скобок), представляющий собой
тело функции. Действие, выполняемое этой функцией заключается в том, что
переменной Value присваивается целочисленное значение.

Более сложные методы, или просто требующие большего числа строк кода,
лучше определять вне класса. Посмотрим, как это сделано для остальных
методов. Определение метода в С++ очень похоже на определение функции в
языке С. В С++ имя класса, которому принадлежит метод, предшествует
имени функции, а разделителем служат два двоеточия:

   void Decimal_Number::Print_Value_In_Hex(void)

{

         //здесь должен быть описан сам метод

};

   void Decimal_Number::Print_Value_In_Octal(void)

{

         //здесь должен быть описан сам метод

};

   void Decimal_Number::Print_Value_In_Binary(void)

{

         //здесь должен быть описан сам метод

};

Обратите внимание на новый момент в синтаксисе С++: комментарии, текст
которых умещается на одной строке, можно обозначать символами "//".

Теперь объединим все строки кода вместе и добавим текст основной (main)
программы. В результате получим программу, которая пользуется двумя
важными свойствами С++ - инкапсуляцией и абстракцией данных
(см.листинг).

Другими, не менее существенными свойствами объектно-ориентированных
языков, включая С++, являются наследование и полиморфизм. Остановимся
вкратце и на них.

                Наследование

Наследование в С++ имеет нечто общее с понятием наследования в биологии.
Аналогично живым существам, которые наследуют свои биологические
свойства от родителей, класс С++ (производный) может наследовать методы
и данные от других классов (базовых). В свою очередь производный класс
может стать базовым для каких-либо других классов. На этом аналогия
кончается. Производный класс наследует ВСЕ методы и структуры данных
базового класса. В С++ возможно наследование от более чем одного класса.
Это свойство называется множественным наследованием. При создании нового
класса, вместо того, чтобы описывать все используемые им методы, можно
унаследовать их от базовых классов. Таким образом, наследование экономит
время при написании программ и дает возможность повторно использовать
ранее созданный код.

               Полиморфизм

Это свойство воплощает очень простую идею, заложенную в
объектно-ориентированные языки программирования. Полиморфизм и
дополняющее его совмещение имен функций позволяют давать одинаковые
имена нескольким функциям, которые выполняют определенную операцию над
объектами нескольких различных классов.

Большинство языков программирования уже поддерживают, в ограниченном
виде, встроенный полиморфизм функций. Например, при выполнении операции
сложения двух чисел, компилятор самостоятельно распознает их тип и
вызывает соответствующую функцию, предназначенную для сложения данных
именно этих типов. В С++ полиморфизм распространяется и на функции,
определяемые пользователем. Они называются виртуальными функциями.
Например, функция, которая извлекает квадратный корень, может быть
определена несколько раз с одним и тем же именем, но разные определения
функции будут вызваны для работы с разными типами данных. Компилятор С++
сам позаботится о том, чтобы была вызвана именно та функция, которая
соответствует типам аргументов.

----------------------------------------------------------

 Листинг программы-конвертора десятичных чисел в восьмеричное, двоичное
и шестнадцатеричное представление

----------------------------------------------------------

#include <stdio.h>

#include <conio.h>

//определение класса

     class Decimal_Number {

           int Value;

     public:

           Decimal_Number(int n) { Value = n; }

           void Init_Value(int n);

           void Print_Value_In_Hex(void);

           void Print_Value_In_Octal(void);

           void Print_Value_In_Binary(void);

     };

//определение методов

   void Decimal_Number::Print_Value_In_Hex(void)

{

         //здесь должен быть описан сам метод

         printf("В шестнадцатеричном виде - %x\n", Value);

};

   void Decimal_Number::Print_Value_In_Octal(void)

{

         //здесь должен быть описан сам метод

         printf("В восьмеричном виде - %x\n", Value);

};

   void Decimal_Number::Print_Value_In_Binary(void)

{

     int i;

     unsigned int bit_mask=0x8000;

     int digit;

//

//печатать 0 или 1

     printf("В двоичном виде - ");

     for (i=1; i<=16; i++) {

          digit = bit_mask & Value;

          bit_mask >>= 1;

          if (digit == 0)

              printf("0");

          else

              printf("1");

      }

      printf("\n");

  }

void main()

{

     int done=0;

     int input;

     int go_on;

     Decimal_Number Number(0);

     while (!done) {

          printf("\n\nВведите десятичное число -> ");

          scanf("%d", &input);

          fflush(stdin);

          Decimal_Number Number(input);

          printf("\n");

//Выполнить преобразования

          Number.Print_Value_In_Hex();

          Number.Print_Value_In_Octal();

          Number.Print_Value_In_Binary();

          printf("\nПродолжить?(y/n) ");

          go_on = getche()

          if (go_on == 'y')

               done = 0;

          else

               done = 1;

      }

  }
