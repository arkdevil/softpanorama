(****************************************************************************)
(*                       MPCRT.DEF 2.00                                     *)
(*                    Modula Plus Tools 2.00                                *)
(*                  Copyright (c) Holofax 1992.                             *)
(*              All rights reserved. Ukraine. Kiev.                         *)
(****************************************************************************)

(*# call ( reg_param => ()) *)   (* for TopSpeed 2.x *)
(*# call(reg_saved => (ds, si, di,st1,st2)) *)
DEFINITION MODULE MpCrt;
(*╔════════════════════════════════════════════════════════════════════════╗*)
(*║               Модуль поддержки экрана и клавиатуры.                    ║*)
(*╚════════════════════════════════════════════════════════════════════════╝*)

FROM MpAsm  IMPORT _Logic,_Screen,_AreaX1,_AreaX2,_AreaY1,_AreaY2,
                   _SetLogic,_OutCharEGA,_SetPage,_UpCase,_LoCase,
                   _StrUpCase,_StrLoCase,_CopyPage;

TYPE
  (* Kурсор ------------------- *)
  CursorType =
    RECORD
      Start : CARDINAL; (* начальная строка в знакоместе *)
      End   : CARDINAL; (* конечная строка в знакоместе  *)
      Color : CARDINAL; (* цвет курсора                  *)
    END;


(*$F*)
  (* Процедура вывода символа на экран --------------------------------- *)
  OutChProc = PROCEDURE((*X*)INTEGER,         (* координаты абсолютной   *)
                        (*Y*)INTEGER,         (* позиции символа         *)
                        (*Ch*)CHAR,           (* выводимый символ        *)
                        (*ColChar*)CARDINAL,  (* цвет выводимого символа *)
                        (*ColBack*)CARDINAL); (* цвет фона               *)


(*$F*)
  (* Процедура вывода строки на экран ---------------------------------- *)
  OutStrProc = PROCEDURE((*X*)CARDINAL,        (* координаты абсолютной  *)
                         (*Y*)CARDINAL,        (* позиции строки         *)
                         (*Str*)ARRAY OF CHAR, (* выводимая строка       *)
                         (*ColText*)CARDINAL,  (* цвет текста            *)
                         (*ColBack*)CARDINAL); (* цвет фона              *)
(*$F*)
  (* Процедура закраски прямоугольной области -------------------------- *)
  ClearBarProc = PROCEDURE((*X1*)CARDINAL,     (* абсолютные координаты  *)
                           (*Y1*)CARDINAL,     (* закрашиваемой пямоуго- *)
                           (*X2*)CARDINAL,     (* льной области          *)
                           (*Y2*)CARDINAL,
                           (*Color*)CARDINAL); (* цвет закраски          *)

(*$F*)
  (* Процедура определения размера буффера сохранения части экрана ----- *)
  SizeBarProc = PROCEDURE((*X1*)CARDINAL,      (* абсолютные координаты  *)
                          (*Y1*)CARDINAL,
                          (*X2*)CARDINAL,
                          (*Y2*)CARDINAL) : CARDINAL;(* размер буффера   *)

(*$F*)
  (* Процедура сохранения области экрана ------------------------------- *)
  GetBarProc = PROCEDURE((*X1*)CARDINAL,       (* абсолютные координаты  *)
                          (*Y1*)CARDINAL,
                          (*X2*)CARDINAL,
                          (*Y2*)CARDINAL,
                          (*Buff*) ADDRESS);   (* буффер  сохранения     *)

(*$F*)
  (* Процедура воостановления области экрана --------------------------- *)
  PutBarProc = PROCEDURE((*Buff*) ADDRESS);     (* буффер восстановления *)

CONST      (* Логические операции вывода *)
  _MOV = 0;
  _AND = 1;
  _OR  = 2;
  _XOR = 3;

(*************************** Цветные константы ******************************)
(* Темные цвета  (текст и фон).           Светлые цвета (текст).            *)
(*   (Foreground & Background)             (Foreground)                     *)
(*--------------------------------------------------------------------------*)

     Black     =  0;(* черный       *)  DarkGray     =  8; (* темно-серый   *)
     Blue      =  1;(* синий        *)  LightBlue    =  9; (* голубой       *)
     Green     =  2;(* зеленый      *)  LightGreen   =  10;(* салатовый     *)
     Cyan      =  3;                    LightCyan    =  11;
     Red       =  4;(* красный      *)  LightRed     =  12;(* алый          *)
     Magenta   =  5;(* малиновый    *)  LightMagenta =  13;(*ярко-малиновый *)
     Brown     =  6;(* коричневый   *)  Yellow       =  14;(* желтый        *)
     LightGray =  7;(* светло-серый *)  White        =  15;(* белый         *)

VAR
  SetVModeOn  : BOOLEAN;      (* Устанавливать ли видео режим              *)
  VideoMode   : CARDINAL;     (* Текущий видео режим                       *)
  Width       : CARDINAL;     (* Ширина экрана                             *)
  Depth       : CARDINAL;     (* Высота экрана                             *)
  AspRatio    : REAL;
  NumColor    : CARDINAL;     (* Число цветов                              *)
  NumPages    : CARDINAL;     (* Число страниц адаптера                    *)
  BitPages    : CARDINAL;     (* Число графических плоскостей EGA          *)
  WidthByte   : CARDINAL;     (* Ширина экрана в байтах                    *)
(*  ActivePage  : CARDINAL;   (* Активная видео страница                   *) *)
  IsTextMode  : BOOLEAN;      (* Если TRUE - Текущий видео режим текстовый *)
  Cursor      : CursorType;   (* Вид текстового курсора                    *)
  CursorStack : INTEGER;      (* Стек курсора                              *)
  CurrentTextColor : CARDINAL;(* Цвет текста                               *)
  CurrentBackColor : CARDINAL;(* Цвет фона                                 *)
  CurrentX    : CARDINAL;     (* Текущее положение указателя (курсора)     *)
  CurrentY    : CARDINAL;
  OutCh       : OutChProc;   (* Процедура вывода на экран цветного символа  *)
  OutStr      : OutStrProc;  (* Процедура вывода на экран строки            *)
  ClearBar    : ClearBarProc;(* Процедура вывода закраски прямоугольника    *)
  SizeBar     : SizeBarProc; (* Процедура определения размера памяти для    *)
                             (* сохранения прямоугольной области            *)
  GetBar      : GetBarProc;  (* Сохранить прямоугольную область в буффере   *)
  PutBar      : PutBarProc;  (* Восстановить прямоугольную область из буффера *)

VAR
    CtrlLeft  : CHAR;        (* Левый символ-разделитель  *)
    CtrlRight : CHAR;        (* Правый символ разделитель *)


CONST     (* Переменные раположенные в модуле MpAsm *)
   Logic  ::= _Logic;
   Screen ::= _Screen;
   AreaX1 ::= _AreaX1;
   AreaY1 ::= _AreaY1;
   AreaX2 ::= _AreaX2;
   AreaY2 ::= _AreaY2;
          (* переменные процедурного типа *)
   SetLogic   ::= _SetLogic;
   OutCharEGA ::= _OutCharEGA;
   SetPage    ::= _SetPage;
   CopyPage   ::= _CopyPage;

(****************************************************************************)
(*               Установка видео режима.                                    *)
(****************************************************************************)

PROCEDURE Text80x25;   (* 80x25 - текстовый режим              *)
PROCEDURE Text80x43;   (* 80x43 - текстовый режим (только EGA) *)
PROCEDURE Text80x50;   (* 80x50 - текстовый режим (только VGA) *)
PROCEDURE GraphEGA_E;  (* 640x200x16  графический режим        *)
PROCEDURE GraphEGA_10; (* 640x350x16  графический режим        *)
PROCEDURE GraphVGA_12; (* 640x480x16  графический режим        *)

(****************************************************************************)
(*               Работа с курсором.(текущим указателем)                     *)
(****************************************************************************)

PROCEDURE GotoXY(X,Y : CARDINAL);
(* Установить курсор в абсолитную позицию X,Y.                              *)
(* ════════════════════════════════════════════════════════════════════════ *)

PROCEDURE WhereXY(VAR X : CARDINAL; VAR Y : CARDINAL);
(* Определить местоположение курсора.                                       *)
(* ════════════════════════════════════════════════════════════════════════ *)

PROCEDURE CursorOn;
(* Отобразить курсор.                                                       *)
(* ════════════════════════════════════════════════════════════════════════ *)

PROCEDURE CursorOff;
(* Спрятать курсор.                                                         *)
(* ════════════════════════════════════════════════════════════════════════ *)

PROCEDURE UserCursor(startline, endline : CARDINAL);
(* Задать вид курсора.                                                      *)
(* ════════════════════════════════════════════════════════════════════════ *)

PROCEDURE FatCursor;
(* Курсор на ползнакоместа.                                                 *)
(* ════════════════════════════════════════════════════════════════════════ *)

PROCEDURE BlockCursor;
(* Курсор на все знакоместо.                                                *)
(* ════════════════════════════════════════════════════════════════════════ *)

PROCEDURE NormalCursor;
(* Нормальный курсор.                                                       *)
(* ════════════════════════════════════════════════════════════════════════ *)


(****************************************************************************)
(*                      Вывод на экран.                                     *)
(****************************************************************************)

PROCEDURE BlinkOn(on : BOOLEAN);
(* Разрешить/запретить(разрешить 16 цветов) мигание символов.               *)
(* ════════════════════════════════════════════════════════════════════════ *)

PROCEDURE CheckArea(x,y : INTEGER) : BOOLEAN;
(* Проверить входит ли точка в область вывода.                              *)
(* ════════════════════════════════════════════════════════════════════════ *)

PROCEDURE SetOutPut(x1,y1,x2,y2 : CARDINAL);
(* Установить область вывода.                                               *)
(* ════════════════════════════════════════════════════════════════════════ *)

PROCEDURE GetOutPut(VAR x1,y1,x2,y2 : CARDINAL);
(* Получить информацию об области вывода.                                  *)
(* ════════════════════════════════════════════════════════════════════════ *)

PROCEDURE ClrScr(c : CARDINAL);
(* Очистить экран заданным цветом.                                          *)
(* ════════════════════════════════════════════════════════════════════════ *)

PROCEDURE TextColor(Col : CARDINAL);
(* Установка текущим цвет текстовой информации.                             *)
(* ════════════════════════════════════════════════════════════════════════ *)

PROCEDURE BackColor(Col : CARDINAL);
(* Установка текущим цвет фона текстовой информации.                        *)
(* ════════════════════════════════════════════════════════════════════════ *)

PROCEDURE SetGrand(c : CARDINAL);
(* Установка цвета бордюра экрана.                                          *)
(* ════════════════════════════════════════════════════════════════════════ *)

(*PROCEDURE SetLogic(Op : SHORTCARD); *)
(* Установить тип логической операции для вывода в графическом режиме.      *)
(* ════════════════════════════════════════════════════════════════════════ *)

PROCEDURE GetLogic() : SHORTCARD;
(* Текущая логическая операция вывода в графическом режиме.                 *)
(* ════════════════════════════════════════════════════════════════════════ *)

PROCEDURE OutText(str: ARRAY OF CHAR);
(* Вывести в абсолютную(установленную GotoXY) позицию строку.               *)
(* ════════════════════════════════════════════════════════════════════════ *)

PROCEDURE OutCtrlText(str : ARRAY OF CHAR; cCtrlText,cCtrlBack : CARDINAL);
(* Вывод строки с разделителями.                                            *)
(* ════════════════════════════════════════════════════════════════════════ *)

PROCEDURE OutCtrlStr(x,y : INTEGER; str : ARRAY OF CHAR;
                                         cCtrlText,cCtrlBack : CARDINAL);
(* Вывод строки с разделителями в абсолютную позицию.                       *)
(* ════════════════════════════════════════════════════════════════════════ *)

PROCEDURE OutFixStr(x,y : INTEGER; str:ARRAY OF CHAR; pos,n,cf,cb : CARDINAL);
(* Вывод фиксированное число символов (n).                                  *)
(* ════════════════════════════════════════════════════════════════════════ *)

(****************************************************************************)
(*        Сохранение и восстановление прямоугольного участка экрана.        *)
(****************************************************************************)

PROCEDURE ChangeAttrTXT(x1,y1,x2,y2,ct,cb : CARDINAL);
(* Установить новые аттрибуты прямоугольной области.                        *)
(* ════════════════════════════════════════════════════════════════════════ *)

PROCEDURE GetBarTXT(x1,y1,x2,y2 : CARDINAL; buff : ADDRESS);
(* Сохранить область экрана по указанному адресу.                           *)
(* ════════════════════════════════════════════════════════════════════════ *)

PROCEDURE PutBarTXT(buff : ADDRESS);
(* Восстановить область экрана.                                             *)
(* ════════════════════════════════════════════════════════════════════════ *)

PROCEDURE SizeBarTXT(l,t,r,b : CARDINAL ) : CARDINAL ;
(* Определить необходимое число байт для сохранения прямоугольной области.  *)
(* ════════════════════════════════════════════════════════════════════════ *)

PROCEDURE ClearBarTXT(x1,y1,x2,y2,c : CARDINAL);
(* Очистить область экрана.                                                 *)
(* ════════════════════════════════════════════════════════════════════════ *)

PROCEDURE SizeBarEGA(l,t,r,b : CARDINAL ) : CARDINAL;
(* Определить необходимое число байт для сохранения прямоугольной области.  *)
(* ════════════════════════════════════════════════════════════════════════ *)

(****************************************************************************)
(*                      Работа со шрифтами.                                 *)
(****************************************************************************)

PROCEDURE GetFontBIOS(mode : SHORTCARD) : ADDRESS;
(* Определить адрес шрифта.                                                 *)
(* 0 - текущий INT 1FH графический шрифт;                                   *)
(* 1 - текущий INT 43H графический шрифт;                                   *)
(* 2 - ПЗУ 8х14;                                                            *)
(* 3 - ПЗУ 8х8;                                                             *)
(* 4 - ПЗУ 8х8;                                                             *)
(* 5 - ПЗУ 9х14; (неиспользуется)                                           *)
(* 6 - ПЗУ 8х16  (только VGA);                                              *)
(* 7 - ПЗУ 9х16  (только VGA);  (неиспользуется)                            *)
(* ════════════════════════════════════════════════════════════════════════ *)

PROCEDURE SetStandFont();
(* Установить стандартный матричный шрифт.                                  *)
(* ════════════════════════════════════════════════════════════════════════ *)

PROCEDURE SetFont(font : ADDRESS; high : CARDINAL);
(* Установить матричный шрифт.                                              *)
(* ════════════════════════════════════════════════════════════════════════ *)

PROCEDURE CharSize(VAR wid,dep : CARDINAL);
(* Определить размеры текущего шрифта                                       *)
(* ════════════════════════════════════════════════════════════════════════ *)

(****************************************************************************)
(*                                                                          *)
(****************************************************************************)

CONST UpCase    ::= _UpCase;   (* Процедуры содежащиеся в MpAsm *)
      LoCase    ::= _LoCase;
      StrUpCase ::= _StrUpCase;
      StrLoCase ::= _StrLoCase;


(*PROCEDURE UpCase(Ch : CHAR) : CHAR;*)
(* Символ в верхний регистр.                                                *)
(* ════════════════════════════════════════════════════════════════════════ *)

(*PROCEDURE LoCase(Ch : CHAR) : CHAR;*)
(* Символ в нижний регистр.                                                 *)
(* ════════════════════════════════════════════════════════════════════════ *)

(*PROCEDURE StrUpCase(VAR Str : ARRAY OF CHAR);*)
(* Строку в верхний регистр.                                                *)
(* ════════════════════════════════════════════════════════════════════════ *)

(*PROCEDURE StrLoCase(VAR Str : ARRAY OF CHAR);*)
(* Строку в нижний регистр.                                                 *)
(* ════════════════════════════════════════════════════════════════════════ *)

CONST    (* for GetKey() *)
  KeyF1  = CHR(128+3BH); (* F1 *)   KeyF2  = CHR(128+3CH); (* F2 *)
  KeyF3  = CHR(128+3DH); (* F3 *)   KeyF4  = CHR(128+3EH); (* F4 *)
  KeyF5  = CHR(128+3FH); (* F5 *)   KeyF6  = CHR(128+40H); (* F6 *)
  KeyF7  = CHR(128+41H); (* F7 *)   KeyF8  = CHR(128+42H); (* F8 *)
  KeyF9  = CHR(128+43H); (* F9 *)   KeyF10 = CHR(128+44H); (* F10 *)
  KeyF11 = CHR(128+85); (* F11 *)   KeyF12 = CHR(128+86); (* F12 *)

  KeyDown  = CHR(128+50H);   (* Down        *)
  KeyUp    = CHR(128+48H);   (* Up          *)
  KeyLeft  = CHR(128+4BH);   (* Left        *)
  KeyRight = CHR(128+4DH);   (* Right       *)
  KeyHome  = CHR(128+47H);   (* Home        *)
  KeyEnd   = CHR(128+4FH);   (* End         *)
  KeyIns   = CHR(128+52H);   (* Ins         *)
  KeyDel   = CHR(128+53H);   (* Del         *)
  KeyPgUp  = CHR(128+49H);   (* PgUp        *)
  KeyPgDn  = CHR(128+51H);   (* PgDn        *)
  KeyENTER = CHR(0DH);       (* Enter       *)
  KeyESC   = CHR(1BH);       (* Esc         *)
  KeyNUM   = CHR(128+03H);   (* Num Lock    *)
  KeySPACE = CHR(20H);       (* Space       *)
  KeyBackSpace = CHR(8H);    (* BackSpase   *)
  KeyTab   = CHR(9H);        (* Tab         *)
  KeyShiftTab  = CHR(128+15);(* Shift & Tab *)

CONST
  (* ---- Эмуляция кнопок мыши клавишами клавиатуры ---------------------- *)
  MsOutKey      = CHR(248);  (* 0F8H - Мышка за окном обе кнопки отпущены  *)
  MsOutKeyLeft  = CHR(249);  (* 0F9H - Мышка за окном левая  кнопка нажата *)
  MsOutKeyRight = CHR(250);  (* 0FAH - Мышка за окном правая кнопка нажата *)
  MsOutKeyAll   = CHR(251);  (* 0FBH - Мышка за окном обе кнопки нажаты    *)
  MsInKey       = CHR(252);  (* 0FCH - Мышка в окне обе кнопки отпущены    *)
  MsInKeyLeft   = CHR(253);  (* 0FDH - Мышка в окне левая  кнопка нажата   *)
  MsInKeyRight  = CHR(254);  (* 0FEH - Мышка в окне правая кнопка нажата   *)
  MsInKeyAll    = CHR(255);  (* 0FFH - Мышка в окне обе кнопки нажаты      *)


PROCEDURE ClearKbd;
(* Очистка пользовательского буфера и буфера BIOSa клавиатуры               *)
(* ════════════════════════════════════════════════════════════════════════ *)

PROCEDURE KeyToBuffer(c : CHAR);
(* Запись символа с в буффер клавиатуры                                     *)
(* ════════════════════════════════════════════════════════════════════════ *)

PROCEDURE GetKey() : CHAR;
(* Возвратить код нажатой клавиши.                                          *)
(* ════════════════════════════════════════════════════════════════════════ *)

PROCEDURE KeyPressed() : BOOLEAN;
(* Проверка на наличие нажатия клавиши.                                     *)
(* ════════════════════════════════════════════════════════════════════════ *)

PROCEDURE Pressed() : CHAR;
(* Была ли нажата клавиша ? "ДА" - код; "НЕТ" - 0C.                         *)
(* ════════════════════════════════════════════════════════════════════════ *)

END MpCrt.
