(****************************************************************************)
(*                       MPGRAPH.DEF 2.00                                   *)
(*                    Modula Plus Tools 2.00                                *)
(*                  Copyright (c) Holofax 1992.                             *)
(*              All rights reserved. Ukraine. Kiev.                         *)
(****************************************************************************)
(*$G+*)
DEFINITION MODULE MpGraph;
(*╔════════════════════════════════════════════════════════════════════════╗*)
(*║             Модуль работы с графическими примитивами.                  ║*)
(*╚════════════════════════════════════════════════════════════════════════╝*)

FROM MpCrt IMPORT SizeBarEGA;

PROCEDURE Sin(a : INTEGER) : INTEGER;
(* Возвращает 16384 * Sin(a), a  в градусах                                 *)
(* ════════════════════════════════════════════════════════════════════════ *)

PROCEDURE Cos(a : INTEGER) : INTEGER;
(* Возвращает 16384 * Cos(a), a  в градусах                                 *)
(* ════════════════════════════════════════════════════════════════════════ *)


PROCEDURE SetArea(l,t,r,b : CARDINAL; cf,cb : CARDINAL);
(* Установить цветную область вывода.                                       *)
(* ════════════════════════════════════════════════════════════════════════ *)

PROCEDURE GetArea(VAR l,t,r,b : CARDINAL);
(* Определить область вывода.                                               *)
(* ════════════════════════════════════════════════════════════════════════ *)

PROCEDURE Plot(x,y : INTEGER; c : CARDINAL);
(* Отобразить точку заданного цвета.                                        *)
(* ════════════════════════════════════════════════════════════════════════ *)

PROCEDURE Point(x,y : INTEGER) : CARDINAL;
(* Определить цвет точки.                                                   *)
(* ════════════════════════════════════════════════════════════════════════ *)

PROCEDURE HLine (x,y,x2 : INTEGER; c : CARDINAL );
(* Отобразить горизонтальную линию.                                         *)
(* ════════════════════════════════════════════════════════════════════════ *)

PROCEDURE VLine(x,y,y2 : INTEGER; c : CARDINAL);
(* Отобразить вертикальную линию.                                           *)
(* ════════════════════════════════════════════════════════════════════════ *)

PROCEDURE GetHLine(x,y,x1 : CARDINAL ; PTRGraph : ADDRESS) ;

PROCEDURE PutHLine(x,y : CARDINAL ; PTRGraph : ADDRESS) ;

PROCEDURE HLineSize(x0,x1 : CARDINAL) : CARDINAL;

PROCEDURE Line(x0,y0,x1,y1: INTEGER; c: CARDINAL);

PROCEDURE LineTo(x2,y2: INTEGER; c: CARDINAL);
(* Отобразить линию от текущего указателя до точки x2,y2.                   *)
(* Tочка x2,y2 не отображается. Это сделано для коректного выполнения логи- *)
(* ческих операций при рисовании нескольких линий одна за другой.           *)
(* ════════════════════════════════════════════════════════════════════════ *)

PROCEDURE Disc(x0,y0,r: INTEGER; c: CARDINAL);
PROCEDURE Circle(x0,y0,r: INTEGER; c: CARDINAL);

PROCEDURE Ellipse(x0, y0, a0, b0: INTEGER; c : CARDINAL; Fill: BOOLEAN);
(* Отобразить эллипс.                                                       *)
(* ════════════════════════════════════════════════════════════════════════ *)

PROCEDURE Arc(x,y : INTEGER; radius : CARDINAL; stangle,endangle : INTEGER;
                                                Color:CARDINAL);
(* Нарисовать дугу.                                                         *)
(* ════════════════════════════════════════════════════════════════════════ *)

PROCEDURE Sector(x,y : INTEGER; r : CARDINAL; stang,endang : INTEGER;
                       color : CARDINAL; fill : BOOLEAN);
(* Нарисовать сектор.                                                       *)
(* ════════════════════════════════════════════════════════════════════════ *)

PROCEDURE Pie(x,y,a,b,atang,endang : INTEGER; color : CARDINAL;
                                                    fill  : BOOLEAN);
(*                                                                          *)
(* ════════════════════════════════════════════════════════════════════════ *)

PROCEDURE Diagramma(x,y,a,b  : INTEGER;
                    count    : CARDINAL;
                    ptr,cPtr : ADDRESS);
(*                                                                          *)
(* ════════════════════════════════════════════════════════════════════════ *)

PROCEDURE StackFill(x, y: INTEGER; Color: CARDINAL; Boundary: CARDINAL);
(*                                                                          *)
(* ════════════════════════════════════════════════════════════════════════ *)

PROCEDURE FloodFill(x, y: INTEGER; Color: CARDINAL; Boundary: CARDINAL);
(*                                                                          *)
(* ════════════════════════════════════════════════════════════════════════ *)

PROCEDURE Polygon(n: CARDINAL; ipx,ipy: ADDRESS; c: CARDINAL);
(* Рисует произвольный многоугольник (c закрашиванием)                      *)
(* ipx,ipy - указатели на массивы слов (точки многоугольника).              *)
(* ════════════════════════════════════════════════════════════════════════ *)

PROCEDURE DrawPoly(n: CARDINAL; ipx,ipy: ADDRESS; c: CARDINAL);
(* Рисует произвольный многоугольник (без закрашивания)                     *)
(* ipx,ipy - указатели на массивы слов (точки многоугольника).              *)
(* ════════════════════════════════════════════════════════════════════════ *)

PROCEDURE ConvexPolygon(n : CARDINAL; ipx,ipy : ADDRESS; Col : CARDINAL);
(* Процедура построения выпуклого многоугольника ; многоугольник может      *)
(* быть и не выпуклым , но по горизонтали должен содержать не более 2 точек *)
(* остальное аналогично Polygon.                                            *)
(* ════════════════════════════════════════════════════════════════════════ *)

PROCEDURE Bar(l,t,r,b,c : INTEGER; fill : BOOLEAN) ;
(* Процедура построения прямоугольника , если fill , то с заполнением       *)
(* l-левая , t-верхняя , r-правая , b-нижняя .Если fill, то с ::= ColorFill *)
(* ════════════════════════════════════════════════════════════════════════ *)

PROCEDURE Box(l,t,r,b : CARDINAL; l1,t1,r1,b1 : CARDINAL ;
              cframe,cl,ct,cr,cb,cf : CARDINAL;
              fill : BOOLEAN;
              hide : BOOLEAN) ;
(* Процедура построения бокса с прямоугольными передней и задней гранями    *)
(* l-левая , t-верхняя , r-правая , b-нижняя .Если fill, то с ::= ColorFill *)
(* l,t,r,b координаты ближней грани , а l1,t1,r1,b1 - дальней               *)
(* сl,ct,cr,cb - цвета граней(соответственно) , сf - цвет ближней грани     *)
(* cframe - цвет рамки.                                                     *)
(* Если fill , то цвета воспринимаются как ColorFill , иначе как обычные    *)
(* Если hide , то невидимые части не отображаются. Если hide=false a fill=  *)
(* true , то закраска не производится, а линии будут иметь ColorFill цвет.  *)
(* ════════════════════════════════════════════════════════════════════════ *)

PROCEDURE GetQImage(l,t,r,b : CARDINAL ; PTRGraph : ADDRESS ) ;

PROCEDURE PutQImage(l,t : CARDINAL ; PTRGraph : ADDRESS ) ;

PROCEDURE GetImage(l,t,r,b : CARDINAL ; PTRGraph : ADDRESS ) ;
(* Сохраняет bar-область на границу пикселя                                   *)
(* ════════════════════════════════════════════════════════════════════════ *)

PROCEDURE PutImage(l,t : CARDINAL ; PTRGraph : ADDRESS) ;
(* Восстанавливает,сохраненнoe GetImage изображение.   *)
(* ════════════════════════════════════════════════════════════════════════ *)

PROCEDURE WaitForRetrace(yn : BOOLEAN);
(* Определяет синхронизировать ли вывод имиджа обратным ходом развертки       *)
(* ════════════════════════════════════════════════════════════════════════ *)

PROCEDURE GetPolygon(n: CARDINAL; ipx,ipy: ADDRESS; PTRGraph : ADDRESS);
(* Сохраняет под многоугольником экран по адресу PtrGraph                   *)
(* ════════════════════════════════════════════════════════════════════════ *)

PROCEDURE PutPolygon(x,y : CARDINAL; PTRGraph : ADDRESS);
(* Выводит на экран сохраненный по PtrGraph mногоугольник , назначение ор   *)
(* аналогично op в PutImage(см. CGA.mod) .                                  *)
(* ════════════════════════════════════════════════════════════════════════ *)

CONST  ImageSize ::= SizeBarEGA;
(* PROCEDURE ImageSize(l,t,r,b : CARDINAL ) : CARDINAL ;                    *)
(* Возвращает размер (в байтах) памяти, необходимой для хранения изображения*)
(* сохраняемого процедурoй GetImage.                                        *)
(* ════════════════════════════════════════════════════════════════════════ *)

PROCEDURE PolygonSize(n : CARDINAL ; ipx,ipy : ADDRESS) : CARDINAL ;
(* Возвращает размер (в байтах) памяти, необходимой для хранения изображения*)
(* сохраняемого процедурой GetPolygon ( cм. модуль UGraph ).                *)
(* ════════════════════════════════════════════════════════════════════════ *)


(****************************************************************************)
(* Вывод текста ввекторными шрифтами.                                       *)
(* Используемые шрифты должны быть в формате BGI  (Turbo C,Pascal,..).      *)
(****************************************************************************)

PROCEDURE SetFontBGI(font : ADDRESS; mulX,divX,mulY,divY : CARDINAL;
                                                   alpha : INTEGER);
(* Установить векторный шрифт.                                              *)
(* ════════════════════════════════════════════════════════════════════════ *)

PROCEDURE LenghtBGI( T : ARRAY OF CHAR) : CARDINAL;
(* Определить длину векторного шрифта.                                      *)
(* ════════════════════════════════════════════════════════════════════════ *)

PROCEDURE OutCharBGI(x,y : CARDINAL; Ch : CHAR; Col : CARDINAL);
(* Вывод символа Ch с координатами x,y и цветом Col , текущим шрифтом с масш. *)
(* ════════════════════════════════════════════════════════════════════════ *)

PROCEDURE OutStrBGI(x,y : INTEGER; T : ARRAY OF CHAR) ;
(* Вывод строки текста Т. Координаты x,y - левый верхний угол начала текста   *)
(* ════════════════════════════════════════════════════════════════════════ *)

PROCEDURE OutShadowStrBGI(x,y : INTEGER; T : ARRAY OF CHAR; dx,dy : INTEGER;
                                                            c : CARDINAL) ;
(* Вывод строки с тенью цвета с и смещением dx,dy.                          *)
(* ════════════════════════════════════════════════════════════════════════ *)

PROCEDURE OutTextBGI( T : ARRAY OF CHAR) ;
(* Вывод строки текста Т. Координаты x,y - "внутренние",устанавливаемые пре-  *)
(* дыдущей OutText или MoveTo.                                                *)
(* ════════════════════════════════════════════════════════════════════════ *)

PROCEDURE GetDepthFontBGI() : CARDINAL;
(* Высота текущего векторного шрифта.                                       *)
(* ════════════════════════════════════════════════════════════════════════ *)

(* ************************************************************************ *)
(* *                Работа с файлами формата PCX(PCC).                    * *)
(* ************************************************************************ *)

TYPE
   HeaderPCX =
     RECORD
       Manuf      :SHORTCARD;                (* Всегда =10 для Paintbrush   *)
       Hard       :SHORTCARD;                (* Информация о версии         *)
       EnCod      :SHORTCARD;                (* Групповое кодирование(=1)   *)
       BitPx      :SHORTCARD;                (* Бит на точку                *)
       X1         :INTEGER;                 (* Размеры картинки(включит.)  *)
       Y1         :INTEGER;                 (*                             *)
       X2         :INTEGER;                 (*                             *)
       Y2         :INTEGER;                 (*                             *)
       HRes       :INTEGER;                 (* Гориз.разрешение дисплея    *)
       VRes       :INTEGER;                 (* Вертик.разрешение дисплея   *)
       Pallette   :ARRAY[0..47] OF SHORTCARD;(* Палитра                     *)
       Vmode      :SHORTCARD;                (* (игнорируется)              *)
       Nplanes    :SHORTCARD;                (*Кол-во плоскостей (вер.2.5=0)*)
       BpLine     :INTEGER;                  (* Байт на строку              *)
       PalInfo    :CARDINAL;                 (* Информ.о палитре(1=цв,2=сер)*)
       SHRes      :CARDINAL;                 (* Разрешение сканнера         *)
       SVRes      :CARDINAL;                 (*                             *)
       Xtra       :ARRAY[0..53] OF SHORTCARD;(* Доп.пустое место (фильтр)   *)
     END;


PROCEDURE SetPallettePCX(header : HeaderPCX);
(* Установить палитру из заголовка файла.                                   *)
(* ════════════════════════════════════════════════════════════════════════ *)

PROCEDURE  UnPackPCX(header : HeaderPCX; buff : ADDRESS);
(* Распаковать файл PCX на экран.                                           *)
(* ════════════════════════════════════════════════════════════════════════ *)

PROCEDURE  UnPackPCC(x,y : INTEGER; header : HeaderPCX; buff : ADDRESS);
(* Распаковать файл PCC на экран.                                           *)
(* ════════════════════════════════════════════════════════════════════════ *)

END MpGraph.
