(****************************************************************************)
(*                      MPMOUSE.DEF 2.00                                    *)
(*                    Modula Plus Tools 2.00                                *)
(*                  Copyright (c) Holofax 1992.                             *)
(*              All rights reserved. Ukraine. Kiev.                         *)
(****************************************************************************)
(*$G+*)
DEFINITION MODULE MpMouse;
(*╔════════════════════════════════════════════════════════════════════════╗*)
(*║            Модуль работы с драйвером "mouse". (33H)                    ║*)
(*╚════════════════════════════════════════════════════════════════════════╝*)

TYPE (* Состояние "Мышки" *)
  MouseStatus = (NoMouse,             (*драйвер или аппаратная поддержка*)
                                      (*        неустановлены           *)
                 HaveNoEqualTwoButton,(* "М Ы Ш Ь" имеет не две клавиши *)
                 HaveTwoButton,       (* "М Ы Ш Ь" имеет две клавиши    *)
                 HaveTreeButton);     (* "М Ы Ш Ь" имеет три клавиши ,
                                             типа Mouse System *)

VAR UseMouse  : BOOLEAN; (* Присутствует ли на экране        *)

TYPE (* Состояние клавиш "Мышки"*)
  ButtonStatus = ( NoButton,LeftButton,RightButton,BothButton,
                 (* использование следующих значений предполагает
                                               наличие 3-х клавишной "мышки"*)
                   CenterButton,LeftAndCenterButtons,RightAndCenterButtons,
                   All3Buttons);

TYPE (* Команды вызова пользовательского прерывания *)
  MouseEventType = (MouseMoved,  (* изменение позиции курсора *)
                    LfPr,        (* нажата левая клавиша      *)
                    LfRl,        (* отпущена левая клавиша    *)
                    RtPr,        (* нажата правая клавиша     *)
                    RtRl,        (* отпущена правая клавиша   *)
                    CtrPr,       (* нажата средняя клавиша    *)
                    CtrRl);      (* отпущена средняя клавиша  *)
      (* Маска вызова *)
  MouseEventSet = SET OF MouseEventType;

TYPE (* Тип текстового курсора "жесткий" или "мягкий" *)
  MouseTextCursorMode = (Hard,Soft);

TYPE (* Координаты "горячего пятна" графического курсора*)
  ActivMousePixel = [0..16];

     (* Массивы масок для графического курсора EGA или VGA *)
  MouseGraphMaskEGA = ARRAY[0..31] OF CARDINAL;
     (* Массивы масок для графического курсора CGA *)
  MouseGraphMaskCGA = ARRAY[0..31] OF SHORTCARD;

CONST
     (* гарфический курсор "кисть"  для EGA или VGA *)
     G_Hand =
         MouseGraphMaskEGA(0E7FFH,      (* 1110011111111111 *)
                           0C3FFH,      (* 1100001111111111 *)
                           0C3FFH,      (* 1100001111111111 *)
                           0C3FFH,      (* 1100001111111111 *)
                           0C0FFH,      (* 1100000011111111 *)
                           0C01FH,      (* 1100000000011111 *)
                           0C003H,      (* 1100000000000011 *)
                           8001H,       (* 1000000000000001 *)
                           0001H,       (* 0000000000000001 *)
                           0001H,       (* 0000000000000001 *)
                           0001H,       (* 0000000000000001 *)
                           0001H,       (* 0000000000000001 *)
                           8001H,       (* 1000000000000001 *)
                           8003H,       (* 1000000000000011 *)
                           0C007H,      (* 1100000000000111 *)
                           0E007H,      (* 1110000000000111 *)

                           0000H,       (* 0000000000000000 *)
                           1800H,       (* 0001100000000000 *)
                           1800H,       (* 0001100000000000 *)
                           1800H,       (* 0001100000000000 *)
                           1800H,       (* 0001100000000000 *)
                           1B00H,       (* 0001101100000000 *)
                           1B60H,       (* 0001101101100000 *)
                           1B68H,       (* 0001101101101000 *)
                           5FF8H,       (* 0101111111111000 *)
                           7FFCH,       (* 0111111111111100 *)
                           7FFCH,       (* 0111111111111100 *)
                           7FFCH,       (* 0111111111111100 *)
                           3FFCH,       (* 0011111111111100 *)
                           1FF8H,       (* 0001111111111000 *)
                           0FF0H,       (* 0000111111110000 *)
                           0FF0H);      (* 0000111111110000 *)

     (* графический курсор "стрелка"  для EGA или VGA *)
     G_DirectR =
         MouseGraphMaskEGA(0FFFCH,       (* 1111111111111100 *)
                           0FFF8H,       (* 1111111111111000 *)
                           0FFE0H,       (* 1111111111100000 *)
                           0FF81H,       (* 1111111110000001 *)
                           0FE01H,       (* 1111111000000001 *)
                           0F803H,       (* 1111100000000011 *)
                           0E003H,       (* 1110000000000011 *)
                           08007H,       (* 1000000000000111 *)
                           00007H,       (* 0000000000000111 *)
                           0800FH,       (* 1000000000001111 *)
                           0C00FH,       (* 1100000000001111 *)
                           0801FH,       (* 1000000000011111 *)
                           0021FH,       (* 0000001000011111 *)
                           007FFH,       (* 0000011111111111 *)
                           00FFFH,       (* 0000111111111111 *)
	                   01FFFH,       (* 0001111111111111 *)
	
                           00001H,      (* 0000000000000001 *)
                           00002H,      (* 0000000000000010 *)
                           0000EH,      (* 0000000000001110 *)
                           0003CH,      (* 0000000000111100 *)
                           000FCH,      (* 0000000011111100 *)
                           003F8H,      (* 0000001111111000 *)
                           00FF8H,      (* 0000111111111000 *)
                           03FF0H,      (* 0011111111110000 *)
                           0FFF0H,      (* 1111111111110000 *)
                           03FE0H,      (* 0011111111100000 *)
                           01FE0H,      (* 0001111111100000 *)
                           03FC0H,      (* 0011111111000000 *)
                           078C0H,      (* 0111100011000000 *)
                           0F000H,      (* 1111000000000000 *)
                           0E000H,      (* 1110000000000000 *)
                           0C000H);      (* 1100000000000000 *)

     G_DirectL =
         MouseGraphMaskEGA(
                            03FFFH,         (*  0011111111111111 *)
                            01FFFH,         (*  0001111111111111 *)
                            00FFFH,         (*  0000111111111111 *)
                            007FFH,         (*  0000011111111111 *)
                            003FFH,         (*  0000001111111111 *)
                            001FFH,         (*  0000000111111111 *)
                            000FFH,         (*  0000000011111111 *)
                            0007FH,         (*  0000000001111111 *)
                            0003FH,         (*  0000000000111111 *)
                            0001FH,         (*  0000000000011111 *)
                            0000FH,         (*  0000000000001111 *)
                            020FFH,         (*  0010000011111111 *)
                            0E0FFH,         (*  1110000011111111 *)
                            0F07FH,         (*  1111000001111111 *)
                            0F07FH,         (*  1111000001111111 *)
                            0F83FH,         (*  1111100000111111 *)

                            00000H,         (*  0000000000000000 *)
                            04000H,         (*  0100000000000000 *)
                            06000H,         (*  0110000000000000 *)
                            07000H,         (*  0111000000000000 *)
                            07800H,         (*  0111100000000000 *)
                            07C00H,         (*  0111110000000000 *)
                            07E00H,         (*  0111111000000000 *)
                            07F00H,         (*  0111111100000000 *)
                            07F80H,         (*  0111111110000000 *)
                            07FC0H,         (*  0111111111000000 *)
                            07C00H,         (*  0111110000000000 *)
                            00E00H,         (*  0000111000000000 *)
                            00E00H,         (*  0000111000000000 *)
                            00700H,         (*  0000011100000000 *)
                            00700H,         (*  0000011100000000 *)
                            00000H);        (*  0000000000000000 *)

                                    (*  1111111011111111 *) (* W  п х Ч *)
                                    (*  1111111111111111 *) (* 0  1 1 0 *)
                                    (*  0000000100000000 *) (* 1  0 1 0 *)

     G_DirectAll =
         MouseGraphMaskEGA(
                            0FEFFH,        (*  1111111011111111 *)
                            0FC7FH,        (*  1111110001111111 *)
                            0F83FH,        (*  1111100000111111 *)
                            0F01FH,        (*  1111000000011111 *)
                            0FC7FH,        (*  1111110001111111 *)
                            0EC6FH,        (*  1110110001101111 *)
                            0CC67H,        (*  1100110001100111 *)
                            00001H,        (*  0000000000000001 *)
                            0CC67H,        (*  1100110001100111 *)
                            0EC6FH,        (*  1110110001101111 *)
                            0FC7FH,        (*  1111110001111111 *)
                            0F01FH,        (*  1111000000011111 *)
                            0F83FH,        (*  1111100000111111 *)
                            0FC7FH,        (*  1111110001111111 *)
                            0FEFFH,        (*  1111111011111111 *)
                            0FFFFH,        (*  1111111111111111 *)

                            00000H,        (*  0000000000000000 *)
                            00100H,        (*  0000000100000000 *)
                            00380H,        (*  0000001110000000 *)
                            007C0H,        (*  0000011111000000 *)
                            00100H,        (*  0000000100000000 *)
                            00100H,        (*  0000000100000000 *)
                            01110H,        (*  0001000100010000 *)
                            07C7CH,        (*  0111110001111100 *)
                            01110H,        (*  0001000100010000 *)
                            00100H,        (*  0000000100000000 *)
                            00100H,        (*  0000000100000000 *)
                            007C0H,        (*  0000011111000000 *)
                            00380H,        (*  0000001110000000 *)
                            00100H,        (*  0000000100000000 *)
                            00000H,        (*  0000000000000000 *)
                            00000H);       (*  0000000000000000 *)


PROCEDURE GetStatusMouseDriver() : BOOLEAN;
(* Проверка состояния драйвера "мышки".                                     *)
(* ════════════════════════════════════════════════════════════════════════ *)

PROCEDURE InitMouse() : MouseStatus;                                  (* 0h *)
(* Начальная установка драйвера и чтение текущего состояния.                *)
(* ════════════════════════════════════════════════════════════════════════ *)

PROCEDURE ShowMouse;                                                  (* 1h *)
(* Сделать курсор видимым.                                                  *)
(* ════════════════════════════════════════════════════════════════════════ *)

PROCEDURE HideMouse;                                                  (* 2h *)
(* Сделать курсор невидимым.                                                *)
(* ════════════════════════════════════════════════════════════════════════ *)

PROCEDURE MouseWhereXY(VAR MouseX : INTEGER;                         (* 3h *)
                             VAR MouseY : INTEGER;
                             VAR Button : ButtonStatus);
(* Определение местоположения курсора и состояния клавиш "мышки".           *)
(* ════════════════════════════════════════════════════════════════════════ *)

PROCEDURE MouseGotoXY(MouseX,MouseY : CARDINAL);                      (* 4h *)
(* Установить курсор на экране в заданную позицию.                          *)
(* ════════════════════════════════════════════════════════════════════════ *)

PROCEDURE MouseButtonPressed(Button : ButtonStatus;                   (* 5h *)
                         VAR Count : CARDINAL;
                         VAR LastX : INTEGER;
                         VAR LastY : INTEGER) : BOOLEAN;
(* Получить информацию о количестве нажатий на клавишу.                     *)
(*                                                                          *)
(*  TRUE  - Button была нажата;                                             *)
(*  FALSE - Button не нажималась;                                           *)
(*  Count - количество нажатий на указанную клавишу с момента последнего    *)
(*          вызова данной функции;                                          *)
(*  LastX,LastY - позиция курсора в момент последнего нажатия указанной     *)
(*                клавиши;                                                  *)
(* ════════════════════════════════════════════════════════════════════════ *)

PROCEDURE MouseButtonReleased(Button : ButtonStatus;                  (* 6h *)
                          VAR Count : CARDINAL;
                          VAR LastX : CARDINAL;
                          VAR LastY : CARDINAL) : BOOLEAN;
(* Получить информацию о количестве отпусканий клавишы                      *)
(*  TRUE  - Button была отпущена;                                           *)
(*  FALSE - Button не отпускалась;                                          *)
(*  Count - количество отпусканий на указанную клавишу с момента последнего *)
(*          вызова данной функции;                                          *)
(*  LastX,LastY - позиция курсора в момент последнего отпусканий указанной  *)
(*                клавиши;                                                  *)
(* ════════════════════════════════════════════════════════════════════════ *)

PROCEDURE MouseDeltaX(XLo,XHigh : CARDINAL);                          (* 7h *)
(* Установить диапазон перемещения курсора по горизонтали (X).              *)
(*  XLo   - минимальная горизонтальная координата курсора;                  *)
(*  XHigh - максимальная горизонтальная координата курсора;                 *)
(* ════════════════════════════════════════════════════════════════════════ *)

PROCEDURE MouseDeltaY(YLo,YHigh : CARDINAL);                          (* 8h *)
(* Установить диапазон перемещения курсора по вертикали (Y).                *)
(*  YLo   - минимальная вертикальная координата курсора;                    *)
(*  YHigh - максимальная вертикальная координата курсора;                   *)
(* ════════════════════════════════════════════════════════════════════════ *)

PROCEDURE DefineGraphMouseCursor(ActivPixelX,                         (* 9h *)
                                 ActivPixelY : ActivMousePixel;
                                 GraphMask   : MouseGraphMaskEGA);
(* Задать параметры графического курсора.                                   *)
(*   До вызова этой прцедуры воизбежание конфликтов необходимо              *)
(*   спрярать курсор с помощью HideMouse.                                   *)
(* ════════════════════════════════════════════════════════════════════════ *)

PROCEDURE DefineTextMouseCursor(mode : MouseTextCursorMode;          (* 10h *)
                                cx   : CARDINAL;
                                dx   : CARDINAL);
(* Задать параметры текстового курсора.                                     *)
(*   cx - маска экрана если курсор "мягкий" или                             *)
(*        номер первой скан линии при "жестком" курсоре                     *)
(*   dx - маска курсора или номер последней скан линии                      *)
(* ════════════════════════════════════════════════════════════════════════ *)


PROCEDURE GetMickeyCount(VAR deltaX : INTEGER;                       (* 11h *)
                         VAR deltaY : INTEGER);
(* Прочитать значение счетчика сигналов микки.                              *)
(*  возвращает число сигналов микки (минимальных приращений перемещения     *)
(*  "М Ы Ш И", регистрируемых аппаратными средствами),                      *)
(*  накопленное с момента последнего вызова функции.                        *)
(*  После вызова функции счетчик обнуляется.                                *)
(*--------------------------------------------------------------------------*)

PROCEDURE SetMouseEventHandler(EventMask   : MouseEventSet;          (* 13h *)
                               UserRoutine : ADDRESS);
(* Задать адрес подпрограммы обработки прерывания.                          *)
(*     Передает драйверу  подпрограмму обработки прерывания                 *)
(*  UserRoutine(процедура c FAR вызовом) вызванного событием EventMask .    *)
(*    ВНИМАНИЕ!                                                             *)
(*     При завершении вашей прикладной программы установите все биты маски  *)
(*  вызова равными нулю и вызовите функцию 12.(процедура ExitsUserHandler)  *)
(* ════════════════════════════════════════════════════════════════════════ *)

PROCEDURE ExitMouseEventHandler;
(* Восстановить прерывание установленое SetMouseEventHandler.               *)
(* ════════════════════════════════════════════════════════════════════════ *)

PROCEDURE MouseModeLightPen;                                         (* 13f *)
(* Включение режима эмуляции светового пера.                                *)
(*  Все клавиши отпущены "перо поднято".                                    *)
(*  Одна клавиша нажата  "перо опущено".                                    *)
(* ════════════════════════════════════════════════════════════════════════ *)

PROCEDURE ExitsModeLightPen;                                         (* 14f *)
(* Запрещение режима эмуляции светового пера.                               *)
(* ════════════════════════════════════════════════════════════════════════ *)

PROCEDURE SetMickeyToPixel( MickeyX , MickeyY : CARDINAL);           (* 15f *)
(* Установить соотношение микки/пиксел.                                     *)
(*  Соотношение определяется числом микки, приходящимся на 8 пикселов экрана*)
(*  Значения микки в пределах 1..0EFFFH.                                    *)
(*  По умолчанию MickeyX - 8/8; MickeyY - 16/8;                             *)
(* ════════════════════════════════════════════════════════════════════════ *)

PROCEDURE HideMouseArea( aX : CARDINAL;                              (* 16f *)
                         aY : CARDINAL;
                         bX : CARDINAL;
                         bY : CARDINAL);
(* Запретить появление курсора в специальной области.                       *)
(* Если курсор попадает в определенную область он исчезает.                 *)
(* Для отмены действия специальной области необходимо вызвать функцию 1f    *)
(* ════════════════════════════════════════════════════════════════════════ *)

PROCEDURE DefineUseMouseCursor( DepthCursor : SHORTCARD;             (* 17f *)
                                WidthCursor : SHORTCARD;
                                ActivPixelX : ActivMousePixel;
                                ActivPixelY : ActivMousePixel;
                                MaskArray   : ARRAY OF WORD) : BOOLEAN;
(* Задать параметры большого блока графического курсора.                    *)
(*  ВНИМАНИЕ !                                                              *)
(*    Функция определена для драйвера PC Mouse.                             *)
(*    Фирма Microsoft не дает документации по этой функции.                 *)
(*  Действие функции аналогично действию 9f,отличие в том, что задаются     *)
(*  размеры массивов определяющих маски экрана и курсора.                   *)
(*  DepthCursor - ширина курсора в словах (2 байта);                        *)
(*  WidthCursor - количество рядов в курсоре по вертикали;                  *)
(*  ActivPixelX - горизонтальная координата горячего пятна курсора(-16..+16);*)
(*  ActivPixelY - вертикальная координата горячего пятна курсора (-16..+16);*)
(*  MaskArray   - массив масок;                                             *)
(*                (DepthCursor * WidthCursor) слов - маска экрана;          *)
(*                (DepthCursor * WidthCursor) слов - маска курсора;         *)
(*  Если функция выполнена успешно возвращается TRUE.                       *)
(* ════════════════════════════════════════════════════════════════════════ *)

PROCEDURE  DoubleSpeedMouse(Limit : CARDINAL);                       (* 19f *)
(* Установить порог удвоенной скорости.                                     *)
(*     Измеряется в микки в секунду. При превышении которого скорость       *)
(* движения курсора на экране удваивается. По умолчанию 64 микки в секунду. *)
(* ════════════════════════════════════════════════════════════════════════ *)

PROCEDURE SetUserMouseHandler(EventMask   : MouseEventSet;       (* 20f *)
                               NewUserRoutine : ADDRESS;
                           VAR OldEventMask   : MouseEventSet);
(* Установить временную подпрограмму обработки прерывания.                  *)
(* ════════════════════════════════════════════════════════════════════════ *)


(*
    Следующие три функции (21,22,23) служат для сохранения и последующего
восстановления параметров состояния драйвера "мышки". Это необходимо
в случае запуска изнутри вашей прикладной программы другой программы,
тоже использующей "мышь".
*)

PROCEDURE SizeMouseBuffer() : CARDINAL;                             (* 21f *)
(* Получить данные о размере буффера для записи состояния драйвера.         *)
(* ════════════════════════════════════════════════════════════════════════ *)

PROCEDURE SaveMouseBuffer(Buff : ADDRESS);                           (* 22f *)
(* Записать параметры текущего состояния драйвера в буффер.                 *)
(* ════════════════════════════════════════════════════════════════════════ *)

PROCEDURE RestoreMouseBuffer(Buff : ADDRESS);                        (* 23f *)
(* Восстановить параметры состояния драйвера из буффера.                    *)
(* ════════════════════════════════════════════════════════════════════════ *)

      (* ----------------------------------------------------- *)
      (* Процедуры работы с внутренним обработчиком прерывания *)
      (* ----------------------------------------------------- *)

PROCEDURE StandardMouseHandler(EventMask : MouseEventSet);
(* Инициализирует внутренний обработчик прерывания, который вызывается при  *)
(* нажатии на кнопку(и), установленную EventMask. Обработчик заполняет ко-  *)
(* льцевой буффер, читаемый процедурой ReadBuffer.                          *)
(* ════════════════════════════════════════════════════════════════════════ *)

PROCEDURE ExitStandardMouseHandler;
(* Отменить прерывание установленое StandardMouseHandler.                   *)
(* ════════════════════════════════════════════════════════════════════════ *)

PROCEDURE ButtonPressed() : BOOLEAN;
(* Возвращает TRUE, если буффер не пустой (была нажата кнопка хоть раз).    *)
(* ════════════════════════════════════════════════════════════════════════ *)

PROCEDURE ReadBufferMouse(VAR x,y : CARDINAL;VAR button : ButtonStatus);
(* Читает буффер (если там что-то есть).                                    *)
(* ════════════════════════════════════════════════════════════════════════ *)

PROCEDURE ClearBufferMouse();
(* Очистка буффера.                                                         *)
(* ════════════════════════════════════════════════════════════════════════ *)

PROCEDURE WriteBufferMouse(x,y : CARDINAL; button : ButtonStatus);
(* Принудительная (пользовательская) запись в буффер. Может быть использо- *)
(* вана для эмуляции работы с мышкой.                                      *)
(* ════════════════════════════════════════════════════════════════════════ *)

END MpMouse.
