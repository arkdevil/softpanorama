
         Как писать нормальные резидентные программы
               на Microsoft C 6.0 (Quick C 2.5)

     Здесь приводятся несколько приемов,  которые  я  применил
полтора года назад, написав 1-ю версию программы KEYMAC. Исхо-
дил я из того, что в памяти должен оставаться ТОЛЬКО необходи-
мый код. Модель памяти - малая (Small).

     1. В  исходном  тексте  сначала  размещается  резидентная
часть,  потом - нерезидентная.  Если программа  собирается  из
нескольких модулей,  то резидентная часть должна быть в первом
из них.

     2. Все глобальные данные,  которые будет использовать ре-
зидентная часть программы, помещаются в сегмент кода. Для это-
го их надо описать с помощью описателя _based(сегмент_кода). В
качестве   сегмента_кода  применяется  следующая  конструкция:
_segname("_CODE"). Поэтому удобно определить макрос типа

#define  _b  _based(_segname("_CODE"))

и описывать глобальные резидентные данные примерно так:
     int _b Count;
     char far * _b FarPtr;

     3. Во  все  обработчики прерываний сразу после входа надо
поставить пару команд: _asm push cs _asm pop ds.
     Во все места,  где идет обращение к данным в кодовом сег-
менте, поставить такую конструкцию с приведением типа:
 для int        -  *(int _based(_segname("_DATA")) *)& ,
 для char far * -  *(char far * _based(_segname("_DATA")) *)&
и  т.п.  Конечно,  лучше  всего определить #дефайны, например:
     #define  _ni   *(int  _based(_segname("_DATA")) *)&

и в  программе ставить:  вместо "Count" - "_ni Count",  и т.п.
Это избавит резидентную часть кода от ненужных  манипуляций  с
сегментными регистрами  и префиксов.  Правда,  в Quick C оста-
нутся "рудименты" этих операций в  виде  бесполезной  загрузки
регистра CX.  Что еще раз доказывает преимущество оптимизирую-
щего компилятора.

     Осторожно! По умолчанию в Си принято ds=ss.  Теперь этого
не  будет,  т.е.  локальные  (в функциях) и глобальные (стати-
ческие) переменные будут адресоваться относительно разных сег-
ментов.

     Внимание!  Смотрите в MAP-файл,  который создается линке-
ром с ключом /m.  Компилятор  Microsoft C 6.00  имеет скверную
привычку  переупорядочивать  некоторые объекты данных и кода в
кодовом сегменте, и это может вам повредить, когда вы высчиты-
ваете размер резидентной части. Попробуйте переставить некото-
рые из них в исходном тексте. В MAPe видно их истинное распо-
ложение. Я предполагаю,  что компилятор хочет,  чтобы объект
данных размещался после тела функции, в которой он упоминается.
     За Quick C 2.5 такой грех уже не водится.

     4. Массивы, длина которых заранее неизвестна, надо форми-
ровать, как  обычно,  в  нерезидентной части в сегменте данных
(malloc() и т.п.).  Когда массив уже готов,  то перед тем  как
оставить программу резидентной,  его надо переписать в кодовый
сегмент после конца резидентной части на место начала  нерези-
дентной. (Напр., если нерезидентная часть начинается с main(),
то это (void far *)&main ).  Но это надо делать так,  чтобы не
налезть на нерезидентный код,  который еще осталось выполнить!

     5. Для  этого в резидентной части придется выделить место
для бесполезной впоследствии функции Terminate(), которая осу-
ществит копирование  массивов в конец резидентной части в сег-
мент данных.  Ей передаются как параметры все необходимые  ад-
реса в виде far-указателей. По окончании копирования эта функ-
ция вызывает INT 27h или INT 21h/AH=31h,  вычислив необходимый
размер (длина   резидентной  части  плюс  размер  резидентного
массива).
     Если захотите, можно  поместить  эту функцию  Terminate()
куда-нибудь в PSP и придумать ее хитрый вызов (напомню,  в  Си
cs>psp, если только не Tiny-модель). В версии KEYMAC 2.2 так и
сделано.

     6. Разумеется, в резидентной части, где только можно, на-
до использовать  ассемблерные вставки.  В этом у MSC/QC меньше
ограничений, чем у Turbo C/Borland C++.  Если  есть  отдельные
функции (кроме прерываний) с параметрами,  то можно их описать
как _fastcall или pascal (если вы знаете, что делаете).

     7. Забудьте о вызове библиотечных функций из  резидентной
части! Они туда не попадут. В том числе такие "безопасные" для
DOS, как memcpy() и т.п.  Правда,  MS C может генерировать для
некоторых из  них  встроенный  код,  но  если  вы  пользуетесь
QuickC, то такой возможности нет. Лучше применять ассемблерные
вставки.

     8. И  лучше  всего  (этого я не делал) писать резидентную
часть на чистом ассемблере,  а остальную -  на  Си,  обеспечив
совместимость структур данных. Не забудьте линковать программу
так, чтобы на первом месте шел ассемблерный модуль!


      Юцис Михаил Сухарович
      г.Черновцы, ул.Рязанская, 24/4
      тел. (037-22) 2-55-51 (д.)
