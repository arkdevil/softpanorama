
                                      КомпьютерПресс 4'91

               ЧТЕНИЕ НЕФОРМАТИРОВАННЫХ ДАННЫХ ИЗ ФАЙЛА


                 У вас возникла необходимость чтения из
                 файла данных, записанных в свободном
                 формате без заранее четко определенной
                 организационной структуры. Вы хотите
                 получить более полный контроль над про-
                 цессом обработки считываемых данных, ис-
                 пользуя для этого специальные разделите-
                 ли между отдельными элементами и различ-
                 ными группами данных. Быть может, вам
                 понадобится включить в файлы данных не-
                 обходимые комментарии ...  Попробуйте
                 воспользоваться для решения этих задач
                 предлагаемой нами программой. Возможно,
                 она вас устроит или просто наведет на
                 полезные мысли.


 В процессе  разработки программного обеспечения програм-
мист часто сталкивается с необходимостью чтения данных из
файлов. Языки  высокого уровня обычно предлагают два пути
решения подобных  задач. Это  либо  использование  мощных
функций форматированного  ввода данных, налагающих весьма
жесткие ограничения  на структуру  записей в  файле, либо
чтение из файла символьных последовательностей с их даль-
нейшим анализом и выделением необходимых элементов.
 Первый способ  наиболее прост и удобен, однако он не об-
ладает необходимой гибкостью, и часто не позволяет в пол-
ной мере удовлетворить все возникающие у программиста по-
требности. Второй способ позволяет решить практически лю-
бую задачу  по чтению  и обработке  данных,  но  является
очень сложным  в реализации, т.к. программисту приходится
создавать, по  сути, систему  анализа и обработки текста,
подобную компиляторам языков программирования или тексто-
вым процессорам.  Такая программа  обычно получается  до-
вольно громоздкой и медленно работающей при выполнении ее
с помощью одних только языков высокого уровня.
 Для решения несложных задач по обработке неформатирован-
ных данных программисты часто используют упрощенный вари-
ант текстового  процессора, обращаясь к функциям формати-
рованного ввода для чтения строковых последовательностей,
сравнивая их затем с заранее определенными ключевыми сло-
вами и  символами и  выделяя  таким  образом  необходимые
структуры данных.  Такой способ  решения вполне приемлем,
хотя и  не слишком  рационален с точки зрения оптимизации
скорости выполнения  программы, т.к.  приходится по  нес-
кольку раз  проверять каждую  прочитанную строку. Достои-
нство же его - в простоте реализации и отсутствии сложных
алгоритмов анализа вводимых данных.
 Недостатки описанного способа заключаются в том, что при
записи информации  в файл, из которого в дальнейшем будет
производиться чтение, пользователь вынужден следовать тем
ограничениям, которые  налагаются функциями форматирован-
ного ввода на считываемую информацию. Эти ограничения ка-
саются необходимости  использования  строго  определенных
разделителей между  элементами данных,  невозможности ис-
пользования ключевых  символов  одновременно  в  качестве
разделителей, а также неудобства распознавания и отслежи-
вания комментариев в файле данных.
 В приведенной  ниже программе  сделана попытка  создания
функции ввода,  свободной от указанных недостатков. Функ-
ция fgetstring() считывает из файла строки данных, позво-
ляя программисту  самому устанавливать те правила, по ко-
торым это  чтение будет производиться. Функция производит
посимвольное считывание  и анализ информации. Программист
должен заранее  определить, какие символы будут восприни-
маться функцией в качестве разделителей элементов данных.
 В целях  обозначения различных  способов разделения эле-
ментов данных  (строк) в  программу были  введены понятия
мягкого, жесткого и специального разделителей.

 Мягкие, жесткие
 и специальные разделители

 Разделителями мы  будем называть такие ключевые символы,
при   обнаружении   которых   в   файле   функция   ввода
fgetstring() заканчивает  чтение очередного поля (строки)
данных независимо  от того, было ли прочитано максимально
установленное для вводимой строки количество символов.
 Мягкими называются такие разделители, которые могут быть
помещены в файл данных в виде последовательных цепочек из
нескольких символов-разделителей,  стоящих подряд друг за
другом, причем функцией ввода такая цепочка мягких разде-
лителей будет восприниматься как один единственный разде-
литель. Количество мягких разделителей в одной последова-
тельной цепочке может быть произвольным. Примерами мягких
разделителей могут  служить символы  пустого пространства
(whitespace characters) - пробел, табуляция, символ новой
строки (CR-LF),  которые стандартной  функцией  ввода  Си
scanf() воспринимаются как единый разделитель, независимо
от их количества в последовательной цепочке.
 Для функции  fgetstring(), представленной  в описываемой
программе, мягкими разделителями, помимо символов пустого
пространства (см. предыдущий абзац), служат также символы
прямой и  обратной косой  черты - '/' и '\'. Однако такой
набор символов-разделителей не является непременным усло-
вием работы функции, поскольку программист может задавать
символы мягких,  равно как и всех других, разделителей по
своему усмотрению.
 Чтобы быть до конца точным в вопросе о возможности изме-
нения набора  символов-разделителей, необходимо отметить,
что здесь у функции fgetstring() есть одно "узкое место".
Функция fgetstring()  позволяет отслеживать  имеющиеся  в
файле данных  комментарии, которые  должны быть  записаны
подобно комментариям  языка Си  (т.е. в  виде /*.....*/).
Такой способ записи комментариев, на наш взгляд, наиболее
удобен, т.к. он позволяет иметь по нескольку комментариев
на одной  строке файла  либо объединять  сразу  несколько
файловых строк  в один  общий комментарий (вложенных ком-
ментариев функция  fgetstring()  не  поддерживает).  Весь
комментарий воспринимается функцией fgetstring() как один
мягкий разделитель.  Это означает,  что комментарии могут
стоять в файле вперемешку с другими мягкими разделителями
либо несколько комментариев могут быть размещены последо-
вательно друг  за другом. Однако в связи с необходимостью
отслеживания комментариев,  символ косой черты '/' всегда
будет восприниматься  функцией ввода  в качестве  мягкого
разделителя. На  наш взгляд, это несущественно, т.к. сим-
вол '/'  традиционно используется  в качестве разделителя
во многих прикладных программах.
 Жестким разделителем  называется такой  управляющий сим-
вол, который, при обнаружении его в файле функцией ввода,
вызывает немедленное  прекращение чтения  очередного поля
(строки) данных,  независимо от  того, предшествовали  ли
ему непосредственно данные или другие символы-разделители
(мягкие, жесткие  или специальные).  Это значит, что если
два жестких разделителя расположены в файле данных подряд
один за  другим либо отделены друг от друга только цепоч-
кой мягких  разделителей, то  для такой  записи  функцией
fgetstring() будет произведено считывание очередного эле-
мента данных, состоящего из пустой строки.
 В качестве  жестких разделителей в описываемой программе
используются символы  запятой ','  и точки с запятой ';'.
Использование жестких  разделителей в файлах данных зача-
стую продиктовано  острой  необходимостью,  т.к.  никаким
другим способом  такой элемент данных, как пустая строка,
ввести невозможно. В нашей программе, осуществляющей счи-
тывание из  файла массивов целых чисел, ввод пустой стро-
ки, при ее дальнейшем преобразовании, означает ввод нуля.
Таким образом,  появляется возможность  записывать нули в
файле данных просто парой жестких разделителей.
 В качестве жестких разделителей строчных переменных мож-
но было  бы использовать  также кавычки (") или апострофы
(') как традиционные для таких целей символы. В этом слу-
чае, возможно,  было бы  целесообразно доработать функцию
fgetstring() таким  образом, чтобы в промежутке между па-
рой установленных  строчных разделителей  никакие  другие
символы вообще не воспринимались бы как разделители. Чте-
ние же строки тогда можно было бы организовать так, чтобы
при длине считываемой строки, превышающей размер передан-
ного для нее буфера, не уместившаяся в буфер часть строки
до замыкающего разделителя просто пропускалась бы. В дан-
ном случае  это будет  вполне уместным, т.к. такая строка
представляет собой  единый и  неделимый элемент данных, и
ее разбиение на части было бы неразумным. Для такого слу-
чая можно предусмотреть также возврат функцией ввода кода
ошибки считывания данных.
 Однако все подобные добавления, несомненно, будут приво-
дить к  увеличению объема вашей программы и снижению ско-
рости ее  выполнения. Поэтому,  на наш  взгляд, не  нужно
стремиться  к  созданию  универсальных,  всеобъемлющих  и
сверхмощных функций. Лучше иметь некоторый набор из более
простых и  более специальных функций и уже из них выбрать
наиболее пригодную для решения конкретной задачи.
 Применительно к  нашей программе,  следует иметь в виду,
что  необходимость   отслеживания  функцией  fgetstring()
жестких разделителей  влечет за собой наложение некоторых
ограничений на  использование  этой  функции  прикладными
программами. Это  связано с тем, что в функцию приходится
вводить некую статическую переменную (в нашей функции она
называется delimiter_flag),  которая должна  быть  жестко
привязана к  конкретному текущему  файлу данных.  Это,  в
свою очередь, вызвано тем обстоятельством, что само нача-
ло файла  данных, а также встречающиеся в нем специальные
разделители (о которых пойдет речь ниже) уже сами по себе
являются жесткими разделителями, которые нужно как-то от-
слеживать. Говоря  проще, если в вашем файле данных самым
первым символом  стоит жесткий  разделитель (запятая  или
точка с запятой) или если перед этим жестким разделителем
идет лишь  цепочка мягких  разделителей (например, пробе-
лов), то, по логике вещей, для такого случая функция вво-
да должна  возвращать пустую строку. То же правило должно
относиться и  к случаю, когда жесткий разделитель помещен
в файле данных сразу после специального разделителя.
 Добравшись, наконец,  до существа  вопроса, разберемся с
ограничениями,  налагаемыми   на  использование   функции
fgetstring() в прикладных программах.
 Ограничения состоят  в том,  что, во избежание путаницы,
функцию fgetstring()  не следует  использовать для парал-
лельного ввода  данных сразу  из нескольких открытых фай-
лов. Если  вы хотите  прочитать данные из нескольких фай-
лов, то  делать это придется последовательно, обрабатывая
файлы один  за другим.  Более того,  необходимым условием
правильной работы  функции fgetstring()  является то, что
функция должна  прочитать текущий  файл данных  до самого
конца (т.е. ею должен быть считан конец файла) и приклад-
ная программа  должна составляться с учетом этих требова-
ний. (Последнее  ограничение касается  лишь случая, когда
есть  необходимость  в  повторном  использовании  функции
fgetstring() для чтения очередного файла данных.)
 Все перечисленные  здесь сложные правила, на самом деле,
не являются  чем-либо сверхъестественным.  Просто при со-
ставлении программ  анализа и обработки данных нужно ста-
раться предусмотреть  все возможные ситуации. Впрочем, вы
можете несколько облегчить себе задачу, поступившись ско-
ростью, объемом,  а главное, простотой найденных програм-
мных решений. Для этого нужно лишь задать у функции ввода
некоторые дополнительные  формальные параметры и осущест-
влять их  проверку в ходе выполнения функции. Этим вы из-
бавите себя  от лишних хлопот по поиску коротких и эффек-
тивно работающих алгоритмов.
 Все приведенные  выше длинные  рассуждения  представляют
какой-либо интерес  только в том случае, когда есть необ-
ходимость в  использовании жестких  разделителей в файлах
данных. Если  же такой необходимости нет, то проблема от-
падает сама  собой. Нужно будет только исключить из функ-
ции fgetstring()  те участки  программы, которые отвечают
за отслеживание жестких разделителей.
 При использовании функции fgetstring() в прикладных про-
граммах нужно  иметь в  виду, что  если на конце вводимой
строки данных  функция встречает символ мягкого или жест-
кого разделителя, то перед возвратом она засылает считан-
ный символ-разделитель  назад в буфер входного потока. То
есть следующий  цикл чтения  опять начнется с ввода этого
символа. (Такой  порядок чтения  соответствует  правилам,
принятым для функций форматированного ввода.)
 Специальными разделителями  мы будем  называть такие уп-
равляющие символы,  которые,  помимо  функции  разделения
элементов данных,  оповещают также  программу о  том, что
далее следует другая специфическая группа данных.
 Специальный разделитель  является, по сути, жестким раз-
делителем, однако между ними есть некоторые различия. Ес-
ли функция fgetstring() считывает специальный разделитель
в конце вводимой строки данных, то она возвращает его на-
зад, как и любой другой разделитель, в буфер входного по-
тока.  В   начале  же  следующего  цикла  чтения  функция
fgetstring() снова  прочитает этот  же символ,  но теперь
она уже  вернет его  вызывающей программе в буфере строки
данных. Если  в файле  данных перед символом специального
разделителя будет  стоять цепочка мягких разделителей, то
это не окажет никакого влияния на результаты работы функ-
ии, и все произойдет приблизительно в том же порядке. Уп-
равляющей программе  останется только отслеживать символы
специальных разделителей  в буфере вводимой строки и про-
изводить переключения  между  обработкой  соответствующих
групп данных.
 В качестве  специальных разделителей  в описываемой про-
грамме используются  символы '#'  (pound)  -  разделитель
двумерных массивов  и '&' (ampersand) - разделитель одно-
мерных подмассивов двумерных массивов.

 Программа чтения
 неформатированных данных
 из файла

 Предлагаемая вашему вниманию программа READDATA осущест-
вляет чтение  из файла  двумерных массивов  целых чисел с
переменным количеством  как самих двумерных массивов, так
и элементов  в каждом двумерном массиве по каждому из из-
мерений. То  есть заданные начальные условия  предполага-
ют,   что   заранее неизвестно  количество  ни  двумерных
массивов   в   файле  данных, ни одномерных подмассивов в
каждом двумерном  массиве, ни количество элементов в каж-
дом одномерном подмассиве двумерного массива.
 Для большей  наглядности  представления  условий  задачи
можно привести пример, в котором подобная ситуация в дей-
ствительности имеет  место. Автором аналогичная программа
используется для  считывания из файлов аминокислотных по-
следовательностей и некоторых других характеристик белко-
вых молекул.  Количество белков,  описанных в  каждом от-
дельном файле,  может быть  различным. Каждый белок может
состоять из нескольких самостоятельных цепочек, количест-
во аминокислот  в каждой  из которых  также заранее неиз-
вестно.
 Как уже  было сказано  выше, для  того  чтобы  программа
READDATA могла  отличить, где  в файле данных разделяются
двумерные массивы  и их одномерные подмассивы, в файл по-
мещаются специальные управляющие символы - соответственно
'#' и '&'.
 Для хранения  считанных из  файла одномерных подмассивов
целых чисел  программа READDATA резервирует в оперативной
памяти компьютера динамические массивы, в которые и поме-
щает данные.
 Поскольку заранее неизвестно, какого размера должен быть
будущий динамический массив, программа вначале резервиру-
ет буфер под максимально допустимое количество элементов,
заведомо превышающее  реально возможное. После считывания
очередной цепочки  (одномерного подмассива)  данных  про-
грамма "сжимает"  размер зарезервированного буфера до де-
йствительно необходимой длины.
 Указатели на  считанные одномерные подмассивы помещаются
в двумерный массив указателей ArrayPrt[][]. В результате,
после прочтения данных из всего файла, образуется двумер-
ный массив  одномерных подмассивов  или трехмерный массив
целых чисел ArrayPrt[][][].
 Количество прочитанных  двумерных  массивов,  количество
одномерных подмассивов в каждом массиве и количество эле-
ментов в каждом одномерном подмассиве также сохраняется в
соответствующих переменных и массивах.
 Для демонстрации  возможностей доступа  к считанным эле-
ментам данных  в программу включена функция print_data(),
осуществляющая распечатку на экране элементов всех прочи-
танных из файла массивов.
 В тексте  программы определены целые константы, устанав-
ливающие максимально  допустимые величины  для каждого из
неизвестных параметров  файла данных  (максимальное коли-
чество элементов по каждому измерению трехмерного массива
ArrayPtr[][][]). Если  в файле данных какой-либо из пара-
метров превысит  максимально допустимое для него значение
(например, количество элементов в одной одномерной цепоч-
ке окажется  больше максимально допустимого), то в работе
программы не  произойдет ничего ужасного, кроме того, что
оставшаяся часть соответствующих элементов будет отнесена
уже к следующей группе данных и структура части или всего
прочитанного трехмерного массива будет нарушена. Впрочем,
можно несколько доработать программу с тем, чтобы она от-
слеживала подобные  случаи и производила перерезервирова-
ние динамических массивов под больший размер.
 В конце  программы автор  не смог удержаться от соблазна
привести маленькую  курьезную функцию,  предлагающую про-
стой алгоритм определения суффикса английского порядково-
го числительного  в соответствии с грамматическими прави-
лами. Функция  getsuffix() используется в составе функции
распечатки данных  print_data() для  нумерации  выводимых
элементов. Возможно,  этот алгоритм тоже кому-нибудь при-
годится.

                                                 А. Синев



