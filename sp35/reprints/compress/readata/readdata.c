/* Программа READDATA.C, автор А.Синев */
/* Программа производит чтение из файла нескольких
   двумерных массивов целых чисел, с переменным
   количеством элементов по каждому измерению.
   Считенными данными программа заполняет динамические
   массивы в оперативной памяти, формируя в результате
   трехмерный массив целых чисел.
   Все использованные в программе библиотечные функции
   поддерживаются стандартом ANSI C.
*/

/* максимальное количество считываемых двумерных
   массивов; максимальное количество одномерных цепочек
   (подмассивов) в каждом двумерном массиве;
   максимальное количество элементов в каждой цепочке */
#define MaximArrays 20
#define MaximChains 5
#define MaximElements 200

#include <stdio.h>
#include <stdlib.h>

void read_data(char *filename);
void print_data(void);
int fgetstring(char *s, int nn_chars, FILE *datafile);
char *getsuffix(int i);

/* двумерный массив указателей на цепочки (подмассивы)
   элементов (целых чисел) */
int *ArrayPtr[MaximArrays][MaximChains];
/* количество прочитанных двумерных массивов */
int NN_Arrays;
/* количество прочитанных одномерных цепочек
   (подмассивов) в каждом двумерном массиве */
int NN_Chains[MaximArrays];
/* количество элементов в каждой прочитанной цепочке */
int NN_Elements[MaximArrays][MaximChains];

/****************************************************/
void main(int argc, char *argv[])
{
 /* проверить количество параметров, переданных
    программе из командной строки */
 if (argc != 2) {
   fputs("Syntax:\nReaddata datafile\n",stdout);
   /* выход, если не передано имя файла данных */
   exit(1);
 }
 read_data(argv[1]);  /* прочитать данные из файла */
 print_data();      /* распечатать данные на экране */
} /* main() */

/************** Чтение данных из файла **************/
/* Функция производит чтение неформатированных данных
   (целых чисел) из файла *filename и заполнение ими
   динамических массивов, указатели на которые
   помещаются в двумерный массив  ArrayPtr[][].
   В результате формируется трехмерный массив целых
   чисел  ArrayPtr[][][].
*/
void read_data(char *filename)
{
 FILE *datafile;

 char buffer[7];    /* буфер считываемой строки */
 int i,j,k;         /* счетчики */
 /* промежуточные переменные: указатели на массивы и
    указатели на счетчики цепочек и элементов. Введены
    для исключения повторяющихся вычислений адреса. */
 int *array, **parray, *chaincntr, *elemcntr;

 /* открыть файл для чтения данных */
 if ((datafile = fopen(filename,"rt")) != NULL) {
   /* инициализация счетчика прочитанных двумерных
      массивов */
   NN_Arrays = 0;
   /* инициализация цикла чтения двумерных массивов */
   for (i=0; i<MaximArrays; i++) {
     /* вычислить адрес текущего счетчика одномерных
        цепочек (подмассивов) */
     chaincntr = &NN_Chains[i];
     /* инициализация счетчика одномерных цепочек */
     *chaincntr = 0;
     /* инициализация цикла чтения одномерных цепочек
        (подмассивов) элементов */
     for (j=0; j<MaximChains; j++) {
       /* вычислить адрес указателя на текущую цепочку
          элементов */
       parray = &ArrayPtr[i][j];
       /* зарезервировать в памяти динамический массив
          на максимально допустимое количество элементов
          отдельной одномерной цепочки */
       if ((*parray = array =
            malloc(MaximElements * sizeof(int))) == NULL) {
         fputs("Can't allocate buffer\n",stderr);
         /* выход из программы, если ошибка размещения
            массива */
         exit(1);
       }
       /* вычислить адрес счетчика элементов текущей
          одномерной цепочки */
       elemcntr = &NN_Elements[i][j];
       /* инициализация цикла чтения элементов текущей
          одномерной цепочки (подмассива) элементов */
       for (k=0; k<MaximElements; k++) {
         /* прочитать ASCIIZ-строку текущего элемента
            (целого числа) в буфер; проверить, был ли
            встречен конец файла */
         if (!fgetstring(buffer,6,datafile)) {
           /* если конец файла, то проверить
              содержимое буфера */
           if (*buffer) {
             /* если буфер не пустой, то преобразовать
                строку в целое */
             array[k] = atoi(buffer);
             k++;
           }
           /* передать в массив NN_Elements[][]
              количество прочитанных элементов
              текущей цепочки */
           *elemcntr = k;
           /* увеличить на 1 счетчик одномерных цепочек
              текущего двумерного массива */
           (*chaincntr)++;
           /* установить значения для завершения
              циклов чтения данных */
           i = MaximArrays;
           j = MaximChains;
           goto next_chain;
         }
         /* проверить, были ли прочитаны символы
            специальных разделителей */
         switch (*buffer) {
           /* если прочитан разделитель двумерных
              массивов, установить значение для
              завершения текущего цикла чтения */
           case '#':
             j = MaximChains;
           /* если прочитан разделитель одномерных
              цепочек */
           case '&':
             /* установить значения счетчиков */
             *elemcntr = k;
             (*chaincntr)++;
             goto next_chain;
         }
         /* преобразовать строку в целое */
         array[k] = atoi(buffer);
       }
       /* если было прочитано максимально допустимое
          количество элементов одномерной цепочки */
       /* установить значения счетчиков */
       *elemcntr = k;
       (*chaincntr)++;
       /* продолжить цикл чтения цепочек элементов */
       continue;
next_chain:
       /* если количество прочитанных элементов цепочки
          равно 0, то освободить зарезервированный
          буфер массива */
       if (!*elemcntr) {
         free(array);
         continue;    /* продолжить цикл чтения */
       }
       /* сжать зарезервированный буфер до размера
          прочитанной цепочки элементов */
       if ((*parray = realloc(array,
                  *elemcntr * sizeof(int))) == NULL) {
         fputs("Can't allocate buffer\n",stderr);
         /* завершить программу, если ошибка
            размещения буфера */
         exit(1);
       }
     }
     /* увеличить на 1 счетчик прочитанных двумерных
        массивов */
     NN_Arrays++;
   }
   fclose(datafile);     /* закрыть входной поток */
 } else {
   /* выход по ошибке открытия файла */
   fprintf(stderr,"\nCan't open file %s",filename);
   perror("");
   exit(1);
 }
} /* read_data() */

/******** Вывод прочитанных данных на экран *********/
/* Функция выводит на экран элементы трехмерного
   массива целых чисел  ArrayPtr[][][], представляя
   его в виде набора двумерных массивов, каждый из
   которых состоит из нескольких одномерных цепочек.
*/
void print_data(void)
{
 int i,j,k;

 printf("\nThe number of arrays read : %d",NN_Arrays);
 for (i=0; i<NN_Arrays; i++) {
   for (j=0; j<NN_Chains[i]; j++) {
     printf("\n\nArray #%d of %d chains",i+1,
                                  NN_Chains[i]);
     printf("\nChain #%d of %d elements\n\n",j+1,
                                  NN_Elements[i][j]);
     for (k=0; k<NN_Elements[i][j]; k++)
       printf("%3d%s : %6d%6s",k+1,getsuffix(k+1),
                               ArrayPtr[i][j][k],"");
   }
 }
} /* print_data() */

/************ Прочитать строку из файла *************/
/* Функция осуществляет чтение из файла  *datafile
   строки с максимальной длиной  nn_chars  и заполняет
   ею буфер  *s.  Размер буфера должен быть равен
   nn_chars + 1.  Чтение строки данных производится с
   учетом комментариев (в стиле Си), а также мягких,
   жестких и специальных разделителей. Комментарии и
   мягкие и жесткие разделители, расположенные после
   вводимой строки (завершающие строку данных),
   остаются непрочитанными. В случае специального
   разделителя функция возвращает его в буфере  *s.
   Возвращаемые значения:  0 - если был встречен конец
   файла;  1 - во всех остальных случаях.
*/
int fgetstring(char *s, int nn_chars, FILE *datafile)
{
 /* считываемый символ и счетчик символов */
 int ch, i;
 /* флажок индикации состояния жесткого разделителя */
 static int delimiter_flag = 1;

 /* инициализация цикла чтения символов строки */
 for (i=0; i<nn_chars; i++) {
skip_delimiters:
   /* прочитать символ из файла */
   ch = fgetc(datafile);
no_comment:
   switch (ch) {      /* производить проверку */
     case EOF:        /* встречен конец файла */
       goto endoffile;
     case '/':        /* встречен символ '/' */
       if (!i) {    /* если не начато чтение строки */
         /* если следующий символ - не '*', то переход,
            иначе - начало комментария */
         if ((ch = fgetc(datafile)) != '*')
           goto no_comment;
comment_contd:
         /* продолжать чтение комментария до следующего
            символа '*' */
         do {
           if ((ch = fgetc(datafile)) == EOF)
             goto endoffile;
         } while (ch != '*');
skip_star:
         /* прочитать следующий символ */
         switch (ch = fgetc(datafile)) {
           case EOF:
             goto endoffile;
           case '/':
             /* если '/', то конец комментария */
             goto skip_delimiters;
           case '*':
             /* если '*', то переход на чтение
                следующего символа */
             goto skip_star;
           default:
             /* для остальных случаев - продолжать
                чтение комментария */
             goto comment_contd;
         }
       }
       break;   /* иначе - прекратить чтение строки */
     case ',':  /* встречен символ жесткого */
     case ';':  /* разделителя ',' или ';'  */
       if (!delimiter_flag)
         /* если это первый жесткий разделитель */
         delimiter_flag = 1;
       else      /* если второй жесткий разделитель, */
         break;  /* то прекратить чтение строки */
     case ' ':      /* встречены символы   */
     case '\t':     /* мягких разделителей */
     case '\n':
     case '\\':
       /* если не начато чтение символов строки, то
          переход (пропустить разделитель), иначе -
          прекратить чтение строки */
       if (!i)
         goto skip_delimiters;
       break;
     case '&':    /* встречены символы специальных */
     case '#':    /* разделителей '&' или '#' */
       if (i)    /* если продолжается чтение строки, */
         break;  /* то прекратить чтение */
       /* передать символ специального разделителя в
          буфер строки */
       s[0] = ch;
       s[1] = 0;             /* закончить строку */
       /* установить флажок жесткого разделителя */
       delimiter_flag = 1;
       return 1;             /* возврат из функции */

     default:                /* в остальных случаях */
       /* переслать прочитанный символ в буфер строки */
       s[i] = ch;
       continue;   /* продолжить цикл чтения строки */
   }
   /* сюда передается управление, если во время чтения
      строки данных был встречен мягкий или жесткий
      разделитель */
   /* вернуть прочитанный символ разделителя в буфер
      входного потока */
   ungetc(ch,datafile);
quit:
   s[i] = 0;                 /* закончить строку */
   /* сбросить флажок жесткого разделителя */
   delimiter_flag = 0;
   return 1;                 /* возврат */
 }
 /* сюда программа приходит, если количество
    прочитанных символов строки данных = nn_chars */
 goto quit;                  /* переход на возврат */

 /* сюда передается управление, если встречен конец
    файла */
endoffile:
 s[i] = 0;                   /* закончить строку */
 /* установить флажок жесткого разделителя */
 delimiter_flag = 1;         
 return 0;                   /* возврат */
} /* fgetstring() */

/*** Определить суффикс порядкового числительного ***/
/* Функция возвращает указатель на строку суффикса
   порядкового числительного для переданной целой
   величины, в соответствии с правилами английской
   грамматики. (Функция используется в составе
   функции print_data()).
*/
char *getsuffix(int i)
{
 i %= 100;   /* вычислить остаток от деления на 100 */
 /* если полученное значение больше 20, то вычислить
    остаток от деления на 10 */
 if (i > 20)
   i %= 10;
 switch (i) {      /* проверка полученного значения */
   case 1:  return "st";
   case 2:  return "nd";
   case 3:  return "rd";
   default: return "th";
 }
} /* getsuffix() */
