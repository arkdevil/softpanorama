                            Что такое PLM?
                            --------------

    Программисты, которым когда-нибудь доводилось писать на ассемблере
какого-либо   процессора,    знают,   насколько   это   трудоемкое   и
неблагодарное занятие.  Вам приходится  использовать сотни  операторов
для того,  чтобы выполнить  действия, которые  на любом языке высокого
уровня укладываются  в несколько  строк. Программы  быстро  становятся
чересчур длинными.  Запись их  в виде  последовательности элементарных
операторов затрудняет  чтение и  поиск ошибок. В то же время разбиение
на  отдельные   подпрограммы  существенно   снижает  эффективность   и
порождает путаницу в куче мелких процедур.
    Чтобы хоть  как-то сократить  количество строк  в программе, можно
использовать макросы.  Макросы позволяют заменить одинаковые или слабо
отличающиеся  фрагменты  текста  на  некоторое  имя  с  параметрами  и
использовать  одну  строку  текста  вместо  нескольких.  Впрочем,  Вы,
наверное, лучше  знаете, что  такое макросы стандартного ассемблера со
всеми их достоинствами и недостатками.
    PLM, выполняя  ту же работу, выглядит как высокоуровневый язык. Он
обеспечивает:
    
    1) раскрутку условий и структурных операторов;
    2) более  удобочитаемый синтаксис  арифметических    и  логических
операций, пересылок между регистрами и переменными;
    3) удобное использование средств сопроцессора;
    4) мощнейшие средства расширения языка;
    5) многое другое.
    
    Вместе с  тем для вас остаются доступными все средства ассемблера.
PLM не вносит собственных искажений в структуру программы.
    На PLM'е  можно писать  столь же  эффективные программы,  как и на
ассемблере. Можно  считать, что  PLM -  это просто  сокращенная  форма
записи ассемблерных программ.


                           Зачем нужен PLM?
                           ----------------
    
    Когда Вы  пишете на  ассемблере, то  действие,  выполняемое  одной
инструкцией, гораздо меньше, чем те понятия, которыми обычно оперирует
программист,  проектируя   программы.  Излишняя  детальность  описаний
заставляет Вас  дробить свою  мысль, затрачивая  на это  львиную  долю
усилий. PLM  же, освобождая программиста от подобной работы, позволяет
сильно повысить  производительность при той же эффективности конечного
продукта.


                           Кому нужен PLM?
                           ---------------

    Для того,  чтобы качественно  писать на  PLM'е,  нужно  достаточно
хорошо знать ассемблер. Тем, кто давно пишет на ассемблере, переход на
PLM  дается   очень  легко,  поскольку  PLM  максимально  приближен  к
ассемблеру. Но PLM будет полезен и тем, кто плохо знаком с ассемблером
или вовсе  не знает,  что это  такое, т.к.  обучение  программированию
сейчас, как  правило, начинается с языков высокого уровня, а синтаксис
PLM'а похож на синтаксис таких языков.
    
    
                           Что делает PLM?
                           ---------------

    Ключевым  моментом,  без  отчетливого  понимания  которого  трудно
уяснить идеологию  PLM'а, является  то, что  PLM -  это не компилятор,
создающий объектный  или исполняемый код. PLM - транслятор, работающий
с  текстом   и  переводящий,   по-сути,  ассемблеровскую  программу  с
высокоуровневого  и  удобоваримого  текста  в  текст  ассемблера.  Все
остальное делают ассемблер и редактор связей.
    PLM работает  с формами, а не со смыслом операторов и выражений, и
поэтому, например,  имена регистров  МП значат для него не больше, чем
имена ячеек памяти. Предполагается, что программисту виднее, где и что
размещать, и  что он не должен доказывать это транслятору. PLM никогда
не будет мешать Вам!


                             Комментарии.
                             ------------

    Строка, начинающаяся  с символа:  "*" или  "%", считается  строкой
коммениария. Остаток  строки за  символом "*" или "%", если после него
есть хотя бы один пробел, тоже считается комментарием. Например:

% Это комментарий
  if ax=0 goto lab  * и это комментарий


                          Ассемблер в PLM'е.
                          -----------------

    Оператор,  начинающийся  с  точки,  переносится  в  результирующий
ассемблеровский  файл  без  изменений.  Например,  если  в  ассемблере
пишется  rep stosb,  то в  PLM'е -  .rep stosb и т.д. (Если даже точка
кажется Вам слишком большой роскошью, не спешите отказываться от PLM'а
- ниже  будет описан  способ, позволяющий  избавиться от необходимости
ставить точку перед ассемблеровскими инструкциями.) Таким образом, PLM
осуществляет "мягкую"  поддержку программирования  на  ассемблере:  Вы
можете  пользоваться   только  теми  операторами  PLM'а,  которые  Вам
нравятся, а  все остальное без каких-либо проблем продолжать писать на
ассемблере. Для того, чтобы Вы хорошо представляли себе, во что именно
транслируются операторы  PLM'а, рядом  с примерами на PLM'е приводятся
соответствующие ассемблеровские раскрутки.


                                Метки.
                                -----

    Метки в  PLM'е точно  такие же,  как и в ассемблере, но если после
метки в  строке что-нибудь  есть, то  метка должна  отделяться хотя бы
одним пробелом.
    PLM при  раскрутке  структурных  операторов  генерит  метки  вида:
@@l<число>; не используйте метки с такими именами.


                      Выражения и присваивание.
                      -------------------------

    Рассмотрим выражения  на примере  оператора присваивания. Мы будем
пользоваться  понятиями   источника  и   приемника,   которые   обычно
встречаются в  описаниях ассемблера.  Идея выражений  PLM'а состоит  в
объединении  нескольких   операций  с   одним  и  тем  же  приемником.
Простейшая форма присваивания выглядит так:

<приемник>=<операция>[<источник>][<операция>[<источник>]]...
    
Правую  часть  этого  оператора  мы  и  будем  в  дальнейшем  называть
выражением.
    Приемником и  источником может  быть что угодно. PLM'у безразлична
семантика выражения,  и о  его смысле  Вы  должны  позаботиться  сами.
Операция  -  это  ассемблеровская  инструкция,  заключенная  в  точки.
Например: .les.,  .xchg., .add. и т.д. Кроме того, имеются стандартные
сокращения:

       +     -    .add.             >     -    .shr.
       -     -    .sub.             <     -    .shl.
       *     -    .mul.          <пусто>  -    .mov.
       /     -    .div.

    Рассмотрим примеры выражений:

     ax=0                  -------->     sub    ax,ax

     Var=0h                -------->     mov    Var,0h

     di=-1<cl.xchg.si      -------->     dec    di
                                         shl    di,cl
                                         xchg   di,si

     dl=.neg.+es:8000h[bx] -------->     neg    dl
                                         add    dl,es:8000h[bx]

    Если  операнд   содержит  символы,   которые  PLM   преобразует  в
инструкции, его  надо заключить в скобки. И вообще, все, что заключено
в скобки, PLM рассматривает как один операнд. Например:

     ax=(-1)               -------->     mov    ax,(-1)

     dx=es:[di]+(Base+5)   -------->     mov    dx,es:[di]
                                         add    dx,(Base+5)

    Если приемник  в явном  виде отсутствует,  то приемником считается
первый операнд выражения:

     =.or.ax               -------->     or     ax,ax

    Операнд выражения  также может  отсутствовать. Вэтом случае просто
выполняется операция (единственный обязательный элемент выражения):

     =.scasb.              -------->     scasb
    
Такая запись  может показаться несколько странной, но она очень удобна
в условных выражениях.

    Более сложная  форма присваивания - последовательное присваивание.
Оно имеет вид:

       <приемник>=...=<выражение 2>=<выражение 1>
    
Сначала присваивается  <выражение 1>.  В  качестве  приемника  берется
первый не  являющийся операцией  терм из  <выражения 2>. Потом  тем же
способом присваивается <выражение 2> и т.д. Например:

     es=ax=ds              -------->     mov    ax,ds
                                         mov    es,ax

     ds=ax+1000h=ds        -------->     mov    ax,ds
                                         add    ax,1000h
                                         mov    ds,ax

     Dat=.and.bx=Mask<cl=6    ----->     mov    cl,6
                                         mov    bx,Mask
                                         shl    bx,cl
                                         and    Dat,bx

     ax=.in.dx.and.9=3DAh     ----->     mov    dx,3DAh
                                         in     ax,dx
                                         and    ax,9

    Другая форма - присваивание списку:

    <приемник 1>,<приемник 2>,...,<приемник N>=<выражение>
    
<выражение> последовательно  присваивается всем  указанным приемникам.
Это эквивалентно последовательности операторов:

                <приемник 1>=<выражение>
                <приемник 2>=<выражение>
                           ...
                <приемник N>=<выражение>

Например:

     x,y,z=0h           ------->         mov    x,0h
                                         mov    y,0h
                                         mov    z,0h

    Обе формы могут использоваться вместе в любых сочетаниях:

     si,di=ax=Addr<1    ------->         mov    ax,Addr
                                         shl    ax,1
                                         mov    si,ax
                                         mov    di,ax


                      Оптимизация в выражениях.
                      -------------------------

    PLM заменяет некоторые команды, в которых есть константы 0, 1 и -1
на более короткие. Например:

     ax=0               ------->         sub    ax,ax ; а не mov ax,0
     di=+1              ------->         inc    di    ; а не add di,1
    
При этом  PLM использует  не значение константы, а ее форму. Для того,
чтобы отказаться от оптимизации, Вы должны изменить форму константы:

     [bx]=0h            ------->         mov    [bx],0h

                               Условия.
                               -------

    Простые условия в PLM'e имеют вид:

        [<выражение 1>]<знак условия>[<выражение 2>]

    Они раскручиваются так: выполняется присваивание

              =<выражение 1>[.cmp.<выражение 2>]
    
Затем <знак условия> транслируется в соответствующий условный jmp. Вот
полная таблица этого преобразования (при неинвертированных условиях):

          <знак условия>  <раскрутка>

               =              je
               <>             jne
               >              ja
               >=             jae
               <              jb
               <=             jbe
               >>             jg
               >>=            jge
               <<             jl
               <<=            jle
               is carry       jc
               is even        jpe
               is odd         jpo
               is overflow    jo
               is sign        js
               is zero        jz

    Обратите внимание  на то,  что в  условиях символы  '=', '<' и '>'
обозначают нечто иное, чем в присваиваниях.
    Условие инвертируется, если перед ним стоит слово 'not'.
    Простые условия  можно объединять  в сложные, используя логические
связки 'and' и 'or'.
    Сложные условия анализируются слева направо. Для изменения порядка
можно использовать  скобки. Вложенность и сложность условных выражений
неограничены.
    Примеры раскрутки  условий будут  приведены ниже, при рассмотрении
условных операторов.



                  Некоторые простые операторы PLM'а.
                  ---------------------------------

             Операторы call, return, goto, extrn, public.
             -------------------------------------------

    call, extrn и public переносятся в ассемблеровский файл без каких-
либо изменений. Т.о., перед ними не нужно ставить точку.
    return заменяется на ret.
    goto заменяется на jmp.


                         Операторы push, pop.
                         -------------------

    Эти  операторы   почти  аналогичны   соответствующим   инструкциям
accемблера за исключением того, что у них могут быть списки операндов.
Кроме того,  операндом push'а  может быть  присваивание. В этом случае
сначала  выполняется   это  присваивание,   а  потом  push <приемник>.
Например:

     push ax,dx=.lea.[di+2]+1,ds  --->   push   ax
                                         lea    dx,[di+2]
                                         inc    dx
                                         push   dx
                                         push   ds

     pop es,dx,ax           --------->   pop    es
                                         pop    dx
                                         pop    ax


                          Директива equals.
                          -----------------

    Директива имеет  вид: equals <список> и раскручивается в несколько
директив ассемблера 'equ'. Например:

   equals MaxInt=0FFFFh,SC=";"  ----->   MaxInt  equ 0FFFFh
                                         SC      equ ";"


                         Оператор if - goto.
                         -------------------

    Этот  оператор  раскручивает  условие  любой  сложности  и  делает
условный переход. Рассмотрим примеры:

    if dx-1<> goto cont     ------->     dec    dx
                                         jne    cont

    if not (bx=(-1) and (is carry or ax<<0)) goto Error
                            |
                            +------>     cmp    bx,(-1)
                                         jne    Error
                                         jc     @@l1
                                         or     ax,ax
                                         jge    Error
                                   @@l1:


                       Директивы data и bytes.
                       -----------------------

    Эти директивы  предназначены для более удобного, чем в ассемблере,
описания  данных.   Их  аргументы   -  списки  элементов,  разделенных
запятыми:

     data <список>
или
     bytes <список>

    Элементами списка могут быть (на примере bytes):

 <имя>           транслируется в <имя> db  ?
 <имя>=<значение>     -∙∙-       <имя> db <значение>
 <имя>(<константа>)   -∙∙-       <имя> db <константа> dup(?)
 <имя>(<константа>)=<значение>  транслируется в
                        <имя> db <константа> dup(<значение>)
 '<имя>'=<значение>   -∙∙-       <имя> equ <значение>
 <имя>=               -∙∙-       <имя> label byte
 =<значение>          -∙∙-             db <значение>
 /                    -∙∙-       even
 /<элемент>      - <элемент> рассматривается как элемент
                   data, а не bytes
 (<список>)*<константа>  ---->   rept <константа>
                                   bytes <список>
                                 endm

    В случае  директивы data  вместо db будет dw. Директива data имеет
модификации: ddata,  fdata, pdata,  qdata и  tdata, которые заменяются
соответственно на  dd, df,  dp, dq  и dt; в остальном они работают так
же.
    Элементы   данных,    разделенные   не    запятыми,   а   точками,
рассматриваются   PLM'ом    как   один   элемент   и   переносятся   в
ассемблеровский  файл   с  заменой  точек  на  запятые.  Это  ускоряет
трансляцию и сокращает объем выходного файла.
    Приведем несколько примеров:

    bytes Text="Input X".10.13,'Length'=$-Text
                    |
                    +------->  Text   db     "Input X",10,13
                               Length equ    $-Text

    data X,/B=1,Buf(100h)  --> X      dw     ?
                               B      db     1
                               Buf    dw     100 dup(?)

    qdata =123e-5.(-2.54)  -->        dq     123e-5,-2.54

    ddata A=(0.-1)*3,Ptr=  --> A      label  dword
                                      rept   3
                                      dd     0,-1
                                      endm
                               Ptr    label  dword



                      Общая структура программы.
                      -------------------------

                               Модули.
                               -------

     Общая  структура модуля на PLM'е соответсвует структуре модуля на
ассемблере. В  этой главе  мы попробуем  обратить Ваше  внимание на ее
основные особенности  с точки зрения PLM'а. Простейшую структуру имеет
модуль, не  содержащий  подпрограмм  и  состоящий  только  из  главной
процедуры. Вот пример простейшей программы на PLM'е:

    model small          ----->  .model  small
    program simplest             LOCALS
    stop                         .code
                                 JUMPS
                                 simplest:
                                         mov    ah,4Ch
                                         int    21h
                                 end     simplest

    Директива 'model'  досталась PLM'у в наследство от ассемблера. Она
генерит  начальную  последовательность  директив  ассемблера,  которая
обычно ничему  не мешает. Эта последовательность директив расчитана на
применение Turbo  Assembler'a фирмы  Borland (TASM) версий 2.0 и выше.
Программа на  PLM'е обычно  начинается с  нее, однако если Вы опустите
эту директиву,  то можете определять сегменты старым методом с помощью
директив   SEGMENT ... ENDS и  использовать другой ассемблер, например
MASM фирмы Microsoft.
    Оператор 'stop' транслируется в две инструкции ассемблера:
    
     mov ah,4Ch
     int 21h

    Директива 'program'  содержит имя точки входа в программу и просто
порождает  метку  с  таким  именем.  После  директивы  'end'  в  конце
ассемблерного модуля  будет указано  это имя.  PLM всегда  заканчивает
ассемблеровский файл end'ом, так что Вам об этом заботиться не надо.
    Для  того,   чтобы  получить   COM-программу,  можно  использовать
директиву .org 100h  перед  program'ом.  Вот  простейший  пример  COM-
программы:

    model tiny
    .org 100h
    program shortest
    return

    Теперь  Вы  можете  без  труда  перенести  структуру  драйверов  и
оверлеев с ассемблера на PLM.


                            Подпрограммы.
                            -------------

    Подпрограммы, как  правило  находятся  непосредственно  за  концом
текста основной  программы. В  PLM'е подпрограмма выделяется с помощью
операторов  начала   и  конца   подпрограммы.  Вот  пример  простейшей
подпрограммы:

    (proc near simplest()
      return
    proc)
    
Более подробные примеры описания подпрограмм приведены ниже, в разделе
"Структурные операторы".


                               Данные.
                               -------

    Данные могут быть описаны в любом месте текста программы с помощью
операторов описания  данных (data,  bytes и др.).  Операторы  описания
данных  не   порождают  директив  переключения  сегмента.  Поэтому  не
забудьте вставить  их в  текст Вашей  программы до  и  после  описания
данных, если это необходимо.


                     Структурные операторы PLM'а.
                     ---------------------------

    Применение структурных  операторов в  программе  делает  ее  более
удобной  для   чтения  и   анализа.  Кроме  того,  написать  несколько
структурных операторов  проще, чем  путаться в похожих именах большого
числа меток  и мучиться,  придумывая уникальное  имя для  каждой новой
метки. В  то же  время Вам не запрещается использовать и метки в любом
месте программы,  где Вы  этого пожелаете.  Хорошо поставленная  метка
способна здорово  облегчить написание  и анализ  программы. Однако это
вопрос Вашего  личного стиля и вкуса. Мы предоставляем Вам возможности
- Вы можете их использовать.


                          Условный оператор.
                          -----------------

    В общем виде условный оператор можно записать так:

    (if <условие 1>
      <группа операторов 1>
    else if <условие 2>
      <группа операторов 2>
    ...
    else
      <группа операторов N>
    if)

    Алгоритм  выполнения  условного  оператора  состоит  в  следующем:
проверяется  <условие 1>,   и  если   оно  истинно,   то   выполняется
<группа операторов 1>, следующая  за  (if'ом,  после  чего  управление
передается за конец условного оператора. Если первое условие ложно, то
проверяется следующее условие (в else if'е), и в случае его истинности
выполняется соответствующая  группа операторов.  Если же  ни  одно  из
условий не выполняется, то управление передается на группу операторов,
следующую за  else'ом. Порядок выполнения условного оператора в случае
отсутствия 'else if' или 'else' очевиден. Вот несколько примеров:

Пример 1.

(if al=9 or al=20h             ------>       cmp    al,9
  bx=1                                       je     @@l2
else if al>="0" and al<="9"                  cmp    al,20h
  bx=2                                       jne    @@l1
else if al>="a" and al<="z"           @@l2:
  bx=6                                       mov    bx,1
else                                         jmp    @@l3
  bx=0                                @@l1:
if)                                          cmp    al,"0"
                                             jb     @@l4
                                             cmp    al,"9"
                                             ja     @@l4
                                             mov    bx,2
                                             jmp    @@l3
                                      @@l4:
                                             cmp    al,"a"
                                             jb     @@l5
                                             cmp    al,"z"
                                             ja     @@l5
                                             mov    bx,6
                                             jmp    @@l3
                                      @@l5:
                                             sub    bx,bx
                                      @@l3:

Пример 2.

(if cx>2000               ------>            cmp    cx,2000
  cx=2000                                    jbe    @@l1
if)                                          mov    cx,2000
                                      @@l1:

Пример 3.

(if [cs:Flag]=0h          ------>        cmp    [cs:Flag],0h
  Call NewIO                             jne    @@l1
else                                     call   NewIO
  Call OldIO                             jmp    @@l2
if)                               @@l1:
                                         call   OldIO
                                  @@l2:


                           Оператор while.
                           ---------------

    Оператор цикла имеет следующий общий вид:

    (while [<условие>]
      <группа операторов>
    while <условие>
      <группа операторов>
    while) [<условие>]

    Группы операторов, находящиеся внутри while'а, выполняются в цикле
до тех  пор, пока  все условия  истинны. В противном случае управление
передается за  конец цикла.  Если условие  за операторами '(while' или
'while)'  опущено,  то  оно  всегда  предполагается  выполненным.  Вот
несколько примеров:

Пример 1.

(while                 -------->     @@l1:
  call Do                                   call    Do
while)                                      jmp     @@l1

Пример 2.

(while                 -------->     @@l1:
  .lodsb                                    lodsb
while) al>" "                               cmp    al," "
                                            ja     @@l1

Пример 3.

(while                 -------->     @@l1:
  ah=1; .int 16h                            mov    ah,1
while <>                                    int    16h
  ah=0; .int 16h                            je     @@l2
while)                                      sub    ah,ah
                                            int    16h
                                            jmp    @@l1
                                     @@l2:

Пример 4.

(while ax=0            -------->     @@l1:
  call Out                                  or     ax,ax
while)                                      jne    @@l2
                                            call   Out
                                            jmp    @@l1
                                     @@l2:

Пример 5.

(while dx<>0           -------->     @@l1:
  call GetNext                              or     dx,dx
while not is carry                          je     @@l2
  call Open                                 call   GetNext
while not is carry                          jc     @@l2
  call Read                                 call   Open
while not is carry                          jc     @@l2
  call Close                                call   Read
while)                                      jc     @@l2
                                            call   Close
                                            jmp    @@l1
                                     @@l2:


                            Оператор save.
                            -------------

    Этот оператор  позволяет сохранить  значения некоторых  переменных
или регистров,  которые могут  быть запорчены  в ходе  выполнения кода
внутри оператора.  Опыт  показывает,  что  оператор  save  чрезвычайно
полезен и,  как  правило,  более  удобен,  чем  простые  push  и  pop,
поскольку он  позволяет избежать  часто  встречающейся  ошибки:  после
push'а забывают  сделать pop.  Действия и синтаксис оператора очевидны
из следующего примера:

Пример 1.

(save ax=0,bx,cx,[es:data1],[es:data2]
  call Dangerous                           sub    ax,ax
save)                             ------>  push   ax
                                           push   bx
                                           push   cx
                                           push   [es:data1]
                                           push   [es:data2]
                                           call   Dangerous
                                           pop    [es:data2]
                                           pop    [es:data1]
                                           pop    cx
                                           pop    bx
                                           pop    ax


                            Оператор proc.
                            -------------

    Этот оператор  предназначен для описания подпрограмм. Он позволяет
определить имя  и аргументы  подпрограммы, а  также регистры,  которые
будут сохранены  в стеке  и восстановлены  перед  выполнением  команды
'ret' (имена этих регистров пишутся в квадратных скобках через запятую
после списка  аргументов функции).  По-существу, он представляет собой
объединение в  один оператор  директив  ассемблера  'proc',  'public',
'uses', 'arg' и 'endp'. Если сразу за началом процедуры идет директива
var <список>, то  она  транслируется  в  LOCAL <список>,  и  ассемблер
генерит  стандартную   точку  входа  для  заданной  модели.  Синтаксис
оператора можно продемонстрировать следующим примером:

(proc far summa(a:word,b:word,c:far ptr)[ds,ax,bx]
 var wk:word     * Reserved for future use
   bx=.lds.c
   [bx]=ax=a+b
   return
proc)         ------>
                              PUBLIC summa
                       summa  PROC   far
                              USES   ds,ax,bx
                              ARG    a:word,b:word,c:far ptr
                              LOCAL  wk:word
                              lds    bx,c
                              mov    ax,a
                              add    ax,b
                              mov    [bx],ax
                              ret
                       ENDP

    Если Вы  не хотите,  чтобы  процедура  объявлялась  в  модуле  как
public, то перед ее именем нужно поставить символ '-'. Например:
    
     (proc -privat()    ------->    privat PROC
       return                              ret
     proc)                          ENDP


                            Оператор case.
                            -------------

    Оператор выбора  case поддерживает  переход по  индексной таблице,
выбирая нужную  метку перехода  в зависимости  от значения  некоторого
выражения. Выполняемые  действия и синтаксис оператора можно понять из
следующего примера:

    (case ax of 3     ------->         mov    bx,ax
    case 0                             cmp    bx,3
      call Do0; break                  jae    @@l5
    case 2                             shl    bx,1
      call Do2                         jmp    cs:@@l1[bx]
    case 1                      @@l1   dw     @@l2,@@l3,@@l4
      call Do21; break          @@l2:
    default                            call   Do0
      call Do_not                      jmp    @@l6
    case)                       @@l4:
                                       call   Do2
                                @@l3:
                                       call   Do21
                                       jmp    @@l6
                                @@l5:
                                       call   Do_not
                                @@l6:

    Константа N, стоящая после of'а, задает число случаев в case'е (от
0 до N-1).
    Значение выражения  по умолчанию  вычисляется в bx. Вы можете сами
задать индексный  регистр, по которому будет сделан косвенный переход.
Для этого  после '(case'  нужно сделать присваивание выражения нужному
регистру. Изменим начало предыдущего примера:

    (case di=ax<1 of 3   ------->      mov    di,ax
           ...                         shl    di,1
                                       cmp    di,(3*2)
                                       jae    @@l5
                                       jmp    cs:@@l1[di]
                                       ...

    В этом случае PLM сам не умножает индекс на 2. В такой конструкции
можно использовать и bx.
    default может  быть опущен. В этом случае, если индексное значение
превосходит граничное, управление передается за конец оператора.
    Заметим, что  в операторе  обязательно должны быть перечислены все
возможные значения.


                            Оператор loop.
                            -------------

    Для поддержки использования команды процессора 'loop' в PLM'е есть
одноименный  оператор   организации  циклов.  Он  позволяет  загрузить
некоторое число  в регистр или переменную и выполнить операторы внутри
цикла заданное число раз. несколько примеров:

     Пример 1.

     (loop 10           ------->            mov    cx,10
       ah=0; .int 21h                @@l1:
     loop)                                  sub    ah,ah
                                            int    21h
                                            loop   @@l1

     Пример 2.

     (loop(SaveCX) ax   ------->            mov    cx,ax
       .rep stosb                    @@l1:
     loop)                                  mov    SaveCX,cx
                                            rep    stosb
                                            mov    cx,SaveCX
                                            loop   @@l1


                     Операторы break и continue.
                     ---------------------------

    Эти операторы  действуют  внутри  case,  loop  и  while.  continue
осуществляет  переход  на  начало,  а  break  -  за  конец  ближайшего
структурного оператора. Например:

     (while                   ---->  @@l1:
       al=[bx]; bx=+1                       mov    al,[bx]
     while al<>0                            inc    bx
       (if al<>13 and al<>10                or     al,al
         .stosb                             je     @@l2
       else                                 cmp    al,13
         [si-1]="$"                         je     @@l3
         break                              cmp    al,10
       if)                                  je     @@l3
     while)                                 stosb
                                            jmp    @@l4
                                     @@l3:
                                            mov    [si-1],"$"
                                            jmp    @@l2
                                     @@l4   equ    @@l1
                                     @@l2:



    Теперь,  после  того  как  Вы  познакомились  с  основными  типами
операторов PLM'а, мы более подробно остановимся на том,

                     Как PLM обрабатывает текст.
                     ---------------------------

    В отличие  от популярных  ныне языков C и Pascal, в которых  конец
строки очень  редко используется как разделитель, в PLM'е конец строки
- более  сильный разделитель,  чем ";".  За исключением  2-х  случаев,
конец строки  всегда означает  конец  оператора.  Только  если  строка
кончается запятой  или символами  "%+" (за  которыми  может  следовать
комментарий)  к  ней  присоединяется  следующая  строка,  и  при  этом
концевые и ведущие пробелы отбрасываются. Например:

 bytes "Hello, world!",   --->   bytes "Hello, world!",13.10."$"
        13.10."$"

  if ax=0 then call some   %+ Эти строки
          else call other  %  объединяются
              |
              +------>    if ax=0 then call some else call other

    Итак, текст  на PLM'е  обрабатывается построчно, и первое, что PLM
делает со  строкой -  это проверка  на  макрооператоры.  Существует  6
предопределенных макрооператоров:

               if - then
               if - then - else
               (while) -
               - (while) -
               - (while)
               (loop) -


    Макрооператоры замечательны  тем, что они сильнее точки с запятой.
В остальном  же это  однострочные аналоги  соответствующих структурных
операторов. Рассмотрим примеры макрооператоров и их эквиваленты:



  .lodsb; if al="$" then [di]=0; dx=si
                   |
                   +--------->          .lodsb
                                        (if al="$"
                                          [di]=0; dx=si
                                        if)

  if is carry then [di]=0; si=di else [di]=ax=[si]
                   |
                   +--------->          (if is carry
                                          [di]=0; si=di
                                        else
                                          [di]=ax=[si]
                                        if)

  (while bx-1<>) call check; call do
                   |
                   +--------->           (while bx-1<>
                                           call check
                                           call do
                                         while)

  call check (while bx-1<>) call check
                   |
                   +--------->          (while
                                          call check
                                        while bx-1<>
                                          call do
                                        while)

  al=.in.dx.test.1 (while =)    ---->   (while
                                          al=.in.dx.test.al
                                        while) =

  (loop 6) es:[bp]=[si]; si=+4  ---->   (loop 6
                                          es:[bp]=[si]
                                          si=+4
                                        loop)

  if bx>0 then (while ax.in.dx.test.1=) (loop 0)
                   |
                   +--------->          (if bx>0
                                          (while ax.in.dx.test.1=
                                             (loop 0
                                             loop)
                                          while)
                                        if)

    Вы можете  определить свои макрооператоры. О том, как это сделать,
мы поговорим несколько позже.

    Затем обрабатываются  отдельные операторы,  разделенные точками  с
запятой.  В  определенном  порядке  они  сопоставляются  с  образцами:
сначала  со  структурными  операторами,  потом  с  остальными,  причем
присваивания  распознаются  в  последнюю  очередь.  Если  оператор  не
подходит ни  под один  образец (стандартный или определенный Вами), то
он считается ошибочным.

    Как  Вы  уже,  наверное,  заметили,  PLM  -  достаточно  необычный
контекстный  анализатор,   использующий  не   последовательный  разбор
текста,  а   сопоставление  строки   с  образцом.  Часть  транслятора,
реализующая  сравнение   с  образцом,   доступна  программисту   через
макроопределения. Это значит, что для каждого из описанных выше этапов
обработки текста  Вы можете  задать свои  образцы и их раскрутку через
ранее определенные.


                 Как происходит сравнение с образцом?
                 ------------------------------------

    Образец -  это строка,  (возможно) содержащая спецсимволы, которые
могут  определенным   образом  сопоставляться   с  группами   символов
(вспомните, как  в командах  DOS можно задать группу файлов, используя
wildcard characters "*", "?").
    В PLM'е есть 7 спецсимволов:

  ?                  - что угодно;
  $                  - группа символов, сбалансированная по кавычкам;
  &                  - группа символов, сбалансированная по  скобкам и
                       кавычкам;
  {<мн-во символов>} - любое число данных символов;
  [<мн-во символов>] - ровно один символ из данного мн-ва;
  !                  - любой символ (ровно один).
  _                  - любое кол-во пробелов (или символов табуляции).

    Будем считать,  что если  сравнение прошло  успешно,  то  значения
спецсимволов попадают  в псевдопеременные  вида  ^#,  где  #  -  номер
спецсимвола в образце (от 1 до 9).
    Мы не  будем  подробно  разбирать  алгоритм,  а  ограничимся  лишь
рассмотрением примеров сравнения и их результатов:
    
Строка         Образец    Результат           Переменные
                                          ^1      ^2      ^3
call subr      call ?         =           subr
a+b            &[-+]?         =           a        +       b
(a-b)          &[-+]?         <>
a*"+"-b        $[-+]?         =           a*"+"    -       b
x+=2           {a-z0-9}!=?    =           x        +       2
y=3            [a-z0-9]!=?    <>
y=3            !?=?           =           y       <пусто>  3
if   ax<>cx    if _?          =      <2 пробела>  ax<>cx
{...}          [{]?}          =           {       ...

    Значения переменных  ^1, ^2,  ^3, ... можно затем использовать для
формирования других строк.
    В PLM'е  есть 3  типа макроопределений:  macro, operator и expr. У
них общий синтаксис:

                  (<тип> "<образец>"
                     <тело макроопределения>
                  <тип>)

где <тип> - это macro, operator или expr.
    Если тело  макроопределения не  содержит точек с запятой, то можно
использовать однострочную форму:
    
        (<тип> "<образец>") -> <тело макроопределения>

    Иногда, если  не возникает разночтений, образец можно не заключать
в кавычки.
    Макроопределения типа  'macro' задают образцы, которые применяются
к  строке   до  того,  как  начинается  какая-либо  ее  обработка  (за
исключением приведения  символов к  нижнему  регистру,  если  включена
соответствующая опция).  Эти  образцы  перекрывают  даже  однострочные
макрооператоры и  являются наиболее мощным средством обработки текста.
С их  помощью Вы  можете делать с текстом практически все, что угодно.
Например, русифицировать часть или даже весь язык:

   (macro $ если ?) -> ^1 if ^2
   (macro $,_то ?) -> ^1 then ^3
   (macro "$[,;]_иначе ?") -> ^1 else ^4
   (macro $ если же ?) -> ^1 иначе если ^2
    и т.д.
    
(Заметьте, что  в 3-м  макроопределении  обязательно  нужно  заключать
образец в  кавычки, иначе  PLM примет  его за 2 оператора, разделенных
точкой с запятой.) После этого строка
    
  если ax=0, то bx=1; если же >>, то cx=(-1)

будет преобразована в

  if ax=0 then bx=1 else if >> then cx=(-1)
    
(Без сомнения,  фантазия подскажет  Вам, как  еще  можно  использовать
макроопределения. Здесь  же приводятся самые простые и, может быть, не
самые полезные примеры.)
    После того,  как строка  разбита на простые операторы (разделенные
точками с  запятой), но  до начала раскрутки к ним применяются образцы
типа 'operator'. Например, пусть задано макроопределение:
    
         (operator <?:?>=?) -> ^2=.l^1.^3
    
Тогда  <es:di>=Addr  равносильно  di=.les.Addr
Макроопределение же

(operator "if ? then goto ?") -> if ^1 goto ^2
    
совершенно бесполезно,  поскольку однострочные  операторы  раскрутятся
раньше, чем начнется сравнение с образцами данного типа.
    Таким  образом,   за  счет   некоторого  сужения  "сферы  влияния"
достигается существенно большая скорость трансляции, т.к. часть работы
(деление программы на операторы) выполняет PLM.
    Меньше всего  снижает скорость  3-й тип макроопределений - 'expr',
поэтому его  использование предпочтительней. Эти образцы применяются к
оператору в  том случае, если PLM не смог ничего ему сопоставить, т.е.
перед тем,  как выдать  сообщение об ошибке. 'expr' следует применять,
только если  Вы уверены, что "его" оператор не подойдет ни под один из
ранее определенных образцов. Например:
    
             (expr display(?)
               dx=offset ^1; ah=9
               .int 21h
             expr)

Тогда
       display(Text)  ----->  dx=offset Text; ah=9; .int 21h

    Макроопределение   (expr ?) -> .^1  позволит Вам с известной долей
риска опускать точку перед ассемблеровскими инструкциями и заблокирует
сообщения о  неверных операторах  (их  будет  отлавливать  ассемблер).
Тогда, например, можно написать:

          cld; al=' '; di=.les.Buf+Shift; rep scasb
и т.д.
    После удачного применения макроопределения его результат считается
новой  строкой  и  обрабатывается  с  самого  начала.  Таким  образом,
макроопределения рекурсивны.
    Последнее  встретившееся  в  тексте  макроопределение  применяется
первым.
    В заключение  заметим, что сравнение строки с образцом написано на
PLM'е.


                          Директива include.
                          -----------------

    Директива include  позволяет включить  в  данное  место  текст  из
другого файла:

     include <имя файла>

    В отдельный  файл  удобно,  например,  помещать  макроопределения,
константы и т.д. Вложенность include'ов неограничена.




                          Транслятор PLM'а.
                          -----------------

    При  запуске  транслятора  PLM'а  командная  строка  должна  иметь
следующий вид:

PLM [опции PLM'а] <входной файл> [<выходной файл>] [опции ассемблера]

    Опции PLM'а:
    
     /c    -   PLM  не  будет  запускать  ассемблер  после  того,  как
               странслирует программу (а по умолчанию он делает это);
    /Exxx -   задает имя  ассемблера, который будет использоваться для
               трансляции   выходного    файла,   полученного   PLM'ом
               (по умолчанию запускается TASM);
    /h,/? -   help;
    /l    -   в выходной  файл будут  помещены строки  исходного файла
               как комментарии ассемблера;
    /m    -   PLM будет  различать верхний  и нижний регистры символов
               (по умолчанию текст переводится в нижний регистр);
    /y    -   PLM поместит  в выходной  файл отладочную  информацию  в
               формате Turbo Debugger'а (фирмы Borland International).

    Входной файл  - файл  с исходным текстом на PLM'е. Если не указано
расширение, то подставляется '.plm'.

    Выходной файл  - файл,  в  который  PLM  помещает  ассемблеровскую
раскрутку  программы.   Если   не   указано   расширение   файла,   то
подставляется '.asm'.  Если же  этот параметр  вовсе  отсутствует,  то
программа транслируется  в файл  с именем входного файла и расширением
'.asm'.

    Опции  ассемблера,   если  они   указаны,  при  вызове  ассемблера
передаются ему как параметры после имени входного файла.


             Использование PLM'а совместно с Borland C++.
             -------------------------------------------

    При использовании  PLM'а c  BC++ удобно  создать  для  него  новую
статью в Transfer'е. Вот пример такой статьи:

 Program Title: P~LM
 Program Path:  plm.exe
 Command Line:  $NOSWAP $SAVE ALL $CAP MSG(TASM2MSG) /m /y $EDNAME /mx

 [X] Translator

    (PLM выдает  сообщения об ошибках в формате TASM'а, поэтому для их
фильтрации можно использовать TASM2MSG.)












                      Лицензия на использование.
                      --------------------------

    1. Данная версия программного продукта является ознакомительной.
    2. Вы можете свободно использовать и передавать данный продукт при
соблюдении условий, указанных в настоящей лицензии.
    3.  Не  допускается  распространение  каких  либо  частей  данного
продукта (отдельно  или в  неполном комплекте)  или если  в  комплекте
продукта имеются модифицированные или новые части.
    4.  Данная   лицензия  имеет   ограниченный  срок   действия.   Не
допускается передача и использование продукта после 1 июля 1992 года.
    5. Все права на данный продукт принадлежат авторам этого продукта.

