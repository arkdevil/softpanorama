       Некоторые практические вопросы объектно-ориентированного
              программирования на языке Turbo Pascal 6.0

                         О.П.Пилипенко

                         Одесса - 1991


        В настоящей статье я хочу поделиться своим ограниченным опытом в
области объектно-ориентированного программирования (ООП), описать  труд-
ности, с которыми я столкнулся, и пути их преодоления, которые мне  уда-
лось найти.


                 ... плюс объектификация всех структур

        Если Ваш интерес к ООП не чисто академический, а вполне  практи-
ческий, то скорее всего Вы не пишете объектно-ориентированную программу с
нуля, а конвертируете уже написанную программу. Стоит ли это делать? Как
подойти к решению этой проблемы? Что следует превращать в объекты? Ответ
на эти и многие другие вопросы Вы можете найти в статье Джеффа Дантеман-
на и Криса Мариначчи "Новые объекты в старых структурах". Статья эта бы-
ла опубликована в журнале BYTE, а мой перевод этой статьи - в  сентябрь-
ском выпуске журнала "Софтпанорама" за  этот год. Я не буду  воспроизво-
дить в своей работе основные положения этой бесценной статьи, однако хо-
чу остановиться на вопросе: какие же структуры данных следует превращать
в объекты, а какие нет?

        Очевидно, что нецелесообразно "объектифицировать" простые типы -
числа, символы, логические  переменные. Такие сложные  структуры данных,
как деревья, списки,  стеки следует превращать  в объекты. Это  позволит
Вам сделать поведение более  сложных объектов единообразным и,  при пра-
вильном подходе,  сократит объемы  исходных текстов  и кодов  Ваших про-
грамм. Для структур данных, имеющих промежуточную сложность, следует ре-
шать вопрос о преобразовании в объекты в каждом отдельном случае.

        Долгое время я считал, что преобразование таких несложных струк-
тур данных, как  одно- и двумерных  массивов может принести  только рост
накладных расходов. При  работе над пакетом  анализа и обработки  данных
VARPET я убедился, что это не так.

        Специфика программ анализа и обработки данных заключается в том,
что центральным объектом в  них является большая прямоугольная  матрица.
Часто, в  качестве рабочих  переменных, в  таких программах присутствует
вторая матрица такого или почти такого  же размера и один - два  больших
вектора. Качество программ анализа  и обработки данных в  первую очередь
определяется качеством управления этими большими структурами данных.

        Первоначально пакет VARPET был рассчитан на работу с нормальными
массивами языка паскаль. И в то время, когда он использовался в Одесском
университете для обучения  студентов и обсчета  их курсовых и  дипломных
работ, это решение удовлетворяло и нас, разработчиков, и  пользователей.
Достаточно скоро пользователи почувствовали вкус автоматизированной  об-
работки данных и их данные перестали помещаться в наши массивы.

        При переработке пакета я решил применить объектно-ориентированные
свойства только появившейся тогда версии 5.5 языка Turbo Pascal.  Воспо-
льзовавшись тем,  что Turbo  Pascal поддерживает  постепенный переход на
ООП, я решил  преобразовать в объекты  только большие числовые  массивы.
Описание этих объектов приведено в листинге 1. В самом тексте  программ-
ного комплекса я лишь заменил обращения к этим массивам и добавил вызовы
их конструкторов и деструкторов.

        После некоторых  исследований и  экспериментов я  заменил методы
объектов-больших массивов  так, чтобы  они превратились  в динамические.
Это сразу позволило работать с массивами данных объемом до 50 - 70  тыс.
чисел. Более того, простая замена методов этих объектов на методы, испо-
льзующие EMS или диск, могут многократно увеличить и эти цифры.


                        Параметризация объектов

        На листинге 2 представлено описание больших массивов данных, ис-
пользуемых в пакете  VARPET. Легко заметить,  что методы вещественных  и
целочисленных массивов совпадают. Их отличает только тип элементов  мас-
сива. Мне кажется,  было бы разумным  ввести в очередную  версию возмож-
ность параметрического описания объектов. Синтаксически это могло бы вы-
глядеть следующим образом:

        VectorBuffer = array[1..$FFF7 div SizeOf(VectorElemType)]
                            of VectorElemType;
        VectorBufPtr = ^VectorBuffer;
        BigVector = object
                      constructor Init(Size : VectorIndexType);
                      procedure SetVal(i : VectorIndexType;
                                       V : VectorElemType);
                      function GetVal(i : VectorIndexType)
                                              : VectorElemType;
                      destructor Done;
                    private
                      Handler : VectorBufPtr;
                      BufSize : word;
                    end;

    var
        RealVector = BigVector where (VectorElemType = real);
        IntegerVector = BigVector where (VectorElemType = integer);

        Если реализация такой конструкции затруднительна, то хотелось бы
иметь  возможность  параметризовать  объекты  через  значения констант и
иметь возможность создавать аналогичные объекты средствами макроязыка.


           Параметризация и определение "генеалогии" объекта

        Рассмотрим листинг 3.  Модуль LISTS представляет  собой описание
абстрактного типа список. Список определен как двунаправленный кольцевой
список, состоящий из реализаций совсем абстрактного типа Item,  содержа-
щего только указатели на соседей и не несущего никакой полезной информа-
ции. Естественно, что список сможет принести пользу только если он будет
состоять из более содержательных элементов.

        Представим себе, что часть иерархии объектов некоторой программы
имеет следующий вид:


        Item─┬───> VisualItem──┬──> TextLine
             │                 │
             │                 │
             │                 ├──> MCBDesc
             │                 │
             │                 │
             │                 └──> ProgEnv
             │
             │
             ├───> MemBuffer
             │
             │
             └───> List


        Некоторые объекты отображаемы на экране, а некоторые - нет.  Эти
объекты можно связывать в списки. Рассмотрим листинг 4. При обходе спис-
ка мы пытаемся визуализировать составляющие ее объекты. Вы заметили, что
при этом приходится прибегать к  приему, который в руководстве по  Turbo
Pascal называется typecast и который можно перевести как  преобразование
или приведение  типов. При  этом у  нас нет  никаких средств контроля за
тем, чтобы мы не попытались визуализировать невидимый объект.

        Такого рода сложностей мы избежали бы, если бы могли написать:

        var
          VisualList = List where (ListItemPtr = VisualItemPtr);

        Альтернативой этому могло бы служить введение функции

                   DescendantOf(Son, Father)

        которая возвращала  бы значение  TRUE, если  объект Son является
потомком объекта Father, и  значение FALSE в противном  случае. Реализо-
вать эту функцию, по крайней мере для объектов с виртуальными  методами,
на мой взгляд достаточно просто. Необходимо только в VMT каждого объекта
добавить ссылку на родителя.


                      Множественное наследование

        Еще одна черта, которую мне бы хотелось увидеть в ближайших вер-
сиях языка Turbo Pascal,  - это множественное наследование.  Мне кажется
что тот вариант множественного наследования, который Бернард Мейер,  ав-
тор объектно-ориентированного языка Эйфель, назвал марьяжем, вполне  впи-
сывается в элегантную структуру  языка паскаль и его  объектно-ориентиро-
ванного расширения.

        Действительно, многие объекты гораздо элегантнее описывались  бы
как дети счастливых браков между объектами. Так визуализатор текста  ло-
гично рассматривать как наследника  объекта окно и объекта  список строк
текста.

        А пока такой возможности нет, заменить ее можно используя указа-
тели. Пример приведен на листинге 5. Листаемый текстовый объект наследу-
ет свойства обычного окна и содержит указатель на список видимых  объек-
тов.

        При такой "эмуляции" множественного наследования встает вопрос -
какой из объектов сделать предком создаваемого? Очень часто желание  ис-
пользовать множественное наследование возникает из-за того, что разраба-
тываемый объект должен иметь двойственную природу - вести себя по  опре-
деленным правилам и уметь взаимодействовать с пользователем. Я  рекомен-
дую в таких  случаях делать такие  объекты потомками объектов  пользова-
тельского интерфейса. Это обеспечит единообразное взаимодействие различ-
ных объектов Вашей программы с пользователем.


         Рост объема кодов объектно-ориентированных программ и
                     методы борьбы с этим явлением

        Существует два противоположных мнения по поводу роста объема ко-
да программы  при применении  объектно-ориентированной технологии.  Одни
утверждают, что ООП позволяет уменьшить объем программы, другие  утверж-
дают, что ООП дискредитирует себя катастрофическим ростом программ и  не
позволяет  писать  скольконибудь  сложные  программы, которые не требуют
два-три мегабайта оперативной памяти.

        Где же истина? Решайте сами. Если Вы используете объекты,  соот-
ветствующие таким абстрактным типам данных, как список, дерево, стек, то
можете быть уверены, что списки окон, строк текста и блоков памяти испо-
льзуют одни и те же методы, один и тот же код. Объем объектно-ориентиро-
ванной программ  может уменьшиться  и потому,  что продуманная  иерархия
объектов позволяет сделать саму  программу более логичной и  менее запу-
танной.

        Применение  объектов,  как  таковых,  практически не увеличивает
размеры кода программы. Вызовы статических методов эквивалентны по  ско-
рости и накладным расходам вызовам обычных процедур. Более того,  интел-
лектуальный линковщик фирмы Borland отбрасывает все статические  методы,
которые никогда не используются.

        С виртуальными методами такой оптимизации нельзя сделать в прин-
ципе. Вследствие полиморфизма тип объекта и конкретный экземпляр вызыва-
емого метода определяется динамически  во время выполнения программы.  В
этом  случае  придется  рассчитывать  либо  на  технологию  DLL  в среде
Windows, доступ к которой обеспечивает Turbo Pascal for Windows 1.0, ли-
бо на внедрение в  Turbo Pascal технологии VROOMM  - объектно-ориентиро-
ванного менеджера виртуальной памяти.

        Итак, если Вы хотите уменьшить объем кодов Вашей объектно-ориен-
тированной программы, старайтесь  всюду, где это  возможно, использовать
статические, а не виртуальные методы. Что же делать, если  использование
виртуальных методов  вызвано объективной  необходимостью или  если Вы их
унаследовали от купленных или написанных Вами ранее библиотек объектов?

        Я предлагаю использовать объектно-ориентированные черты менедже-
ра оверлеев версий 5.5 и 6.0 языка Turbo Pascal. Самая мелкая порция ко-
да, с которой работает менеджер оверлеев - модуль. Нам было бы  удобнее,
чтобы менеджер оверлеев мог работать с отдельными объектами и даже с от-
дельными методами. К этой цели можно легко приблизиться. Для этого нужно
модули описать так, чтобы один модуль содержал описание одного  объекта.
Затем такие модули можно описать как оверлейные.

        Если последовательно применять этот прием, можно быть уверенным,
что виртуальные методы абстрактных объектов и объектов, входящих в  биб-
лиотеку, но не используемых в Вашей программе, в большинстве своем  ока-
жутся "заперты" на диске и не будут загромождать оперативную память.

        Тем  не  менее,  я  считаю,  что  я не единственный, кто ждет от
Borland системы управления памятью не позволяющей, а обеспечивающей вир-
туализацию на уровне  объектов. Хотелось бы,  чтобы такая система  могла
управлять не только виртуализацией методов объектов, но и их данными.

-----------------------------------------------------------------------
Примечание редактора:
Программы находятся в \forum\tp-club\pilipenko
