               Cофтпанорама 1991, No. 10 (24), выпуск С
                    ********* ARTICLES ***********
             Составители: Н.Н. Безруков, В.В. Пономаренко
************************************************************************
                                          Глава из книги Юрия Лесюка
                                          публикуется с разрешения автора
                                                                 Б.Н.Н.




                                Антомия
                                Компьютерной
                                Игры

Глава IV Спрайты

                Видеоадаптеры и драйверы спрайтов
                Введение в спрайтовую графику. Исторический аспект
                Виды спрайтов (на примере игры Captain Comic: собственно
                                спрайты; спрайты кубиков; спрайты
                                призов; спрайты врагов)
                Особые случаи спрайтов: показателя снарядов;
                                спрайты мультипликатов; спрайты цифр и
                                букв (на примере счетчика баночек с
                                колой)
                Использование спрайтов при работе с конструктором
                                образов (спрайты в игре Prince of Percia)

        В данной главе мы познакомимся с термином, которым буквально
        проникнут процесс создания игрушек: со спрайтами. Ввиду тесной
        связи спрайтов и графической системы вывода компьютера, мы
        приведем кратенькие (но достаточные) описания распространенных
        на IBM PC графических адаптеров. Обоснуем мотивы выбора в
        дальнейшем изложении адаптера EGA, введем понятие драйвера
        спрайта, и изложим (еще немного дальше) суть спрайтовой
        техники, сопроводив суть историческим экскурсом в проблему.

        Дальнейшее изложение главы проиллюстрирует на примере игры
        Captain Comic разнообразие встречающихся спрайтов и драйверов,
        их обслуживающих.

        Совсем уж хитрые случаи спрайтов назовем особыми, и некоторые из
        них проанализируем.

        Одним из ухищрений в последних достижениях спрайтовой техники
        является sprite image constructor (спрайтовый конструктор
        образов) (игрушка Prince of Percia с потрясающей воображение
        пластикой движений главного героя). Анализом нюансов работы в
        этой технике мы и завершим данную главу.


Видеоадаптеры и драйверы спрайтов

Многие компьютерные игры представляют собой случаи (с точки зрения
реализации) изощренного использования возможностей видеоадаптера.
Поэтому доскональное знание видеоадаптеров, их систем команд, регистров,
режимов - неотъемлемая часть (с точки зрения теоретической подготовки)
специалиста по компьютерным играм. Вместе с тем, более-менее полное
описание даже одного адаптера (допустим, EGA) само по себе представляет
хорошенький (с точки зрения толщины) томик.

Не являясь целью данной книги, видеоадаптеры, тем не менее будут
рассмотрены, и нельзя сказать, что рассмотрены они будут поверхностно.
Рассмотрены они будут ДОСТАТОЧНО: по минимуму для того, чтобы не
затенять существенных мест изложения; по максимуму, когда являются
существенными местами в изложении. Как же определить достаточность
изложения? А-а-а? - О-о-о-о! Основных критериев в нашем случае
несколько.

Во-первых, - мы реализуем КОМПЬЮТЕРНУЮ игрушку. Следовательно, должны
ясно себе представлять, что же в "этой штуке" (компьютере) физически
происходит. Для этого мы изучим принципы действия, вопросы
физического расположения оперативной памяти адаптеров, упомянем основные
режимы работы.

Во-вторых, - мы РЕАЛИЗУЕМ компьютерную игрушку. Следовательно нам нет
необходимости изучать те моменты функционирования адаптеров, которые не
будут использованы в рамках основного изложения книги. Да мы даже не
взглянем на многие регистры адаптеров, не посмотрим на многие режимы их
работы.

В-третьих, мы реализуем компьютерную ИГРУШКУ. Следовательно, будем
анализировать (особенно в главе про спецэффекты) спецэффекты,
использующие специфические возможности адаптеров. И тут мы, хотим этого
или не хотим, но проанализируем эти возможности более полно.

Читателей, которые все же настойчиво захотят ознакомиться с
видеоадаптерами поподробнее, мы пошлем. Пошлем прямо к списку
литературы, освещающей данный вопрос. Ну а теперь, к делу.


Что касается персональных компьтеров IBM PC, то те времена, когда
разнообразие видеосистем заключалось в наличии алаптера монохромного
дисплея и графического дисплея, давно минули не только на диком западе,
но и в нашей благословенной стране. В наше время на базаре (который
хотелось бы назвать рынком, да язык не поворачивается (совесть ему не
позволяет и чувство меры)) предлагается множество самых различных
адаптеров и всевозможных дисплеев. То есть стандартов много. И если мы
попытаемся даже упомянуть их, времени это займет много. Мы же пойдем
другим путем (ни на что не намекаю!). Приведем системы дисплеев IBM,
которые на сегодняшний день являются промышленными стандартами:

        адаптер монохромного дисплея (в оригинале - Monochrome Display
                Adapter - MDA, или по-русски - Ем-Дэ-А)
        адаптер графического дисплея (в оригинале - Color Graphics
                Adapter - CGA, или по-русски - Це-ГА)
        улучшенный графический адаптер (Enhanced Graphics Adapter - EGA
                - Е-ГА - соответственно)
        видеографический адаптер (Video Graphics Array - VGA - Ве-ГА)

Вот их-то и рассмотрим.


Сначала немного о памяти. Различные видеоадаптеры используют различное
количество ОЗУ для своей работы. Но в системе с любой стандартной
конфигурацией  зарезервированная видеопамять начинается с адреса a0000
(который, между прочим, находится на границе DOS-совских 640 кБайт) и
длится 128К до адреса bffff (что, кстати, не всегда хватает, но об этом
дальше).

Чито касается адаптера MDA, то с ним все ясно: при нашем желании писать
ГРАФИЧЕСКИЕ игрушки, его рассмотрение занимает несколько строк, ибо
данный адаптер пригоден только для отображения символов и с графикой не
работает. И хотя с нашей точки зрения (с точки зрения программистов
графических компьютерных игр), оправдать существование такого
недоразумения сложно, объяснение этому все-таки есть. Во первых, что
немаловажно с точки зрения коммерческой, этот адаптер дешевый.
Во-вторых, он дает очень качественное изображение с высокой четкостью и
разрешением. Матрица символа в этом дисплее - 9 x 14 точек. Этот адаптер
использует 4 Кбайта зарезервированной под видеопамять памяти по адресам
b0000 - b0fff. Стандартный алфавитно-цифровой режим для 25 строк по 80
символов в каждой.

С остальными адаптерами придется повозиться.

Чтобы изложение было завершенным, начну с азов. Изображение состоит из
точечек. Точечек может быть много. Причем точечки могут быть цветными
И все эти "может быть" жрут оперативную память! Чем больше точечек, тем
больше памяти, чем больше цветов, тем больше памяти. После определенного
количества точечек и цветов усложняются алгоритмы доступа к ним. После
того, как память перерастает мыслимые пределы (относительного
выделенного для этих целей  адресного пространства  компьютера),  она
переходит   их  (мыслимые  пределы)   и размещается на платах
видеоадаптеров, что опять-таки вызывает усложнение алгоритмов доступа к
точечкам. Но давайте считать.

Одна точечка - один битик. Для монохромных (то есть одноцветных) режимов
работы видеоадаптеров, если битик равен 0, то это - черный, если он 1 -
белый цвет. Поскольку доступ к оперативной памяти компьютера по-минимому
является побайтным (обратите внимание на этот факт в целях дальнейшего
изложения материала о спрайтах), выровняем количество точек на 8, и
рассчитаем количество памяти для видеорежима 320 x 200 точечек, которые
иногда будем называть пикселями (для солидности, вообще-то; с остальных
точек зрения, точка - она и в Африке точка! (каламбур)).
Если мы работаем с четырьмя цветами, то надо умножить еще на 2 - два
бита могут держать 2^2 степени комбинаций. А результат поделим на 8,
чтобы оперировать байтами.
Итак, 320 * 200 * 2 / 8 = 16000 (или 3e80h, если по-человечески). 80
байт оставим на совести разработчиков, и округлим.

Округляем -- 4 килобайта (К). (Обратите внимание на длинненькое тире в
фразе. Поскольку есть любители читать запись - 4 как минус четыре, что
по логике есть нонсенс по отношению к оперативной памяти, то длинненькое
тире из двух минусов по законам арифметики даст минус на минус - плюс,
что позволит избежать разночтения в любом случае.)

Итак, режим 320х200 точек, 4 цвета требут 4 кБайта памяти. А
адаптером CGA используется (смотрим в документацию) 16 кБайт. Куда же
деть остальные 12 К памяти? А выход прост - сделать из них страницы
(pages). Зарезервирована для этих 16 К видеопамять по адресам
b8000 - bbfff.

Что нам интересно в станицах, так это, что их можно переключать, делая
активным. Активная страница это та, что в данный момент видима на
экране. А в это время в неактивных страницах мы можем изменять их
(страниц) содержимое. После этого, изменив определенным образом
содержимое невидимой страницы, мы переключаем адаптер на ее отображение.
И если на вновь переключенной странице все осталось тем же самым, за
исключением координаты какого-то элемента, мы получим иллюзию движения
данного элемента, что вобщем-то и является одним из фундаментальных
принципов создания компьютерных игрушек.

        <
        адаптер CGA: структура памяти
                     регистры
                     принцип вывода точек
        >

        <
        адаптер EGA: стркутура памяти плоскости
                     регистры
                     принцип вывода точек
        адаптер VGA сравнительно с EGA
        >


Понятно, что CGA проще всего, VGA лучше всего. Но все-таки мы
рассмотрим более внимательно стандарт адаптера EGA. И вот почему.
Стандарт CGA, являясь почти очевидным, не представляет сложности в
процессе использования. И если мы собираемся не формально подойти к
делу, то должны рассмотреть не столько стандарт посложнее, сколько
стандарт который более эффективен в использовании. А два более сложных
(но и более эффективных) стандарта EGA и VGA по сути своей работают
одинакого. По форме же работа в VGA фактически обрастает сложностями,
подробностями, громоздкостями. Следовательно, выбрав EGA, мы освоим
принципы работы, которые позволят спокойно перейти на VGA, но листинги
программ все же останутся более читабельны. Безусловно, примеры
использования будут приведены для всех адаптеров.


Драйверы спрайтов

Программу, обслуживающую внешнее устройство, преобразовывающую
информацию к виду, требуемому этим внешним устройством в вычислительной
технике принято называть драйвером. Что касается производства
компьютерных игрушек, то здесь драйвер как понятие приобретает
существенный оттенок. Драйвер компьютерной игрушки взаимодействуя с
внешним устройством дисплеем, обслуживает уровень отдельных изображений
- спрайтов (чуть погодя мы дадим их определение), в отличии, например,
от драйвера операционной системы, который, работая с дисплеем, делает
это побайтно.

Еще немного поопределяем. Драйвер, непосредственно взаимодеющий с
физическим устройством, называют физическим драйвером устройства, а
уровень обмена информацией называют физическим. Если же некоторый
драйвер уже пользуется физическим драйвером, то он будет называться
логическим (и таким же будет уровень).

В одних случаях, например, в игрушках, сделанных на алфавитно-цифровых
дисплеях, когда изображение состоит из нескольких символов, драйвер,
выводящий изображения, будет в работе для вывода пользоваться физическим
драйвером (причем, чаще всего, уже готовым, системным) для вывода
отдельных байт изображения, и является логическим. В других случаях,
например, в нашей книге, приграммист сам реализует и физический и
логический уровни драйверов дисплея.

В редакторе, допустим, довольно-таки сложной программе, всегда есть один
физический драйвер обмена информацией с дисплеем. Остальные драйверы
дисплея, пользуются этим драйвем для остальных случаев взаимодействия с
дисплеем, и такая организация программы способствует МОБИЛЬНОСТИ
программы. При переносе ее на другой дисплей, или на другую машину,
программист переписывает физические драйвера, и программа может начинать
работать.

Момент мобильности, безусловно, важен и при реализации игрушек. Ибо
очень обижает, если игрушка не идет на имеющемся в нашем распоряжении
адаптере (особенно если этот адаптер лучше, чем тот, на который
рассчитана игрушка).

Следовательно, в зависимости от того, как мы определим физический
уровень в драйверах вывода на дисплей, зависит количество кода, который
нужно будет переписывать для переноса игры на другой адаптер.

Основным критерием, в данном случае, служит эффективность выполнения
программы. Вот для получения более быстрой игры, драйверы дисплеев и
работают с целыми изображениями, а то и со специфическими
последовательностями этих изображений.


Вот тот теоретический минимум, знание которого понадобится нам для
понимания следующего материала. Безусловно, после того, как
теоретические положения будут проиллюстрированы примерами, качество
понимания заметно улучшится. Так что не надо огорчаться, если не все
осталось понятым.


Введение в спрайтовую графику. Исторический аспект

Одним из фундаментальных понятий в создании компьютерных игр является
понятие спрайта. Тесно переплетаясь с системой графических драйверов
вывода на экран, спрайты диктуют структуры данных, проектируемых для
игры. Различные видеоэффекты базируются на использовании спрайтов.
Многие компьютерные игры, с точки зрения графики, являются системами
обработки спрайтов.

Что должне осознать каждый, собирающийся писать компьютерные игры - это
важность умения владеть техникой работы со спрайтами. Если проектировщик
эффективно реализовывает спрайты, игрушка будет и быстрой, и живой, и
т.д.; при неудачной же реализации спрайтов...

Интересно проследить эволюцию спрайтов.

С самого начала, когда дисплеи были только алфавитно-цифровыми, спрайтов
не было. Точнее, они были, но так не назывались.

        <
        игрушки ladder  catchum
                pecmen
        >

В истории спрайтов было все. И хитроумные законы вывода спрайта на
экран, и аппаратные реализации спрайтов.

        <
        аппаратная реализация спрайтов в компьютере ямаха
        >

А результатом этого исторического процесса на данном этапе явился ряд
приемов, которые мы и используем в данной книге, последовательно вводим,
и непосредственно прибегаем.


Итак, что же такое спрайты? Грубо говоря, это прямоугольник изображения,
выводимый как единое целое в координату по определенному логическому
закону на экран.

И если с выводом в координату как единого целого трудностей в понимании
не возникает, то по поводу закона вывода скажем несколько слов.

Довайте сразу же сопроводим сказанное примером.




На экране у нас выведен некоторый фон: кустики, деревья, здания, небо,
тучки, и т.д. Возле дерева попытаемся расположить человечка.

Как, неважно пока, но человечек занесен в спрайт. А поскольку
спрайт прямоугольный, а сам человек кривой (да не обидятся люди на
вышесказанное), то между краем спрайта и изображением человека
образуется черная дыра (цвет 0x0000). Если теперь вывести его на экран,
попросту перекопировав точку за точкой, то мы пролучим картинку.

Что не совсем то, что хотелось. Попытаемся сделать иначе: в каждой
точке экрана будем фиксировать цвет как результат операции OR.

Теперь уже ближе к желаемому, но все так же не оно [желаемое]. Ибо если
фон под человечком не был 0, то результирующий цвет будет не
соответствовать оригиналу (спрайту, изображающему человечка).

Учтя это, усложним немного алгоритм вывода изображения на экран: с
каждой точкой изображения проделываем следующую опрерацию: если цвет
текущей точки спрайта не нолевой, окрашивает соответствующую точку на
экране в черный (нолевой цвет), с точки зрения ноликов и единичек, это
будет логическое умножения AND на нолик, а затем сложим OR с этой точкой
цвет точки изображения - OR.

Вот основной принцип получения изображения, перекрывающего фон. Теперь
наведем порядок в терминологии. И построим драйвера различных адаптеров
дисплеев.


        <
        драйвер спрайтов для адаптера CGA
        >

Драйвер спрайта для адаптера EGA

Давайте внимательно рассмотрим иллюстрацию (см. рис. Формат хранения и
принцип формирования спрайта для адаптера EGA), которая поможет
разобраться нам в том, как организованы данные для конкретного спрайта
размером 16х32 пиксела.

В памяти компьютера строка из a0h слов является изображением, хранимым
в следующем формате. Номера регистров цветов составляют четыре
плоскости, четыре битовые карты. Следовательно, верхние 16 пикселов
(ширина спрайта) займут 16 / 8 = 2 байта или 1 слово. Каждое из этих
слов находится в своей плоскости. Первая плоскость (впрочем, как и
каждая следующая) состоит из (высота спрайта) 20h слов. На четыре
плоскости приходится 80h слов. Последние 20h слов приходятся на так
называемую маску спрайта. Маска спрайта представляет собой
инверсированный силуэт изображения. То есть, в тех местах, в которых в
спрайте цвет объекта не нолевой, соответствующий бит маски спрайта равен
1, в местах с пустым (или, нолевым, или черным цветом), бит маски
равен 0.

Таким образом, вывод на экран силуэта спрайта при помощи операции OR,
даст на экране изображение силуэта объекта.

Поскольку представлять все это конкретно, действительно важно, хотя и
нудно, давайте-ка все-таки для полного счастья приведем дамп
соответствующего участка памяти.

    0 map
      x000: 00 00 00 00 00 00 03 c0  07 e0 0f f0 0f f8 0f f8
      x010: 0f f8 0f f8 07 f0 03 c0  00 00 02 40 02 40 03 c0
      x020: 07 e0 07 60 07 20 07 a0  07 e0 07 e0 07 e0 0f f0
      x030: 0f f0 1e 78 1e 78 1c 38  1c 38 00 00 00 00 00 00
    1 map
      x040: 00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00
      x050: 00 00 00 00 00 00 00 00  01 80 00 00 00 00 00 00
      x060: 00 00 00 00 00 00 00 40  38 1c 30 0c 18 18 10 08
      x070: 00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00
    2 map
      x080: 00 00 00 00 00 00 00 00  00 00 00 f0 01 f8 01 f8
      x090: 01 f8 00 f8 00 00 00 00  00 00 05 a0 0d b0 1c 38
      x0a0: 18 18 38 9c 38 dc 38 5c  00 00 30 0c 18 18 10 08
      x0b0: 00 00 00 00 00 00 00 00  00 00 1c 38 7c 3e 7c 3e
    3 map
      x0c0: 00 00 00 00 00 00 03 c0  07 e0 0f 10 0e 58 06 48
      x0d0: 0e 08 07 18 03 f0 01 40  01 80 07 e0 0f f0 1f f8
      x0e0: 1f f8 3f fc 3f fc 3f fc  3f fc 37 ec 1f f8 1f f8
      x0f0: 0f f0 1e 78 1e 78 1c 38  1c 38 1c 38 7c 3e 7c 3e
   mask map
      x100: ff ff ff ff ff ff fc 3f  f8 1f f0 0f f0 07 f0 07
      x110: f0 07 f0 07 f8 0f fc 3f  fe 7f f8 1f f0 0f e0 07
      x120: e0 07 c0 03 c0 03 c0 03  c0 03 c8 13 e0 07 e0 07
      x130: f0 0f e1 87 e1 87 e3 c7  e3 c7 e3 c7 83 c1 83 c1


А теперь попробуем в этих цыфирьках увидеть изображение. Для этого
берем в каждой плоскости последовательно по слову и переводим эти слова
перпендикулярно в цвета. Например, 10h слово (слово, а не байт!) по
картам памяти:

    номер карты слово     двоичная запись слова
    --------------------------------------------------------
        3 map:  1f f8  >  0 0 0 1  1 1 1 1  1 1 1 1  1 0 0 0
        2 map:  18 18  >  0 0 0 1  1 0 0 0  0 0 0 1  1 0 0 0
        1 map:  00 00  >  0 0 0 0  0 0 0 0  0 0 0 0  0 0 0 0
        0 map:  07 e0  >  0 0 0 0  0 1 1 1  1 1 1 0  0 0 0 0
    --------------------------------------------------------
    шестнадцатиричная  >  0 0 0 c  c 9 9 9  9 9 9 c  c 0 0 0
        интерпретация     ----------------------------------
             цветовая  >  a a a R  R B B B  B B B R  R a a a
        интерпретация
    --------------------------------------------------------
    слово маски:e0 07  <  1 1 1 0  0 0 0 0  0 0 0 0  0 1 1 1



Что касается цветовой интерпретации, то еще раз обращаем свое внимание
на тот факт, что номерам цветов в адаптере EGA соответствуют номера
регистров, в которых собственно и хранятся сами номера цветов. В данном
случае, мы считаем, следовательно, что в регистре цвета под номером с
(12 по-русски) находится цвет lightRed (светло-красный), что и
отображено большой латинской буквой R.

Следовательно, мы нарисовали 10h-ю строку пикселей спрайта. Проделав
аналогичную операцию с остальными словами, получаем следующую картинку.

             0 1 2 3 4 5 6 7 8 9 a b c d e f
          +-----------------------------------+
       00 |                                   |
       01 |                                   |
       02 |                                   |
       03 |              B B B B              |
       04 |            B B B B B B            |
       05 |          B B B B m m m M          |
       06 |          B B B m m M m M M        |
       07 |          b B B m m M m m M        |
       08 |          B B B m m m m m M        |
       09 |          b B B B m m m M M        |
       0a |            b B B B B B B          |
       0b |              b B b B              |
       0c |                G G                |
       0d |            R B R R B R            |
       0e |          R R B R R B R R          |
       0f |        R R R B B B B R R          |
       10 |        R R B B B B B B R R        |
       11 |      R R R B B B Y B B R R R      |
       12 |      R R R B B B Y Y B R R R      |
       13 |      R R R B B B B Y B R R R      |
       14 |      G G G B B B B B B G G G      |
       15 |      Y Y   B B B B B B   Y Y      |
       16 |        Y Y B B B B B B Y Y        |
       17 |        Y B B B B B B B B Y        |
       18 |          B B B B B B B B          |
       19 |        B B B B     B B B B        |
       1a |        B B B B     B B B B        |
       1b |        B B B         B B B        |
       1c |        B B B         B B B        |
       1d |        R R R         R R R        |
       1e |    R R R R R         R R R R R    |
       1f |    R R R R R         R R R R R    |
          +-----------------------------------+
             0 1 2 3 4 5 6 7 8 9 a b c d e f

Для того, чтобы убедиться, что мы разобрались с маской спрайта, давайте
проанализируем строку слово маски. Всем только нолевым по-вертикали
строкам соответствует значение бита 1. Остальным - ноли (0).
Следовательно, результирующее слово == e0 07, что полностью сошлось с о
значением 10h-го слова в карте маски дампа.


А теперь мы напишем драйвер спрайта для адаптера EGA.


        <
        подпрограмма show_sprite
        >

        <
        кодировка драйверов
        >

draw_sprite_at_map_16xCX        proc near
        ; private - служебная подпрограмма, выводит [ah] карту спрайта
        ;     размером 16 на [cx] пикселей на экран в координату [di]
        ;
        push    di
        mov     dx, 03c4h
        mov     al, 2
        out     dx, al          ; port 3c4h, EGA sequencr index
                                ;  al = 2, map mask register
        inc     dx
        mov     al, ah
        out     dx, al          ; port 3c5h, EGA sequencr func
        mov     dx, 03ceh
        mov     al, 4
        out     dx, al          ; port 3c4h, EGA graphic index
                                ;  al = 4, read map select
        inc     dx
        mov     al, bl
        out     dx, al          ; port 3c5h, EGA graphic func
        mov     bx, bp
        mov     dx, cx

draw_sprite_at_map_loop:
        mov     ax, [bx]
        and     es:[di], ax
        lodsw                   ; String [si] to ax
        or      es:[di], ax
        add     di, <длина строки на экране>
        add     bx, 2
        loop    drow_sprite_at_map_loop

        mov     cx, dx
        pop     di
        ret
draw_sprite_at_map_16xcx        endp



Виды спрайтов (на примере игры Captain Comic: собственно
               спрайты; спрайты кубиков; спрайты
               призов; спрайты мультипликатов)

   <
   принцип формирования изображения в игре экрана с помощью фонового и
   активного экранов
   >



   ┌─────────────────────────────┐   ┌─────────────────────────────┐
   │ ╔═══════════════╗           │   │ ╔═══════════════╗           │
   │ ║               ║  ▌▌▌▌▌▌││││   │ ║               ║  ▌▌▌▌▌▌││││
   │ ║          e    ║           │   │ ║          o    ║           │
   │ ║        ====   ║  ▌▌▌▌▌▌▌▌▌│   │ ║        =====  ║  ▌▌▌▌▌▌▌▌▌│
   │ ║          I    ║  ┌───────╖│   │ ║          I    ║  ┌───────╖│
   │ ║---------------║  │ *     ║│   │ ║---------------║  │ +     ║│
   │ ╚═══════════════╝  │       ║│   │ ╚═══════════════╝  │       ║│
   │   $  $  $  S  S    ╘═══════╝│   │   $  $  $  S  S    ╘═══════╝│
   └─────────────────────────────┘   └─────────────────────────────┘


   <
   драйверы спрайтов с учетом принципа
   >


Особые случаи спрайтов:
               спрайты показателя снарядов;
               спрайты цифр и букв

Мы увидели, что такое спрайты, познакомились со многими их
разновидностями. Кажется, что придумать что-то особенное на уровне
исходной концепции (то бишь, идеи) спрайтов трудно? Трудно! И все-таки
придумывают. Примеры таких спрайтов попытаемся рассмотреть.

Перед следующим примером, введем еще одно неписанное правило
разработчиков компьютерных игр: все объкты в программе обрабатываются
как спрайты, даже если это кажется невозможным.

Объяснюсь. Но для этого запустите игрушку Captain Comic и присмотритесь
внимательно к тому, как функционирует показатель снарядов (верхний
прямоугольник из ряда светло/темно красненьких полосочек в серой
каемочке). Когда мы придержим нажатой клавишу Insert (естественно, если
в нашем ряспоряжении есть несколько баночек с колой), то показатель
снарядов уменьшает свое значение, делая светло-красненькие полосочки
темными по одной справа налево. Присмотрелись? По ОДНОЙ!

А теперь давайте-ка посчитаем. Ширина одной светло/темной-полосочки
3 (три) пикселя, вместе с паузой между полосочками - 4 (четыре), а
МИНИМАЛЬНЫЙ РАЗМЕР СПРАЙТА - 8 (восемь) пикселей. Как мы знаем, или,
по-крайней мере, догадываемся, это не просто так. Это потому, что по
памяти мы может по-минимуму пересылать только байты в нашей машине. А
байты и слова мы гоняем по памяти потому, что это намного быстрее, чем
отдельный биты (и не в 8 раз, а намного больше, ибо время (и команды)
будут уходить на сдвиги/установку/сдвиги нужного числа битов).

Так вот, разработчик игрушки вышел из этой ситуации следующим остроумным
способом. Он взял и сложил две полоски. С учетом расстояний между ними,
получилось ровно 8 (восемь) бит, то есть - байт. А после этого нарисовал
три спрайта следующего вида:

             спрайт N% 1      спрайт N% 2      спрайт N%3
             две темные       одна светлая     две светлые
             полоски          одна темная      полоски
             ┌────────┐       ┌────────┐       ┌────────┐
             │▓▓▓ ▓▓▓ │       │░░░ ▓▓▓ │       │░░░ ░░░ │
             │▓▓▓ ▓▓▓ │       │░░░ ▓▓▓ │       │░░░ ░░░ │
             │▓▓▓ ▓▓▓ │       │░░░ ▓▓▓ │       │░░░ ░░░ │
             │▓▓▓ ▓▓▓ │       │░░░ ▓▓▓ │       │░░░ ░░░ │
             │▓▓▓ ▓▓▓ │       │░░░ ▓▓▓ │       │░░░ ░░░ │
             └────────┘       └────────┘       └────────┘

Ну что, догадались дальше? Если да, то пропустите следующий абзац.
Если нет, то пропустите абзац после следующего.


Не догадались, ну не расстраивайтесь. Сейчас все уясним. Итак, вначале
мы берем и выводим на экране строку из требуемого нам количества
спрайтов под номером 3. Вот так:  333333. Теперь нам нужно затемнить
одну полоску справа. следовательно, на место последнего спрайта выводим
спрайт номер 2. Получаем: 333332. Дальше, нам нужно, чтобы были темными
последние две полоски. Следовательно, на место последнего спрайта
выводим спрайт номер 1: 333331. Следующий шаг, нужно, чтобы на экране
было темными три полоски. Для этого на место предпоследнего спрайта под
номером 1 выводим спрайт под номером 2. Получаем: 333321. И так далее...


Ну что ж, неплого, молодец! Снимаю шляпу перед твоей проницательностью,
читатель. А теперь, если позволишь, я перейду к изложению реализации так
мастерски угаданного тобою алгоритма.


Хотя выглядит данный алгоритм угрожающе громоздким, благодаря свойствам
двоичных чисел, программа реализации данного алгоритма, между тем,
весьма изящна. Заключается она в анализе последнего бита счетчика
текущего указателя показателя снарядов (или, что более проще,
разрядности показателя снарядов).

Переменная - указатель показателя снарядов является общей для двух
подпрограмм. Первая - инкрементирует указатель, вторая - декрементирует
его. Для реализации алгоритма, определим, что наши три спрайта хранятся
в памяти по адресам: sprite_number_1, sprite_number_2 и sprite_number_3.

Алгорим работы подпрограммы инкремента указателя показателя снарядов.
Берем текущее значение указателя. Инкрементируем его, бдительно следя
за тем, чтобы значение не превысило максимально возможного. Допустим,
получилось 6. Анализируем последний его битик. Если последний битик -
четный (0), то выводим спрайт, который находится по адресу
sprite_number_2, иначе (то есть при нечетном - 1 - битике) выводим
спрайт по адресу sprite_number_3. Требумые спрайты выводим в позицию,
смещенную относительно позиции начала показателя снарядов на
текущее значение указателя показателя снарядов.

Программа декремента работает аналогично. То есть, декрементируя текущее
значение указателя показателя снарядов, смотрим, чтобы не получилось
меньше ноля. После этого анализируем последний его (указателя) битик.
Если последний битик - четный (0), то выводим спрайт, который находится
по адресу sprite_number_1, иначе, выводим спрайт по адресу
sprite_number_2. И вычисляем нужную для вывода позицию, прибавляя
смещение относительно позиции начала показателя снарядов на текущее
значение указателя показателя снарядов.

Теперь то же самое, но на ассемблере. Итак,


increment_pointer_of_fireballs_viewer   proc near
        ;
        ;
        ;
        mov     al, ds:data_23e
        cmp     al, 0ch
        je      loc_ret_282
        inc     al
        mov     ah, al
        inc     al
        shr     al, 1
        mov     bx, 0a000h
        mov     es, bx
        mov     di, 88eh
        lea     si, ds:data_123e
        test    ah, 1
        jnz     loc_281
        lea     si, ds:data_124e
loc 281:
        xor     ah, ah
        add     di, ax
        jmp     short loc_285

loc_ret_282:
        ret
increment_pointer_of_fireballs_viewer   endp


decrement_pointer_of_fireballs_viewer   proc near
        ;
        ;
        mov     al, ds:data_23e
        cmp     al, 0
        je      loc_ret_284
        dec     byte ptr ds:data23e
        mov     ah, al
        inc     al
        shr     al, 1
        mov     bx, 0a000h
        mov     es, bx
        mov     di, 88eh
        lea     si, ds:data_123e
        test    ah, 1
        jz      loc_283
        lea     si, ds:data_122e
loc_283:
        xor     ah, ah
        add     di, ax
        jmp     short loc_285
loc_ret_284:
        ret
decrement_pointer_of_fireballs_viewer   endp


loc_285:
        mov     ah, 1
        call    sub_56
        mov     ah, 2
        call    sub_56
        mov     ah, 4
        call    sub_56
        mov     ah, 8
        call    sub_56
        ret
sub_55 endp


sub_56  proc near
        ;
        ;
        mov     dx, 3c4h
        mov     al, 2
        out     dx, al

        inc     dx
        mov     al, ah
        out     dx, al
        mov     bx, 10h
        push    si
        push    di
loc_286:
        movsb
        add     di, 27h
        dec     bx
        jnz     loc_286
        pop     di
        pop     si
        mov     bx, 10h
        push    di
        add     di, 2000h
loc_287:
        movsb
        add     di, 27h
        dec     bx
        jnz     loc_287
        pop     di
        ret
sub_56  endp





Использования спрайтов при работе с конструктором
            образа (спрайты в игре Prince of Percia)

Вспомним Поле Чудес. В следующей строке дано слово, термин, которым
называется механизм, использованный для реализации момента движения
принца в игрушке Prince of Percia.

        XXXXXXXXXX XXXXXXXXXXX XXXXXX

Я не буду предлагать вам идти на суперигру. Более того, я даже не стану
предлагать вам отгадывать буквы. Я просто скажу вам ответ:

        спрайтовый конструктор образа

А подаю я вам этот ответ так необычно, потому что хочу, чтобы вы не
только почитали об этом конструкторе, и не только понимали, в чем
заключается фокус (то есть, как внутри работает то, что так изумительно
выглядит снаружи), но и восхитились красотой и замысла и реализации
этой, поистине великолепной, игрушки!

Началось все с желания ощасливить главного героя игры - приделать
ему пионерский галстук. Как всегда, загрузил отладчик, обошел несколько
уровней предварительной защиты против взлома, заботливо расставленых
создателями игры, и стал вычислять место расположения спрайтов главного
героя. Как? Один из стандартных подходов тривиален. Зарисовываю героя по
точкам на бумаге в клеточку. Адаптер, на котором функционирует игра,
естественно, известен. По правилам этого адаптера формирую часть дампа
памяти, который будет соответствовать картинке. И с помощью команды
поиска строки, отыскиваю по оперативной памяти нужное место.

После этого делается "оживитель". Оживитель представляет собой маленькую
программу, позволяющую не выходя из отладчика, высвечивать некоторый
участок памяти как спрайт. Так вот, запускаю оживитель, и обнаруживаю,
что не нахожу ни одного изображения Принца в полный рост. Вместо этого:
руки, ноги, туловища, головы. Все - как в морге. Отслеживаю фрагмент
программы, который пользуется данными адресами: жуткая толпа переходов
туда-сюда. И только потихоньку начинается складываться полная картина.


Некоторый детали этого полотна приведу. Исходное изображение принца было
проанализировано мультипликатором, причем неплохим. И было разбито,
причем не только на фазы, как это делается обычно, но на детали набора
фаз (более подробно о деталях - учебник анатомии).

Даже если поверхносто проанализировать фазы, которые мы наблюдаем
при движении принца на экране (делается это следующим образом.
Нажимается команда управления движением (к примеру, влево, или вправо),
и нажимается клавиша Escape. Эта клавиша приостанавливает игру (пауза),
а поскольку проверка на нажатие Escape происходит после формирования
следующего кадра игры, и перед выдачей его на экран, то серия нажатий
клавиши Escape дает эффект замедленной съемки, позволяя сосредоточиться
на деталях фаз Принца), то насчитывается не менее полусотни фаз. А
полное число комбинаций, по расчетам, превышает несколько сотен. При
умножении места, занимаемого спрайтом Принца на адаптере EGA (для
конкретности) на количесто фаз, получаем число, превышающее объем
оперативной памяти в 640 К.


Вот эта нескладушка и натолкнула, вероятно, разработчика на ужасно
красивый выход из ситуации. Изображения Принца разбивается на три
плоскости: заднюю, среднюю и переднюю. Для каждой плоскости, по смыслу
формируется набор "деталей тела": для задней плоскости - задняя рука,
нога, для средней плоскости - ракурсы головы, верхней части туловища,
нижней части туловища, и т.д.

По результатам анализа всего множества фаз, формируется система
кодирования-конструирования полного изображения Принца, которая
привязывается к командно-двигательной части проекта игры. (То есть,
когда пользователь вводит команды, а игра корректно отрабатывает их.
Корректно, например, после того, как пользователь подошел к краю
пропасти, и перешел этот край, то игра отрабытывает падение по смыслу,
что бы пользователь дальше не нажымал). К сценариям движений Принца
(прыжок, приземление, поворот, выпад шпагой...) привязываются
коэффициенты инерции движения (задержки при поворотах, короткий шажечек
после длинного прыжка, если не был нажат shift, и т.п.).

        Что полезно заметить в данном месте, что эти же вопросы
        актуальны и в нашей игрушке, и потому будут рассмотрены нами
        полностью и комплексно (то есть с примерами и с рисунками) в
        главе vii Основной Цикл Игры, в параграфе Как двигается Капитан
        Комик.

Функция под названием Спрайтовый Конструктор Образа согласно сценарию
движения по коду-формуле полного изображения формируем изображение,
накладывая по AND-OR алгоритму последовательно детали планов, планы
Принца, получая на фоновом экране результат, который и предъявляется
зрителю.


Вот, в общем-то и все, но всмотритесь в экран! Какая пластика
движений!..


