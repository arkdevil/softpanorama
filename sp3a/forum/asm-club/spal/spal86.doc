




                СТРУКТУРНЫЙ АССЕМБЛЕР (SPAL)
                    для процессора 8086


    Структурный асссемблер (SPAL) представляет собой библиотеку макро-
    определений, с помощью которой можно легко реализовать основные
    конструкции структурного программирования. В библиотеку SPAL86
    входят следующие макроопределения :

             .AND      .OR       .BEGIN
             .IF       .ELSE     .ENDI
             .BREAK    .BREAK_IF
             .WHILE    .ENDW
             .DO       .ENDD
             .FOR      .ENDF
             .LOOP     .ENDL
             .SWITCH   .CASE     .DEFAULT   .ENDS
	     .POP      .PUSH
	     .CALL     .ENTER    .LEAVE

      Для трансляции программы, написанной на языке SPAL86, необходимо
   включить  в транслируемый модуль файл с библиотекой макрооопределений:

		    include SPAL86.INC


            ОСНОВНЫЕ ПОНЯТИЯ И ОБОЗНАЧЕНИЯ


	 1. Операнд.
	 ------------
     Операнды языка SPAL86 ничем не отличаются от операндов языка MASM.
   Необходимо помнить только, что если внутри операнда встречаются
   разделители (пробел, запятая и т.д.), его необходимо взять в угловые
   скобки <>.

	 Примеры операндов языка SPAL86 :
	    bx    - операнд в регистре  bx
	    5                      - непосредственное значение операнда  5
	    idn                    - операнд в ячейке памяти
	    <offset s_tab>         - смещение адреса s_tab
	    <word ptr es:[si]>     - словный операнд по адресу es:si

	2.  Логическая операция.
	-------------------------
     Набор логических операций отвечает возможностям процессора 8086.
   Логические операции могут быть трех типов :
	    - битовые операции
	    - операции сравнения
	    - операции с флагами

	 Битовые операции:
	-------------------------------
	    - ON   маска, заданная операндом 1 присутствует в
		   операнде 2.
	    - OFF  маска, заданная операндом 1 отсутствует в
		   операнде 2.

	   <Лог_Опер_Бит> = <ON | OFF>

     Когда битовая логическая операция встречается в логическом выражении,
   генерируется команда  test.


	 Операции сравнения и операции с флагами
	------------------------------------------

     Эти операции имеют одинаковую мнемонику и отличаются количеством
   операндов в логическом выражении :

	1 операнд        -  операция с флагами
	2 или 3 операнда -  операция сравнения

     Когда логическая операция интерпретируется как операция сравнения,
   генерируется команда cmp;
     когда логическая операция интерпретируется как операция с флагами
   никакой команды установки флагов не генерируется.

                 <Лог_Опер_Срав> = <Лог_Опер_Флаг> =

         <A  | NBE | AE | NB  | B  | NAE | BE | NA | C  | E  | Z  | G  | NLE
          GE | NL  | L  | NGE | LE | NG  | NC | NE | NZ | NO | NP | PO | NS
          O  | P   | PE | S   | CXZ| CXNZ
         >

          3.  Логическое выражение.
          --------------------------
           В зависимости от количества операндов логическое выражение имеет
         следующий вид:


               -  0 операндов:
              -----------------
                     <Лог_Выр>  =  <Лог_Опер_Флаг>
                  Логическая операция может быть только операцией с фла-
               гами. В зтом случае логические команды не генерируются,гене-
               рируется только команда перехода.

                  Например :
		       A       -  (CF or ZF) = 0
		       NO      -  OF = 0
		       O       -  OF = 1


               -  1 операнд :
              ----------------
                     <Лог_Выр>  =  <Опер  Лог_Опер_Срав>

                  Логическая операция может быть только операцией сравне-
               ния, а в качестве 2-го операнда подразумевается 0. В зтом
               случае генерируется команда
				 or  <Опер>, <Опер>
	       и соответствующая команда условного перехода.
		 Операндом в таком выражении может быть только регистр.

                  Например :
             ax  E                  - содержимое регистра ax равно 0
	     di  NE                 - содержимое регистра di не равно 0
	     bx  A                  - содержимое регистра bx выше 0


               -  2 операнда :
              -----------------
               <Лог_Выр>  =  <Опер1  Лог_Опер_Бит|Лог_Опер_Срав  Опер2>

                  Логическая операция может быть как битовой, так и опера-
               цией сравнения. Если логическая операция является операцией
               с битами, генерируется команда
				test  <Опер2>, <Опер1>
               и соответствующая команда условного перехода.
               Если логическая операция является операцией сравнения, гене-
               рируется команда
				 cmp  <Опер1>, <Опер2>
               и соответствующая команда условного перехода.

                  Например:
	      1  ON  bx               - бит 0 установлен в регистре bx
	      ax OFF idn              - биты, установленные в регистре ax,
                                        отсутствуют в ячейке idn
	      <offset s_tab> A 64000  - смещение адреса таблицы s_tab выше
                                        64000


       Данная таблица раскрывает смысл операций с флагами и операций срав-
   нения в логических выражениях :
  ________________________________________________________________________
 !           !                           !  Смысл операции сравнения :    !
 ! Код опер. !   Состояние флагов        !    Опер 1 ....  Опер2 (или 0)  !
 !___________!___________________________!________________________________!
 !           !                           !                                !
 !  A/NBE    !     (CF or  ZF) = 0       !  выше/не ниже и не равно       !
 !___________!___________________________!________________________________!
 !           !                           !                                !
 !  AE/NB    !          CF = 0           !  выше или равно/не ниже        !
 !___________!___________________________!________________________________!
 !           !                           !                                !
 !  B/NAE    !          CF = 1           !  ниже/не выше и не равно       !
 !___________!___________________________!________________________________!
 !           !                           !                                !
 !  BE/NA    !     (CF or ZF) = 1        !  ниже или равно/не выше        !
 !___________!___________________________!________________________________!
 !           !                           !                                !
 !  C        !          CF = 1           !          --------------        !
 !___________!___________________________!________________________________!
 !           !                           !                                !
 ! E/EQ/Z    !          ZF = 1           !           равен                !
 !___________!___________________________!________________________________!
 !           !                           !                                !
 ! G/GT/NLE  ! ((SF xor OF) or ZF) = 0   !  больше/не меньше и не равно   !
 !___________!___________________________!________________________________!
 !           !                           !                                !
 !  GE/NL    !      (SF xor OF) = 0      !  больше или равно/не меньше    !
 !___________!___________________________!________________________________!
 !           !                           !                                !
 ! L/LT/NGE  !      (SF xor OF) = 1      !  меньше/не больше и не равно   !
 !___________!___________________________!________________________________!
 !           !                           !                                !
 !  LE/NG    ! ((SF xor OF) or ZF) = 1   !  меньше или равно/не больше    !
 !___________!___________________________!________________________________!
 !           !                           !                                !
 !  NC       !         CF = 0            !          --------------        !
 !___________!___________________________!________________________________!
 !           !                           !                                !
 !  NE/NZ    !         ZF = 0            !           не равен             !
 !___________!___________________________!________________________________!
 !           !                           !                                !
 !  NO       !         OF = 0            !          --------------        !
 !___________!___________________________!________________________________!
 !           !                           !                                !
 !  NP/PO    !         PF = 0            !          --------------        !
 !___________!___________________________!________________________________!
 !           !                           !                                !
 !  NS       !         SF = 0            !          --------------        !
 !___________!___________________________!________________________________!
 !           !                           !                                !
 !  O        !         OF = 1            !          --------------        !
 !___________!___________________________!________________________________!
 !           !                           !                                !
 !  P/PE     !         PF = 1            !          --------------                      !
 !___________!___________________________!________________________________!
 !           !                           !                                !
 !  S        !         SF = 1            !          --------------        !
 !___________!___________________________!________________________________!
 !           !                           !                                !
 !  CXZ      !                           !     Регистр CX равен 0         !
 !___________!___________________________!________________________________!
 !           !                           !                                !
 !  CXNZ     !                           !     Регистр CX не равен 0      !
 !___________!___________________________!________________________________!


                                      Примечание :
                                         1. Термины "выше" и "ниже" применимы
                                            для сравнения беззнаковых величин
                                            (адресов).
                                         2. Термины "больше" и "меньше" ис-
                                            пользуются при учете знака числа.
                                         3. Слова xor и or обозначают соответ-
                                            ствующие логические операции.



            ОПЕРАТОРЫ СТРУКТУРНОГО АССЕМБЛЕРА


        Операторы и параметры, указанные в квадратных скобках, могут
     отсутствовать.

     1. Условный оператор .IF
     -------------------------

          .IF   <Лог_Выр>
        [ .OR   <Лог_Выр> ]
        [ .AND  <Лог_Выр> ]
          .BEGIN [L]

            ...................

        [ .ELSE [L] ]

            ...................

          .ENDI

       Параметр L  в операторах .BEGIN и .ELSE необходим для генерации длин-
     ных переходов в том случае, когда размер блока команд больше 128 байт.
     Если зтот параметр не указан и размер блока больше 128 байт, транслятор
     MASM  выдаст сообщение об ошибке.

       Примеры:

         .IF ax E           ;если значение ax равно 0
         .OR ax E 1         ;или значение ax равно 1
         .BEGIN             ;то
            mov  bx,  10    ;загрузить в bx значение 10
         .ELSE              ;иначе
            mov  bx,  20    ;загрузить в bx значение 20
         .ENDI              ;конец оператора .IF

         .IF   1  ON  bx    ;если бит 0 в регистре bx установлен
         .AND  bx E   cx    ;и регистр bx равен регистру cx
         .BEGIN             ;то
             add  cnt, 2    ;увеличить ячейку cnt на 2
         .ENDI              ;конец оператора .IF


	 2.1. Дополнительный оператор .$IF
       -------------------------------------

	 .$IF  <<Лог_Выр>>,<<Инструкция1>>,<<Инструкция2>>

	Если логическое выражение имеет значение ИСТИНА, выполняется
     Инструкция1;
	Если логическое выражение имеет значение ЛОЖЬ и Инструкция2
     задана, выполняется Инструкция2.

	Примеры:

   .$IF  <ax EQ 1>, <mov  bx,  5>, <mov  bx,  6> ;Если ax равен 1
						 ;записать в bx 5;
						 ;иначе
						 ;записать в bx 6

   .&IF  <idn GE bx>, <mov   idn,  0>   ;если idn больше или равно bx,
					;записать в idn  0



     2. Операторы выхода из цикла .BREAK и .BREAK_IF
     ------------------------------------------------

        Операторы выхода прерывают выполнение самого ближнего к этим опе-
     раторам цикла, который может быть любым из допустимых в языке SPAL86
     циклов. А именно :

            .WHILE  ------ .ENDW
            .DO     ------ .ENDD
            .FOR    ------ .ENDF
            .LOOP   ------ .ENDL

        Оператор .BREAK осуществляет безусловный выход из ближайшего цикла и
     имеет следующщий вид :

             .BREAK
                      или
             .BREAK L

     Параметр L необходимо указывать для генерации длинного перехода. В про-
     тивном случае транслятор выдаст сообщение об ошибке.
        Оператор .BREAK_IF имеет следующий вид:

             .BREAK_IF  <Лог_Выр>

     Если значение логического выражение истинно - выполняется выход из
     ближайшего цикла, если ложно - выполнение цикла продолжается. Оператор
     .BREAK_IF генерирует только короткие переходы. Для генерации длинного
     перехода или когда количество логических условий больше одного
     необходимо использовать следующую конструкцию :

                        .IF  <Лог_Выр>
                       [.OR  <Лог_Выр> ]
                       [.AND <Лог_Выр> ]
                        .BEGIN
                           .BREAK [L]
                        .ENDI



     3. Оператор цикла .WHILE
     ------------------------

        .WHILE  <Лог_Выр>
      [ .OR     <Лог_Выр> ]
      [ .AND    <Лог_Выр> ]
        .BEGIN [L]

          .....................

         [ .BREAK [L] ]
         [ .BREAK_IF <Лог_Выр> ]

          .....................

        .ENDW

      Параметр L в операторе .BEGIN необходимо указывать, когда тело цикла
    больше 128 байт. В зтом случае генерируется длинный переход. По умолча-
    нию генерируется короткий переход. Если размер тела цикла больше 128 байт
    и параметр L не указан, транслятор MASM выдаст сообщение об ошибке.

        Примеры :

         mov  cx,  0            ;  цикл повторяется пока bx не станет
         .WHILE  bx  NE         ;  равным 0 , но не более 100 раз
         .BEGIN
	   .IF cx E 100
	   .BEGIN
	     .BREAK
	   .ENDI
	   dec  bx
	   inc  cx
         .ENDW

         С использованием оператора .BREAK_IF этот пример
      выглядит следующим образом :

         mov  cx,  0
         .WHILE bx NE
         .BEGIN
	   .BREAK_IF cx E 100
	   dec  bx
	   inc  cx
         .ENDW

         Другой вариант реализации этого цикла :

         mov  cx,  0
         .WHILE bx NE
         .AND   cx NE 100
         .BEGIN
            dec  bx
            inc  cx
         .ENDW



     4.  Оператор цикла DO
     ---------------------

        .DO

          .................

         [ .BREAK [L] ]
         [ .BREAK_IF <Лог_Выр> ]

          .................

        .WHILE  <Лог_Выр>
      [ .OR     <Лог_Выр> ]
      [ .AND    <Лог_Выр> ]
        .ENDD

        Примеры :

          mov  cx,  0
          .DO
            dec  bx
            inc  cx
            .IF  cx E 100
            .BEGIN
               .BREAK
            .ENDI
          .WHILE bx NE
          .ENDD

        С использованием оператора .BREAK_IF этот пример выглядит
     следующим образом :

          mov  cx,  0
          .DO
             dec  bx
             inc  cx
             .BREAK_IF  cx E 100
          .WHILE  bx NE
          .ENDD

        Другой вариант реализации этого цикла :

          mov  cx,  0
          .DO
             dec  bx
             inc  cx
          .WHILE  bx NE
          .AND    cx NE 100
          .ENDD



     5. Оператор цикла .FOR
     -----------------------

             <счетчик>     = <Опер>
             <количество>  = <Опер>

        .FOR   <счетчик> [,<количество>]
        .BEGIN [L]

           .................

         [ .BREAK [L] ]
         [ .BREAK_IF <Лог_Выр> ]

           .................

        .ENDF

        В поле <счетчик> указывается переменная, которая используеся опера-
     тором .FOR для счетчика повторов. При нормальном выходе из цикла значе-
     ние этой переменной равно -1. В поле <количество> задается количество
     повторов. Если это поле не определено, считается что счетчик уже
     установлен ранее.

         Примеры :

	     mov   ax,  0
	     mov   bx,  0
	     .FOR  cx, 100     ;В 100 байт памяти записываетя 0
             .BEGIN
		mov  [bx+addr], ax
		inc  bx
             .ENDF

        Другой вариант реализации :

	     mov   ax,  0
	     mov   bx,  0
	     mov   cx,  100
	     .FOR  cx,          ;В 100 байт памяти записываетя 0
             .BEGIN
		mov  [bx+addr], ax
		inc  bx
             .ENDF



     6.  Оператор цикла .LOOP
     ------------------------

         .LOOP

           .................

          [ .BREAK [L] ]
          [ .BREAK_IF <Лог_Выр> ]

           .................

         .ENDL

       Операторы  LOOP ... ENDL  реализуют бесконечный цикл, выход из
     которого возможен только с помощью операторов .BREAK или .BREAK_IF .

         Примеры :

            .LOOP                             ; Бесконечный цикл
            call get_command
            call do_op
            .ENDL


	    mov  cx,100
            .LOOP                             ; Цикл выполнится 100 раз
	      .BREAK_IF  cx EQ
	      dec  cx
            .ENDL

      Так как регистр CX часто используется как счетчик,в языке SPAL
    предусмотрены условия CXZ и CXNZ.
      Условие CXZ (Равенство CX нулю) особенно эффективно в операторе
   .BREAK_IF.
      Более эффективная реализация примера:

	     mov  cx,  100
             .LOOP
                .BREAK_IF CXZ
		dec  cx
             .ENDL




     7.  Оператор выбора .SWITCH
     ----------------------------

                <переменная_выбора>      = <Опер>
		<конст1> = ... <конст5>  = <Опер>
		<тип_оператора>          = <SB | SW | LB | LW>

	 .SWITCH <тип_оператора>,<переменная_выбора>
         .СASE   <конст_1>,[<конст_2>,<конст_3>,<конст_4>,<конст_5>]

                .............................

         .СASE   <конст_1>,[<конст_2>,<конст_3>,<конст_4>,<конст_5>]

                .............................

         .СASE   <конст_1>,[<конст_2>,<конст_3>,<конст_4>,<конст_5>]

                .............................

         ....................................
         ....................................

       [ .DEFAULT ]

                .............................

         .ENDS



	 Возможные значения параметра <тип_оператора> : SB,SW,LB,LW.
     Первая буква определяет размер команд перехода внутри оператора .SWITCH:
	S  -  короткие переходы;
	L  -  длинные переходы;
     Вторая буква определяет размерность переменной выбора :
	B  -  байт;
	W  -  слово;

	 !!! Внимание !!! Оператор .SWITCH использует регистр ax в том случае,
     когда переменная выбора является словом (тип оператора SW или LW);
     и регистр al - когда байтом (тип оператора SB или LB).
	 Если параметр <переменная_выбора> не указан, считается, что его
     значение уже находится в регистре ax или al соотвественно типу оперaтора.


        Пример :

	     .SWITCH  SB, bl
             .CASE    0,1
		 mov cx,bx
		 call fun1
             .CASE    2,3
		 mov cx,bx
		 call fun2
             .DEFAULT
		 call err
             .ENDS



     8.  Оператор сохранения регистров в стеке и восстановление из
	 стека  .PUSH  .POP
     --------------------------------------------------------------

     .PUSH    <Опер1>,<Опер2>,...,<Опер10>

              .............

     .POP     <Опер1>,<Опер2>,...,<Опер10>

       Максимальное количество операндов в операторах .PUSH/.POP
     равно 10.
       В операторе .PUSH генерируются команды
		   push <Опер>
     по количеству операндов и в том же порядке, в котором операнды указаны.
       В операторе .POP  генерируются команды
		   pop <Опер>
     по количеству операндов и в обратном порядке.

        Пример :

	  .PUSH ax, bx
	  mov   ax,  0
	  .FOR  bx,100
          .BEGIN
             ......
          .ENDF
	  .POP  ax, bx




      9.  Оператор вызова процедур  .CALL
      --------------------------------------

      .CALL   name, <Опер1>,<Опер2>,...,<Опер10>

	Записывает параметры в стек в обратном порядке, вызывает указанную
     процедуру. Максимальное количество параметров равно 10.
	Правила передачи параметров в операторе .CALL соответствуют правилам
     языка C.

      Например:

	   .CALL  name  bx, atr2, dx




     10.  Операторы входа в процедуру и выхода из нее  .ENTER\.LEAVE
     ------------------------------------------------------------------

       .ENTER [<размер области локальных переменных>]

     Генерирует следующий код:

	  push  bp
	  mov   bp,  sp
	  если задана область локальных переменных,
	  то
	     sub  sp, <размер области локальных переменных>



       .LEAVE

     Генерирует  следующий код:

	  если задана область локальных переменных в операторе .ENTER,
	  то
	    mov  sp, bp
	  pop  bp



-----------------------------------------------------------------------------



 В качестве более полного примера,наглядно демонстрирующего стиль SPAL
 приводится следующая процедура:
;--------------------------------------------------------------------
; Процедура удаления конечных пробелов из строки и замена
; всех строчных букв на прописные.
;
;     Вызов процедуры  .CALL  rem_blank, "адрес строки","длина строки"
;
; Возвращает ax = -1 - Строка состоит из одних пробелов
;            al > 0  - Реальная длина строки
;--------------------------------------------------------------------
rem_blank  PROC
	   ARG  adr_str, len_str
	   .ENTER
	   .PUSH si
	   mov  si, adr_str
	   mov  ax, len_str
           add si,ax
	   inc ax
	   .WHILE <byte ptr [si]> EQ ' '
	   .AND   ax  GT
	   .BEGIN
	     dec si                    ; Удаление конечных пробелов
	     dec ax
	   .ENDW
	   .IF ax EQ
           .BEGIN
	     mov ax,-1                 ; Строка из одних пробелов
           .ELSE
	     .PUSH ax
	     .FOR ax
	     .BEGIN
	       .IF  <byte ptr [si]> GE 65
	       .AND <byte ptr [si]> LE 90
	       .BEGIN
		 add byte ptr [si],32   ; Преобразование в строчные буквы
	       .ENDI
		dec  si
	     .ENDF
	     .POP ax
           .ENDI
	   .POP  si
	   .LEAVE
	   ret
rem_blank  ENDP

