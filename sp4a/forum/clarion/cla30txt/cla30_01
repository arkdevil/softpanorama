Фирма ИНСАЙТ*INSIGHT Comp.  -  Официальный Дилер CLARION Software Corp.
103460, Москва, Зеленоград, Панфиловский проспект, корп. 1205
	т. 532-29-43, (531-82-30)       факс    531-18-94
	E-Mail: puh@pczz.msk.su         Fido:   2:5020/11.2
-----------------------------------------------------------------------

                Clarion Developers Conference
                       Technical Notes

                         Bill Mueller

   The Developers  Conference was  centered around  giving the
attendees an overview of the all new Clarion 3.O. As such, the
tone of the conference was not to give nitty-gritty details of
new usage.  Nevertheless, one  received a fairly good feel for
how things  are to be. even if not the exact implementation. I
will present  the information  fairly rapid-fire,  without too
many details, to give you an overview of the changes. So, with
that in mind, let's take a tour of some of the highlights.

   First some  size and  speed figures.  For a  minimal  sized
program (i.e.,  display "Hello  World"), the  distributed run-
time code  size would  be (please do not confuse minimal sized
program with  what size  you can  expect for a normal business
application):
          Clarion:       10k
          Clipper:       141k
          FoxPro:        656k
          Paradox:       1,515k

   

   The timing of a Sieve of Eratosthenes in seconds:
          Clarion:        6.2 Secs
          Clipper:        10 min, 34 sec
          FoxPro:         16 min, 10 sec
          Paradox:        Over 6 hours
          Turbo C++:      10.3 secs
   

   Transactions performed over a network per second:

          Clarion:       25.5
          Clipper:       8.0
          FoxPro:        6.4

   Clarion 3.0  introduces some  new data  types,  mostly  for
compatibility will  different file  managers and  for  calling
foreign functions.  The new  data  types  include:  DATE,TIME,
FLOAT (formats unknown to me), USHORT, ULONG (unsigned short &
long),   CSTRING    (compatibility   with   C)   and   PSTRING
(compatibility with Pascal).

   The CASE  structure will  allow a range in the OF statement
(i.e. CASE  Variable: OF 1 TO 5.). LOOPs will now operate very
quickly (Clarion pre-3.O had a very slow looping construct).

   The MAP  will look  quite a  bit different.  Because of new
memory management  features in  the TopSpeed  environment, the
AREA  and   OVERLAY  statements  are  a  thing  of  the  past.
Func/Proc's are declared as prototypes (C-like, something like
"MyFunc(SHORT,*REAL),REAL"). Within  the Func/Proc, parameters
are not  declared, since  the data  type is already known. The
EXTERNAL statement  is eliminated;  the pointer to an external
variable is noted by the "*" in the above MAP statement.

   Implicit file  opens will  no  longer  happen  -  one  must
explicitly OPEN  or SHARE  a file.  Using a  data file  access
command without opening the file will return an error.
   In the  area of  screens and  video, there  are  masses  of
detail changes  to support  various stuff  mostly in line with
CUA/SAA compliance.  The screen may be resized at any time for
a different amount of rows (i.e., 25, 43. 50).

   Image  fields   can  display   PCX  images   which  can  be
dynamically resized.  The new  screen  effects  (when  opening
screens) include: Zoom, Fade, Wipe and Fall. New SAA/CUA field
types include:  Radio Buttons,  Check Boxes,  List  Boxes  and
Pushbuttons.

   In a  slight clarification  to  the  CTJ  article,  Clarion
Professional Developer  3.0 Highlights, the of screen can be a
maximum of  256 rows  OR 256 columns. The total space that can
be used  by the virtual screen is 64k and is determined by the
formula of:  Rows *  Cols *  2 <=  64k. The 2 represents the 2
bytes needed  at each position for character and video values.
So the largest practical box is about 180 rows by 180 columns.

   Forward referencing  of variables  is no  longer supported.
Any local  variables used  in screens  (or  reports)  must  be
declared prior  to the  screen  (or  report).  The  conversion
utilities to  be provided will handle this change for you, but
there is no time like the present to change your work habits.

   Local variables  are now stack based, rather that static in
nature. The  practical  effect  of  this  (other  than  memory
savings) is  that variables  will always  be cleared  (" or 0)
when the  Proc/Func is  entered. And, you may now do recursion
(if you are so inclined).

   AND and  OR evaluation  is optimized  - known  as  shortcut
evaluation. What this means is that as soon as the result of a
logical expression  are  determined,  then  the  rest  of  the
expression is  not evaluated. If you have developed a habit of
setting some  values in the expression (usually through a call
to a  function), you will to change that habit since that part
of the  expression may  not be  reached if  prior  expressions
forced the total expression into a true or false state.

   The improvements  in report  options are  many and  varied,
allowing much more flexibility in this area. New features here
include such  things as  a length  attribute, text  fields for
memos, suppressing  blank lines  (Suppress), printing a detail
on a  page by  itself (Alone),  appending  to  another  report
(Append), blank  lines before  printing structure  (Separate),
how many  lines must  print at  bottom  before  a  page  break
(Allow), and number of lines to print for a structure (Fixed).
Attribute we  are accustomed  to using  in other  context  are
allowed in  reports: LFT,  RHT, CENT,  UPR, LWR, CAP, CLIP and
WRAP. There  is also logical printer support. And yes, reports
will now  put out the industry standard 0D0A (CR/LF) at end of
the line.

   During the  link step,  you will  have a  choice  of  three
methods: Static  (straight EXE with no overlays or DLL usage),
Overlays (allocated dynamically at runtime, I assume much like
LPM's Virtual  Linker or  WarpLink do  now)  or  Dynamic  Link
Libraries for the highest degree of flexibility.

   Of course  I just  can't resist making a comment  about the
new Application  Generator  (Designer)  and  Template  (Model)
files within  Clarion 3.0.  To put it into a nutshell - I like
it. For  us "old  time hand coders" who have an inclination to
do things  our way  instead of somebody else's way. I do think
that Clarion  Software has  given us  the tools  we have  been
asking for  in order  to have  full and complete access to the
language while  programming the Template files and while using
the Application  Generator. Outstanding. And this has a direct
benefit to  the Designer-user  crowd. I  suspect that, besides
the improved  models available from third-party vendors, there
will  also  be  other  people  getting  involved  in  Template
programming to bring fresh ideas and techniques to the Clarion
community.

                        Keeping a Secret?
                         Alan Frayer.
                               

   In  his   seminar  during   the  1991   Clarion  Developers
Conference, Will Fastie, senior analyst for investment banking
firm Alex  Brown &  Sons and  former editor  of  the  PC  Tech
Journal,  presented   an  industry   perspective  on   Clarion
Professional Developer, both past and present. His points were
both  insightful   and  objective,  and  illustrate  Clarion's
position in  the industry,  something  which  many  developers
don't consider.

   Business people  don't first  buy programming languages and
then look  for applications to develop. Instead they determine
they have  a specific  need, then  look for a way to fill that
need. This search hasn't always been easy.

   To reasons  why choosing  a method  to  create  a  business
application used  to be  so difficult  stated Fastie, would be
the lack  of a truly business-application oriented programming
language, and  the difficulty in using the available languages
to create an application.
   Fastie once  surveyed readers  of the  PC Tech  Journal and
discovered, while  the programmers  thought  C  was  the  most
important language,  the majority  of them  didn't  use  C  to
develop applications... they used database management systems.
The reason  of this  is simple.  The closer the language is to
describing the  business problem,  the faster  and more easily
the problem  can be  solved. Languages  such as C, Pascal, and
Basic are  far removed  from the  problem,  and  require  many
additional steps  just to  reach the  problem.  The  increased
number of steps also increases the likelihood of error.

   Language publishers  have  tried  to  address  what  Fastie
referred to  as the tedium of conventional languages. Products
such as  Turbo Pascal  offer  integrated  environments  in  an
attempt to  automate some  of the  more tedious  tasks. But to
this date,  most of  these products have failed to incorporate
enough integration to make up for the effort required to write
code in  conventional languages, and does nothing to bring the
language closer to the business problem.

   On the  other hand,  database languages,  because of  their
limitations are  easier to  learn and  require fewer  steps to
address the  problem. Database  applications tend  to be  less
error prone  and the  programming  environments  often  better
integrated then that of conventional languages.

   Fastie said  the biggest  advantage of  database  languages
over conventional  languages, however, was record abstraction.
Record  abstraction   allows  data   records  be   treated  as
individual items  instead of components. Record could be acted
on, and  the details  associated with  the  records,  such  as
pointers, would  be handled  automatically. Abstraction allows
records their own data type.
   The limitations  of database  languages also  work  against
them. While  it is  simple to  create a phone book application
with a  product like  dBase,  a  phone  dialer  is  much  more
complex, if  not impossible,  due to  the limitations  of  the
language. Fastie  also  takes  exception  to  claims  by  most
database publishers  of integrated  tools. While the tools may
work better  than those  in conventional languages, they still
perform as  stand alone  tools, and  frequently the best tools
for the  job have  to be  added  after  the  purchase  of  the
database product.

   Bruce Barrington  addressed these  issues when  he and  his
team  first   created  Clarion.   Version  1.0   was   written
SPECIFICALLY for solving business problems, and contained data
types appropriate for such applications, unlike just about any
other  conventional  programming  language.  It  offered  some
degree of  integration to relieve tedium, but more importantly
the language supported integration. Barrington planned for the
language and the environment to work together and it showed as
early as  1.0   This integration was more effective than other
solutions offered at that time.

   With the  release of Clarion 2.0 (which included Designer),
the entire  program was  abstracted, not  just the  record and
other data  types. The  developer could  set specifications in
Designer, and  Designer would  create the entire program, from
start to  finish. No  other language  offered that  degree  of
abstraction. Tedium was virtually eliminated, as it applied to
standard coding  (instead we  speak of  the tedium  of drawing
screens, which  most of  us would prefer over tedious coding).
Designer  was   the  first   application  generator   directly
integrated  into  the  environment  and  the  most  completely
integrated. Designer-generated  code satisfies  the compiler's
demand for  accuracy, as  well as  the programmer's demand for
usability.

   Designer is  as restrictive  as you need. If you need heavy
restriction, as  a new  programmer you  can have it by leaving
everything as it is shipped. If you need more freedom, you can
edit your  generated code,  and for  even more freedom you can
edit the model files. Clarion 3.0 will even be more flexible.

   One of  Fastie's more  notable remarks was that he does not
consider Clarion  a database  product  -  he  considers  it  a
programming language  with data  types for  records and files.
Clarion 3.0  will make  his case  even stronger. He blames the
inclusion of record abstractions for the general definition of
database  products,   yet  notes   Cobol  also  offers  record
abstraction  and  is  not  considered  a  database.  The  code
generators in  Clarion (2.0  -  3.0)  encourage  the  database
appearance yet  the language  does not  limit  application  to
database programming.

   Clarion   Professional   Developer   is   an   application-
development tool  and language.  The abilities described allow
you to  produce an  application in less time than with another
language, which  saves you  money The abilities described also
reduce  the  chance  of  error,  which  reduces  the  cost  of
development.

   Fastie admitted  that Clarion  isn't perfect.  He  imparted
upon us  a mission to keep Clarion Software on its toes, since
through pressure  from users  improvements are  made.  If  you
don't like  something about  the product,  Fastie urges you to
let Clarion  know, and  keep doing so. In this manner, Clarion
shall grow closer to ideal.

   

   Attendees' Reactions

   Brian Blackledge

   

   During the  past few  years I  have had  the opportunity to
attended several  developer's conferences-ranging  from  small
PC-related programing conferences to the extravagant Macintosh
database conferences  hailed by  the Mac  community as "super-
conference". However, none of these gatherings created as much
excitement and  offered as much promise to developers and end-
users as Clarion's first developers conference.

   Daily workshops covering the new features of 3.0 were often
standing-room only.  Developers, viewing incomplete, but quite
functional Clarion  tools and  applications,  were  amazed  by
Clarion's new  virtual/graphics screen  support, the  stunning
speed  of   compiled  EXE's  and  3.0's  gamut  of  integrated
development tools. The typical developer's response to Version
3.0 sounded something like this:
- If 3.0 had been around 6 month months ago, I could have ...
- When 3.0 ships, I can't wait to develop ...

   It's clear  that for  Clarion developers Version 3.0 is the
long-awaited  product  of  possibilities.  It  stimulated  the
imagination of  all who witnessed its power and functionality.
If the  success of  the conference  could be  measured by  the
excitement generated  by this  product alone,  then  Clarion's
first developers conference was a resounding success and truly
did live up to its billing as the Clarion event of the year!

   It's also  clear that  the ramifications  of the conference
extend  far   beyond  its   original  scope  and  intent.  The
relationship between  Clarion Software and its loyal following
of developers  can and never will be the same again. A new era
has emerged  almost overnight  - an  awakening. For  the first
time the  two parties  have met  and shared face-to-face their
development goals,  dreams and expectations of Clarion 3.0 and
beyond. For  the first  time we  both captured  a  short,  but
meaningful glimpse  of each  other at  work and  at play - far
away from  the sometimes cold and impersonal nature of a phone
conversation or  a casual BBS exchange. Perhaps, in many ways,
this   newly    established   relationship    presents    more
possibilities than 3.0 itself.
