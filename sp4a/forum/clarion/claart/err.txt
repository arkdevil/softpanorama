Фирма ИНСАЙТ*INSIGHT Comp. - Официальный Дистрибутор CLARION Software Corp.
      103460, Москва, Зеленоград, Панфиловский проспект, корп. 1205
	   т. 532-29-43, (531-82-30)       факс    531-18-94
	   E-Mail: puh@pczz.msk.su         Fido:   2:5020/11.2
---------------------------------------------------------------------

        Некорректные и ошибочные ситуации.

        Если программа работает верно, значит, ошибки в ней еще не 
выялены! 

        В процессе собственного почти четырехлетнего программирования в 
среде Сlarion Professional, кроме достоинств (их так много, что даже 
перечислять их бессмысленно), были выявлены и недостатки пакета, 
некорректные и просто ошибочные ситуации, а в большинстве случаев и 
способы эффективной борьбы с ними.  Эти способы представляют собой 
такие же трюки, как и другие нестандартные приемы, описываемые в этой 
книге. 

        Читатель, если Вам известно о каких-то еще ситуациях, которые 
можно трактовать, как ошибки в среде Сlarion Professional,- сообщите о 
них нам! Мы доведем эту информацию до сведения Сlarion Software.

        Все ситуации , о которых здесь пойдет речь, если в тексте не 
указано иное, были выявлены под IBM DOS 5.0, тестировался Сlarion 
Version 2.1 release 218A.

        1. MEMO-поля, содержащие нетекстовую информацию (PCX-картинки, 
например), портятся при чтении.

        Как, по-видимому, известно читателю, MEMO-поля хранятся на 
диске порциями по 252 байта. Независимо от реального количества 
непробельных символов в MEMO-поле на диске будет сохранено целое число 
таких порций по 252 байта каждая или ни одной порции в частном случае 
пустого MEMO-поля.

        Ситуация состоит в том, что все символы <0>, завершающие
252-байтный блок MEMO-поля( если они там есть), заменяются на
пробелы (<32>). Причем, происходит это при чтении MEMO-поля, а не при
его записи - на диске все нормально. Иными словами, если длина
MEMO-поля превышает 252 байта, а 250-252 его символы - '<0,0,0>', -
после чтения этой записи они получат значение '<32,32,32>'. Предельный 
случай этой ситуации, когда все 252 байта состоят из одних символов 
<0>. В этом случае после чтения все (!) они заменятся на пробелы...

        Все подробности и доказательство в следующей ниже программе.
Смотри файлы before и after, генерируемые ею, но обязательно
шестнадцатиричным вьюером, например Scanner-ом.

**********************************************************************
Test	     Program

!  Из результатов работы этой программы можно заключить,
! что в КАЖДОМ 252-байтовом блоке мемо-поля CLARION заменяет
! КОНЕЧНЫЕ нули на пробелы

Data	     File,Pre(Dat),Create,Reclaim
By_key	       Key(Dat:Key),Nocase,Opt
Text	       Memo(20000)
Record	       Record
Key		 Byte
	     . .
	     Group,over(Dat:Text)
Dat_Memo_row   byte,Dim(20000)
	     .
file	  dos,pre(dos),name(filename)
record	  record
b	  byte,dim(20000)
	  ..
filename  string(10)


	     EJECT('CODE SECTION')
  CODE
  SETHUE(7,0)
  BLANK
  open(data)
  if error() then create(data).
  SETHUE()

  CLEAR(dat_memo_row[])
  dat_memo_row[100]=49	      ! '1'
  dat_memo_row[200]=50	      ! '2'
  dat_memo_row[300]=51	      ! '3'
  dat_memo_row[20000]=52      ! '4'

  filename='before'
  create(file)
  dos:record=dat:text
  put(file)
  close(file)

  dat:key=01 ;
  add(data)
  get(data,By_key)

  filename='after'
  create(file)
  dos:record=dat:text
  put(file)
  close(file)

**********************************************************************

        Как мы боремся с этой ситуацией?

        К сожалению, на уровне Clarion - программы удовлетворительного 
способа обойти эту ошибку найти не удалось. Применяемое нами и 
рекомендуемое пользователям решение: использовать написанный нами LEM 
"Сжатие". Помимо своей основной функции - сжимать информацию в 
memo-полях или перед их загрузкой из файлов - этот LEM, зная об 
имеющейся ошибке, никогда не помещает символ <0> в memo, заменяя его на 
последовательности <1,1>, а символ <1> соответсвенно на <1,2>. Кстати, 
занимая всего порядка 6Кб ОЗУ,  LEM "Сжатие" обеспечивает в зависимости 
от характера информации ее двуx-трехкратное сжатие.

        LEM "Сжатие" описан в одном из разделов этой книги.

        2. Возможно, даже более неприятной оказалась другая ситуация,
проанализировать которую столь же детально, к сожалению, не удалось. А
это значит - она может неожиданно проявиться...

        Ситуация состоит в том, что в стандартном цикле просмотра файла 
по ключу могут быть найдены не все записи с заданным значением ключевых 
полей. Это происходит, если их значения изменяются внутри цикла, да и 
то в очень редких случаях.

        Речь идет о фрагменте кода следующего вида :

        clear(record,-1)
        field = old_value
        set(key,key)
        loop until eof(file)
          next(file)
          if field <> old_value then break.
          ......
          field = new_value
          put(file)
        .

        Оказывается, существуют базы данных, где по завершению этого
цикла остаются записи с field = old_value.

        Ситуация проявляется при достаточно больших количествах 
записей, обрабатываемых в таком цикле. По всей вероятности, в процессе 
модификации ключа при "переливании" информации из одного его узла в 
другой теряется указатель в ключе.  Важно заметить, что ключевые файлы 
целостность не теряют, дело именно в потере указателя, а не в 
разрушении ключей.

        Нижеследующая программа генерирует БД, на которой была выявлена
описываемая ситуация, и демонстрирует ее.  Весьма неожиданным был факт,
что ситуация проявляется только, если файл открывается оператором OPEN и
не проявляется в случае открытия оператором SHARE ?!

        То, что программа более корректна в сетевом режиме, хорошо;
плохо, что она "менее корректна" в однопользовательском варианте...
Кстати, легко было бы понять и простить, если бы программа не замечала
чего- либо, что произошло с файлом по инициативе другой рабочей
станции, но в данном-то случае речь идет об одной лишь программе и
файле, монопольно используемом ею.

**********************************************************************
next_put     Program

old_val	  equate(2)
new_val	  equate(1)

next_put     File,Create
key	       Key(field),Dup,Nocase,Opt
RECORD	       Record
field		 Short
	     . .

  CODE
  SETHUE(7,0)					 !SET WHITE ON BLACK
  BLANK						 !  AND BLANK
  SETHUE()					 !    THE SCREEN

  do create

  mode" = 'open:'
  do error

  close(next_put)
  do create
  close(next_put)

  mode" = 'share:'
  share(next_put)
  do error


error	 routine

  field = old_val
  SET(key,key)
  LOOP UNTIL EOF(next_put)
    NEXT(next_put)
    IF ~(field = old_val) THEN BREAK.
    field = new_val
    PUT(next_put)
  .
  field = old_val
  GET(next_put,key)
  IF ERROR()
    stop(mode" & 'OK')
  else
    stop(mode" & 'ERROR')
  .

create	  routine

  create(next_put)
  stream(next_put)
  field = new_val
  loop 1320 times
    append(next_put)
  .
  field = old_val
  loop 1082 times
    append(next_put)
  .
  build(next_put)
**********************************************************************

        Как мы боремся с этой ситуацией?

        Из вышесказанного следует, что достаточно открыть файл SHARE-ом
и бороться с этой ошибкой не придется (по крайней мере, пока это
спасало), но программа при этом работает заметно медленнее, а средства
повышения производительности такие, как STREAM, CACHE, BUFFER,
автоматически игнорируются.

        Можно предложить другой, более громоздкий, но не снижающий
эффективности способ: заключить описываемый цикл во внешний и прерывать
его по условию, что во внутреннем цикле не было найдено ни одной 
записи.  Для этого можно, например, вести во внутреннем цикле счетчик 
записей.  Схема следует ниже:

      loop
        count# = 0                      !
        clear(record,-1)
        field = old_value
        set(key,key)
        loop until eof(file)
          next(file)
          if field <> old_value then break.
          ......
          field = new_value
          put(file)
          count# += 1                   !
        .
        if count# = 0                   !
          break                         !
      . .


        3. REPORT WRITER трактует поля типа BYTE в CLARION-овской БД
как знаковые. Эту ситуацию наглядно иллюстрирует отчет REP_ERROR_1, где
записи базы данных, состоящие из единственного поля типа BYTE,
отбираются по условию меньше 0. На экране вместо сообщения "NO RECORDS
MATCHED" мы видим перечень значений, начиная со 128 и выше. К
сожалению, эта ситуация проявляется не только при сравнении с 0, но и
при других сравнениях и в арифметических операциях.

        Проще всего обойти эту ситуацию - не использовать тип BYTE
вовсе, используя вместо него SHORT... Более сложный способ - ввести в
описание Reporter-Database условное поле следующего смысла

                      if BYTE_VAR > 0
                        BYTE_VAR
                      else
                        BYTE_VAR+256
                      end

        Эта формула играет на правилах преобразования основного и 
дополнительного кодов. Действительно, число HEX(FF), если его 
трактовать как знаковое, - это -1, а как беззнаковое - это 255.

        См. отчет REP_ERROR_1_HOW_TO, иллюстрирующий предлагаемый метод
обхода ошибочной ситуации.

        4. Эта ошибка встречается при компиляции структур SCREEN,
содержащих русский текст. Откомпилируйте эту программу и запустите ее
(желательно иметь драйвер русского терминала).

**********************************************************************
	     program

DESCRIPTION STRING('<157>та строка портится, являясь достаточно ' |
			    & 'длинной строкой на русском языке')
Screen	     Screen	  Window(7,80),Hue(0,3)
	       Row(2,36)  String('Description')
	       Row(5,31)  String('item1 {8}item2')
	       Row(3,5)	  Menu(@S72),Use(Menu_field")
	       Row(6,29)    String('BAD STRING')			       |
			      Desc('<157>та строка портится, являясь '	       |
			      & 'достаточно длинной строкой на русском языке')
		 Col(42)    String('GOOD STRING'),Desc(Description)
	     .		  .
	     code
	     open(screen)
	     ACCEPT
**********************************************************************

        Вы, видимо, заметили, что русский текст в параметре DESC
испорчен компилятором. Это происходит регулярно, когда в конструкциях
DESC или PAUSE встречаются достаточно длинные русские текстовые
константы. Та же программа демонстрирует и способ борьбы с этой
ситуацией: выносить текстовую константу из структуры SCREEN в обычную
(не SCREEN) переменную и помещать ее метку в конструкцию DESC или
PAUSE вместо текстовой константы, как это сделано с 'GOOD STRING'. К
сожалению, я не могу указать, что такое "достаточно длинная текстовая
константа", ее длина где-то порядка 60-65 символов, однако, длина не
определяет однозначно, испортит ли компилятор русскую констату или нет.
Могу лишь отметить, что случаев порчи английских текстовых констант не
зарегистрировано. 

        Этой ошибкой Clarion "обязан" именно компилятору, т.к. 
константы испорчены в .PRO файле, более того, поправив их любым 
шестнадцатиричным редактором непосредственно в этом файле, можно 
получить вполне "исправную" программу.


        5. Потусторонние ошибки.

        Обе ситуации, описываемые в этом разделе, приводят к зависанию
утилит Clarion, что сопровождается разрушением целостности рабочего
винчестера... Они имеют и еще одну общую черту, по которой, собственно,
и объединены в этом разделе: анализ выявил столь неожиданные причины их
возникновения, что объяснить, как причины влияют на следствия,
практически возможным не представляется.

        5.1. Эта ошибка обнаружена в REPORTER - е, только под версией
DRDOS 5.0, если в CONFIG.SYS имеются строки 
        HIDOS = ON
        DEVICE=HIDOS.SYS /B=AUTO
В результате ядро DRDOS перегружается в верхнюю память, увеличивая на 
64 Кб память, доступную пользовательской программе, в частности, 
Clarion-программе. (То, что ошибка проявляется только под конкретной 
версией операционной системы, свидетельствует скорее всего об ошибке в 
этой ОС, но то, что REPORTER оказался одной из немногих не работающих 
под DRDOS программ, не украшает его.)

        Ошибка проявляется при попытке сохранения отчета, содержащего
поле типа COUNT, - REPORTER пишет на диск, пока не заполнит все дисковое
пространство (максимально терпения хватало на 4-5 Мб). Разумеется, если
терпения не хватает и пользователь перегружает компьютер, целостность
винчестера приходится восстанавливать соответсвующими утилитами. Здесь
не приводится примера отчета, т.к. это проявляется на совершенно любом
отчете, содержащем счетчик записей.

        Способы борьбы с данной ошибкой крайне просты: не использовать
DRDOS, или (что предпочтительней) поставить символ '?' в CONFIG.SYS,
чтобы получилось ?HIDOS = ON, тогда DRDOS будет задавать вопрос
использовать ли эту строку или проигнорировать ее. Отвечайте N (no),
если Вы собираетесь проектировать отчет, -  ситуация проявляться не
будет.

        5.2. Эта ошибка обнаружена в утилите Designer. Оказывается,
Designer некорректно реагирует на попытку изменить метку файла (нажав
^O, когда маркер стоит на имени этого файла), если в графе PATH окна
его описания стоит метка ранее определенной переменной. Более того,
реакция не однозначна: изменим метку файла и нажмем ^Enter - Designer
сообщит нам, префикс файла должен быть уникальным, хотя мы меняем не
префикс, а метку файла, если же нажать не ^Enter, а Enter - Designer
начнет активно работать с диском, но делает он это, по-видимому,
циклически. Как и в предыдущем случае результатом является переполнение
винчестера.

        Для иллюстрации предлагаю заглянуть в LABEL.APP: там объявлен
лишь один файл (метка Label) и в нем лишь одно поле Field1 string(1),
путь к файлу задается переменной mem:device. Попробуйте, например,
заменить метку Label на Label_ (советую только сохранить все ценное, что
было на Вашем винчестере и не ставить этот эксперимент, если Ваше
приложение лежит на сервере локальной сети).

        Способ обхода ошибки прост: вначале очистите поле PATH, затем
измените метку, а затем восстановите значение очищенного поля PATH.

        6. Ситуация, описываемая в данном пункте, имеет аналогии как в 
Designer-е, так и в Reporter-е и состоит в том, что отслеживаются 
изменения не всех полей прерывания, а лишь на тех уровнях, где имеются 
какие-либо выводные поля.

        6.1. Обсудим эту ситуацию на примере подготовленного 
Reporter-ом отчета REP_ERROR2, предлагаемого Вашему вниманию на 
прилагаемой дискете. Этот отчет производит сортировку БД по полям 
Field1+Field2, из которых лишь второе объявлено группой, т.е.  полем 
прерывания отчета. Запустив отчет мы обнаруживаем, что Reporter не 
заметил изменений поля Field1, отследив лишь изменения поля Field2.  
Возможно, это и корректно, но вряд ли удобно. В самом деле, трудно 
предложить пример, когда пользователю потребовалось бы сортировать базу 
данных по полю и не учитывать изменения этого поля при формировании 
подзаголовков (обработке полей прерывания), с другой стороны, зачем 
объявлять поле группой, т.е. подзаголовком (полем прерывания), если на 
этом уровне нет ни одного выводного поля? Между тем, именно это 
последнее пришлось сделать в отчете REP_ERROR2_HOW_TO, чтобы получить 
требуемый результат. (Ситуация имеет практическое значение и возникает, 
например, если необходимо получить все имеющиеся в БД сочетания 
каких-либо нескольких полей с целью последующего выделения этих полей в 
связный файл. Reporter ведь можно использовать еще и как средство 
реконфигурации БД...)

        6.2. В Designer-е дело выглядит еще хуже, там изменение полей 
прерывания анализируется лишь, если на уровне данного поля прерывания в 
отчете есть выводная информация. Однако, поместить что-то в 
Designer-овский отчет так, чтобы это что-то не выводилось, нельзя (по 
крайней мере, без специальной модификации модельного файла). Самое 
лучшее в данной ситуации (кстати в полном соответствии с фирменной 
документацией, где, правда, об этом говорится в другом контексте) 
объединять поля в группы, тем самым заставляя Clarion за одну проверку 
выявлять изменения всех полей, которые надо отслеживать. 

        К сожалению, рекомендация объединять поля в группы применима не 
всегда, поскольку может быть слишком много сочетаний и может не 
существовать такого варианта размещения полей в файле, при котором эти 
поля расположились бы рядом (необходимое условие включения полей в 
группу).

        Явные аналогии между Designer-ом, и Reporter-ом позволяют
заключить, что речь идет, по-видимому, не об ошибке, а о не очень, с
моей точки зрения, удачном подходе. 

        Что касается Designer-а, то требуемые изменения выглядят не 
очень сложными,- его нужно научить анализировать изменения всех 
ключевых полей и, соответсвенно, производить инкремент переменной 
BRK_FLAG#.  Впрочем, по-видимому, в версии 3.0 это можно будет сделать 
на уровне модельного файла. Подождем Clarion 3.0 ...

                        Главный специалист
                        фирмы Инсайт                  Л.В. Гольцблат

