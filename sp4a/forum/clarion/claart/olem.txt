Фирма ИНСАЙТ*INSIGHT Comp. - Официальный Дистрибутор CLARION Software Corp.
      103460, Москва, Зеленоград, Панфиловский проспект, корп. 1205
	   т. 532-29-43, (531-82-30)       факс    531-18-94
	   E-Mail: puh@pczz.msk.su         Fido:   2:5020/11.2
---------------------------------------------------------------------

    О подключении объектных модулей к EXE программам на Clarion-е,
              "оверлейных LEM-ах" и не только об этом.

1 Почему Clarion не умеет грузить LEM в оверлеи?

        Чтобы ответить на этот вопрос рассмотрим вначале идеологию
работы гипотетического менеджера оверлеев. (Отнеситесь ко всему, что
следует дальше лишь как к демонстрации общей идеи, не обольщаясь
излишне достоверностью вкравшихся в рассуждения деталей.)

        Итак... Чтобы произвести подгрузку оверлейного сегмента,
менеджер оверлеев должен прежде всего получить управление. В какой
момент это может произойти? Интуитивный ответ- при обращении к этим
сегментам. Можно было бы ожидать, что будучи достаточно
интелектуальным, линковщик и в самом деле отслеживает все обращения за
пределы данного сегмента, и когда это происходит передает управление
менеджеру оверлеев.

        Это и в самом деле так для случая инструкций

        CALL <МЕТКА_ПОДПРОГРАММЫ>

т.е. для вызова подпрограмм. В этом сучае редактор связей, работающий с
объектым модулем как с черным ящиком, и умеющий только заменять метки
на их адреса, вполне в состоянии заменить метку не на адрес
подпрограммы пользователя, а на адрес какой-либо другой подпрогаммы.
Это может быть, например, адрес генерируемой линковщиком заглушки,
которая вызовет оверлейный менеджер, попросив его загрузить требуемую
программную единицу (сегмент), и затем передаст управление в
"свежезагруженный" сегмент.

        Сколько различных линковщиков, столько реализаций механизма
оверлеев, но все они базируются на основной идее: простой подменой
метки организуется передача управления внешней по отношению к
конкретной разработке прикладного программиста логике, выполняющей все
необходимые действия.

        Еще раз подчеркнем, что все это относилось лишь к передачам
управления (по меткам, находящимся в других оверлейных сегментах). А
как обстоят дела с данными, находящимися в таких сегметах?

        Дела, оказывается, обстоят гораздо хуже. Прерывания по
обращению по адресу, реализовано лишь начиная с 386 процессора, значит,
единственный способ передать управление менеджеру оверлеев (по крайней
мере на XT и AT-286) - учесть эту возможность в компиляторе языка
программирования, что не прибавит эффективности программе на этом
языке... (Все другие варианты приводят к весьма сложной задаче
модификации алгоритма работы объектного модуля, противоречащей к тому
же работе с ним как с черным ящиком.)

        Иными словами, возникает ограничение - обращение к данным в
оверлейных сегментах может производиться лишь после обращения к
подпрограммам в этих сегментах, когда оверлейный сегмент уже загружен.
(Кстати, в большинстве языков данные просто всегда резидентны в ОЗУ.)

        Действительно, в момент обращения к подпрограмме производится
подгрузка оверлейного сегмента, в том числе и данных. После этого к ним
можно обратиться безо всяких проблемм просто по адресу.

        Сейчас мы наконец приступим к рассмотрению механизма вызова
LEM-а в Clarion-е и обнаружим, что данные в LEM-е должны быть
сформированы раньше, чем ему передано управление. В этом и состоит
причина, почему LEM нельзя располагать в оверлеях.

        Рассмотрим механизм вызова LEM-а более подробно. Как всегда при
согласовании модулей, написанных на разных языках основная проблемма -
передать параметры и получить результаты обратно, так чтобы это поняли
обе стороны. В LEM-ах Clarion-а проблемма передачи параметров решается
путем резервирования в его начале, по определенным правилам, места под
таблицу описания процедур (функций) и их параметров.

        Кто формирует эту таблицу? LEM? Нет! Если Вы написали хоть один
LEM, Вы знаете,- никакого кода, формирующего таблицу описания
параметров в LEM-е нет, наоборот чуть ли не с первой инструкции LEM
начинает использовать информацию из этой таблицы как данность. Значит,
ее обязана сформировать среда Clarion до запуска LEM-а. Естественно в
момент формирования таблица уже должна быть в ОЗУ, т.е. она должна
подгружаться до передачи управления самому LEM-у. Но как рассмотрено
выше, лишь в момент передачи управления может быть произведена подкачка
оверлея. Вот мы и пришли к невозможности использовать LEM в оверлеях!

        2 Давайте пофантазируем. Наши рассуждения показали, на самом
деле, что не весь LEM не может быть в оверлее, а лишь только таблицы,
описывающие его параметры. Что если удалось бы разделить LEM на сегмент
данных и сегмент кода. Тогда можно было бы, оставив сегмент данных в
корневой области, перенести кодовую часть в оверлеи!

        К сожалению, впрямую разделить бинарный, т.е. уже обработанный
линковщиком модуль на сегменты невозможно из-за того, что все ссылки в
нем уже выражены в смещениях. И берутся эти смещения от начала
бинарного модуля, а не от той точки, где Вы можете пожелать разрезать
его гипотетической бритвой. Правда остается еще возможность постараться
разработать "LEM-ы" так чтобы их можно было разделить на код и данные!
Но... Как Вы объясните процессору, как пользоваться этими новыми
"LEM-ами"? (Вообще-то это получатся уже не LEM-ы, а некие интерфейсные
модули, по-видимому, другой структуры.)

        По всей вероятности под процессором решить задачу переноса
LEM-а в оверлей практически невозможно. Для этого пришлось бы залезть
непосредственно в сам процессор и модифицировать его код... Не самое
достойное занятие.

        Остается вариант попробовать подключить "LEM" к EXE-программе
на этапе линковки. Но и здесь можно было бы ожидать появления почти
неразрешимой проблеммы. Если бы Clarion (в соответствии с
документацией!) работал бы идентично в EXE и PRO вариантах, разбить LEM
на сегменты было бы нельзя. Ведь процессор, анализируя таблицу описания
процедур LEM-а, находит там смещение точки входа и передает управление
по этому смещению ОТ НАЧАЛА LEM-а. Что будет в этом месте, если
сегменты разделены? Разумеется там будет что угодно, но не точка входа
в LEM. Нас спасает различие в алгоритмах вызова LEM-а в EXE и PRO
вариантах... Чтобы обнаружить это различие пришлось разобраться со
структурой BOJ модуля, генерируемого транслятором из LEM-а при его
трансляции. (Кстати эта структура нигде не описана.)

        Решение этой небольшой проблеммы позволило научиться
самостоятельно разрабатывать на TurboC и ассемблере объектные модули,
понятные Clarion-у, располагать их в оверлеях, непосредственно
обращаться к библиотеке функций Clarion-а и открыть путь к более
раскованному смешению OBJ модулей TurboC и Clarion, вплоть до вызова
Clarion-процедур из C-программ.

        Речь здесь идет о TurboC, главным образом потому, что все
эксперименты проводились лишь с компиляторами tcc и tasm. Следует
однако иметь в виду, что Clarion написан на этом языке и при подлючении
модулей на других языках, может быть придется решать уже не столько
проблеммы интерфейса с Clarion, сколько проблеммы интерфейса этого
языка с TurboC.

        3 Рассмотрим сейчас логическое устройство BOJ модуля,
генерируемого транслятором из LEM-а при его трансляции, и в дальнейшем,
обрабатываемого линковщиком. (Несмотря на весьма непривычное
расширение- это обычный обектный модуль, поэтому его физическая
структура не особенно интересна.)

        Для примера возьмем простейший LEM, получающий в виде параметра
текстовую строку и выдающий ее на стандартный вывод. Это выполняется
операцией ДОС 09h (строка должна оканчиваться символом $, но оставим
это "на совести" Clarion - программы, т.е. предположим, что
передаваемая строка имеет в конце этот символ). Назовем этот LEM, как и
содержащуюся в нем процедуру, STDOUT.

_TEXT	SEGMENT PUBLIC BYTE 'CODE'
        ASSUME CS:_TEXT,DS:_TEXT

	DB	'BIO'
        DD      0
        DW      offset BINEND
        DB      1                       ;в этом LEM-е всего 1 процедура


        db      'STDOUT', 7 DUP(0)      ;ИМЯ ПРОЦЕДУРЫ
        dw      stdout                  ;точка входа
        db      0                       ;это процедура
        db      1                       ;число параметров

        db      0                       ;параметр типа STRING
STR1    dd      0                       ;адрес передаваемой строки
        dw      0                       ;длина передаваемой строки

STDOUT  proc    far

        lds     bx,STR1
        mov     ah,09h
        int     21
        ret

STDOUT  endp

BINEND  db      0
_TEXT   ends

        end

        Во что превратит транслятор этот модуль? То что будет
сгенерировано эквивалентно следующему коду:

        extrn   BINFNC:far

STDOUT_BIN_SEG   SEGMENT PUBLIC PARA 'CLARION'
        ASSUME CS:_TEXT,DS:_TEXT

	DB	'BIO'
        DD      BINFNC
        DW      offset BINEND
        DB      1                       ;в этом LEM-е всего 1 процедура

        public  _LEM_STDOUT
_LEM_STDOUT label byte
        db      'STDOUT', 7 DUP(0)      ;ИМЯ ПРОЦЕДУРЫ
        dw      _CODE_STDOUT            ;точка входа
        db      0                       ;это процедура
        db      1                       ;число параметров

        db      0                       ;параметр типа STRING
STR1    dd      0                       ;адрес передаваемой строки
        dw      0                       ;длина передаваемой строки

        public  _CODE_STDOUT
_CODE_STDOUT  proc    far

        lds     bx,STR1
        mov     ah,09h
        int     21
        ret

_CODE_STDOUT  endp

BINEND  db      0

STDOUT_BIN_SEG   ends

        end

        Прежде всего заметим, BINFNC - точка входа из LEM - а в среду
Clarion, она достаточно интересна, заслуживает отдельного разговора и
здесь более не рассматривается. Кстати, объектный модуль полученный в
результате трансляции, приведенного выше текста, может быть
непосредственно подлинкован к Clarion программе вместо BOJ модуля.

        Наиболее для нас важное - глобальные метки генерируемые
транслятором, - это метки _LEM_<ИМЯ_ПРОЦЕДУРЫ> и _CODE_<ИМЯ_ПРОЦЕДУРЫ>.
Первая из них указывает на таблицу описания процедуры, вторая на точку
входа в процедуру. Наличие этих меток наводит на мысль, что EXE -
модуль, в отличие от процессора не сканирует сегмент LEM-a, разбираясь
с его таблицами, а обращается непосредственно по меткам.

        Если это так, то можно выкинуть из текста все лишнее (сигнатуру
BIO и т.п.), разделить сегменты оставив _LEM_STDOUT в корне, а
_CODE_STDOUT переложить в оверлей. Эта гипотеза была проверена
экспериментально, и полностью подтвердилась! Следующий ниже текст есть
по сути дела то же самое, переписанное по правилам Large модели. Это
объектный модуль расширения языка (OLEM), такие модули могут
располагаться в любых оверлейных областях по общим правилам написания
ARF файлов.

STDOUT_TEXT   SEGMENT PUBLIC BYTE 'CODE'
STDOUT_TEXT   ENDS
_DATA	SEGMENT PUBLIC BYTE 'DATA'
_DATA	ENDS
_BSS	SEGMENT PUBLIC BYTE 'BSS'
_BSS	ENDS
DGROUP	GROUP	_DATA,_BSS

_DATA	SEGMENT PUBLIC BYTE 'DATA'
	ASSUME CS:GETVER_TEXT  ,DS:DGROUP

        public  _LEM_STDOUT
_LEM_STDOUT label byte
        db      'STDOUT', 7 DUP(0)      ;ИМЯ ПРОЦЕДУРЫ
        dw      _CODE_STDOUT            ;точка входа
        db      0                       ;это процедура
        db      1                       ;число параметров

        db      0                       ;параметр типа STRING
STR1    dd      0                       ;адрес передаваемой строки
        dw      0                       ;длина передаваемой строки
_DATA	ENDS

STDOUT_TEXT   SEGMENT PUBLIC BYTE 'CODE'
        public  _CODE_STDOUT
_CODE_STDOUT  proc    far

        lds     bx,STR1
        mov     ah,09h
        int     21
        ret

_CODE_STDOUT  endp

STDOUT_TEXT   ENDS

        end

        В действительности кое-что лишнее в этом модуле все же 
осталось, - это первые 16 байт по адресу _LEM_STDOUT в принципе 
программист может использовать их по своему усмотрению, но 
зарезервировать их надо, т.к. Clarion ищет таблицу описания параметров 
и их число по предопределенным смещениям от указанной метки.

        Модуль написан именно в Large - модели поскольку в этой модели 
написан и сам Clarion. Это дает неожиданное, но весьма полезное 
качество: сегмент данных LEM-а объединяется линковщиком с сегментом 
данных Clarion-а, т.е. с глобальными переменными самого Clarion-а. 
Поскольку перед запуском LEM-а, точнее уже OLEM - а, Clarion формирует 
таблицу его параметров, он загружает регистр DS сегментом своих 
глобальных переменных, в результате они становятся доступными из OLEM-а 
прямо по имени! Наименее интересное, получаемое свойство,- возможность 
непосредственно присваивать код ошибки Clarion просто записав, 
например, GLOBERR = <КОД_ОШИБКИ>. Более подробное знакомство со средой 
дает куда более интересные возможности, но это за рамками данной 
статьи...  

        4. Что недосказано?

        Механизм возврата параметров из LEM-а. Как выяснилось этот 
механизм описан далеко не полностью, разобравшись с ним нам удалось 
научить функции LEM-а возвращать значения лежащие не только в сегменте 
LEM-a, но и в произвольном месте ОЗУ, снять ограничение 255 на размер 
возвращаемого функциями символьного значения.

        Протокол обращения из LEM-а к ядру Clarion, т.е. точка входа 
BINFNC. Кстати из OLEM-а к ядру можно обращаться не только через эту 
точку входа, но и напрямую, вызывая библиотечные функции.

        Переменные среды Clarion - значительная их часть на данный 
момент известна.

        Возможность вместо стандартной С-библиотеки использовать 
функции непосредственно из библиотек Clarion1.lib и Clarion2.lib. Эта 
возможность приводит прежде всего к значительному уменьшению размера 
OLEM - а по сравнению с LEM-ом, во вторую очередь OLEM получает в свое 
распоряжение Clarion-овские алгоритмы распределения памяти в том числе 
и виртуальной...

        5. Как это использовать?

        Нами подготовлен комплекс в составе генератора интерфейсных 
молулей в формате LEM либо OLEM, библиотеки, реализующей преобразование 
типов возврата из соглашений языка C в соглашения Clarion, #include 
файлов, описывающих глобальные переменные Clarion, библиотеки 
нескольких полезных при програмировании OLEM - ов функций, полного 
описания интерфейса BINFNC, и более, нежели lm.lib, эффективной 
библиотеки, работающей с этим интерфейсом.

        Генератор интерфейсных модулей полностью совместим с фирменным 
LEM-maker -ом по базе данных (т.е. описание любого LEM - а, 
подготовленное стандартным LEM-maker -ом, может быть обработано нашим 
генератором и в результате может быть получен, как LEM так и OLEM). В 
отличии от LEM-maker -а он поддерживает все мыслимые типы возврата 
C-функций, в том числе unsigned, double * и т.п., не ограничивает длину 
возвращаемого значения. Кроме того, за счет сокращения (в 4 раза!) 
числа проходов по базе данных наш генератор работает существенно 
быстрее, генерируя еще и намного более понятный код.

        Комплекс содержит также описание правил оформления С-программ 
(и их примеры), которые можно подлинковывать к Clarion, безо всякой 
ассемблерной преамбулы, но с библиотекой преобразования типов 
возвращаемых значений, входящей в состав комплекса.

        Весь этот комплекс имеется на прилагаемой к планируемой книге 
дискете и может быть приобретен отдельно. Его цена 3000 руб + 28% , 
безнал.

                        Главный специалист
                        фирмы Инсайт                  Л.В. Гольцблат



