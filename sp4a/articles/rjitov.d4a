
  Алексей Рытов, С-Петербург

  Объектно-ориентированные расширения в Clipper 5.0

  1. Введение

  Объектно-ориентированные языки  и все с ними связанное стало весьма по-
пулярным в последнее аремя.  Вот и разработчики Clipper'а 5.0 включили  в
язык несколько предопределенных типов "объектов",  что, повидимому, можно
рассматривать как намек на более мощные объектноориентированные  расшире-
ния в одной из будущих версий. Автор этой статьи также решил не оставать-
ся в стороне от горячей темы.  Не ограничиваясь  обычными  разговорами  о
пользе объектов и классов,  автор покажет,  как уже сейчас можно ввести в
CLIPPER 5.0 полноценные средства объектно-ориентированного программирова-
ния.  Предполагается, что читатель работает на CLIPPER 5.0, знаком с язы-
ком C и имеет в своем распоряжении какой-нибудь C-компилятор  (рекоменду-
ется Microsoft C 6.0, хотя автор использовал Turbo C++).

  2. Что есть и чего не хватает в CLIPPER 5.0 для объектноориентированно-
го языка

  В CLIPPER 5.0 введен новый тип значений  -  объект.  Имеется  несколько
предопределенных классов объектов, каждому из которых соответствует функ-
ция-конструктор,  возвращающая новый объект данного  класса.  Возможность
создания новых классов объектов не предусмотрена. Как правило, полученный
при вызове конструктора объект присваивается, для дальнейшего использова-
ния, переменной. Каждый объект имеет внутреннее состояние (т.н. instance-
переменные) и набор методов (аналог функций),  общий  для  всех  объектов
данного класса.  Программист изменяет внутреннее состояние объекта и зас-
тавляет его выполнять требуемые действия,  вызывая соответствующие методы
(говорят также, посылая сообщения объекту).

  Чтобы понять,  что дает введение объектов,  обратимся к классу TBrowse,
предназначенному для просмотра разного рода информации в виде таблиц (ра-
бота с TBrowse достаточно подробно рассмотрена в документации,  а в ката-
логе SAMPLES  имеются  примеры).  Типичный  фрагмент  кода,  использующий
TBrowse,  показан на фиг.1. Все сложности и тонкости, связанные с отобра-
жением таблицы и хранением состояния  отображаемой  информации,  упрятаны
внутрь  объекта  и программист обычно не должен знать или интересоваться,
как они реализованы.  С другой стороны, программист имеет полный контроль
над использованием возможностей объекта (например,  перемещение подсветки
вызовами методов Up() и Down() может выполняться не  по  нажатию  клавиш,
как показано в примере, а при перемещении "мыши" или наступлении каких-то
других событий в программе).

  Если бы в CLIPPER 5.0 было возможным введение новых  классов  объектов,
определяемых разработчиком,  то выявилось бы и еще одно преимущество объ-
ектного подхода:  поскольку программа воздействует на объект только через
его методы,  объект некоторого класса может быть заменен объектом другого
класса (например,  выполняющим схожие, но несколько отличающиеся функции,
либо  функционально эквивалентным,  но иначе реализованным),  если только
этот другой класс адекватно реагирует на посылаемые ему программой  сооб-
щения.

  И наконец,  в  Clipper 5.0 отсутствует самое красивое и мощное средство
объектных языков - иерархическая система классов с  наследованием свойств
объектов.  Наследование избавляет от необходимости переписывать каждый из
методов для каждого из набора сходных классов. Вместо этого создается ба-
зовый класс (суперкласс),  определяющий наиболее общие свойства и методы,
а затем - порожденные классы,  для которых описываются только те перемен-
ные  и  методы,  которые  отличают их поведение от поведения суперкласса.
Например,  иерархия классов, обеспечивающая отображение данных и диалог с
пользователем, могла бы выглядеть примерно так, как показано на фиг.2.

  3. Как объекты реализованы в CLIPPER 5.0

  Объект в CLIPPER 5.0 - это просто значение типа массив,  с которым свя-
зана таблица методов.  В этом можно убедиться,  попробовав  обращаться  к
элементам массива-объекта,  как показано на фиг.3.  То,  что программисту
кажется instance-переменными,  которым можно присваивать значения (напри-
мер,  'tbr:cargo = tbr:cargo+1'), на самом деле представляется парами ме-
тодов для получения и записи значения,  причем для  записывающего  метода
перед именем "переменной" ставится '_' (предыдущий пример фактически пре-
образуется компилятором к виду 'tbr:_cargo(tbr:cargo()+1)').  Поскольку в
CLIPPER  разные  элементы  массива  могут хранить разные типы значений (в
т.ч. вложенные массивы), массив позволяет адекватно представлять внутрен-
нее состояние любого объекта.

  Небольшое исследование  показало,  что  функция-конструктор  (например,
TBrowseNew() - фиг.  4) просто создает массив требуемой длины,  заполняет
его начальными значениями,  а затем вызывает функцию ToTBrowse(), которая
и превращает простой массив в объект нужного класса. Чтобы научиться соз-
давать свои типы объектов,  автору пришлось разобраться в том,  что стоит
за этой функцией. Почти точный ее аналог, но применительно к рассматрива-
емому далее примеру класса STACK, приведен на фиг.5. Используются следую-
щие функции из библиотеки CLIPPER, не описанные в документации:

  VALUE near * _eval; - указатель на структуру, в которой различные функ-
ции (в т.ч. _arraynew()) возвращают результат.

  VALUE far  *  _ArrayNew(int  size)  - создает массив с указанным числом
элементов

  SYM far * _get_sym( char far* name) - находит или создает элемент  таб-
лицы символов для указанного имени

  MDTable far * _mdCreate( int size, SYM far * sym ) - создает пустую хэш
-таблицу методов указанной длины.  Параметр sym - адрес элемента  таблицы
символов для имени класса.

  void _mdAdd(MDTable far *mdt,  SYM far *nm, void *adr) - добавить метод
в таблицу mdt.  Имя метода задано адресом элемента таблицы  символов  nm,
параметр adr указывает адрес процедуры, реализующей данный метод.

  void _mdAssociate(  VALUE  near  * aObj,  MDTable far * mdt ) - связать
созданную ранее таблицу методов с массивом,  заданным адресом  ссылки  на
него. Именно этот вызов и превращает массив в объект.

  Пользуясь перечисленными  выше  функциями,  уже  можно  определить свой
собственный класс.  На фиг.5,6,7 приведен пример простого  класса  STACK.
Этот  пример  очень похож на реализацию стека из файла SAMPLES\STACK.PRG,
поставляемого с CLIPPER 5.0,  но функция StackNew()  из  файла  _STACK.C,
приведенная на фиг.5, превращает STACK в настоящий объект.

  Обсуждение внутренней структуры блоков VALUE,  SYM и MDTable, упоминае-
мых выше, выходит за рамки данной статьи. Поскольку доступ к их компонен-
там в данном примере не нужен, в файле _STACK.C все указатели на них опи-
саны как (void far*) или (void near*).  Тех, кого интересует эта и другая
информация  о  внутренней структуре CLIPPERмашины и использовании недоку-
ментированных функций CLIPPER-библиотеки,  автор отсылает к  своей  книге
'Тайны программирования на C для Clipper 5.0',  которая в настоящее время
готовится к изданию.

  4. Реализация полноценной иерархической структуры классов.

  Автором разработано и реализовано  объектно-ориентированное  расширение
языка CLIPPER,  состоящее из нескольких компонентов, подробнее рассматри-
ваемых далее.

  Во-первых, пришлось усилить поддержку работы с объектами на самом  ниж-
нем уровне, для чего был проанализирован и переписан библиотечный модуль,
содержащий описанные выше функции _mdCreate(), _mdAdd() и _mdAssociate().
С  точки зрения остальных компонентов библиотеки,  работа этих функций не
изменилась, так что все предопределенные классы будут вести себя по-преж-
нему.  На самом же деле,  формат таблицы методов и алгоритм вызова метода
изменены так,  чтобы реализовать наследование методов: если метод не най-
ден  в  таблице методов данного класса,  то поиск продолжается в таблицах
методов по цепочке его суперклассов, вплоть до класса OBJECT, который яв-
ляется суперклассом для всех остальных.

  Во-вторых, добавлены функции высокого уровня, которые позволяют создать
логически стройную иерархию классов, причем описание классов может выпол-
няться  непосредственно в CLIPPER-программе и не требует использования C.

  Изначально в описываемом объектно-ориентированном расширении определены
два класса - OBJECT и CLASS.  Класс OBJECT является базовым для всех  ос-
тальных классов в создаваемой иерархии (включая предопределенные в библи-
отеке). Объекты, принадлежащие к этому классу, не имеют instance-перемен-
ных, но умеют отрабатывать следующие сообщения (и, следовательно, объекты
всех остальных классов наследуют это умение):

  Obj:ClassName - возвращает строку-имя класса для объекта Obj

  Obj:Class - возвращает объект класса CLASS, обладающий способностью по-
рождать объекты, подобные Obj (принадлежащие к тому же классу)

  Obj:HasMethod(cMethod) -  возвращает логическое значение .T.,  если Obj
может обрабатывать сообщение с именем cMethod (т.е.  этот метод определен
либо в классе самого объекта, либо в одном из его суперклассов).

  Каждый объект класса CLASS содержит в себе информацию,  необходимую для
порождения объекта некоторого другого класса,  т.е.  является  описателем
класса.  CLASS наследует все методы из OBJECT и,  кроме того, имеет собс-
твенные методы NEW и ADD. При вызове Cls:New(...) создается объект, класс
и  число  переменных  (размер  массива)  которого определяются описателем
класса.  Если в классе созданного объекта есть метод 'INIT', то он выпол-
няется с теми же параметрами, которые были заданы в вызове New(...). INIT
может заполнить изначально пустые элементы instance-массива нового объек-
та и выполнить любые другие начальные установки.

  Для определения нового класса объектов имеется функция ClassNew(),  ко-
торая выдает объект-описатель для нового класса (сам этот описатель  при-
надлежит к классу CLASS):

  oMyClass = ClassNew( cClassName, oSuperCls, aMethods )
  Именем нового класса будет cClassName, его суперкласс определяется объ-
ектом oSuperClass (принадлежащим классу CLASS),  а набор методов - масси-
вом  aMethods,  каждый  элемент  которого  -  либо  пара  {  cMethodName,
cProcName }, либо просто cName, если имя метода совпадает с именем проце-
дуры, реализующей этот метод.

  Параметры oSuperCls и aMethods необязательные:  если не  задан  суперк-
ласс,  то им будет OBJECT, а методы могут быть добавлены последующими вы-
зовами oMyClass:Add( aMethods ).

  Рассмотренные функции дополняются файлом описаний CLASS.ch,  в  котором
задается синтаксис новых команд языка, служащих для создания классов. Те-
перь приведенный выше пример определения класса  Stack  может  быть  пол-
ностью записан на языке высокого уровня (фиг.8).

  Способ реализации классов в Clipper 5.0 требует их динамического описа-
ния:  перед тем,  как создавать объекты некоторого класса, надо сформиро-
вать  таблицу  методов этого класса и включить в нее все методыпроцедуры.
Описанные выше средства высокого уровня позволяют выполнить такую инициа-
лизацию на CLIPPER-уровне,  без использования C. Однако необходимость яв-
ной инициализации классов в процессе выполнения все равно усложняет прог-
рамму  и  делает  ее громоздкой,  тем более что набор методов класса чаще
всего известен статически.

  Автору удалось найти способ формировать классы статически,  не  изменяя
синтаксиса языка.  Для этого была написана утилита CLASS.EXE, которая мо-
дифицирует объектный модуль (откомпилированную Clipperпрограмму), превра-
щая его в определение класса.  Суть модификации состоит в том, что в объ-
ектный файл добавляется процедура инициализации  класса,  которая  неявно
вызывается  при  запуске программы (аналогично заданию начальных значений
STATIC-переменных), а все определенные в модуле процедуры и функции (кро-
ме STATIC-процедур и процедур, специально указанных соответствующей опци-
ей в командной строке) становятся методами класса.  Имя класса по умолча-
нию  совпадает  с  именем модуля или задается опцией командной строки.  В
командной строке задается также имя суперкласса и ряд  других параметров.

  Введено переопределение арифметических и логических операций.  Если та-
кая операция (например,  '+') выполняется над значениями-объектами, и при
этом для одного из этих объектов определен метод с соответствующим именем
(например, _2OP_PLUS для сложения), то этот метод будет вызван. Таким об-
разом, можно определить, например, класс комплексных чисел со всеми необ-
ходимыми арифметическими действиями, как показано на фиг.9,10 (после ком-
пиляции COMPLEX.OBJ должен быть обработан  утилитой  CLASS).  Разумеется,
такая  реализация  комплексных  чисел  будет крайне неэффективной и может
служить только в качестве демонстрационного примера.

  Автор планирует дополнить описанные здесь объектно-ориентированные рас-
ширения библиотекой наиболее употребительных классов (окна,  меню,  прос-
мотр текстов на экране и т.п.) и выпустить все это в качестве  коммерчес-
кого продукта.

  P.S. Уже  после  написания  данной  статьи автор познакомился с версией
Clipper 5.01.  Серьезных изменений в работе с объектами не произошло, так
что пример реализации класса STACK, приведенный выше, будет успешно рабо-
тать и в новой версии.  Введены,  однако,  (недокументированные) функции,
позволяющие  создать новый класс и добавить в него методы непосредственно
в CLIPPER-программе:

  __ClassNew( cName, nSize ) -> nMDT  - создает таблицу методов
(класс) с заданным именем. Параметр nSize указывает число элементов, раз-
мещаемых при создании нового массива-объекта данного  класса.  Возвращает
адрес  таблицы в виде целого числа,  которое может затем использоваться в
качестве идентификатора класса.

  __ClassAdd( nMDT, cMethod, cProc )  - добавляет в таблицу методов,
заданную nMDT,  метод  с именем cMethod,  реализованный процедурой cProc.
Устранены ограничения на число методов,  которые могут добавляться в таб-
лицу.

  __ClassIns(nMDT) -> oNew  - создать новый объект указанного класса.
Размер создаваемого объекта-массива хранится в таблице методов,  помещен-
ный туда при создании класса функцией __ClassNew().

  __ClassNam(nMDT) -> cName  - возвращает имя класса, заданного своим
идентификатором (адресом) nMDT.

  Используя эти  функции,  можно  определить  класс   STACK   на   уровне
CLIPPER-программы,  как показано на фиг.11, без какого-либо вмешательства
в системные функции.

  Остается лишь отметить, что новые функции определения классов представ-
ляют собой всего лишь переходники для тех же вызовов _mdCreate()/_mdAdd()
/_mdAssociate() и не делают менее актуальной задачу разработки  полноцен-
ной иерархической системы классов.



        tb = TBrowseNew( nTop, nLeft, nBottom, nRight )  // Создаем объект
        ... // Устанавливаем блоки доступа и другие instance-переменные tb
        tb:addColumn(TBColumnNew(...))  // Добавляем объект-"столбец" для
        ...                             // каждого из столбцов будущей таблицы
        @ nTop-1, nLeft-1 TO nBottom+1, nRight+1 // Выводим рамку

        while .t.                       // Цикл обработки клавиш:
           DO WHILE !tb:Stabilize()     // Даем отработать функции
           ENDDO                        // "постепенного" отображения таблицы
           nKey := INKEY(0)             // и ждем ввода клавиши
           do case
             case ( nKey == K_LEFT )    // По клавише <СТРЕЛКА_ВЛЕВО>
                tb:left()               // вызывается метод tb:left()
             case ( nKey == K_RIGHT)    // Аналогично при нажатии других клавиш
                tb:right()              // вызываются подходящие методы объекта,
             case ( nKey == K_ESC)      // либо требуемые действия выполняются
                break                   // непосредственно.
             case ( nKey == .... )
                ............            // Прочие действия
           endcase
        ENDDO

           Фиг.1 Упрощенная схема типичной программы, использующей TBrowse

    OBJECT
    ├─── Browser                // Содержит общие методы обновления экрана
    │    ├─── TextBrowser       //   Просмотр текста
    │    │    ├─── TextEditor   //     Добавлены методы редактирования
    │    │    └─── HyperText    //     Добавлен переход по связям (HELP)
    │    ├─── TBrowse           //   Просмотр табличной информации
    │    │    └─── ArrayBrowser //     Специализир. для просмотра массивов
    │    │    └─── DBaseBrowser //     Для просмотра DBF-файлов
    │    ├─── ListBrowser       //   Просмотр масс. по неск. эл-тов в строке
    │    │    └─── DirBrowser   //     Специализир. для просмотра каталогов
    │    └─── TreeBrowser       //   Просмотр иерархий, аналогично данной
    │         └─── DirTree      //     Просмотр дерева каталогов
    ├─── Menu                   // Меню
    │    ├─── MainMenu          //   Пункты меню размещены в строку
    │    ├─── PopUpMenu         //   Вертикальное "выпадающее" меню
    │    └─── .......           //   ... и другие типы меню
    ├─── Entry                  // Классы для ввода данных
    │    ├─── _GETSYS           //   Ввод строки по GET
    │    ├─── Button            //   Ввод логического значения
    │    └─── Lever             //   Ввод числа "перемещением ручки"
    └─── Panel                  // Организует работу со множеством размещенных
                                // на экране объектов всех остальных классов

           Фиг.2 Гипотетическая иерархия классов для организации пользова-
                 тельского интерфейса

//      [1]  xCargo                             Дополнительная информация
//      [2]  { nTop, nLeft, nBottom, nRight }   Координаты на экране
//      [3]  { oTBColumn1, ... }                Массив объектов-столбцов
//      [4]  cColor                             Строка цветов
//      [5]  { cHeadSep, cColSep, cFootSep }    Строки разделителей
//      [6]  bSkipBlock                         Блок прокрутки строк
//      [7]  bGoTopBlock                        Блок перехода в начало
//      [8]  bGoBottomBlock                     Блок перехода в конец
//      [9]  cInternal                          Все рабочие данные объекта


        t = TBrowseNew( 1,2,3,4 )
        t:cargo = "Ценный груз"
        ? "t:cargo = ", t[1]
        ? "Coords  = ", t[2][1], t[2][2], t[2][3], t[2][4]

           Фиг.3 Фрагмент, демонстрирующий "массивное" происхождение
                 объектов в Clipper 5.0. Откомпилируйте и проверьте,
                 если не верите на слово !

        func TBrowseNew( nT, nL, nB, nR )
                local aSelf := Array(9)
                TOTBROWSE( aSelf )      // aSelf превращается в объект !
                aSelf[3] = {}
                aSelf[2] = { nT, nL, nB, nR }
                aSelf[5] = { "", " ", "" }
                aSelf:ColorSpec = SetColor()
                aSelf:SkipBlock = {||}
                aSelf:GoTopBlock = {||}
                aSelf:GoBottomBlock = {||}
                return aSelf

           Фиг.4 Реконструированный текст функции TBrowseNew

/* ----------------------------------------------------------------------
               _STACK.C  - функция-конструктор для класса STACK
   ---------------------------------------------------------------------- */

#include "extend.h"

extern CLIPPER stk_pop(),   stk_push(),   stk_depth(),  stk_name(),
               stk_empty(), stk_gettop(), stk_settop(), stk_print();

static void far * stackHandle = 0;

CLIPPER StackNew(){

        extern void far * _get_sym( char far* );
        extern void far * _mdCreate( int, void far* );
        extern void _mdAdd( void far*, void far*, void far* );
        extern void near *_eval;
        extern void far *_arraynew(int size);
        extern void _mdAssociate( void near*, void far* );

        if( !stackHandle ){
          stackHandle = _mdCreate( 8, _get_sym( "STACK" ) );
          _mdAdd( stackHandle, _get_sym("POP"),   stk_pop    );
          _mdAdd( stackHandle, _get_sym("PUSH"),  stk_push   );
          _mdAdd( stackHandle, _get_sym("DEPTH"), stk_depth  );
          _mdAdd( stackHandle, _get_sym("EMPTY"), stk_empty  );
          _mdAdd( stackHandle, _get_sym("TOP"),   stk_gettop );
          _mdAdd( stackHandle, _get_sym("_TOP"),  stk_settop );
          _mdAdd( stackHandle, _get_sym("CLASSNAME"), stk_name );
          _mdAdd( stackHandle, _get_sym("PRINT"), stk_print );
        }
        _arraynew(0);
        _mdAssociate( _eval, stackHandle );
}

           Фиг.5 Функция-конструктор для простого демонстрационного
                 класса STACK. Компилируйте MSC или TC в large-модели.

// ----------------------------------------------------------------------
//            STACK.PRG - реализация функций-методов класса STACK
// ----------------------------------------------------------------------

#command IF <cond> THEN <*statement*>  =>  IF <cond> ; <statement>; ENDIF
#translate self()  =>  qself()

//  Stack:Push( <exp> )  -  Положить элемент на стек

procedure Stk_Push( exp )
   LOCAL oStack := self()
   AADD( oStack, exp )


//  Stack:Pop() --> value  - снять со стека верхнее значение

function Stk_Pop
   LOCAL oStack := self(), valueLast, nLen
   nLen := LEN( oStack )
   IF nLen = 0  then return NIL         // Стек пуст ?
   valueLast := oStack[ nLen ]          // Получить вершину стека
   ASIZE( oStack, nLen - 1 )            // и удалить ее
   return valueLast


// Stack:Depth --> nElems  - получить число элементов на стеке

function Stk_Depth
   local oStack := Self()
   return len(oStack)


// Stack:Empty --> lEmpty  - выдать признак <стек пуст>

function Stk_Empty
   local oStack := Self()
   return oStack:depth == 0


// Stack:Top --> value  - получить значение верхушки, не удаляя ее из стека

function Stk_GetTop
   local oStack := Self()
   if oStack:empty then return NIL
   return oStack[ LEN( oStack ) ]

// Stack:Top = value  - изменить значение верхушки, не меняя указатель стека

procedure Stk_SetTop( value )
   local oStack := Self()
   if oStack:empty then return
   oStack[ LEN( oStack ) ] = value

// Stack:ClassName --> "STACK"  - выдать имя класса

function Stk_Name
   return "STACK"

// Stack:Print  -  Процедура печати содержимого стека

procedure Stk_Print
   local oStack := Self(), nLen, i
   nLen := oStack:depth
   if nLen = 0
     ? "Stack is empty"
   else
     ? "Stack( ", oStack[1]
     for i=2 to nLen
       ?? ",",oStack[i]
     next
     ?? " )"
   endif

           Фиг.6 Функции-методы для класса STACK. Компилируйте командой
                 CLIPPER STACK /N /M /W


// ----------------------------------------------------------------------
//              TSTK.PRG  -  Тест для класса STACK
// ----------------------------------------------------------------------

procedure tstk
    local a, stk := StackNew()
    stk:push( 1 )
    stk:push( 2 )
    stk:push( 3 )
    stk:push( stk:className )
    stk:top = stk:top + " is a class"
    stk:print()
    stk:pop()
    a = stk:pop
    ? "a = ", a
    stk:print()

           Фиг.7 Тестовая программа для класса STACK.
                 Компилируйте командой "CLIPPER TSTK /N /M /W",
                 компонуйте командой "RTLINK FI TSTK,STACK,_STACK"

#include "class.ch"     //  определяет, в частности, к-ду задания класса:

* #command create [<Scope:local,static,public,private>] class <ClassName> ;
*         [from <Parent>] ;
*         [methods <Proc1> as <Method1> [,<ProcN> as <MethodN>]] => ;
*         [<Scope>] <ClassName> := Class():new( <"ClassName">, <Parent>, ;
*         { [{ <"Method1">,<"Proc1"> }] [,{ <"MethodN">,<"ProcN"> }] } )

static  Stack := NIL       // Флаг "необходима инициализация"

procedure Stk_Push( exp )   //  Stack:Push( <exp> ) - Положить элемент на стек
    ......

    ......  // Здесь следуют все определения методов, как на фиг.5, кроме
            // метода className, который наследуется от класса OBJECT

function StackNew
    if empty(Stack)
      create class STACK methods ;
           stk_push as PUSH, ;
           stk_pop  as POP, ;
           stk_depth as DEPTH, ;
           stk_empty as EMPTY, ;
           stk_gettop as TOP, ;
           stk_settop as _TOP, ;
           stk_print as PRINT
    endif

    return Stack:new


           Фиг.8 Схема реализации класса STACK при наличии полноценной
                 поддержки классов.

/*      Файл COMPLEX.PRG демонстрирует введенные автором объектно-ориентированные
        расширения CLIPPER 5.0 на примере определения класса комплексных чисел.
        Используется ряд методов с предопределенными именами (для инициализации
        объекта, для его распечатки, для арифметических операций над объектом)
        Чтобы этот набор процедур стал определением класса, полученный после
        компиляции .OBJ-файл должен быть обработан программой CLASS.    */


procedure INIT( nReal, nImg )           // Инициализация комплексного числа
        local slf := self()
        if empty( nReal ) then nReal = 0
        if empty( nImg ) then nImg = 0
        aSize( slf, 2 )
        slf[1] = nReal
        slf[2] = nImg

func RE                         // Выборка вещественной части
        return self()[1]

func IM                         // Выборка мнимой части
        return self()[2]

proc _RE( nReal )               // Присваивание вещественной части
        self()[1] = nReal

proc _IM( nImg )                // Присваивание мнимой части
        self()[2] = nImg


func _2OP_PLUS( x )             // Переопределение арифметической операции '+'
        local slf := Self()
        do case
           case valtype(x) == 'N'           // Правый операнд - число
                return COMPLEX( slf:re+x, slf:im )
           case className(x) == "COMPLEX"   // Правый операнд - объект COMPLEX
                return COMPLEX( slf:re+x:re, slf:im+x:im )
           otherwise                        // Неверный тип правого операнда
                return NIL
        endcase


func _2OP_MINUS( x )            // То же, для операции '-'
        ...                     // Ветвление, аналогичное предыдущему

func _2OP_MULT( x )
        local slf := Self()
        local a,b,c,d
        a = slf:re
        b = slf:im
        do case
           case valtype(x) == 'N'
                return Complex( a*x, b*x )
           case className(x) == "COMPLEX"
                c = x:re
                d = x:im
                return Complex( a*c - b*d, b*c + a*d )
           otherwise
                return NIL              // Illegal operand type
        endcase

proc PRINT                              // Метод вывода, вызываемый по ?
        local slf := Self()
        QQOut( "("+alltrim(str(slf:re))+ ;
               if(slf:im >= 0,"+","")+ ;
               alltrim(str(slf:im))+"i)" )


function COMPLEX( nRe, nIm )            // Конструктор комплексного числа
        return class("COMPLEX"):new( nRe, nIm )

           Фиг.9 Пример определения класса с использованием разработанных
                 автором объектно-ориентированных средств.

#include "class.ch"

//      Тест для класса работы с комплексными числами

proc test
        local   x,y,z, t
        x = Complex( 1, 2 )
        y = Complex( 2, -1 )
        z = (2*x+4)*y
        ? x, y, z

                Фиг.10 Тестовая программа для COMPLEX.PRG

//      _STACK.PRG
//      Инициализация класса STACK с использованием функций Clipper 5.01

 #command create class <ClassName> size <nSize> ;
         [methods <Proc1> as <Method1> [,<ProcN> as <MethodN>]] => ;
         <ClassName> := __ClassNew( <"ClassName">, <nSize> ) ; ;
         [__ClassAdd( <ClassName>, <"Method1">,<"Proc1"> )] ;;
         [__ClassAdd( <ClassName>, <"MethodN">,<"ProcN"> )]

static  Stack := NIL       // Флаг "необходима инициализация"

function StackNew
        local oNewStack
        if empty(Stack)
          create class STACK size 1 ;           // Хотя мы хотим создать
          methods ;                             // объект-стек изначально
               stk_push as PUSH, ;              // пустым, функция __ClassNew()
               stk_pop  as POP, ;               // требует, чтобы размер
               stk_depth as DEPTH, ;            // создаваемого объекта был
               stk_empty as EMPTY, ;            // ненулевым, поэтому мы
               stk_gettop as TOP, ;             // вынуждены,
               stk_settop as _TOP, ;
               stk_print as PRINT
        endif
        oNewStack := __ClassINS( Stack )        // создав объект,
        aSize( oNewStack, 0 )                   // изменить его размер
        return oNewStack


           Фиг.11 Схема реализации класса STACK в Clipper 5.01.
                  Компилируйте командой CLIPPER _STACK /N /M /W,
                  Компонуйте командой RTLINK FI TSTK,STACK,_STACK


