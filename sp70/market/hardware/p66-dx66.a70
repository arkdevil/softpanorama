From: tut@iai.mv.com (Bill Tuttle)
Newsgroups: comp.sys.intel
Subject: Re: Pentium vs 486
Message-ID: <782253730snx@iai.mv.com>
Date: Sat, 15 Oct 94 20:42:10 GMT
Organization: Imaging Automation

mschmit@ix.netcom.com writes in article <37mv64$7ai@ixnews1.ix.netcom.com>:
> 
> The Pentium is not just 2 486's in a chip, for example, here are some machine
> cycle changes:
> 
> 
> 	486	Pentium
> 
> fadd      8-32	1-3
> fmul      11-16	1-3
> lods      5	2
> rep movs  3	1
> call      3	1
> ret       5	2
> 
> There are a lot of other minor details that are different. They all add up. The
> bottom line is that some small routines and loops can be optimized to be 2 to 10
> times faster than the 486, as far as CPU speed goes. General benchmarks fail to
> show this. The benchmarks are only good if they, fairly accurately mimic how
> applications work. With RISC processors, they are probably comparable from
> one RISC machine to the next. I don't think they are as good at predicting
> CISC performance (relative to RISC performance).
> 
> Mike
>
You can not just determine the speed improvements by looking at instruction
execution times.  I will grant that for floating point operations, the
Pentium is much faster that a 486.  You have to look at real algorithyms with
real code.  I am a software engineer with 12 years of Intel assembly language
experience.  The last 8 years has primarily been involved with graphics,
image processing and compression.

I have done extensive research and code modeling on Pentium machines.  I have
implemented several dozen routines in 'C' and 'ASM'.  All of them have been
optimized for pentium execution while not slowing down 486 execution.  What
you have to keep in mind is what is your real instruction mix.  Our target
machine base is 486SX to Pentium.  Therefore all of our fraction computations
are fixed point based, we use NO floating point.

We have done extensive performance testing of this code between a 486 DX/2 66
machine and a Pentium 66 machine.  We see an average of 75% speed improvement
in 'C' code and an average of 125% speed improvement in ASM code.  There are
many reasons for this.  First the 64 bit memory bus interface, is of limited
benifit.  If your code is memory bandwith limited it is probably fast enough
already.  Also, even though the Pentium helps you with AGI's there are other
dependencies such as simultaneous memory access to cache banks.  Next, is the
issue of code generation.  There are complex rules about instruction
dispatching.  Generally, only single clock ALU and load store instructions
can be paired.  Those instructions that received decreases in clock execution
times generally can NOT be paired.

The net result is that the combination of doubling the memory bandwith,
paired execution in two integer execution units, and decreased clock times
for some instructions averages out to a two fold improvement in perforance.
Yes different types and sections of code may get more or less improvement.
However, with the exception of pure floating point code, there is no where
near four times performance increase in real code.

Bill Tuttle -- tut@iai.mv.com

