*****************************************************
     Turbo Pascal Version 7.0
     Fast Vision 1.1
     Нечто похожее на документацию к objects.pas
     Copyright (c) 1993, 94 by RDA Software
*****************************************************

Я  ненавижу  писать  help'ы,  документацию,  комментарии и т.п., так что не
судите  меня  слишком  строго. Если что Вам будет непонятно, то попытайтесь
разобраться в исходном тексте или обратитесь ко мне.

*******************************************************
 Новые типы. По-моему, в комментариях это не нуждается
*******************************************************

  PByte = ^Byte;
  PInt  = ^Integer;
  PWord = ^Word;
  PLong = ^LongInt;
  PReal = ^Real;

*************************************
 Новые объекты и изменения в старых.
*************************************

 Новые методы в TStream
------------------------

function ReadPasString: String;
Функция   читает   стандартную  pascal'евскую  строку  из  потока,  который
является  текстовым  файлом,  т.е.  побайтно  до  тех  пор,  пока  не будет
встречена комбинация CRLF.

function ReadString: String;
Функция читает стандартную pascal'евскую строку из потока.

function ReadTextFile: PLineCollection;
Полностью читает текстовый файл в строковую коллекцию.

function StringRead: PString;
Производит  те  же  действия,  что  и  ReadPasString  и  размещает  строку,
прочитанную из текстового файла в динамической памяти.

procedure StringWrite(P: PString);
Пишет   строку   из  динамической  памяти  в  текстовый  файл,  связанный с
потоком. Пара к функции StringRead.

procedure WritePasString(S: String);
Пара к функции ReadPasString.

procedure WriteString(S: String);
Пишет в поток стандартную pascal'евскую строку.


 TData
-------
Объект-контейнер для различных данных

Size: Word;    Размер данных, хранящихся в объекте.
Data: Pointer; Указатель на данные.

constructor Init(ASize: Word);
Инициализирует  объект.  Резервирует  память  размера  ASize  и если памяти
достаточно,  то  инициализирует  ее  нулями. Если же памяти недостаточно,то
Size устанавливается в 0.

constructor Load(var S: TStream);
Читает  данные  из  потока.  Сначала  читается  длина  данных  (поле Size),
потом  (если  это  возможно)  резервируется  память  требуемого размера и в
эту  память  читаются  данные  из  потока. Если памяти недостаточно,то Size
устанавливается в 0 и чтение данных не производится.

destructor Done; virtual;
Освобождает память, занимаемую данными и сам объект.

procedure Store(var S: TStream); virtual;
Сохраняет в потоке размер данных и сами данные.


 TXMSStream
------------
Поток  в  XMS  памяти.  Для  его  работы  Вам необходимо установить драйвер
HIMEM.SYS   или  аналогичный  обеспечивающий  доступ  к  Extended  memory в
соответствии с eXtended Memory Specification.

constructor Init(AMaxSize: Word);
Инициализирует   поток  с  максимальным  размером  в  ASize  КБ.  Остальные
методы  этого  объекта  лишь  перекрывают  абстрактные  методы  из TStream,
поэтому  работа  с  ними  полностью  аналогична.  Желающие могут посмотреть
код (занятие не для слабонервных).


 TSortedCollection
-------------------
procedure Resort;
Пересортировывает  коллекцию.  Необходимо  при  изменении  ключа сортировки
(например список файлов).


 TLineCollection
-----------------
Объект для хранения динамических строк, но без сортировки
Перекрыты:
procedure FreeItem(Item: Pointer); virtual;
function  GetItem(var S: TStream): Pointer; virtual;
procedure PutItem(var S: TStream; Item: Pointer); virtual;

function MaxLen: Byte;
Возвращает   длину   самой   длинной   строки   в   коллекции.  Необходимо,
например,  при  использовании  коллекции  в  качестве "поставщика" текста в
TScroller,   когда   надо  установить  максимальные  границы  скроллинга. Я
обычно пишу: SetLimit(Lines^.Count, Lines^.MaxLen);


 TSortedLineCollection
-----------------------
Полный   аналог   TLineCollection   для   отсортированных   строк.  Похоже,
создание  этого  объекта  было  ошибкой,  т.к. он дублирует TStrCollection,
но выкинуть тоже жалко.


 TDataCollection
-----------------
Очень  удобный  объект.  Фактически  представляет собой безразмерный массив
однотипных   данных,  раазмещаемых  в  динамической  памяти.  Постоянно  им
пользуюсь,  чего  и  Вам желаю. Чувствую, что не смогу понятно рассказать о
нем, так что лучше посмотрите исходник - там все просто.

procedure CopyFrom(Src: PDataCollection);
Полностью копирует данные из однотипного обыекта.


 TSortedDataCollection
-----------------------
Полный   аналог  TDataCollection,  только  с  возможностью  сортировки.  Не
забывайте перекрывать метод Compare, так как он является абстрактным.


 TResourceFile
---------------
Метод  Error  теперь  по-умолчанию  выдает  сообщение  и аварийно завершает
программу. Желающие могут восстановить статус-кво, дважды нажав Ctrl+Y.

function SearchKey(Key: String): Boolean;
Возвращает True, если ресурс с ключом Key существует.


******************
 Новые переменные
******************
  ResFile: TResourceFile;
  StrList: PStringList;
Предполагается   их   использование   с   файлом   ресурсов,   т.к.  модуль
подключается  везде,  где  есть  хотя  бы  один  объект из Turbo Vision (во
всяком  случае,  я  так  делаю).  Ну а если нужны лишние 8 байт, то заREMте
или удалите.


****************************************************************************
Быстрые   функции   для  работы  с  различными  целыми  типами.  Лентяи  из
Borland'а  могли  бы  и сами поместить их сюда, ведь они бывают нужны очень
часто. Названия говорят сами за себя, а if not then подучите английский.
****************************************************************************

function Min(X, Y: Integer): Integer;

function Max(X, Y: Integer): Integer;

function MinWord(X, Y: Word): Word;

function MaxWord(X, Y: Word): Word;


****************************************************************************
Целый   набор   функций   сравнения.  Удобно  использовать  при  сортировке
коллекций.
****************************************************************************

function WordCmp(Key1, Key2: Word): Integer;
Функция возвращает результат сравнения двух чисел типа Word:
    -1, если Key1 < Key2;
     0, если Key1 = Key2;
     1, если Key1 > Key2.

function LongCmp(Key1, Key2: LongInt): Integer;
Тоже,  что  и  WordCmp,  только  для  LongInt'ов.  ВНИМАНИЕ!  Помните,  что
LongInt - знаковый тип, для двойных слов используйте DWordCmp.

function DWordCmp(Key1, Key2: LongInt): Integer;
Тоже,  что  и  WordCmp,  только  для  двойных  слов.  Я не забыл о том, что
LongInt  -  знаковый  тип,  но  использовал  его  для  удобства записи. Эта
функция при сравнении НЕ УЧИТЫВАЕТ ЗНАКА чисел.

procedure SetFlags(var X: Word; Flags: Word);
Аналогична операции X := X or Flags (установка флагов). В 1.5-2 раза
медленнее (в простых случаях, но в них она и не нужна), размер-?,
но запись короче, т.к. обычно: X^.Options := X^.Options or ofXXXX; и т.п.
Вместо этого предполагается:   SetFlags(X^.Options, ofXXXX); Но нужно ли
экономить 5-10 тактов (если Вы, конечно, не создаете тысячи окон)?

procedure ClearFlags(var X: Word; Flags: Word);
Аналогична X := X and not Flags (сброс флагов).


*************************************************************************
 Аналоги C'шных SetJmp и LongJmp, осуществляющих длинные переходы. Текст
 взят из книги С.В. Мизрохи "TURBO PASCAL и объектно-ориентированное
 программирование".
*************************************************************************

type
  TLongJmp = record
    SpReg, BpReg: Word;
    JumpPtr: Pointer;
  end;

procedure SetJmp(var JumpDest: TLongJmp);
procedure LongJmp(var JumpSource: TLongJmp);


******************************************************
 Набор процедур и функций обмена для различных данных
******************************************************

function SwapByte(X: Byte): Byte;
Меняет местами старшую тетраду в байте с младшей

procedure SwapPtr(var P1, P2: Pointer);
 Выполняет: P := P1; P1 := P2; P2 := P
