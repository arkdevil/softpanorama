*****  Computer Select, January 1994  : Articles *****

Journal:    PC Week  Dec 13, 1993 v10 n49 p103(2)
COPYRIGHT Ziff-Davis Publishing Company 1993
-------------------------------------------------------------------------
Title:     Software development on front burner.
             (PC Week LABS: First Looks)
Author:    Coffee, Peter


Abstract:  Software developers look to foreign development sites to solve
           problems with programming productivity and the cost of
           software development. One reason overseas development is
           appealing is lower salary costs; such places as Hong Kong and
           India offer trained, experienced software developers at
           salaries as low as $180 to $250 per month. Overseas
           development also offers savings from fewer development delays
           and better quality. Research by Caper Jones indicates that
           software made in Japan has as much as 99 percent fewer bugs
           per line of code than software developed in America. Such
           prevalence of program errors significantly affects the time it
           takes for new products to be released. There is a higher level
           of investment in the software-development process overseas;
           software is considered a manufactured product, so software
           project management and quality are better.
-------------------------------------------------------------------------
Full Text:

Programming productivity and the cost of software development have
emerged as mainstream economic issues. A recent National Public Radio
"All Things Considered" program featured interviews from Bombay
discussing the low cost and high quality of software development in
India. Millions of corporate decision makers, listening as they drove
home, may have wondered where their own software-development dollars are
going and what they are getting in return.

In places such as Hong Kong and India, software developers with technical
degrees and two or more years of experience command salaries on the order
of those paid to cabinet-level ministers of their national governments --
something in the range of $180 to $250 per month.

Visitors from the United States are astonished by the quality of this
talent: On that NPR radio broadcast, one U.S. executive said, "I was
prepared to give low-tech work, but for the same dollars I can get
designer-level people. All I have to do is make the process work at a
distance."

It is ironic that by adopting tools such as formal specification
languages and application prototypes, sofware engineers are making it
much easier for their management to contemplate going offshore for the
actual development effort.

In his 1987 book "Crunch Mode," John Boddie observed, "Most programs
spring from truly wretched specifications, if indeed there are any
specifications at all." Boddie described the "ritual dance of successive
approximation" that can only be joined by developers with "an
appreciation of the cultural aspects of the problem and the user's agenda
for its solution." This vague and reiterative process makes it hard to
carry on development without a common culture, language, and daily
interaction between develope rs and users.

"Now, armed with detailed design documentation and specifications,"
Boddie warned, "the programmer needs only to translate the requirements
into code. ... It is the analyst, through improved specifications, that
allows the foreign programmer to do an acceptable job."

Why should management embrace overseas development? Not merely because of
lower staff salary costs -- the actual cost of software-development
salaries in most corporations is only a small percentage of total costs,
but the costs of software-development delay and poor software quality can
be much greater (though often much less obvious).

"Software is `in series' with 90 percent of what we do," estimated one
manager interviewed by Edward Yourdon in his 1992 book "The Decline and
Fall of the American Programmer." What that manager was saying was that
software failure implied overall project failure, even if the software
represented a small part of total project costs.

Software in Japan has been found, in some cases, to have 99 percent fewer
bugs per line of code than the typical American product, according to
research by Capers Jones.

This has major implications for achieving quick time to market of new
products and services, given the "in series" role of software in product
design, manufacturing, billing for services, and, increasingly, in
product function with more and more industrial and consumer products
deriving much of their utility from embedded software.

Corporate decision makers are looking offshore because they find higher
levels of investment in the software-development process. Both software
project management and software quality are more impressive in countries
that treat software as a manufactured product -- one that can benefit
from the same attention to constant process improvement as found, for
example, in the Japanese automobile and consumer electronics industries.

In this Tech View, PC Week Labs will examine some of the major factors
affecting the cost and quality of software development and will describe
some of the tools that readers may wish to consider in their pursuit of
better solutions.

Beyond language

In a recent Tech View (see PC Week, Nov. 29, Page 97), PC Week Labs
examined features of programming languages that affect the reliability of
software and the productivity of software development.

But even the perfect programming language, assuming that such a thing
exists, would be only a part of the solution. With 50 percent to 80
percent of software-development dollars going to correction and
enhancement of existing code, new languages cannot eliminate the billions
of lines of "legacy code." Nor does the invention of a new language imply
the immediate free retraining of existing development staff.

Moreover, the writing of code represents only a slim majority of the
effort involved in any substantial software project. As shown in the
table above, derived from data presented in Barry Boehm's 1981 book
"Software Engineering Economics," all of the programming that takes place
during the design, programming, and testing phas- es of a typical
32,000-line project represents only 58 percent, or about 53 man-months,
of the 91 man-months that would be a preliminary estimate for a project
of this size.

What are the non-language components of the programming process, and how
can they be done better without the drastic step of migrating development
staff to a higher-order language? What happens during the other 38
worker-months, and how can those tasks be made more productive?

Most common errors

The most common origin for software errors, according to a 1987 study by
James Collofello and Jeffrey Buck, is the creation of new defects in
previously working features as a side effect of adding new features. This
accounted for 53 percent of the errors that Collofello and Buck
encountered.

To prevent such errors, language designers turn to information-hiding
techniques (such as those found in Ada and Modula-2) and to the
encapsulation of internal details that comes with object-oriented
languages (such as Smalltalk and C++).

Where language migration is not an option, developers would do well to
look at the latest generation of version-control tools, which makes it
much easier to establish what was done to a piece of code, when, and by
whom.

Version-control tools generally keep only the latest version of any given
file intact for instant retrieval, with the option of reconstructing any
previous version.

This also makes it possible to generate a report showing the differences
between any two versions of a file, along with the comments that may have
been attached when new versions were "checked in" to the system.

New version-control products such as Mortice Kern Systems Inc.'s RCS and
Microsoft Corp.'s Delta make use of GUI environments to offer visual
display of file differences.

Even more important, however, are the capabilities of identifying
collections of related files that represent a release of an overall
project, and of managing multiplatform software products with both common
and platform-specific elements.

The dominant version-control tool, driven by requirements such as this,
is Intersolv Inc.'s well-supported but rather expensive PVCS, which is
also found as an embedded tool (or supported by add-in menus) in products
such as Powersoft Corp.'s PowerBuilder and Digitalk Inc.'s
Smalltalk-based Team/V multiuser development environment.

Another tool aimed specifically at multiplatform, multirelease
environments is Softool Corp.'s CCC/Manager. An attractive though less
well-known product is Burton Systems Software Inc.'s TLIB, a low-cost,
high-performance tool with legions of happy users despite its far less
pervasive advertising. Those with specialized requirements or even
tighter budgets can find several shareware and public-domain
version-control products.

Another vital component of software quality assurance is the assignment
and tracking of responsibility for defects as they are identified and
resolved. PC Week Labs has evaluated The Software Edge Inc.'s Defect
Control System (see PC Week, Nov. 29, Page 83) and found it an
exceptionally well-designed set of tools for tracking individual items
and analyzing trends in defect identification and resolution.

Another product worth considering is UnderWare Inc.'s Track Record, a
less narrowly focused and less expensive product than Defect Control
System, but also less capable.

Logically speaking ...

Breakage during "improvement" is the most common origin for errors, but
incorrect and missing program logic are the most common types of error --
accounting, respectively, for 64 percent and 23 percent of the errors
found in the Collofello and Buck study.

How can these errors be reduced?

Again, there are language-based attacks upon the problem. The surest ways
to minimize errors in logic are to minimize the number of statements
required to describe the problem and to minimize the conceptual distance
between the user's description of the problem and the language of the
program that solves it.

The first approach leads to languages such as Smalltalk and Ada, which
deliver the same function in one-fifth or one-tenth the number of lines
required by C or COBOL.

The second approach leads to formula-based tools such as Lotus
Development Corp.'s Improv, declarative programming tools such as Prolog,
or decision-support tools such as SAS Institute Inc.'s SAS.

But we're assuming that maintenance considerations make it impractical to
move software-development efforts into another language. What can be
added to an existing base of language tools and skills to make logic
errors less common?

One of the biggest steps that can be taken is to move away from
handwritten code toward code generators, which let programmers work at
the level of specifications rather than the level of executable
statements (see table, Page 103). In COBOL, Ada, and client/server
(C-based) environments, Texas Instruments Inc.'s Information Engineering
Facility is a supreme example, but this mainframe-hosted environment is
larger and more expensive than many organizations can afford to acquire
or support.

On a far more modest scale, Logic Technologies Inc.'s DOS-based Logic Gem
allows programmers to specify sets of conditions, automatically
generating both English-language documentation and executable code in C,
FORTRAN, Xbase, BASIC, COBOL, or Pascal.

Count the right things

It's axiomatic that things unmeasured are impossible to control, and
software development in most organizations is woefully short of
quantitative measures.

Some such measures are output-oriented, such as lines of code per unit of
effort. However, this should be strongly discouraged as the sole measure
of productivity because lines of code are arguably a cost of delivering a
capability, rather than a product in their own right.

More relevant to meeting mission goals are performance- and
process-oriented measures, such as defect rates, timing and magnitude of
changes to specifications, and responsiveness to requests from both
internal and external customers. Tools such as Defect Control System are
well-suited to many of these tasks, but development managers should not
hesitate to employ a database product and source-code analysis tools to
develop customized process analysis systems.

The other hazard of counting is that the wrong things will be added up.

If only new code is considered as a measure of work performed, there is
little or no incentive -- perhaps even a disincentive --for programmers
to seek existing reusable modules or to make the additional effort
required to make a module reusable when it is originally written.

In general, reusability is not rewarded, not managed through
configuration management or version control, not made convenient through
library browser tools, and not filtered to ensure that the code made
available for reuse is of uniformly high quality. This is just about the
worst thing that a software-development organization can do to itself.

Recycling code

Reuse of code can take many forms, ranging from cut-and-paste copying to
the packaging of code in a DLL (dynamic link library).

DLLs can be updated, thereby improving the performance of all other
programs that use that module, without any intervention by their
developers or maintainers.

Though generally written in non-object-oriented languages, DLLs deliver
the critical process improvement most often attributed to object-oriented
techniques: They formalize the interface to a function, hiding the
details of its implementation, and let other software treat it as a
plug-in unit that can be updated without unexpected side effects.

Developers should therefore require that their "legacy" tools, such as
COBOL and C compilers, offer the ability to encapsulate working code in
DLL form. Developers should also seek out prototyping tools, such as GUI
builders, that can easily exploit such DLLs to create new graphical
packaging for existing line-of-business applications.

Back to basics

One should not ignore the most fundamental of tools, such as the
programmer's source-code editor. In one of the few comprehensive
life-cycle bug logs for a major piece of software (the TEX
text-formatting package), Donald Knuth found that he tended to make
conceptually similar errors. Good programming editors make it easy to
look at similar lines as a group, no matter how widely separated they may
be in the actual source-code files, encouraging programmers to be their
own best auditors.

Programming editors such as Mansfield Software Group Inc.'s KEDIT and the
IBM EPM Editor that is bundled with OS/2 all provide variations on this
addictive capability.

Other addictive utilities have grown up in the programmer-driven
environment of Unix. Mortice Kern Systems' MKS Toolkit, Hamilton
Laboratories' C Shell, and Thompson Automation's Thompson Toolkit all
offer DOS, OS/2, and/or NT versions of these utilities, with the kind of
file-management and analysis features that encourage an enterprising
manager to build a quality-oriented software-development shop.
-------------------------------------------------------------------------
Topic:     Trends
           Foreign Manufacture
           Software Quality
           Software engineering
           Time to Market
           Product Development
           Cost of Programming


Record#:   14 809 723
                              *** End ***
