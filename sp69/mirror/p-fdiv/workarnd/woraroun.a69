From: rocket@panix.com (mike halem)
Newsgroups: comp.sys.intel
Subject: Pentium Bug Work Around
Date: 23 Nov 1994 16:56:49 -0500
Organization: PANIX Public Access Internet and Unix, NYC
Message-ID: <3b0dr1$1qu@panix2.panix.com>

Here's a work around for the pentium bug that could be implemented somewhat
efficently in a compiler.  It would allow recompiled applications to run
with full double precision accuracy and with a minimum of impact.

(I apologize if the MATLAB Chief Scientist has created a similar algorithm
as was suggested in a news article I read on a wire service.  As it is not
in this newsgroup and I do not read the MATLAB group (I don't own it), I did
not see it as of the time of this writing.  Regardless, I created this
algorithum independently last night.)

1) Add a compiler switch to generate FDIV checked code.

2) When the switch is on, have it insert the following algorithm for FDIV's
only:

	-Do the FDIV using Pentium's defective FPU.
	-Multiply the results by the denominator and compare to the
	Numerator (in the FPU).
	-If the results are not the same within the limits of double
	precision rounding error, do the division using the integer
	portion processor using standard FP emulation code.

The code could be generated in-line or in a function, depending on the need
to conserve memory or to get greater execution speed.  A compromise could be
struck for in-line code gen where only the division emulation is moved to a
function.  An startup function could check the processor to see if it
harbors the bug, and then bypass the checking for good Pentiums.  

There would be the execution overhead of the multiply and the compare for
each division, but without having a pentium instruction timing sheet, I
would guess that this would only slow the total operation by not more than
two to one.  (FMULs and FCMPs are typically faster than FDIVs.) Because the
errors are indeed rare, (lets say 1:10^-4), even if emulation division is
much slower, it will not appreciably change average performance for random
inputs.  This is the tradeoff we must pay for accuracy if Intel stiffs us on
a chip exchange. An startup function could check the processor to see if it
harbors the bug, and then bypass the checking for good Pentiums.

I am donating this algorithm to anyone who wants it.  I hope that microsoft
implements it for me in VC++, and recompiles and distributes Access and
Excel, the applications that I use.  Maybe other companies can show their
ability to compete by being the first to offer the correction.

Finally, I am not saying this is the best algorithm.  If you have a better
one, please contribute it.

Michael A. Halem
rocket@panix.com

