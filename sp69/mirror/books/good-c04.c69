Newsgroups: comp.lang.c
Subject: Good C Book           4/9
From: david.mohorn@sourcebbs.com (David Mohorn)
Message-ID: <14.21665.711@sourcebbs.com>
Date: Mon, 14 Nov 94 00:07:00 -0005
Organization: SelectiveSourceBBS Virginia Beach (804)471 6776

Subject: Good C Book

(Continued from previous message)

@@ a smaller type, high-order bytes are lost.
When an integer value is converted to a signed type which can't hold that
value, the result need not be that given by removing some bits. For example,
a rule that converted all such values to the minimum value of the destination
type (SCHAR_MIN, SHORT_MIN, INT_MIN) would be conforming.

A simpler way to state what this section means is:
* If the source value can be represented in the destination type, it is
  unaltered.
* Otherwise, if the destination type is unsigned, reduce the value modulo
  U<type>_MAX+1.
* Otherwise the destination type is signed and the value is implementation
  defined.

6.2.1.4
@@ When converting a larger [floating] type into a smaller one, if the value
@@ cannot be represented, information content may be lost.
Actually, unlike integers, such conversions are undefined, and the program
may crash as a result.

6.2.1.5
@@ these automatic conversions are also intuitive.
These conversions have been the subject of much debate. This section would
benefit from a proper explanation of the "value preserving" rules, and why
they were chosen.

6.2.2.1
@@ First, an array name without an index is a pointer to the first element of
@@ the array and is not an lvalue.
This has to be one of the worst expressions of the Rule I have ever seen !
First, there are a number of contexts (such as sizeof) where an array name
does *not* get changed to a pointer. Second, if the decay to a pointer takes
place at all, it takes place whether or not there is an index; for example,
decay takes place when the array name is used as a function argument. Last,
an array name *is* an lvalue; it is the resulting pointer that is not.

6.2.2.3
Considering how often they are used, the rather peculiar way they are
specified, and the need to cast them in some contexts but not others, it is
odd that null pointer constants are not mentioned at all.

6.3
@@ The standard states that when an expression is evaluated, each object's
@@ value is modified only once. In theory, this means the compiler will not
@@ physically change the value of a variable in memory until the entire
@@ expression has been evaluated. In practice, however, you may not want to
@@ rely on this.
The book then in effect goes on to say that "i = ++i + 1" is usually compiled
as if it were "i += 2".

As anyone who has survived the "i = i++" thread on comp.lang.c knows, this is
not only nonsense, but dangerous nonsense. The correct way to discuss this
part of the standard is to point out what can and can't be done in a strictly
conforming program, and leave it at that. Suggesting that such code can ever
have a defined answer is asking for trouble.

@@ The rest of this section formally defined what type of lvalue can refer to
@@ an object.
Well, in one sense this is true. However, what is important is *why* only some
lvalues can refer to a given object, and the annotations completely skip this.
The reason is, of course, to indicate when a compiler can assume that two
identifiers refer to the same object. For example, in:

    char *cp;
    int *ip;

    void f (double *d)
    {
        *d = 3.14159;
        *cp = 1;
        *ip = 2;
    }

The rules of this section say that the assignment to *cp could potentially
alter *d, and the compiler must generate code that takes that into account,
but the assignment to *ip cannot, and the compiler may assume that *d and *ip
do not overlap. This is called "aliasing", and knowing when aliasing takes
effect is an important factor in correctly optimising code.

6.3.2.2
@@ When no prototype for a function exists, it is not an error if the types
@@ and/or number of parameters and arguments differ. The reason for this
@@ seemingly strange rule is to provide compatibility with older C programs in
@@ which prototypes do not exist.
On the contrary, when no prototype exists, the number of arguments to a call
must be the same as the number of parameters in the function (which cannot
be a varargs function), and the types must be compatible after promotion.
What should have been written is that no error message is required if these
rules are broken.

6.3.2.3
Though this section mentions the existence of the "common initial subsequence"
rule for unions, it does not explain it properly, nor does it mention that
in all other circumstances assigning to one element of a union makes all other

(Continued to next message)

