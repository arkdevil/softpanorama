Newsgroups: comp.lang.c
Subject: Good C Book           8/9
From: david.mohorn@sourcebbs.com (David Mohorn)
Message-ID: <14.21669.711@sourcebbs.com>
Date: Mon, 14 Nov 94 00:07:00 -0005
Organization: SelectiveSourceBBS Virginia Beach (804)471 6776

Subject: Good C Book

(Continued from previous message)

- hash:  for "o" conversion, ensure that the first digit is a zero;
         for "x" conversion, a non-zero result will begin with "0x";
         for "X" conversion, a non-zero result will begin with "0X";
         for floating-point conversions, there will always be a decimal point
         even if no digits follow it;
         for "g" and "G" conversion, trailing zeroes are retained;
         hash may not appear on any other conversions;
- zero   explained on page 133.

The field width is an asterisk or a decimal integer. If the converted value
has fewer characters that the field width, it is padded to the width (unless
altered by the flags, the padding is with spaces on the left). The field width
cannot reduce the width of the converted value. Note that a zero at the start
of the width is the "0" flag; it does not mean that the width is in octal.

The precision is a dot followed by an asterisk, a decimal integer, or nothing
(equivalent to zero). It can only appear with certain conversions, and its
meaning varies:
d, i, o, u, x, X: the minimum number of digits to appear
e, E, f:          the number of digits after the decimal point
g, G:             the maximum number of signficant digits
s:                the maximum number of characters to be taken from the string
It must not appear with any other conversion.

If the width, precision, or both, is an asterisk, the actual value is taken
from an int argument to the fprintf() function. The arguments are always in
the order:
* width if an asterisk
* precision if an asterisk
* actual value to be converted
A negative width means add the "-" flag and use the absolute value; a negative
precision means that the precision should be treated as if omitted.

The optional letters may appear as follows:
h with d, i, o, u, x, X:
  the argument value (which is int or unsigned int) will be converted to
  short or unsigned short before printing;
h with n:
  the argument is a (short *) rather than a (int *);
l with d, i, o, u, x, X:
  the argument is long or unsigned long
l with n:
  the argument is a (long *) rather than a (int *);
L with e, E, f, g, G:
  the argument is a long double rather than a double.
These letters may not appear with any other conversion.

7.9.6.2
Both the examples of scansets don't use a field width. This means that if the
user inputs a line which is too long, it will overflow the buffer with
potentially disasterous results. They also use "fflush(stdin)", which is
undefined. Finally, the comment after that use is:
@@ /* clear crlf from input buffer */
The Standard doesn't even talk about "crlf" pairs, and except in discussing
the meaning of text streams (7.9.2), use of the term is inappropriate.

7.9.7
The annotations talk about "high order byte" and "low order byte" as if an
integer only has two bytes. In any case, these functions are not defined in
terms of "bytes", but in terms of conversion to unsigned char.

The first example calls fgetc() and assigns the result to a char variable.
This means that an error or end-of-file will cause the program to loop forever.

7.9.10.2
@@ The following fragment illustrates how files are commonly read:
@@    do {
@@        ch = fgetc (fp);
@@        /* ... */
@@    } while (!feof (fp));
This example suffers from the "Pascal disease". The function feof() does not
mean "end of file has been reached", but means "a previous read hit end of
file and returned EOF". Thus, when the last character of the file is read and
processed, "feof (fp)" will still be false, and the loop will be repeated one
more time. This time, ch will be set to EOF, but there is no indication in
the annotations that this must be treated specially. Only after this EOF has
been processed, probably wrongly - for example, if the file is being copied
to somewhere else, a spurious character will be output - will the call to
feof() return true.

7.9.10.3
@@ Also, for files opened for binary operations, EOF is a valid binary value
@@ and does not necessarily indicate an error or end-of-file condition.
This is dangerous nonsense, caused because the annotations use char variables
instead of ints to hold the results of fgetc(). What the standard says is, in
effect, that fgetc() returns a positive or zero value if it read a character,
and a negative value (EOF) if it reached end-of-file or an error occurred.

It is true that EOF, cast to the type unsigned char, is identical to value
that can be read from a binary file (or even a text file). However, this is
just the effect of bad programming; anyone with experience in C file handling
should be aware of this.

7.10.1

(Continued to next message)

