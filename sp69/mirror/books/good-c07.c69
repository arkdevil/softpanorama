Newsgroups: comp.lang.c
Subject: Good C Book           7/9
From: david.mohorn@sourcebbs.com (David Mohorn)
Message-ID: <14.21668.711@sourcebbs.com>
Date: Mon, 14 Nov 94 00:07:00 -0005
Organization: SelectiveSourceBBS Virginia Beach (804)471 6776

Subject: Good C Book

(Continued from previous message)

occur.

7.1.6
The annotations include an example of offsetof(). Unfortunately, the
explanation of this example assumes that there is no padding in the structure.
If structures had no padding, offsetof() wouldn't be needed because the offset
of a field could be computed from the sizes of the preceeding fields.

7.3
These functions are nearly all locale dependent: whether a character is a
letter depends on the language in use as well as the character set.
Unfortunately, the opportunity to explain this has been omitted in favour of
a long example printing lines like:
@@    x is alphanumeric

7.4.1.1
@@ The setlocale() function sets all or a specified portion of those items
@@ described in the lconv structure
This is true in one sense, but oh so misleading. The setlocale() function
alters the meaning of many of the functions in the standard. For example, it
can change which characters are letters, or it can alter the decimal point
character. It can also affect the order in which strcoll() sorts strings.
In all, there are five "categories" that it can affect. The lconv structure
is affected by two of these, but not the other three, and it is not the only
thing that these two affect.

7.6
The example calls setjmp() using the statement:
@@      result = setjmp (jumpbuf);
Unfortunately, the standard puts strict limits on the places in which setjmp
can be called; essentially it must be one of the four forms:
    while (setjmp (jumpbuf))
    while (setjmp (jumpbuf) < 42)
    while (!setjmp (jumpbuf))
    setjmp (jumpbuf);
[The "while" may be replaced by "if" or "switch", or may be the implicit
while of a "for" statement.]
The example in the annotations, however, doesn't use any of these forms, and
so the compiler must produce a diagnostic for this code.

The standard also puts limitations on what can be done with local variables
in functions that call setjmp(). I am surprised to find no mention of these
limitations at all.

7.7
There is no mention of the type sig_atomic_t, and when it should be used.

7.9
@@ The type fpos_t is some type of an unsigned integer.
Actually, not only is there no such requirement in the standard, but fpos_t
was designed for the circumstances when a file position *can't* be fitted
into an unsigned long. The forthcoming Normative Addendum 1 also puts further
requirements on fpos_t which, while compatible with the current standard, can
*not* be implemented if it is an unsigned integer.

7.9.2
@@ Thus, it is permissible for a text stream to treat all characters as part of
@@ one long, uninterrupted line, if it so chooses.
Fine sounding words. I wish I knew what they mean !

The standard states that an implementation may treat spaces at the end of lines
in text files specially, and may add and remove zero bytes at the end of binary
files. Neither of these rules are mentioned.

7.9.5.2
There is no mention of fflush(NULL), nor that fflush cannot be applied to
an input stream.

7.9.6.1
@@ Note that if stream is a pointer to stdout,
Just a nit, but stdout is a pointer, and stream cannot point to it.

Here, and in many other places, printf() is called with a format of "%lf" and
a corresponding argument which is a double. Unfortunately, the standard states
that "%f" is the correct format for a double, and "%lf" is undefined. This is
a particularly bad sin because the description of the "l" flag is missing
(left page 132 of the book is a repeat of page 131).

While I cannot of course just copy the missing text, I can summarise what has
been lost.

After the % appear:
- optional flags
- an optional field width
- an optional precision
- an optional "h", "l", or "L"
- a character specifying the conversion type

The flags are:
- minus: left justify the conversion within the field width, instead of right
         justify;
- plus:  any signed conversion will begin with a plus or minus sign;
- space: any signed conversion which does not begin with a sign will be
         prefixed with a space; this is ignored if the plus flag also appears;

(Continued to next message)

