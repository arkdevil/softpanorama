Newsgroups: comp.lang.c
Subject: Good C Book           6/9
From: david.mohorn@sourcebbs.com (David Mohorn)
Message-ID: <14.21667.711@sourcebbs.com>
Date: Mon, 14 Nov 94 00:07:00 -0005
Organization: SelectiveSourceBBS Virginia Beach (804)471 6776

Subject: Good C Book

(Continued from previous message)

then the type of v is:
    unsigned char *[5];

6.5.7
@@ The general form of an initialization is
@@    type var = initializer;'
Once again, the whole concept of declarators is omitted. While it is true that
that is one form of an initialization, it excludes lines like:
      int a [5] = { 1, 2, 3, 4, 5 };

6.6.4.2
This is another example where the annotations describe a "general form"
which isn't. In this case, it implies that the "default" case label must be
the last one in the switch, and that it can't have an associated "break".
The problem with these "general" forms is that, while they are fine in a
teaching context, they omit all the grubby details that a user of the standard
needs to know, such as fall-through cases, or Duff's Device.

I would also have appreciated a warning that ordinary labels are still allowed
within the body of a switch statement, so:
    switch (i)
    {
    /* ... */
    defualt:
        j = 0;
        break;
    }
is legal code, but is *not* the default case of the switch.

6.7.1
@@ To understand the difference between the modern and old forms, here is the
@@ same function defined using both forms:
@@    /* Modern function definition. */
@@    float f (int a, char c)
@@    {
@@      /* ... */
@@    }
@@    /* Old-form function definition. */
@@    float f (a, c)
@@    int a;
@@    char c;
@@    {
@@      /* ... */
@@    }

Unfortunately, these two aren't exactly the same. With the modern function
definition, the argument corresponding to c is converted to type char and
passed to the function. With the old-form definition, it is converted to int,
passed to the function as an int, and then converted to char.

Why does this matter, you may ask ? Well, it matters when we're trying to
write a prototype for the function. The prototype for the new form definition
is:
    float f (int a, char c);
as you might expect. However, the prototype for the old form is:
    float f (int a, int c);

6.8.2
@@ The #include statement has these two forms:
Actually, it has three forms. While the third is fairly uncommon, it ought at
least to be acknowledged.

6.8.3
Probably just a typographical error, but the expansion near the bottom of the
page is:
  printf ("%d ", ABS (((-20) < 0 ? -(-20) : (-20)));
and should be:
  printf ("%d ", ((-20) < 0 ? -(-20) : (-20)));

6.8.6
There is no mention of the fact that using any #pragma in a translation
unit (this means after #ifdef'd-out code has been removed) prevents it from
being strictly conforming.

7.1.2
The title of this subclause is: "Standard headers", but the annotations
begin with: "A header file". This obscures the fairly important point that
the standard headers need not be files; there is at least one implementation
where the effect of the standard headers is known by the compiler, and there
are no such files at all.

@@ All conforming C compilers will supply all of the functions described here.
This only applies to "hosted" implementations, and is not true for
"freestanding" implementations.

7.1.3
@@ Frankly, many C programmers are not aware of the rules described in
@@ this section.
Quite right ! Unfortunately, the chance to explain the rules was missed.

7.1.4
@@ If errno is zero, then no error has been detected.
This isn't true at all. No library function will ever set errno to zero, but
if it *is* zero before one is called, it can remain zero even if an error does

(Continued to next message)

