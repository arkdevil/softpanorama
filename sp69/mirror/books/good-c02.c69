Newsgroups: comp.lang.c
Subject: Good C Book           2/9
From: david.mohorn@sourcebbs.com (David Mohorn)
Message-ID: <14.21663.711@sourcebbs.com>
Date: Mon, 14 Nov 94 00:07:00 -0005
Organization: SelectiveSourceBBS Virginia Beach (804)471 6776

Subject: Good C Book

(Continued from previous message)


5.1.1.3
The standard is clear that diagnostics are required when syntax rules and
constraints are violated, and are optional otherwise. This is not covered at
all. Instead we get the vague statement that
@@ The standard requires that a compiler issue error messages when an error
@@ in the source code is encountered.
without discussing the different kinds of errors.

5.1.2.2
@@ You are therefore free to declare main() as required by your program.
This statement is immediately followed by the example:
    void main (void)
even though the text of the standard directly opposite states that this is
undefined. Indeed, the text I quote makes me wonder whether Schildt believes
that:
    struct foo { int i; double d; } main (double argc, struct foo argv)
is permitted !

Most of the examples in the book declare main() as void. I won't bother to
point them out individually.

5.1.2.2.1
@@ Though most compilers will automatically return 0 when no other return
@@ value is specified (even when main() is declared as void), you should
@@ not rely on this fact because it is not guaranteed by the standard.
Indeed it is not. If main() is declared as void, I don't know of any compiler
that will return 0. Indeed, the standard forbids it to !

5.1.2.3
This section is often called the "as if" rule, because it says that an
implementation may do anything providing that the effect is "as if" the
exact wording of the standard was followed. This is almost completely ignored
in favour of explaining "side effect" and "automatic storage".

5.2.1.2
@@ Therefore, a multibyte character is a character that requires more than
@@ one byte.
Ignoring the fact that "character" and "byte" are synonymous in the standard
(something that is not mentioned in the annotations), the definition of
multibyte character is clear that it *does* include single byte characters.

@@ First, the null character may not be used except in the first byte of a
@@ multibyte sequence.
I read this as meaning that the multibyte character <00><94> is legal while
the multibyte character <94><00> is not. In actual fact, the standard states
that a zero byte must not appear in *any* multibyte character other than the
null character (i.e. the end of string indicator). This means that string
operations such as strcpy will work as expected with multibyte character
sequences.

There was an opportunity here to explain multibyte characters and how to
use them, something that most books omit. Unfortunately, this one omits it
as well.

5.2.3
@@ In other words, one copy of a library function in memory may not be used
@@ by two or more currently executing programs.
This is blatant nonsense - on most Unix systems, if the same program is
executing several times, all the code is shared by both processes. Indeed,
many go further and share one copy of the standard C library among every
process on the system.

What this section of the standard is talking about is re-entrancy. The
functions in the library are not re-entrant, and so may not be called from
within themselves. For example:
* qsort() cannot be called from within the compare function passed to qsort();
* if a signal can be raised within a library function (perhaps by an external
  event such as the user pressing a BREAK key), then the signal handler must
  not call that library function.
The latter rule is particularly important: code using malloc must not call
malloc from within signal handlers.

5.2.4.1
@@ A compound statement is a block of code.
A nice sounding statement, but totally meaningless. A compound statement is
a block of code beginning with { and ending with the matching }. For example,
the body of a function is a compound statement.

5.2.4.2
@@ First, notice that a character is defined as 8 bits (1 byte). All other
@@ types may vary in size, but in C a character is always 1 byte long.
Certainly a character is always 1 byte long, since that is what a byte is
defined as. However, nowhere does the standard require a byte to be 8 bits;
an implementation with 47-bit bytes can conform to the standard.

The assumption that 1 byte = 8 bits occurs at several other points in the book.
I won't always bother to point it out.

6.1
The book carefully talks about tokens, and then proceeds to mention
preprocessing tokens, while totally failing to note the difference, or why
both concepts exist. I would have thought that this was exactly the sort of
thing annotation was all about.

(Continued to next message)

