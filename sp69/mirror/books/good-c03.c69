Newsgroups: comp.lang.c
Subject: Good C Book           3/9
From: david.mohorn@sourcebbs.com (David Mohorn)
Message-ID: <14.21664.711@sourcebbs.com>
Date: Mon, 14 Nov 94 00:07:00 -0005
Organization: SelectiveSourceBBS Virginia Beach (804)471 6776

Subject: Good C Book

(Continued from previous message)


6.1.1
@@ No other keywords are allowed in a conforming program.
False. Other keywords are allowed, providing that they either occupy the
implementation namespace (such as "__far"), or that they are only used after
inclusion of a non-standard system header. For example, a compiler could
state that, following "#include <8086.h>", "far" is a keyword. Since no
strictly conforming program can include that header, and providing that "far"
is not treated specially without it, such a compiler would conform to the
standard.

Of course, no other keywords are allowed in a *strictly* conforming program.

6.1.2
If one is going to mention that only the first six characters of external
names are significant, one should also mention that the case of those six
characters is not.

6.1.2.1
@@ * File scope begins with the beginning of the file and ends with the end
@@ of the file
@@ * Block scope begins with the opening { of a block and ends with its
@@ associated closing }.
This is not true: while the scopes end as described, they begin, for each
identifier, at the end of its "declarator" (that is, at the comma, equals
sign, or semicolon after it is declared). This is particularly important for
idenfifiers with block scope. Consider this code:

    /* Line 1 */ {
    /* Line 2 */    int i = 10;
    /* Line 3 */    {
    /* Line 4 */        int j = i;
    /* Line 5 */        int i = 5;
    /* Line 6 */        printf ("i = %d, j = %d\n", i, j);
    /* Line 7 */    }
    /* Line 8 */ }

All three variables have block scope, but they are different:
  outer i: from the "=" on line 2 to the "}" on line 8
  inner i: from the "=" on line 5 to the "}" on line 7
        j: from the "=" on line 4 to the "}" on line 7
In particular, the "i" on line 4 refers to the one in the outer block, and
so j has the value 10, not 5.

6.1.2.2
@@ Identifiers with external linkage are accessible by your entire program
Once again this is in error - for example, an identifier with external linkage
is not accessible in a translation unit that uses the same name with internal
linkage. The point of linkage is to indicate when the same identifier refers
to the same object, yet the annotations omit this entirely.

6.1.2.3
There is no mention of the fact that each structure and union type has its
own namespace, so that more than one structure or union can have a field
with a given name.

6.1.2.5
@@ An unsigned integer expression cannot overflow. This is because there is
@@ no way to represent such an overflow as an unsigned quantity.
More nonsense. An implementation either does or doesn't have a way to represent
overflow - usually integers don't, while floating point may or may not (some
systems have INFINITY values that effectively indicate overflow). However,
an unsigned integer expression cannot overflow because the standard says so -
the choice was made that unsigned integer arithmetic is done modulo some
base (UINT_MAX+1 for unsigned int, ULONG_MAX+1 for unsigned long). There is
no magic about this; it was an arbitrary decision by the authors of the
standard.

6.1.3.4
@@ x = 'A'; /* give x the value 65 */
This comment, and the following text, leave the reader believing that 'A'
must have the value 65, and by extension that C requires the use of ASCII
codes. This is of course false, but it would be hard to tell from the book.

This, plus the comments assuming 8-bit bytes, and use of the terms "high byte"
and "low byte" of integers later on, makes me wonder whether a better title
for the book is: _The_ANSI_C_Standard_annotated_for_some_MSDOS_compilers_ :-).

6.1.4
@@ In other words, the executable version of a C program contains a table
@@ that contains the string literals used by the program.
While this is one way to implement strings, it is not the only one. Such a
comment does not belong in a book like this.

@@ Further, the effect of changing the string literal table is implementation
@@ dependent. The best practice is to avoid altering the string table.
It's more than just implementation dependent (a term which, by the way, is not
used by the standard), it's completely undefined. You *must* *not* modify a
string literal.

6.2.1.2
A description which is essentially correct is spoilt by the addition of the
words:
@@ In the most general terms, when you convert from a larger integer type to

(Continued to next message)

