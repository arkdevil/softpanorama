Newsgroups: comp.lang.c
Subject: Good C Book           5/9
From: david.mohorn@sourcebbs.com (David Mohorn)
Message-ID: <14.21666.711@sourcebbs.com>
Date: Mon, 14 Nov 94 00:07:00 -0005
Organization: SelectiveSourceBBS Virginia Beach (804)471 6776

Subject: Good C Book

(Continued from previous message)

elements have undefined values.

6.3.6
There is no mention of the rule that addition and subtraction of pointers and
integers must yield a pointer to the same array or one past the end of the
array.

6.3.7
@@ When right-shifting a negative value, generally, ones are shifted in (thus
@@ preserving the sign bit), but this is implementation dependent.
The result of signed right shift of a negative number is implementation
defined; there is no suggestion in the standard that shifting in ones is the
"best" thing to do.

6.3.13
There is no mention of the fact that && and || evaluate explicitly left to
right, and stop when the result is known. This would be an opportunity to
discuss sequence points, but the opportunity is missed.

6.3.16.2
When talking about compound assignments (+= etc.), the annotations mention
that "a += b" means the same as "a = a + b", but do not point out that the
two are not equivalent; for example, "*a++ *= 2" is strictly conforming code
which increments a once, while "*a++ = *a++ * 2" is not.

6.3.17
Again, there is no mention of sequence points.

6.5
@@ In simple language, a declarator is the name of the object being declared.
In real C, a declarator is everything about the type and name of the object
except the basic type and storage class. For example, in "static int *p[5];",
the declarator is "*p[5]", and includes the concepts of pointer, array, and
size of array as well as the name.

6.5.1
@@ A variable declared using extern is not a definition.
Not only is this wrong, but the annotations to 6.7.2 directly contradict it,
with the correct example of "extern int count = 10;".

@@ In essence, a static local variable is a global variable with its scope
@@ restricted to a single function.
Actually, a static local variable is a global variable with its scope
restricted to some block scope; that is, from the end of its declarator to
the closing } of the block it is declared in.

@@ When static is applied to a global variable or function, it causes that
@@ variable or function to have file scope
The global variable or function has file scope whether or not static is
applied to it. The static keyword causes it to have internal linkage, which
is a different matter.

@@ The register specifier is only a request to the compiler, which may be
@@ completely ignored.
It can't be completely ignored, because whether or not it affects the way in
which the variable is implemented, it is still illegal to take the address of
an object declared register.

6.5.2.1
There is no mention of the implementation-defined aspects of bit fields.

@@ This padding must occur at the end, not at the beginning, of the object.
Padding can occur anywhere except at the beginning of a structure. In
particular, it can occur between two fields. Of course a union can only be
padded at the end.

6.5.3
@@ (Many compilers display a warning about this fragment, but still accept
@@ it.)
@@    const int i = 10;
@@    int *p;
@@    p = &i;
@@    *p = 0; /* modify a const object through p */
Actually, the standard requires a diagnostic for the third line, because
it violates the third dashed item of the constraints of 6.3.16.1. If an
explicit cast had been used in that line, I believe that the assignment
would be strictly conforming. If so, then it is true that the standard does
not require a diagnostic for the last line, but nevertheless it is undefined,
not just something to warn about.

6.5.4
@@ The information and constraints in this section are mostly applicable
@@ to compiler implementors.
Since this section defines how to declare arrays, pointers, and procedure
prototypes, one has to wonder what the author actually considers interesting !

6.5.4.3
Considering that it has come up in at least two Defect Reports, I would have
expected some mention of the rule about typedef names within prototypes.

6.5.5
A useful way to think of a type name is as a declaration with the identifier
being declared omitted. So, for example, if v is declared as:
    unsigned char *v[5];

(Continued to next message)

