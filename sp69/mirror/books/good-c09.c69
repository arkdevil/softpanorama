Newsgroups: comp.lang.c
Subject: Good C Book           9/9
From: david.mohorn@sourcebbs.com (David Mohorn)
Message-ID: <14.21670.711@sourcebbs.com>
Date: Mon, 14 Nov 94 00:07:00 -0005
Organization: SelectiveSourceBBS Virginia Beach (804)471 6776

Subject: Good C Book

(Continued from previous message)

@@ Also, remember that if the string does not contain a valid numeric value
@@ as defined by the function, then 0 is returned. Although strtod(),
@@ strtol(), and strtoul() set errno when an out-of-range condition exists,
@@ there is no requirement that errno be set when the string does not contain
@@ a number. Thus, if this is important to your program, you must manually
@@ check for the presence of a number before calling one of the conversion
@@ functions.
Actually, it is quite hard to make such a check, but luckily it is also
unnecessary. If there is no number in the string, all three functions set
*endptr to the original value of nptr, while if there is (even if it is zero)
they set it to point after the last character of the number.

7.10.2
The example appears to assume that time_t is an integral type, and so assigns
the result of time() to a long. In fact, it could be double, and it might be
that the cast always yields zero. To extract a random number from the value
returned by time(), it is necessary to do something like the following, which
constructs an unsigned int from all the bits of a time_t value.

    unsigned int random_from_time (time_t t)
    {
        unsigned int i, j, k;
        char *p;

        i = 0;
        p = (char *) &t;
        /* Divide t up into pieces each the size of an unsigned int */
        for (k = 0; k + sizeof j <= sizeof t; k += sizeof j)
        {
            /* Copy the bits of the piece into j and add the value to i */
            memcpy ((char *) &j, p + k, sizeof j);
            i += j;
        }
        /* Do the same with any remnant (e.g. if j is 4 bytes and t is 11) */
        if (k < sizeof t)
        {
            j = 0;
            memcpy ((char *) &j, p + k, sizeof t - k);
            i += j;
        }
        return i;
    }

7.10.7 and 7.10.8
@@ Since multibyte characters are implementation-specific, you should refer
@@ to your compiler's user manual for details.
There is a lot that can be said about multibyte and wide characters without
having to know individual encodings, and there is a sore lack of such
tutorial material. It is a great pity to be faced with two almost blank pages
instead.

7.11.4
The annotations use the term "rearrange" when discussing strxfrm(). It should
be noted that the result of strxfrm may be longer than the original string.

The example compares two arrays of floats using memcmp. While such a comparison
is strictly conforming, it is not useful - the result of the comparison depends
on the details of the encoding of floats, and is in no way related to which
number is greater or smaller. (For example, it is possible to have an encoding
in which 0 < 2, but 2 > 3, as far as this comparison works. In the same way,
comparing integers with memcmp is equally useless on a little-endian system.)

7.12.2.3
There is no description of mktime and how it can be used to solve problems
like "what day is 100 days after December 25th 1993". This appears to be solely
because there was no room on the page opposite the definition of mktime.

