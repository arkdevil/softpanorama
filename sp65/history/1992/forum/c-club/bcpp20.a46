              TECH specialist                  april 1991

                Borland C++ 2.0

                                            Ron Burk

Пакет Borland C++ 2.0 представляет собой полный набор инструментов для
разработки программ на С, С++ и ассемблере - для DOS и Windows.
Предыдущим продуктом этой серии был пакет Turbo C++ 1.0 - в стандартном
и профессиональном (Professional) вариантах. Последний включает, кроме
полного стандартного варианта, также Turbo Debugger, Turbo Assembler и
Turbo Profiler. Пакет Borland C++ 2.0 продолжает серию программных
продуктов от Turbo C++ Professional, а Turbo C++ в стандартном варианте
будет продаваться как последняя версия продукта из другой серии.

Полный пакет, включая примеры, занимает около 15 Мбайт. В пакет входят
компилятор ANSI C, компилятор С++ (совместимый с версией AT&T 2.0),
Turbo Debugger, Turbo Assembler и Turbo Profiler. Далее будут
рассмотрены различия между Borland C++ 2.0 и Turbo C++ 1.0 Professional.

               Поддержка среды Windows

Поддержка создания Windows-программ - это наиболее значительное отличие
Borland C++ 2.0 от предшествующей версии - Turbo C++ 1.0 Professional.
Проблема состоит в том, что генерация объектного кода под Windows
отличается от аналогичного процесса в DOS: эти программы должны иметь
доступ к специальным библиотекам, которые описывают Windows API
(стандартный интерфейс разработчика). Кроме того, для разработки
прикладных программ под Windows необходимо иметь соответствующие
инструменты для создания Windows-ресурсов (блоки диалога, меню и т.д.) и
включения их в .EXE-файлы. До недавнего времени, генерация кода для
Windows требовала исключительно использования компилятора Microsoft C, а
для доступа к ресурсам этой среды использовался специальный пакет -
Microsoft SDK.

Впоследствие фирма Zortech предложиля альтернативу для Microsoft C,
добавив опцию компилятора, при использовании которой для функций Windows
генерируется специальный пролог и эпилог. Однако и в этом случае
остается в силе необходимость приобрести пакет Microsoft SDK, все права
на который остаются за фирмой Microsoft.

Borland убедил Microsoft раскрыть содержимое файла WINDOWS.H (файла
заголовка, используемого большинством программ, созданных для Windows),
а также опубликовать документацию по ранее закрытым интерфейсам. В
результате появился на свет пакет C и C++ под Windows, который не
требует приобретения  Microsoft Windows SDK. Пакет Borland C++
поддерживает Windows в самых различных аспектах. Он, например, включает
WhiteWater Resource Toolkit - это Windows-программа, которая позволяет
программисту пользоваться всем спектром функций Microsoft SDK, не
знакомясь с ними подробно, и, таким образом, создавать и редактировать
ресурсы  Windows (иконки, битовые изображения, меню и т.д.). Оба
компилятора предоставляют разнообразные возможности для генерации кода
для Windows-программ и динамических библиотек (DLL). Turbo Debugger
позволяет отлаживать Windows-программы на одном или двух мониторах, а
также через последовательный порт. Для процедур на языке ассемблера
Turbo Assembler генерирует соответствующий пролог и эпилог.

      Programmer's Platform (Платформа программиста)

       Интегрированная среда разработчика (ИСР)

Programmer's Platform в новой версии была доработана с тем, чтобы
распознавать специальные опции компилятора, относящиеся к Windows. В ней
автоматически происходит вызов компилятора ресурсов Windows - Resource
Compiler, и Import Librarian (      ) - для компиляции функций DLL.
Редактор связей теперь можно установить таким образом, чтобы он
генерировал либо объектные файлы для DOS, либо .EXE-файлы для Windows,
либо файлы DLL для Windows же. Командой MAKE можно задать генерацию
import libraries, по желанию используя DLL file exports либо DEF file
exports.

 Новая версия позволяет сохранять содержимое буфера команд, области
"clipboard" и условия прерывания - как часть создаваемого программного
файла-проекта. Текстовый редактор новой версии снабжен командами Undo
(отмены исполнения) и Redo (повторного исполнения). Он сохраняет до 64К
изменений для каждого файла, открытого в процессе работы.

Пакет Borland C++ включает также версию ИСР в защищенном режиме. К
сожалению, эта версия осуществляет доступ Windows к ИСР только в
стандартном (WIN/S) режиме. Для многих программистов это означает отказ
от многозадачности и от использования виртуальной памяти.

                 Компиляторы

Возможности компиляторов С и С++ также расширены с учетом
программирования под Windows. В наибольшей степени это относится к
опциям компилятора для генерации кода для функций DLL и/или для функций
Windows API. Функции, которые могут быть использованы в программах для
Windows (экспортируемые), требуют специального кода в своем прологе и
эпилоге. Этот специальный код несколько медленнее и больше по размеру,
нежели пролог и эпилог для обычной функции.

Оба компилятора полностью контролируют создание таких функций со
специальным прологом и эпилогом. Для того, чтобы осуществить это на
практике, достаточно либо задать соответствующую опцию компилятора в
командной строке, благодаря которой все функции станут экспорируемыми,
либо воспользоваться ключевым словом _export в заголовке функции, что
сделает экспортируемой именно ее. Опция командной строки приведет к
генерации функций типа "call-back", которые могут использоваться без
обычно обязательного в таких случаях вызова функции MakeProcInstance().
Те же самые опции применимы и для генерации экспортируемых динамических
(DLL) функций. Впрочем, для DLL-функций невозможно использовать функции
типа "call-back", поскольку они предполагают равенство DS=SS, а DLL
предполагают обратное.

Оба компилятора также позволяют использовать предварительно
откомпилированные (предкомпилированные) файлы заголовков, в том случае,
если в последний не вносились изменения, и не изменялись опции командной
строки, влияющие на то, как будет интерпретироваться файл заголовка. Так
как Windows-программы и C++-программы часто имеют очень большие файлы
заголовков, эта опция позволит экономить время компиляции.

Предкомпиляция может быть задана либо через опцию командной строки, либо
через директиву #pragma . Вероятно потребуется некоторый навык, чтобы
успешно пользоваться этой возможностью. Так, например, исходные тексты
должны включать (#include) одни и те же файлы заголовка в одинаковом
порядке. Так как исходные файлы для Windows часто включают WINDOWS.H,
который довольно велик, эти рекомендации, вероятно, не лишены смысла.
Используя директиву #pragma можно избежать предкомпиляции головных
файлов, включенных только в один исходный файл.

            Windows и C++

Использование динамически подгружаемых библиотек (DLL) создает
определенные проблемы для программирования под Windows. Любые прикладные
программы, которые обращаются к функциям DLL, могут пользоваться любыми
статическими данными (глобальные переменные, статические переменные),
которые описаны для этих функций. Это и есть основное ограничение,
которое Windows накладывают на создание для DLL классов C++. Далее, все
данные и функции класса из DLL должны быть "far". Для этого можно
объявить этих членов класса с помощью ключевого слова FAR, либо
компилировать этот класс в большой модели памяти.

Классы DLL следует экспортировать таким образом, чтобы они были доступны
другим программам. Для этого можно использовать опцию компилятора,
которая делает все функции экспортируемыми, а затем поместить имена этих
функций в секцию EXPORTS файла описания модуля. Другая возможность - это
использовать ключевое слово _export при объявлении класса. Классы C++
используют два неявных указателя: this - указатель на текущий объект, и
таблицу указателей виртуальной функции. Если они используются в
экспортируемых из DLL классах, то оба указателя должны быть типа "far".
Для этого используется соответствующая опция компилятора.

При экспорте отдельных классов из DLL рекомендуем пользоваться
объявлением их _export для DLL, и объявлением их ключевым словом huge в
программе, которая использует этот класс. В Borland C++ определен макрос
_DLL_ для создания DLL. Вы можете условно компилировать такой класс с
_export в DLL и huge где-либо еще. Объявление класса DLL как _export
делает "far" указатели виртуальной функции и указатель this, и, таким
образом, заставляет компилятор автоматически экспортировать все
невстроенные (non-inline) функции и статические данные класса.

           The Whitewater Resource Toolkit (WRT)

Ресурсами Windows называются блоки диалога, битовые изображения,
курсоры, иконки, меню, используемые в основной программе. Программа
может генерировать ресурсы непосредственно в ходе своего исполнения
(например, вызывая соответствующую функцию Windows для создания меню),
либо для их подключения можно воспользоваться редактором ресурсов,
включив их впоследствии с .EXE-файлом с помощью компилятора ресурсов.

Имеется несколько причин, объясняющих, почему следует избегать генерации
ресурсов в динамическом режиме. Если вы связываете статически описанные
ресурсы с .EXE модулем, то можете использовать функции Windows для
подгрузки ресурсов именно в тот момент, когда они на самом деле
требуются. Несколько Windows-программ могут совместно пользоваться
единственной копией любого ресурса (в отличие от большинства данных).
Еще более важным оказывается то свойство, что кто-либо со стороны может
изменить статическое описание ресурса без изменения исходного текста
вашей прикладной программы. Если программа построена правильно, то
перевод ее экранных сообщений на другой язык становится лишь делом
редактирования ресурсов.

WRT позволяет создавать Windows-ресурсы и управлять ими. Он включает
редакторы для каждого из стандартных ресурсов. Каждому из них
соответствует клавиша верхней строки окна WRT. Окно WRT также содержит
два окна просмотра - для проверки ресурсов в существующих файлах (с
расширениями .RES, .DLL или .EXE), копирования ресурсов из файла в файл
и переименования ресурсов. Они позволяют переносить ресурсы
непосредственно в .EXE файлы. WRT генерирует файлы, совместимые с
компилятором ресурсов Microsort SDK. WRT и был создан с целью заменить
часть утилит, входящих в Microsoft Windows SDK. Возможности обоих
пакетов примерно одинаковы, однако WRT позволяет делать то же самое
более наглядным образом. Он также снабжен разными приятными дополнениями
- типа режима тестирования для блоков диалога. В большинстве случаев,
для управления ресурсами можно не прибегать к компилятору ресурсов, но,
несмотря на это, фирма Вorland получила лицензию от Microsoft на
компилятор ресурсов RC.EXE и включила его в состав Borland C++ 2.0.

                Turbo Debugger (отладчик)

В пакет Borland C++ 2.0 входят и Turbo Debugger (для DOS), и Turbo
Debugger for Windows (TDW). Последний поддерживает особенности, присущие
отладке программ в среде Windows. TDW работает в среде Windows, но
работает в полноэкранном текстовом режиме. В режиме отладки можно
пользоваться ключом Alt-F5 для просмотра текущего экрана Windows, но
взаимодействие с этим экраном невозможно. Отладка в среде Windows
значительно отличается от аналогичного процесса в среде DOS. Если вход в
отладчик осуществляется по нажатию Ctrl-Alt-SysReq, и при этом
прерывается работа Windows, то при попытке пошаговой отладки появится
сообщение о непреодолимой ошибке - "Unrecovarable application error".
Для большинства программ под Windows пошаговая отладка приведет к
попаданию в бесконечный цикл обработки сообщений.

Именно поэтому предпочтительнее устанавливать точки прерывания в местах
взаимодействия прикладных программ со средой Windows. TDW позволяет
установить прерывания при посылке сообщений от Windows к определенному
окну в прикладной программе. В качестве условий прерывания можно указать
либо вполне определенные номера сообщений, либо описать один или
несколько классов сообщений (сообщения "мыши", сообщения DDE
(динамический обмен данными между приложениями) и другие). В момент
подачи сообщения можно либо войти в режим отладки, либо просто
регистрировать сообщение в соответствующем окне отладчика.

TDW позволяет просматривать содержимое глобальной и локальной "кучи"
прикладной программы. Также можно просмотреть модули задачи и модули
DLL, загруженные Windows, включая показ пути, откуда они были загружены.
Вся эта информация появляется в одном из окон TDW.

TDW также может отлаживать и функции из библиотек DLL (DLL-функции).
Обычно прикладная программа содержит статические вызовы функций DLL. TDW
регистрирует эти DLL-функции в момент загрузки программы. В тот момент,
когда происходит вызов функции из DLL, TDW автоматически подключается к
исходному тексту и таблице символов этой функции.

DLL-функции можно вызывать и динамически. В этот момент вы передаете имя
DLL-функции - Windows-функции LoadLibrary(), которая, в свою очередь, и
производит собственно загрузку этой функции. Затем имя DLL передается
функции       GetProcAddress(имя DLL), и она возвращает адрес этой
DLL-функции в самой библиотеке. TDW "видит" вызов LoadLibrary() и
загрузит таблицу символов этой DLL-функции.

                 Turbo Assembler

Новая версия Turbo Assembler имеет больше возможностей для организации
интерфейса с языками высокого уровня. Некоторые директивы, а именно -
.MODEL, PROC, EXTRN, COMM, GLOBAL  PUBLICDLL, могут включать
индентификатор языка высокого уровня (Pascal, BASIC, FORTRAN, C или
Prolog). Инструкция CALL также воспринимает такой индентификатор, что
освобождает от учета соглашений о вызовах для различных языков
программирования:

    call    gotoxy C,ax,bx

Здесь имеется индикатор языка - Си, так что ассемблер генерирует такую
последовательность команд:

  push    bx

  push    ax

  call    _gotoxy

  add     sp,4

Другими словами, ассемблер "понимает", что условия вызова для Си требуют
того, чтобы аргументы были помещены в стек в обратном порядке, и чтобы
вызывающая программа, а не вызываемая, извлекала их из стека. Он также
понимает, что символы Си имеют стоящий впереди неявный знак
подчеркивания "_". Если в этой же инструкции ассемблера заменить "C" на
"PASCAL", то ассемблер создаст корректные команды и для этого языка.

Совсем не обязательно включать индикатор языка в каждую команду CALL. По
умолчанию принимается тот язык, который был ранее указан в директиве
.MODEL. Таким образом, появляется возможность переносить функции,
написанные на ассемблере, в другие языки высокого уровня, не затрачивая
при этом много усилий.

Можно также задать модификатор WINDOWS либо в директиве .MODEL, либо в
(индивидуальных) директивах PROC. После этого Turbo Assembler создает
пролог и эпилог для используемых процедур. Например, такая короткая
функция:

   .model medium, C

   .code

RetZero proc WINDOWS

   mov    ax,0

   ret

RetZero endp

   end

генерирует следующий код:

;RetZero - функция для Windows, которая просто возвращает ноль

;

RetZero proc    WINDOWS

        push    ds

        pop     ax

        xchg    ax,ax

        inc     bp

        push    bp

        move    bp,sp

        push    ds

        move    ds,ax

        move    ax,0

        pop     ds

        pop     bp

        dec     bp

        ret

RetZero endp.

Директива PUBLICDLL определяет метки и процедуры ассемблера, которые
являются точками входа DLL:

  PUBLICDLL    foo

foo proc  near                 (определяет) процедуру foo, которая может
быть экспортирована из DLL.

Пакет Borland C++ 2.0 включает также версию Turbo Assembler работающую в
защищенном режиме (через интерфейс DPMI). Запуск этой версии в
расширенном режиме Windows даст возможность пользоваться тем же, что и у
Windows, средствами управления виртуальной памятью. Для любых программ
на ассемблере, кроме очень больших, обычной версии Turbo Assembler
вполне достаточно.

                  Документация

Документация пакета Borland C++ 2.0 состоит из девяти томов и большой
справочной системы типа "гипертекст". Вот названия этих книг: Getting
Started (151 стр.), Borland C++ Users' Guide (308 стр.), Borland C++
Programmers' Guide (444 стр.), Borland C++ Whitewater Resource Toolkit
(131 стр.), Borland C++ Library Reference (593 стр.), Turbo Assembler
Users' Guide (495 стр.), Turbo Assembler Quick Reference Guide (146
стр.) и Turbo Profiler Users' Guide (195 стр.). Все пособия снабжены
предметными указателями. На на диске также содержатся примеры.

Кроме обычной поддержки для языков программирования, справочная система
включает помощь и для Windows, а именно: по структурам данных, типам
данных, по кодам завершения и виртуальным кодам клавиш, по сообщениям и
библиотеке WINMEM32.DLL, а также по всем API-функциям. Последние
доступны только в интегрированной среде разработчика (IDE) Borland, а не
как файл формата Windows.

Часть документации представляет собой текстовые файлы, содержимое
которых может быть распечатано. Здесь содержаться последние изменения,
внесенные в документацию, а также описание некоторых небольших утилит
типа GREP. Один из текстовых файлов содержит также краткое введение в
программирование на C++ под Windows.
