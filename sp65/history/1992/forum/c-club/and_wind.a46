The C++ Report                  март 1991

          /DOS/C++ и Windows

                                         Alex Lane

   Windows и объектно-ориентированное программирование (ООП)

Сегодня Windows - это предмет нескончаемых дискуссий. Впрочем, не
вызывает сомнения тот факт, что Windows является стандартом GUI для
машин, работающих под DOS. Среда Windows предлагает пользователям
множество преимуществ, включая возможность параллельного общения с
несколькими прикладными программами одновременно в многозадачной среде.
Многозадачность дает доступ к большому массиву памяти и позволяет
приложениям совместно использовать часть программного обеспечения. Ниже
мы рассмотрим некоторые аспекты такого использования, в той части,
которая относится к совместному использованию классов C++.

Несколько лет назад, еще до популяризации идей ООП, программисты для
Windows были убеждены, что занимаются объектно-ориентированным
программированием. В конце концов, рассуждали они, окно - это "объект",
котрый получает и обрабатывает "сообщения". Сообщения информируют окно
обо всех событиях, которые могут оказать воздействие на него (например,
ввод с клавиатуры или получение сигналов от "мыши"). Если сообщение не
могло быть обработано самим окном, то оно передается на обработку его
окну-"предку". Это ведь и есть объектно-ориентированное
программирование, не так ли?

Итак, когда вы смотрите на некоторые детали исполнения, то самый
милосердный ответ - это "что-то вроде". Windows частично используют
терминологию ООП, но не последовательно. Сами сообщения не являются для
Windows объектами. Нет эффективного способа сказать сообщению, чтобы
"оно само о себе позаботилось". Каждое окно должно скурпулезно
перечислить все существующие типы сообщений и описать способы их
обработки в предложении CASE. Вдобавок к этому, наследование
способностей окон-"предков" по обработке разных видов сообщений
относится только к непосредственному "предку". На практике это означает,
что приходится копировать части текста из программы в программу. В
будущем мы обсудим, как можно обойти эти проблемы средствами С++ (вместо
С).

         Совместное использование классов C++

                  в среде Windows

Прикладные программы для Windows могут совместно пользоваться
подпрограммы, которые содержатся в файлах, носящих название динамически
подгружаемых библиотек (или DLL). Вообще говоря, и Windows представляют
собой некоторое множество таких библиотек. По существу это означает то,
что однорвременно может быть запущено несколько прикладных программ,
которые имеют доступ к одним и тем же DLL-подпрограммам.

В DLL можно поместить и классы С++, однако некоторые вещи при этом
следует иметь ввиду. Если DLL-подпрограмма имеет сегмент данных, то он
не будет иметь никакого отношения к стеку (или сегменту данных) той
прикладной программы, которая пользуется этой DLL. Это означает, что при
создании DLL-подпрограммы следует использовать указатели типа "far".
Другими словами, если класс C++ используется только как часть какой-либо
DLL-подпрограммы, он не должен быть объявлен как "far". С другой
стороны, если класс будет использоваться и вне своей DLL-подпрограммы
(либо какой-либо другой DLL, либо прикладной Windows-программой), то все
данные и функции этого класса должны быть объявлены "far". Вы должны
быть уверены в том, что все указатели таблицы символов виртуальной
фуекции и указатель класса "this" должны быть также "far". При этом
также необходимо, чтобы такой класс был экспортируемым ("exported"), так
чтобы его функции и данные были доступны извне DLL.

Интересные замечания можно сделать касательно статических данных класса
C++ и DLL. Напомню, что статические данные класса есть ничто иное, чем
глобальные переменные, локальные по отношению к данному классу. Если
класс A имеет статическую целую переменную i, то все применения
(instances of) класса A могут использовать эту переменную. Далее, ею
также смогут пользоваться и все порожденные классы. Для того, чтобы
осуществить это на практике, порожденный класс должен иметь статическую
переменную с таким же именем.

Что же происходит, когда какой-либо DLL-класс имеет статическую
переменную? Тогда эта переменная будет глобальной для всех instances
этого класса (и для его наследников), где бы они не находились. Иначе
говоря, если прикладная программа X использует класс A, и им же
пользуется прикладная программа Y, то они совместно используют одну и ту
же переменную i. Где бы это могло пригодиться? Может быть для
ограничения количества статичных данных в многозадачной среде Windows, в
которой реализованы эти приложения? И так ли уж необходимы отдельные
переменные i для прикладных программ X и Y?

Это зависит от конкретных обстоятельств. Программисту следует задуматься
в тот момент, когда он использует статичные данные в тех классах,
которые будут использоваться из DLL. В статичной переменной нельзя
хранить данные, которые относятся только к данной прикладной программе,
так как она ошибочно может быть использована другими прикладными
программами. Конечно, можно специально занять эти переменные под
передачу сообщений между приложениями, использующими такие классы, но
это вряд ли правильный подход, так как для Windows-приложений существуют
для этого более удобные способы. Таким образом, единственными данными,
которые удобно хранить в статических переменных, будут те, которые
относятся к переменным описания среды. Это тоже не особенно практично,
учитывая то, что у Windows есть собственные возможности для передачи
такой информации. Наилучший выход таков: не вносите классы со
статическими переменными в состав динамически подгружаемых библиотек -
DLL.

Альтернативный подход может быть таким: каждой прикладной задаче,
которая использует DLL, выделять собственные статические переменные.
Подробнее об этом - в следующих публикациях нашей рубрики.
