       КОММЕНТАРИИ К ИСХОДНОМУ ТЕКСТУ ПРОГРАММЫ !DirRoom

    Текст программы !DirRoom находится в файлах !DirRoom.pas -
собственно программа, и DirRUnit.pas - модуль со служебными
подпрограммками.
-------------------------------------------------------------

                          DirRUnit:

Error - сообщение об ошибке (S),
        удаление, если он был открыт, файла !DirRoom,
        пауза (если !DirRoom запускалась с параметром /P)
        и выход из программы с кодом ExCode.
    Это единственная процедура, требующая TP 6.0.
    Если ее строку очистки буфера и ожидания нажатия клавиши
            while keypressed do readkey;  readkey;
    переписать, например, как
            while keypressed do Ch:=readkey;  Ch:=readkey;
    то подойдут и более ранние версии TP.
StrUpCase - преобразование строки в верхний регистр.
Str2Long - преобразование строки в длинное целое. Если преобра-
    зование прошло успешно, то I приобретает значение этого це-
    лого, а функция - true. В обратном случае I не изменяется,
    а функция возвращает false.
        В общем случае следовало бы перед Val удалить из S про-
    белы. Но в данном случае этого нет, т.к. преобразуются
    только значения ParamStr, не имеющие пробелов изначально.
TextOpen - открытие файла tf с именем S. Это и есть файл
    !DirRoom. Запись в текстовой файл программировать легче (на
    пару строк), чем посредством BlockWrite, а скорость записи
    на диск такая же, как при BlockWrite блока длиной
    SizeOf(TextBuf).
AddBackSlash - если последний символ строки - не '\', то допи-
    сывает '\' в конец строки.
-------------------------------------------------------------

                           !DirRoom:

Help - выдача справочного экрана.
    За счет того, что каждый writeln выдает не одну строку эк-
    рана, а сразу несколько - объем EXE-файла сократился на 512
    байт (4%-5%).
GetCommandLineParameters - разбор командной строки. Недостаток
    процедуры - все параметры должны быть разделены пробелами.
GetDiskParameters - определение параметров диска функцией 36h
    DOS. Определяются размер кластера в байтах (ClSizeB), в
    элементах каталога (ClSizeEl); а также свободное пространство
    диска в кластерах (FreeSpaceCl).
DetermineDRfile - определение корневого каталога и, если режим
    не информационный - уточнение имени файла !DirRoom. Сначала
    он открывается в предположении, что в командной строке пе-
    редано полное имя файла; а в случае неудачи - в предположе-
    нии, что передан лишь его директорий, а имя следует подста-
    вить по умолчанию.
WriteTableHeader - печать заголовка таблицы и открытие окна от
    текущей строки до низа экрана для списка каталогов.

CountDirSpace - подсчет кластеров, занятых оглавлениями катало-
    гов. Если режим не информационный, то !DirRoom уже был от-
    крыт в DetermineDRfile и, значит, учитывается.
         Сканирование дерева начинается с корневого каталога.
    Для каждого найденного подкаталога (в Attr установлен бит
    16, имя не равно '.' или '..') CountDirSpace вызывается ре-
    курсивно.
        Т.к. максимальная длина полного имени файла не может
    превышать 64 символа (или я не прав?), то максимальная сте-
    пень вложения каталогов - 32 (если имя каждого подкаталога
    состоит из одного символа). Исходя из размеров переменных
    CountDirSpace, можно предположить, что для каждого вызова
    этой процедуры требуется около 0.5 Kb стека. Действительно,
    на 32-уровневом дереве программа работает и при {$M 20496,0,0}.
    Так что {$M 65520,0,0} должно хватать с большим запасом.
    Еще больше усилить запас можно, объявив Dir не string, а
    более короткой, например, string[69]. Тогда для 32 уровней
    хватает {$M 15496,0,0}.
        В первом издании "IBM PC для пользователя" В.Э. Фигур-
    нова был текст программы CRClist, в которой аналогичный
    фрагмент выглядел так:

  while DosError = 0 do begin
    with SRec do
      if (Attr and 16 <> 0) and (Name[1] <> '.') then begin
        SearchDir(Dir+Name);
        Regs.AH := $1A;          {Восстанавливаем DTA}
        Regs.DS := Seg(SRec);
        Regs.DX := Ofs(SRec);
        MSDos(Regs);
      end;
    FindNext(SRec);              { Ищем еще каталог }

    т.е. после каждого выхода из рекурсивного вызова процедуры
    поиска подкаталогов (в CRClist она называется SearchDir)
    восстанавливалась DTA. Не знаю, как в TP 5.0, а в TP 6.0 и
    5.5 это излишне, потому что DTA устанавливается на SRec при
    каждом вызове FindNext (см. Turbo Pascal Runtime Library
    Version 6.0, FIND.ASM).

CreateDirRoomFile - запись в открытый ранее !DirRoom нужного
    числа байт. Байты записываются не по одному, а по 32 только
    для придания содержимому файла более осмысленного вида, на
    скорость записи это практически не влияет - она определяет-
    ся размером буфера.


         11-11-92                    В.С. Рабец

                           e-mail:   rabets@icph20.sherna.msk.su

                           Адрес:    142 432
                                     Московская обл.
                                     Ногинский р-н
                                     п. Черноголовка
                                     Школьный б-р, 18, кв. 241
                                     Рабцу В.С.

САМОРЕКЛАМА:
             В ноябрьском номере журнала "Монитор" читайте
╔═══════════════════════════════════════════════════════════════════════╗
║                          В.С. Рабец                                   ║
║                                                                       ║
║               Работа с DOS и BIOS в обход прерываний                  ║
║ (Turbo Pascal'евский модуль для вирусологов и защитников информации). ║
║                                                                       ║
║                            АННОТАЦИЯ:                                 ║
║     Статья рассказывает о методах нахождения точки входа в обработчи- ║
║ ки прерываний DOS и BIOS и обращения непосредственно к этим обработ-  ║
║ чикам. Приведен модуль OriginOS, реализующий данные методы на Turbo   ║
║ Pascal 6.0. Статья содержит некоторые сведения о языке ассемблера, до-║
║ статочные для понимания работы ассемблерных процедур OriginOS.        ║
║                                                                       ║
╚═══════════════════════════════════════════════════════════════════════╝
