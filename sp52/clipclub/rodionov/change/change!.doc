      ┌──────────────────────────────────────────┐
      │   Утилита проекции баз данных CHANGE!    │
      │             Версия 2.0                   │
      └──────────────────────────────────────────┘

   Change! - Изменись!
   Этим магическим словом царь обезьян Сунь Укун предварял
 свои семьдесят два волшебных превращения. Утилита CHANGE!
 предназначена для более прозаичных целей, но превращений
 она может делать бессчетное количество.
 По сути своей - это УНИВЕРСАЛЬНЫЙ конвертор(или транслятор)
 DBF-овских баз данных из одной структуры в другую (и причем
 довольно быстрый). CHANGE! может быть особенно полезен для 
 организации обмена информацией между различными АРМ'ами.

 Для его использования надо иметь: а) базу данных, над которой
 вы хотите попрактиковаться, б) редактор текстов и в) саму утилиту.

   Формат запуска:
   ==============
 CHANGE <имя1> <имя2> <имя3> [<ключи>]

 Порядок параметров позиционный.

 Где: <имя1> - имя файла исходной базы данных, возможно с путем и
               расширением
      <имя2> - имя файла результирующей  -"-
      <имя3> - имя файла с целевым списком. Расширение целевого
               списка по умолчанию .AIM

   Рассмотрим подробнее целевой список. В целевом списке Вы указываете,
какие поля Вам хотелось бы получить, и выражение, которым это поле
заполнить. Говоря умным языком, в целевом списке вы задаете 
о т н о ш е н и е   на исходной таблице, а в результирующей базе
получаете  г р а ф и к  этого отношения.

   Структура целевого списка:
   =========================
 <элемент>,...,<элемент> [#FOR <условие>]

 Где <элемент> := <выражение>[{[<имя>/[<тип>/[<длина>[/<дес>]]]}]

    <выражение>:=любое допустимое выражение Clipper'а. Имена полей
                 исходной базы следует предварять префиксом S->.
                 Примеры выражений: s->pole, int(s->pole1/25), 33, "kaka".
                 Ниже будет указан список функций, которыми можно
                 пользоваться в выражениях.

    <имя> :=     имя поля в результирующей базе. По умолчанию извлекается
                 что-то похожее на имя поля из <выражения>

    <тип> :=     тип результирующего поля (C/N/D/L/M). По умолчанию такой же,
                 как у <выражения>. Если типы не совпадают, то выполняются
                 преобразования типов, за исключением самых дебильных, типа
                 L->D

    <длина>:=    длина результирующего поля. Правила умолчания аналогичны.

    <дес>:=      десятичные позиции результирующего поля.

    <условие>:=  любое синтаксически верное условие Clipper'а
                (выражение, возвращающее логическое значение) .

   Целевой список может разбиваться на отдельные строки и
 усеиваться пробелами в произвольном порядке (но не в именах!) .

   Для построения сложных списков можно использовать три пользовательские
 переменные _UserCount, _UserStr, _UserSwtch. Их начальное значение
 соответственно
_UserCount=0
_UserStr=""  (пустая строка)
_UserSwtch=.F. (ложь)
 Таким образом, в целевом списке можно писать (например, для целей
 нумерации):

 (_usercount:=_usercount+1){pole_num//3}


 Пример целевого списка:     (комментарии показаны просто для наглядности,
 ======================           вносить их в список нельзя)

  s->napst_i{cvidsil},        <= переименование поля
  s->shifr{cobject//15},      <= переименование и изменение длины
  val(s->prstr){nsrok//2},    <= преобразование типа с помощью ф-ции VAL
  s->prstr{nsrok/n/2},        <= то же с неявным преобразованием
  "01."+s->nstr{dnachalo/d},  <= сложное преобразование в дату из строки
  2{ntrest//2},               <= создание нового числового поля длиной 2
                                 с занесением в него значения 2
  " "{cpriznak}               <= создание пустого символьного поля
  #FOR s->czakazch="ИВАНОВ"   <= условие

  Длина целевого списка почти не ограничена:
  а) число элементов <= 4096 и б) объем файла .AIM <=64K
  На практике (да и в теории) этого должно всегда хватать.

  Ключи запуска:
  =============
  /C - создать целевой список. По этому ключу создается новый
  файл <имя3> в котором структура исходной базы данных представлена
  в формате целевого списка. После этого вы имеете полное право
  откорректировать его по своему усмотрению.

  /NE - нет эха. Отключается дублирование на консоли целевого списка
  и условия

  /NT - не болтать. Отключается вывод визуальной информации о
  проценте выполненной работы.

  /NA - не задавать вопросы. При этом отключаются вопросы насчет
  существующих файлов (убивать- не убивать).

  Прочая информация
  =================
  Первая версия была разработана на Clipper S'87.
  Переход на 5.01 позволил увеличить скорость обработки раза в три,
  а украл всего-то 40K pklit'нутого кода.

  Обработка базы 900K с целевым списком в 125 полей занял 3 минуты
  на не очень быстрой AT-шке. Для той же базы но со списком 25 полей
  обработка шла всего минуту.

    Я выражаю свою глубокую признательность коллективу разработчиков
 СУБД "ИКАР" за нагло украденный мною формат целевого списка
 (новое - это хорошо забытое старое!).

   

 Использование
 =============
   Это FREEWARE, т.е. пользуйтесь на здоровье, но автор ответственности
 никакой не несет.

 Развитие
 ========
  В дальнейшем предполагается включить в программу:
1. Проекция многих баз данных, возможно, с индексами
   ( т.е. фактически программа приблизится к SQL-оператору SELECT)
2. Включение большого количества функций преобразования данных.
   (Вы можете сделать это сами, имея объектный модуль). 
   Для вызова из программы используйте формат _change(p1[,p2[,p3[,p4]]])
   Нагрузка параметров та же, что и при вызове из ДОС.

 Координаты
 ==========
  По всем вопросам обращайтесь ко мне по телефонам:
   (044) 272-97-93
   (044) 211-94-71
   или письменно по адресу
   252191, г.Киев, ул.Касияна,6, кв.214
   Родионову Ю.В.


Приложение.
===========
      Список функций преобразования данных Clipper 5.01
        которые можно использовать в целевом списке.

ABS        DATE        INKEY       LOWER       PAD         STRTRAN
ALLTRIM    DAY         INT         LTRIM       RAT         STUFF
ASC        DELETED     ISALPHA     LUPDATE     REPLICATE   SUBSTR
AT         DESCEND     ISDIGIT     L2BIN       RIGHT       TIME
BIN2I      DOW         ISLOWER     MAX         ROUND       TRANSFORM
BIN2L      DTOC        ISUPPER     MIN         RTRIM       TYPE
BIN2W      DTOS        I2BIN       MLCOUNT     SECONDS     UPPER
CDOW       EMPTY       LASTREC     MEMOLINE    SOUNDEX     VAL
CHR        EXP         LEFT        MOD         SPACE       VALTYPE
CMONTH     HARDCR      LEN         MONTH       SQRT        WORD
CTOD       IF          LOG         STR         YEAR

