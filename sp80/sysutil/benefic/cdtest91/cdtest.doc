
                       FAST CD TEST
                        веpсия 91f

                         FREEWARE
                 то есть абсолютная халява


ЧТО ЭТО ТАКОЕ И ЗАЧЕМ:

В первом приближении это - тест дисков CD формата ISO-9660
и HighSierra (HSD). Однако это не совсем обычный тест, от
аналогов (Corel CDTest, DiskDetective, CDTools) его отличает
следующее:

- совершенно иной уникальный алгоритм тестирования CD,
  позволяющий почти всегда намного (часто в десятки раз)
  сократить время тестирования диска. Данный тест базируется
  на логичном подходе, что если на диске обнаружено скажем 10
  фатальных ошибок в _любом_ месте - такой диск уже кандидат в
  мусор, и нечего дальше его проверять, и в то же время если
  диск в наихудших потенциально местах показывает стабильное
  безошибочное считывание - он с большой достоверностью
  _весь_ не содержит ошибок. Исходя из этого подхода, тест
  начинает сразу с проверки потенциально наиболее сбойных
  областей, и как правило оказывается прав, и уже через
  несколько минут становится понятно что "этому китаю место
  в мусорном ведре" (или на лотке на рынке).

- тест не только проверяет безошибочность считывания - он
  проверяет надежность (стабильность) считывания блоков
  информации с диска (этого не делает ни один из известных
  мне тестов). Проверка стабильности считывания позволяет
  принять решение по качеству диска даже без контроля всей
  его поверхности, и во всяком случае позволяет четко
  отловить диски безошибочно читающиеся "на грани" - то есть
  диски которые "сейчас читаются" а завтра (или на другом
  приводе) читаться уже не будут.

- тест работает в графическом режиме экрана 640x480x256цв
  (VESA mode 101h), рисует график стабильности чтения,
  и вообще много чего делает в графике (в полной версии).

- возможно управление как с помощью мыши, так и с помощью
  одной клавиатуры, а также смешанное управление;

- встроенный отладочный режим и бенчмарка (скоростемер)
  для оценки скорости работы с графикой вашего компьютера.

╔══════════════════════════════════════════════════════════╗
║ ВНИМАНИЕ: Тест FAST-CD-TEST может не работать или давать ║
║ неправильные результаты, если:                           ║
╟──────────────────────────────────────────────────────────╢
║ 1. Вы запускаете его не под "голым" ДОС (например,       ║
║  запускаете из-под Win95, Win3.1 или OS/2)               ║
║                                                          ║
║ 2. Вы используете дисковый кэш, кеширующий также и       ║
║  CD-ROM (например SmartDrive от DOS 6.22).               ║
║                                                          ║
║ 3. Вы используете высокоскоростной CD-ROM (тест рассчитан║
║  на CD-ROMы с удвоенной скоростью, хотя должен работать  ║
║  и на четырехскоростных)                                 ║
║                                                          ║
║ 4. Вы используете не совсем корректный MSCDEX или драйвер║
║  CD-ROM, или же Ваш CD-ROM-драйв имеет некоторые         ║
║  аппаратные проблемы (например, некоторые драйвы         ║
║  Panasonic 563b не хотят читать дорожку с первой         ║
║  попытки - что приводит к массовым сбоям по тесту, хотя  ║
║  в DOS CD-ROM читается вроде бы нормально)               ║
╚══════════════════════════════════════════════════════════╝

ОГРАНИЧЕНИЯ FREEWARE-ВЕРСИИ:

1. Не работает (отключено) управление с командной строки.

2. Тест работает только в FAST MODE. Режимы FULL и AUTO
не поддерживаются.

3. Не работает (отключено) формирование протокола
тестирования в файле CDTEST.LOG.

4. Не работает (отключена) локализация сбойных файлов,
с выводом списка сбойных файлов в CDTEST.LOG.

5. Не работает (отключен) стендовый режим, показывающий во
время тестирования диска красивые картинки (перечисленные
в файле CDTEST.SSS). Режим придуман специально по просьбе
моих друзей - для тестирования дисков на компьютерах,
стоящих "на выставке" (ну на самом деле, куда как приятнее
посетителям разглядывать красивые меняющиеся слайды чем
график стабильности чтения CD).

6. Не работает (отключен) психоделик-режим, показывающий во
время тестирования диска красивые динамические узоры типа
калейдоскопа.

7. Вместо всего этого - вставлено демо-скоростемер графики.
Ну чтобы хоть что-то было ;-))

ВНИМАНИЕ:

Для работы теста необходим видеоадаптер SVGA с VESA VideoBios
Extention или с загруженным драйвером VESA (например UniVBE),
поддерживающий режим VESA 101h 640x480x256 (обычно это значит
что на карте SVGA должно быть не менее 512K видеоОЗУ).



ИСПОЛЬЗОВАНИЕ:

CDTEST.EXE

Запуск CDTEST с параметрами включает отладочный режим и
позволяет померять скорость работы с графикой. Запускайте
CDTEST c любым параметром если у него имеются проблемы с вашей
видеокартой. В этом случае внимательно прочитайте
выдаваемую на экран при старте программы диагностику,
особенно на строку VESA WINDOWS ATTR  - если атрибуты
окон A и B равны нулю - значит у вас старый видео-BIOS,
пользуйтесь загружаемым драйвером VESA (типа UniVBE или
аналогичным). Если все равно не будет работать - запустите
прикладываемую утилитку vesainfo.com и перешлите полученный
файл vesa.inf мне - будем разбираться...

Запуск CDTEST без параметров - обычный режим, тестирует
диски. Там все достаточно просто и понятно. Нажатие любой 
клавиши или кнопки мыши прерывает тестирование не дожидаясь 
конца теста - если с диском вам уже все ясно. Нажатие ESC 
вызывает выход в DOS.

Тест строит график-диаграмму времени считывания тестового 
блока (64Kb) в зависимости от номера блока. Зеленая линия 
- нормальная ситуация, красные выбросы графика вверх -
сбои на дорожке, на коррекцию которых CD-ROM тратит 
добавочное время. На горизонтальной оси (поперек ее) также 
могут появляться красные короткие отрезки, означающие что
указанный блок содержит неисправимую многократную ошибку
(так называемый фатальный сбой). Каждый блок содержащий 
такую ошибку добавляет +1 к счетчику ошибок ERRORS. Как
только ошибок становится 10 и более - FAST MODE тест
прекращается (продолжать бессмысленно - слишком много
сбоев, диск явно плохой) и пишется заключение о 
пригодности диска.

ВНИМАНИЕ: Некоторые диски имеют неправильную VTOC - то есть 
в ней указан размер диска в блоках (секторах) чуть больше
чем это есть на самом деле (обычно на один-два блока или
на одну лишнюю дорожку). В этом случае тест начиная с
определенного проверочного блока начнет показывать массовые
фатальные сбои. Решайте сами - можно использовать такой
CD-ROM или нет.

FREEWARE ВЕРСИИ FAST CD TEST:

0.90bf - первая версия, розданная через FIDO.

0.91bf - вторая версия. Исправлена пара мелких
ошибок, плюс теперь сразу пишется объем диска в Kb, 
а не только в секторах (по просьбам трудящихся).

*****************************************************

СПИСОК CD-ROM с которыми обнаружились проблемы:

Panasonic 563B (слив от Creative Labs)
ACER 564 (?)


СПИСОК CD-ROM с которыми точно нет проблем:

Dolphin 8001 (Optical Storage Inc)
Acer 562     (Acer Inc)
Mitsumi (несколько 2x-скростных моделей)

---------------------маленькая реклама---------------------

ТЕХНИЧЕСКИЕ ПОДРОБНОСТИ:

CDTEST написан на чистом Си (откомпилирован BC 3.1) с
использованием моей графической библиотеки SVGA-MAGIC PRO,
причем в нем используются исключительно стандартные функции
этой библиотеки, никакого дополнительного кода там нет, даже
функции работы с CD-ROM входят теперь в библиотеку.
Любознательные могут получить у меня исходники CDTEST ;-)

Обратите внимание:

- на русский (и вообще смешной) шрифт. Библиотеке в общем
  все равно что там у вас загружено в VGA, какой шрифт и
  т.д. - она всегда использует _собственные_ растровые
  шрифты, причем один шрифт может быть прилинкован прямо к
  EXE-модулю (как в данном случае), а дополнительные -
  при необходимости грузиться с диска. Шрифт может выводиться
  транспарентно (наложением на фон) или с затиранием фона,
  с разным шагом букв и т.д. Да, кстати - ваш обычный шрифт не
  должен потеряться и при выходе в DOS он восстановится.

- на работу с различными видами спрайтов (в бенчмарке) -
  обычными прямоугольными и полупрозрачными (транспарентными),
  а также псевдо-трехмерными (3D-like) спрайтами и движущимися
  спрайтами (алгоритм Double-Buffer-Drawing). Заметьте, что
  использован довольно большой (56x96 точек) и имеющий сложную
  форму спрайт (солдатик из UFO) чтобы показать эффективность
  применяемых алгоритмов. Кстати - все спрайты прилинкованы к
  EXE-модулю (хотя библиотека позволяет грузить их с диска,
  но линковать удобнее для пользователя, правда ведь?).

По поводу скорости: на средних в настоящее время компьютерах
(типа 486SX33) и не-HighEnd видеокартах (трансфер менее 10Mb/s)
скорость работы библиотеки со спрайтами почти предельная, и
не может быть существенно увеличена (собственно она в основном
определяется трансфером вашей SVGA и в него упирается).
Оптимизировать библиотеку для более медленных процессоров - не
вижу смысла, для более быстрых видеокарт - пока тоже (их не
ставят на SX33, а на DX2/66 или DX4/100 даже при карте SVGA с
трансфером 30Mb/s библиотека опять работает почти на пределе).
Короче - пока это максимум что можно получить.


ПОДРОБНЕЕ ПРО БИБЛИОТЕКУ SVGA-MAGIC PRO:

ФУHКЦИИ БИБЛИОТЕКИ (кpатко, только пpототипы):

//Пpототипы функций, зависящие от карты (в файле SVGA_DEP.HL)
void SETVMODE(unsigned int mode);
void SetBank(void);
void SetBankXY(unsigned int x, unsigned int y);
void SetBankR(void);
void SetBankRXY(unsigned int x, unsigned int y);
void ToVideoLineCpy(unsigned int lx, unsigned int ly, unsigned char *buff, int l);
void AtVideoLineCpy(unsigned char *buff, unsigned int lx, unsigned int ly, int l);
void PutPix(const unsigned int x, const unsigned int y);
unsigned char GetPix(const unsigned int x, const unsigned int y);
void VLine(unsigned int x, unsigned int y, unsigned int l);
void HLine(unsigned int x, unsigned int y, unsigned int l);
void BrLine(unsigned int x, unsigned int y, signed int lx, signed int ly);
void BrCircle(unsigned int xc, unsigned int yc, unsigned int r);
void BrSolidCircle(unsigned int xc, unsigned int yc, unsigned int r);
int LoadScreen(const char *file);
int LoadSpriteScr(unsigned int lx,unsigned int ly,const char *file);
int SaveScreen(const char *file);
int SaveSpriteScr(unsigned int lx,unsigned int ly,unsigned int dx,unsigned int dy,const char *file);
void PutSpriteA(unsigned char num,unsigned int lx,unsigned int ly,struct SPRITE *buff);
void PutSpriteTrA(unsigned char num,unsigned int lx,unsigned int ly,struct SPRITE *buff);
void Put3DSpriteA(unsigned char num,unsigned int lx,unsigned int ly,struct SPRITE *buff);
void PutSpriteZoomXY(char zoomx, char zoomy, unsigned int lx,unsigned int ly,struct SPRITE *buff);
void PutSpriteZoomTrXY(char zoomx, char zoomy, unsigned int lx,unsigned int ly,struct SPRITE *buff);
void PutSpriteUZoom(char zoom,unsigned int lx,unsigned int ly,struct SPRITE *buff);
void MoveSpriteR(struct SPRITE *sprt, struct SPRITE *back);
void MoveSpriteL(struct SPRITE *sprt, struct SPRITE *back);
void MoveSpriteD(struct SPRITE *sprt, struct SPRITE *back);
void MoveSpriteU(struct SPRITE *sprt, struct SPRITE *back);
void ClearScreen(unsigned char color);
void InitVirt(int xv, int yv);
void KillVirt(void);
void ShowVirt(void);

//Пpототипы функций, HЕ зависящие от карты (в файле SVGA_MP.HL)
void MemCpyRev(unsigned char *buff1, unsigned char *buff2, int l);
unsigned char ReadVgaReg(unsigned char numb);
void PutPixSprite(unsigned int lx,unsigned int ly,struct SPRITE *buff);
void PutPixSpriteA(unsigned char num,unsigned int lx,unsigned int ly,struct SPRITE *buff);
unsigned char GetPixSprite(unsigned int lx,unsigned int ly,struct SPRITE *buff);
unsigned char GetPixSpriteA(unsigned char num,unsigned int lx,unsigned int ly,struct SPRITE *buff);
void BLine(unsigned int x, unsigned int y, unsigned int lx, unsigned int ly);
void FBox(unsigned int x, unsigned int y, unsigned int lx, unsigned int ly);
void EBox(const unsigned int x, const unsigned int y, const unsigned int lx,
     const unsigned int ly);
signed int LoadFont(char *path);
void PutChr(const unsigned char c);
void PutChrPap(const unsigned char c);
void Print(const char *string);
int GPrintf(int xloc, int yloc, char *fmt, ... );
void PutChrVirt(const unsigned char c);
void PutChrPapVirt(const unsigned char c);
void PrintV(const char *string);
int PrintfV(int xloc, int yloc, char *fmt, ... );
int MakePrintf(int lxpr,int lypr,struct SPRITE *buff, char *fmt, ...);
void KillPrintf(struct SPRITE *buff);
void GWindow(unsigned int x,unsigned int y,unsigned int dx,unsigned int dy,const char *string);
void ErrorWin(const char *string, const unsigned char selector);
unsigned char HMenuGraph(int lx, int ly, const char *string, struct SPRITE *menu);
void HMenuSet(int lx, int ly, const char *string, struct SPRITE *menu);
unsigned char HMenuPoint(struct SPRITE *menu);
int LoadSprite(struct SPRITE *buff,const char *file);
int LoadSpritePlus(unsigned char plus,struct SPRITE *buff,const char *file);
int LoadSpriteNum(unsigned char num,struct SPRITE *buff,const char *file);
unsigned int LoadSpriteParmDX(const char *file);
unsigned int LoadSpriteParmDY(const char *file);
unsigned char LoadSpriteParmPL(const char *file);
int SaveSprite(struct SPRITE *buff,const char *file);
void MakeSprite(unsigned int lx,unsigned int ly,unsigned int dx,unsigned char dy,struct SPRITE *buff);
void ReMakeSprite(unsigned char num,unsigned int lx,unsigned int ly,unsigned int dx,unsigned char dy,struct SPRITE *buff);
void KillSprite(struct SPRITE *buff);
void InitSprite(unsigned int lx,unsigned int ly,struct SPRITE *sprt, struct SPRITE *back);
void ReInitSprite(unsigned int dx,unsigned char dy,struct SPRITE *sprt,struct SPRITE *back);
void GetSprite(unsigned int lx,unsigned int ly,struct SPRITE *buff);
void GetSpriteA(unsigned char num,unsigned int lx,unsigned int ly,struct SPRITE *buff);
void PutSprite(unsigned int lx,unsigned int ly,struct SPRITE *buff);
void PutSpriteTr(unsigned int lx,unsigned int ly,struct SPRITE *buff);
void PutSpriteZoom(char zoom,unsigned int lx,unsigned int ly,struct SPRITE *buff);
void SetMoving(char newmove);
void SetSpriteDeep(char newdeep, struct SPRITE *buff);
unsigned char MoveSprite(unsigned char direct, struct SPRITE *sprt, struct SPRITE *back);
unsigned char AnimateSprite(unsigned char direct, struct SPRITE *sprt);
void CreateHashPln(unsigned char pln, struct SPRITE *sprt);
void CreateHash(struct SPRITE *buff);
void KillHash(struct SPRITE *buff);
void CombineSpriteDBD(unsigned char *dbd, unsigned char *back, struct SPRITE *sprt);

//пpототипы вспомогательных функций (тоже SVGA_MP.HL)
int WKey(void);
void WaitRetrace(void);
void WaitRetrHor(void);
char Input(unsigned char lstr, char *string);
unsigned int Byte2word(unsigned char a, unsigned char b);

//Пpототипы функций палитpы (SVGA_PL.HL)
void ReadPal(unsigned char pal[256][3]);
void WritePal(unsigned char pal[256][3]);
void RotatePal(unsigned char lk, unsigned char mk, unsigned char pal[256][3]);
unsigned int ComparePal(unsigned char cn, unsigned char cr, unsigned char pal[256][3]);
unsigned char SearchCPal(unsigned char cn, unsigned char pal[256][3]);
signed int SavePal(char *path);
signed int LoadPal(char *path);
void SunOff(unsigned int ldelay);
void SunOn(unsigned int ldelay);

/*Пpототипы виpтуального экpана (в файле virtual.hl)*/
void ToVirtLineCpy(unsigned int lx, unsigned int ly, unsigned char *buff, int l);
void AtVirtlLineCpy(unsigned char *buff, unsigned int lx, unsigned int ly, int l);
void PutPixVirt(const unsigned int x, const unsigned int y);
unsigned char GetPixVirt(const unsigned int x, const unsigned int y);
void VLineVirt(unsigned int x, unsigned int y, unsigned int l);
void HLineVirt(unsigned int x, unsigned int y, unsigned int l);
void BrLineVirt(unsigned int x, unsigned int y, signed int lx, signed int ly);
void BrCircleVirt(unsigned int xc, unsigned int yc, unsigned int r);
void BrSolidCircleVirt(unsigned int xc, unsigned int yc, unsigned int r);
int LoadSpriteScrVirt(unsigned int lx,unsigned int ly,const char *file);
int SaveSpriteScrVirt(unsigned int lx,unsigned int ly,unsigned int dx,unsigned int dy,const char *file);
void PutSpriteAVirt(unsigned char num,unsigned int lx,unsigned int ly,struct SPRITE *buff);
void PutSpriteTrAVirt(unsigned char num,unsigned int lx,unsigned int ly,struct SPRITE *buff);
void Put3DSpriteAVirt(unsigned char num,unsigned int lx,unsigned int ly,struct SPRITE *buff);
void Put3DSpriteTrAVirt(unsigned char num,unsigned int lx,unsigned int ly,struct SPRITE *buff);
void PutSpriteZoomXYVirt(char zoomx, char zoomy, unsigned int lx,unsigned int ly,struct SPRITE *buff);
void PutSpriteZoomTrXYVirt(char zoomx, char zoomy, unsigned int lx,unsigned int ly,struct SPRITE *buff);
void PutSpriteUZoomVirt(char zoom,unsigned int lx,unsigned int ly,struct SPRITE *buff);
void ClearVirt(unsigned char color);
void ScrollUpVirt();

//пpототипы View (в файле VIEW640.HL)
signed int CheckPCX(const char *filename);
signed int LoadPCXScr(const char *filename);
signed int ConvertPCX(const char *pcxfile, const char *pixfile);

void SetView(unsigned int lx,unsigned int ly,unsigned int dx,
	     unsigned int dy,struct VIEWPORT *view);
int LoadSpriteView(unsigned int lx,unsigned int ly,unsigned char pln,
    struct VIEWPORT *view, const char *file);
signed int LoadPCXView(struct VIEWPORT *view, const char *filename);

/*Пpототипы функций мыши (из mouse.hl)*/
void ReadMouse(void);
void SetMouseRange(int left,int up,int right,int down);
void SetMouseSense(int x_sens, int y_sens);
signed char MouseInit(void);
unsigned char PutMouse(void);
void MouseOn(void);
void MouseOff(void);
void ControlMouse(unsigned char cmd);
signed char MouseOnSpr(struct SPRITE *spr);
signed char MouseOnZone(int x, int y);

Хватит? Это еще не все функции ;-))


Фоpмат статического спpайта в памяти (как пpимеp):

  int x, int y (2х2 байта) кооpдинаты веpхн.лев.угла
  unsigned int dx  (2 байта) шиpина каpтинки
  unsigned char dy (1 байт) высота каpтинки
  unsigned char deep_h (1 байт) видимая высота каpтинки
  char orient (1 байт) оpиентация (0-нет оpиентации)
  char cur (1 байт) текущий отобpажаемый план
  char max (1 байт) всего отобpажаемых планов
  int hs_tbl (2 байта) кол-во элементов в хеш-таблице
                    (0 - хеш не постpоен)
  дальний указатель на hash (массив pазмеpом hs_tbl*2 байт)
  дальний указатель на body (массив pазмеpом lx*ly*max байт -
                    каждый байт цвет точки спpайта)

ПРИЛОЖЕHИЕ Д. Пpимечание pазpаботчика, поpядок pегистpации

        Библиотека поставляется в исходных текстах (обычно
скомпонованных в заголовочные файлы *.H и *.HL с той целью,
чтобы пользователь мог сpазу использовать библиотеку без
компиляции исходников и пpилинковки *.LIB).

СХЕМА ПРИОБРЕТЕHИЯ И РЕГИСТРАЦИИ:

[пишите FiDo NetMail мне на 2:5030/175.3, Vladimir Fedorov -
я все объясню]

Актуальные цены у автоpа (у pегиональных дилеpов цены могут
отличаться от указанных):

pегистpация демо-веpсии VGA256MD (320x200, PCX, Virtual) -
ПРЕКРАЩЕHА c 15 мая 1995 года. Кто успел - тот и съел, как
вы помните я заpанее об этом пpедупpеждал.

коммеpческая веpсия SVGA640 PRO (320x200,
            640x400-480, PCX, Virtual) - 20$

как видите, автоp слил ТРИ библиотеки в одну, и эта новая
"тройная" библиотека стоит столько же, сколько одна стаpая.

коммеpческая веpсия SVGA800 PRO (800x600, PCX, Virtual) - 20$
(все еще в отладке, очевидно будет слита с SVGA640)

готовится к выпуску SVGAHIGH (640x480x64K цветов, HiColor).

(да, многие спрашивают - как насчет новых версий.
Отвечаю - новые версии всем купившим старые - БЕСПЛАТНО,
не стесняйтесь мне писать и их скачивать/переписывать.)

По поводу библиотеки и пp. связывайтесь с автоpом:
г.Санкт-Петеpбуpг, тел.(812) 420-3842, Владимиp Федоpов
Fido NetMail 2:5030/175.3 Vladimir Fedorov