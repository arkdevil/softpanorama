Софтпанорама 1992, No.4 (28) *** Articles ***  Составитель Н.Н.Безруков
************************************************************************
                                  Дополнительные материалы и макросы, 
                                  относящиеся к в данной статье,
                                  помещены в разделе FORUM\ME-CLUB\GURIN
                                                                  Б.Н.Н.

                               Гурин С. В.

     ИСПОЛЬЗОВАНИЕ РЕДАКТОРА MULTI-EDIT КАК ИНТЕГРИРОВАННОЙ  СРЕДЫ
              ПРИ СОЗДАНИИ РАЗЛИЧНЫХ ПРОГРАММНЫХ СИСТЕМ

                 Томск, ТПИ, кафедра электрических станций.
                        Рабочий телефон 49-25-07.


                     В данной статье излагается подход,  который позволяет
                     быстро и качественно выполнить разработку  достаточно
                     сложных интегрированных прикладных программных систем.


                               Содержание

       1. Возможности интегрированной среды Мulti-Edit
       2. Организация взаимодействия макроязыка с другими языковыми
          системами на примере Tурбо C++
       3. Общий план построения прикладной программной системы


                                Введение

   При создании сложных интегрированных прикладных программных систем разра-
ботчикам приходится создавать целый класс подсистем, которые можно отнести к
общеупотребительным. Таковыми можно считать: подсистема интерактивной  помо-
щи, подсистемы различных меню, подсистема управления простыми базами данных,
файловая оболочка,  редактор текстов,  калькулятор, средства  работы в сети.
Традиционный способ основан либо на самостоятельном проектировании каждой из
подсистем, либо на использовании библиотек. Самостоятельная разработка  тре-
бует достаточно большого времени и, чаще всего, может осуществляться  только
достаточно большим коллективом программистов. Использование библиотек  может
существенно экономить время разработки, но вызывает кучу проблем по согласо-
ванию интерфейсов  между собственной  программой и  библиотеками и библиотек
между собой. Кроме того, маловероятно, что в распоряжении разработчика  ока-
жутся все нужные библиотеки.

   В данной статье излагается другой подход. Он основан на максимальном  ис-
пользовании уже готового программного обеспечения. База этого подхода - мощ-
ная интегрированная среда текстового редактора Multi-Edit версии 5.00.  Если
посмотреть на список возможностей, предоставляемых редактором Multi-Edit, то
можно убедиться, что он покрывает весь спектр перечисленных выше общеупотре-
бительных подсистем  и,  кроме  того,  имеет  встроенный алголоподобный язык
программирования. В  этом смысле,  сочетание мощной  интегрированной среды и
языка программирования напоминает мне сочетание языка C и операционной  сис-
темы UNIX. Язык C создавался как основное средство проектирования операцион-
ной системы и распространение UNIX во многом обусловило распространение  са-
мого языка C.

   Учитывая это, можно рассматривать Multi-Edit как гибкий и легко развивае-
мый инструмент, причем его гибкость и мощность во многом обусловлена  встро-
енным языком, на котором, кстати, созданы все подсистемы Multi-Edit.  Сделаю
лирическое отступление и скажу, что ни одна из программных систем, доступных
на IBM PC, не произвела на меня такого сильного впечатления, как Multi-Edit.
После сказанного остается удивляться, почему этот инструмент используется на
малую долю своих потенциальных возможностей - в основном только как редактор
текста.

   Несмотря на столь широкие возможности, все же есть ряд подзадач,  которые
интегрированная среда Multi-Edit не может удовлетворить. К таким  подзадачам
можно, например, отнести:

  - ввод/вывод и обработка прерываний реального времени от внешних устройств,
  - достижение скорости, которую могут обеспечить лишь программы, написанные
    на ассемблере или, например, на Cи,
  - работа с графикой.

В то же время можно отметить, что эти возможности достаточно легко  реализу-
ются в других языковых системах, например, в C. Таким образом, если бы  уда-
лось осуществить взаимодействие макросов макроязыка с процедурами и функция-
ми других языков, то класс задач, которые можно реализовать в  интегрирован-
ной системе Multi-Edit, был бы существенно расширен.


              1. Возможности интегрированной среды Мulti-Edit

    В интегрированной системе Multi-Edit можно выделить ряд подсистем: неко-
торые из них являются встроенными, а некоторые - прикладными, созданными  на
базе  встроенных  с  использованием  макроязыка. Прикладные подсистемы могут
быть достаточно легко изменены (если есть исходные тексты) или  перепроекти-
рованы заново, с  учетом каких-либо специфических  требований. Далее я  буду
рассматривать наиболее важные особенности, имеющие отношение, в основном,  к
интегрированной системе, и, лишь вскользь, некоторые  возможности Multi-Edit
как редактора текстов.

   1. Макроязык.
   Макроязык  Multi-Edit  представляет  собой алголоподобный алгоритмический
полуинтерпретируемый язык  - выходным  кодом компилятора  является некоторый
промежуточный интерпретируемый код. Единицей компиляции языка является  мак-
рофайл, который может состоять из одного или нескольких макросов. Макрос яв-
ляется эквивалентом процедуры с несколько необычным способом передачи  пара-
метров в виде текстовой  строки, отдельные аргументы в  которой определяются
как:
   /имя_аргумента=значение
По сравнению с обычным способом передачи параметров, макроязык разрешает ис-
пользование переменного  списка параметров,  который может  быть сформирован
или изменен динамически  на этапе выполнения.  Структурно макрос состоит  из
раздела описания переменных и тела, содержащего выполняемые операторы.  Мак-
рос может содержать в своем теле некоторое подобие процедур. Внутренние про-
цедуры не имеют  аргументов и возвращаемых  значений, поэтому обмен  данными
между внутренними процедурами и  телом макроса выполняется через  ранее опи-
санные переменные. Для  хранения статических данных  макроязык предоставляет
механизм динамических глобальных переменных, время жизни которых определяет-
ся явными операциями создания и уничтожения. Глобальные переменные  доступны
всем макросам - через них  также может быть огранизован межмакросный  обмен.
Полуинтерпретируемость,  динамические  глобальные  переменные и динамическая
строка параметров обеспечивают возможность раздельной компиляции и динамиче-
ского связывания макросов во время выполнения. Более того, в процессе выпол-
нения некоторого макроса, можно  создать тело другого макроса,  откомпилиро-
вать его и тут же выполнить. Макросы могут быть динамически связаны с клави-
шами, т.е. нажатие на некоторую клавишу может быть ассоциировано с  выполне-
нием некоторого макроса.

    В языке определены целые, плавающие, символьные и строковые  переменные.
Для  строковых  переменных  определено  очень  большое число разнообразных и
удобных операций и  библиотечных (встроенных) функций.  Операторы управления
представлены конструкциями if..then..else, while, goto и call (вызов  проце-
дуры).

    Встроенная библиотека содержит большое число разнообразных функций, про-
цедур и системных переменных. Основные разделы библиотеки:
    - текстовые операции
      - операции с текстовыми блоками
      - позиционирование маркера
      - операции поиска - замены
      - строковые операции
    - назначения клавиш на макросы
    - управление временными событиями (по таймеру)
    - интерфейс с
      - операционной системой
      - подсистемой помощи (help)
    - операции с
      - файлами
      - экраном
      - клавиатурой
      - окнами
      - мышкой

    2. Подсистема меню
    Кроме библиотеки встроенных функций, Multi-Edit  позволяет  организовать
библиотеку (набор) макрофайлов, реализующих проблемно-ориентированные  высо-
коуровневые операции или подсистемы. Одной из таких подсистем является  под-
система меню, позволяющая динамически создавать меню различных типов:
    - горизонтальное меню верхнего уровня,
    - выпадающее вертикальное меню,
    - всплывающее вертикальное или горизонтальное меню,
    - вертикальное меню с переменным числом элементов,
    - меню с произвольным расположением и типом полей, поля могут
      иметь следующие типы:
      - целое десятичное число,
      - целое шестнадцатиричное число,
      - символьная строка,
      - вертикальное подменю,
      - выбор одного из двух вариантов,
      - выбор "1 из N" (аналогично кнопочному переключателю без фиксации)
      - переход к выполнению некоторого макроса,
      - код клавиши,
      - часть текстового окна (динамический список символьных строк),
      - окно для редактирования текста,
      - каталог файлов

    Для всех типов меню определен  клавишный выбор и выбор с  помощью мышки.
Макросы меню могут  быть вызваны из  любых макросов. Кроме  основных функций
работы с меню имеется дополнительный сервис:
    - для каждого элемента и поля меню можно определять свою собственную
      контекстную помощь; объем информации, предоставляемой по каждому
      пункту, может быть сколь угодно большим,
    - для полей типа целого числа и символьной строки можно определить
      список-историю нескольких последних значений,
    - для динамических меню дополнительно определены встроенные функции
      создания, удаления, копирования и редактирования элементов меню.

    3. Контекстная помощь (Help)
    Подсистема контекстной помощи  основана на использовании  языка описания
гипертекстов. Текст помощи записывается в файле как обычный текст, но допол-
нительно снабжается операторами метаязыка:
    - раздел помощи,
    - ссылка на другой файл,
    - ссылка на другой раздел,
    - ссылка на некоторый текст,
    - именованная (короткая) ссылка, активизируемая по назначенной клавише,
    - вызов некоторой программы (exe, com или bat),
    - изменение атрибутов текста
    Текст помощи может быть оформлен произвольным образом, включая  таблицы,
нарисованные в псевдографике. Можно оформлять часть текста как меню,  пункты
которого - это ссылки на другие разделы помощи. Используя перекрестные ссыл-
ки, можно задавать любую структуру  перехода по разделам помощи: линейную, в
виде дерева, в виде произвольного графа. Текст помощи может быть размещен  в
одном или  нескольких файлах.  Для уменьшения  размеров файлов  и увеличения
скорости перехода по ссылкам используется индексный компилятор help-файлов.

    4. Вызов других программ из Multi-Edit
    Запуск программы из макросов Multi-Edit может быть выполнен с  использо-
ванием встроенной функции shell_to_dos или сервисных макросов. Возможно  не-
сколько режимов запуска:
    - без выгрузки Multi-Edit,
    - с выгрузкой Multi-Edit на диск,
    - с выгрузкой Multi-Edit на EMS,
    - с выгрузкой Multi-Edit на EMS и диск
При полной выгрузке в  оперативной памяти остается резидентная  часть длиной
примерно 2 килобайта, поэтому  возможен запуск достаточно сложных  программ,
требующих  много  памяти.  После  завершения программы, состояние Multi-Edit
восстанавливается таким, каким оно было до запуска программы. Остающаяся ре-
зидентная часть может запускать  программу либо непосредственно, либо  через
command.com. Сервисные  макросы предоставляют  удобные средства  по сохране-
нию/восстановлению экрана и управлению режимами выгрузки и запуска. Типичным
примером запускаемых программ являются компиляторы различных языков програм-
мирования.

    5. Система управления базами данных
    В среде  Multi-Edit разработана  простая, текст-ориентированная  система
управления базами данных, основанная  на использовании динамического меню  с
произвольным числом и типом полей. Несмотря на свою простоту, она  покрывает
достаточно большое число практических задач, связанных со структурным хране-
нием и обработкой информационных  массивов. Наиболее просто реализуется  ие-
рархическая модель базы данных с организацией в виде дерева. Система  управ-
ления предоставляет следующие возможности:
    - создание новой базы данных с определенной структурой,
    - создание и удаление разделов,
    - создание, удаление, копирование и редактирование элементов,
    - просмотр и выбор элемента по заданному признаку,
    - запуск макроса функциональной обработки.
Физически, записи базы данных реализуются как строки текстовых метафайлов. В
одном  метафайле  можно  создавать  несколько  различных баз данных. Примеры
встроенных баз данных Multi-Edit: параметры настройки интегрированной среды,
список адресов-телефонов, список и параметры компиляторов языков  программи-
рования, типы и режимы принтеров.

    6. Текстовый редактор
    Текстовый редактор представляет собой систему макросов. Расширение  воз-
можностей редактора  осуществляется за  счет добавления  новых макросов. Так
как  многооконность и многофайловость является внутренним свойством интегри-
рованной среды, то эти качества переносятся также и на редактор. Особо можно
выделить динамическую систему назначения клавиш на макросы, реализующие  за-
данные действия, и присвоения функциональным клавишам названий (меток), ото-
бражаемых в нижней строке  экрана. Возможности, доступные в  редакторе текс-
тов:
    - одновременное редактирование нескольких файлов в различных окнах с
      возможностью межоконного копирования частей файлов,
    - развитая система откатов (восстановление результатов предыдущих
      действий),
    - запоминание последовательностей нажатий на клавиши с последующим
      многократным повторением,
    - форматирование текста,
    - распечатка текста с установкой режимов принтера,
    - проверка правописания,
    - поиск и подстановка с использованием регулярных выражений,
    - многофайловый поиск,
    - рисований линий в псевдографике.

    7. Калькулятор
    Калькулятор может  работать с  целыми (десятичными,  шестнадцатиричными,
восьмиричными, двоичными) и плавающими числами. Доступны все  арифметические
и логические операции.

    8. Файловая оболочка
    Оболочка позволяет создавать от одного до пяти окон, в каждом из которых
выводится свой каталог. Определены операции прохода по каталогам, смены  те-
кущего каталога или диска, запуска выполняемых файлов, загрузки файлов в ре-
дактор, удаления, копирования и переименования файлов. Каталоговая структура
может быть представлена графически в виде дерева подкаталогов. Файлы катало-
гов при выводе могут быть отсортированы (по имени, расширению, размеру,  да-
те)   и   отфильтрованы   с   использованием   универсальных   сопоставлений
(wildcards).

    9. Подсистема работы с мышкой
    Мышка может быть использована практически во всех подсистемах интегриро-
ванной среды как альтернатива  операциям перемещения маркера. В  большинстве
случаев она более удобна.

    10. Подсистема работы в сети
    Подсистема позволяет работать в сетях с использованием различных модемов
и сетевых протоколов. Возможности:
    - ведение журнала работы в сети,
    - доступ к файлам,
    - база данных телефонных номеров для связи,
    - сервис по установке параметров модемов и эмулятора терминала.

    11. Подсистема установок
    Эта подсистема позволяет выполнить настройку  интегрированной среды:
    - формат и раскладку экрана,
    - цвета экрана, используемые в различных подсистемах,
    - назначения клавиш на макросы,
    - параметры драйвера мышки и принтеров,
    - назначения расширений имен файлов, учитывая специфику используемых
      языков программирования и компиляторов,
    - режимы выгрузки Multi-Edit и рабочий каталог.


       2. Организация взаимодействие макроязыка с другими языковыми
                   системами на примере Tурбо C++

   Для организации взаимодействия макроязыка с другими языковыми системами я
предлагаю следующее решение: интегрированная система Multi-Edit  запускается
из тела некоторой программы, содержащей функции, которые дополняют возможно-
сти Multi-Edit: между этими функциями и макросами создается интерфейс, осно-
ванный  на  использовании  программных  прерываний. В структуре программного
пректа выделяются функции (подзадачи), которые невозможно реализовать на ма-
кроязыке и программируются на любом подходящем языке. К этим функциям добав-
ляется главная программная функция,  которая анализирует командную строку  и
вызывает Multi-Edit с контролем завершения. Таким образом, в оперативной па-
мяти одновременно сосуществуют функции  на выбранном языке и  макросы Multi-
Edit. После выхода из Multi-Edit завершается и программа, написанная на  вы-
бранном языке.  Для вызова  функций из  макроязыка используется  программное
прерывание. Использование  программного прерывания  хорошо описано  в статье
Алексея Романова, опубликованной в одном из последних выпусков Софтпанорамы:
"INTERFACING MULTI-EDIT WITH ASSEMBLY LANGUAGE". Методика, предложенная Але-
ксеем Романовым хорошо подходит  для включения в макроязык  небольшого числа
коротких ассемблерных вставок. Ограничения этой методики:

    - можно использовать только язык ассемблера,
    - длина ассемблерных вставок не может превышать 2048 байт,
    - невозможно использовать библиотеки языковых систем, например,
      стандартную библиотеку C.

Методика, предлагаемая  в этой  статье, свободна  от указанных  ограничений.
Идея использования программных прерываний заключается в том, что в программе
на макроязыке генерируется прерывание (используя функцию intr), а  параметры
передаются через регистры процессора. К программе на выбранном языке  добав-
ляется еще одна функция: диспетчер прерываний, который сохраняет  передавае-
мые параметры и вызывает требуемую функцию. Интерфейс между макросом  макро-
языка и функций на выбранном  языке получается таким же, как  между макросом
макроязыка и функциями DOS или  BIOS. Функция на выбранном языке  возвращает
результаты также  через регистры.  Разберем подробнее  реализацию описанного
подхода, используя в качестве выбранного языка C++.

// ************************ Программа на Turbo C++ *************************

# include <process.h>
# include <stdlib.h>
# include <dos.h>

# if !defined(__SMALL__)
#   error Программу можно компилировать только в модели памяти small
# endif

extern unsigned _heaplen = 2000; // размер области динамических данных
extern unsigned _stklen  = 500;  // размер области стека
extern int r_ax = 0;             // регистр кода ошибки
extern int r_bx = 0;             // обменные регистры
extern int r_cx = 0;
extern int r_dx = 0;
extern int r_si = 0;
extern int r_di = 0;

void interrupt multi_edit_handler(void); // прототип диспетчера прерываний

# pragma argsused
void main(int argc, char *argv[], char *env[])
{ static int  vector;
  static char vector_environment[16] = "ME_VECTOR=";

  // поиск свободного вектора в таблице прерываний
  for (vector = 0x80; vector <= 0xFF; ++vector)
    if (!peek(0, 4 * vector) && !peek(0, 4 * vector + 2)) break;
  if (vector == 0xFF) abort();
  // формирование строки окружения для передачи вектора в Multi-Edit
  itoa(vector, vector_environment + 10, 10);
  // добавление полученной строки в окружение
  if (putenv(vector_environment) == (-1)) abort();

  // захват вектора прерывания и установка адреса диспетчера
  setvect(vector, (void interrupt (far *)(...))multi_edit_handler);
  // запуск Multi-Edit
  if (spawnve(P_WAIT, "me.exe", argv, env) == (-1)) abort();
  // восстановление значения вектора прерывания
  setvect(vector, 0L);
}

// Примеры двух функций, вызываемых из Multi-Edit

void function_0(void) // вывод байта r_cx в порт внешнего устройства r_bx
{ outportb(r_bx, (unsigned char)r_cx); }

void function_1(void) // ввод байта r_cx из порта внешнего устройства r_bx
{ r_cx = inportb(r_bx); }

// Инициализация массива ссылок на функции
extern int max_function = 1;
extern void (*function_array[])(void) = { function_0, function_1 };

// ************************* конец программы *******************************


   Комментарии к программе на C++:

   Для того, чтобы программа на C++ занимала в памяти как можно меньше  мес-
та, ее нужно компилировать в модели памяти small. При модели tiny  возникают
проблемы с раздельной компиляций драйвера прерываний, большие же модели  па-
мяти требуют большего места.

   Для передачи  данных функциям  и возврата  значений, определяются внешние
целые переменные: r_ax, r_bx,  r_cx, r_dx, r_si, r_di,  отражающие состояние
соответствующих регистров.  С их  помощью можно  передавать функциям  на C++
простые и структурные данные. Простые данные передаются либо  непосредствен-
но, либо через ссылку. Структурные  данные всегда передаются по ссылке.  Для
передачи структурных  данных в  Multi-Edit используются  строки, заполненные
нужным образом. Для возврата значений в Multi-Edit можно использовать  также
либо простые переменные, либо структурные, передаваемые через ссылки, указы-
вающие на локальные строковые переменные.

   Регистр ax используется для передачи  номера функции и для возврата  кода
ошибки. Если ошибки нет, то возвращается 0; при ошибке, соответствующая  C++
функция должна установить значение переменной r_ax, равное коду ошибки,  ко-
торый будет анализироваться в макросах Multi-Edit.

   Для уменьшения объема памяти загруженной программы можно уменьшить размер
кучи, из которой выделяется  память при динамическом создании  объектов. Для
этого нужно оценить максимальный суммарный размер одновременно  существующих
динамических объектов  и использовать  его для  ограничения размеров области
данных. Это делается установкой системной переменной _heaplen,  определяющей
размер динамически выделяемой области  данных. Следует учитывать, что  часть
динамически выделяемой памяти используется ядром времени исполнения,  компо-
нуемым к каждой C++ программе. Важное замечание: C-стеком пользуется  только
функция  main  и  ядро,  остальные  функции  используют Multi-Edit-стек. Это
накладывает  ограничение  на  использование  автоматических  переменных:   в
C-функциях желательно использовать только простые автоматические  переменные
и не использовать автоматические  структурные переменные: массивы и  записи.
Кроме  того,  нежелательно  использовать  рекурсию.  Поскольку использование
C-стека  очень  ограничено,  его  размер,  задаемый  в  системной переменной
_stklen, может быть существенно уменьшен.

  Вектор прерывания, используемый для  связи макросов Multi-Edit и  программ
C++, ищется во второй половине таблицы прерываний: используется первый попа-
вшийся свободный  вектор. При  запуске, программе  Multi-Edit передаются все
параметры командной строки и все строки окружения плюс строка ME_VECTOR, ис-
пользуемая для передачи номера найденного вектора прерывания. После заверше-
ния Multi-Edit, вектор прерывания освобождается.

  Функции, вызываемые из  макросов по номеру,  могут быть записаны  в том же
файле, что и main, или в других файлах при раздельной компиляции. Обязатель-
ное условие: функции должны описываться как void имя(void). Для быстрого вы-
зова нужной функции определяется внешний массив function_array, который ини-
циализируется ссылками на функции,  вызываемые из Multi-Edit: номер  функции
равен индексу в массиве. Массив function_array используется диспетчером пре-
рываний. Максимальный индекс массива, равный числу функций минус 1,  опреде-
ляется в глобальной целой  переменной max_function, которую использует  дис-
петчер прерываний для контроля корректности номера функции.

   Диспетчер прерываний написан на ассемблере:

; ************************** диспетчер прерываний *************************

DGROUP group _DATA
  assume  ds:DGROUP

_DATA segment word public 'DATA'
_DATA ends

_TEXT segment byte public 'CODE'
  assume  cs:_TEXT

@multi_edit_handler$qv proc far    ; Диспетчер связи с Multi-Edit
  push  es                         ; Сохранение регистров, не используемых
  push  ds                         ; для обмена параметрами между функциями
  push  bp                         ;  C++ и макросами Multi-Edit
  sti                              ; Разрешение аппаратных прерываний
  mov   bp, DGROUP                 ; Установка сегментного регистра данных
  mov   ds, bp
  cmp   ax, word ptr DGROUP:_max_function  ; Контроль правильности задания
  ja    short error_function               ; номера функции
  mov   word ptr DGROUP:_r_bx, bx  ; Заполнение обменных переменных
  mov   word ptr DGROUP:_r_cx, cx  ; соответствующих регистров
  mov   word ptr DGROUP:_r_dx, dx
  mov   word ptr DGROUP:_r_si, si
  mov   word ptr DGROUP:_r_di, di
  mov   bx, ax                     ; Получение индекса в таблице C-функций
  shl   bx, 1                      ; по значению регистра ax
  mov   cx, word ptr DGROUP:_function_array[bx]
  xor   ax, ax                     ; Обнуление кода ошибки
  mov   word ptr DGROUP:_r_ax, ax
  cmp   cx, ax                     ; Контроль отсутствия функции
  je    short error_function       ;
  call  cx                         ; Вызов C-функции с заданным номером
  mov   di, word ptr DGROUP:_r_di  ; Заполнение регистров соответствующими
  mov   si, word ptr DGROUP:_r_si  ; значениями обменных переменных
  mov   dx, word ptr DGROUP:_r_dx
  mov   cx, word ptr DGROUP:_r_cx
  mov   bx, word ptr DGROUP:_r_bx
  mov   ax, word ptr DGROUP:_r_ax  ; Заполнение значения кода ошибки
  jmp   short exit_handler
error_function:
  mov   ax, 1                      ; Возврат 1 при ошибке номера функции
exit_handler:
  pop   bp                         ; Восстановление регистров, не использ.
  pop   ds                         ; для обмена параметрами между функциями
  pop   es                         ; C++ и макросами Multi-Edit
  iret                             ; Возврат в Мulti-Edit
@multi_edit_handler$qv  endp

_TEXT ends

  public @multi_edit_handler$qv
  extrn  _r_ax:word
  extrn  _r_bx:word
  extrn  _r_cx:word
  extrn  _r_dx:word
  extrn  _r_si:word
  extrn  _r_di:word
  extrn  _function_array:word
  extrn  _max_function:word
  end

; *********************** конец текста диспетчера **************************

  Комментарии к диспетчеру прерываний:

  Поскольку я не являюсь знатоком ассемблера, то для написания  ассемблерных
процедур использую следующий прием:  пишу заготовку ассемблерной функции  на
C++ и компилирую C-текст в ассемблерный. После получения ассемблерного текс-
та корректирую его в соответствии со своими задачами.

  Обработчик  прерываний  заполняет  обменные  переменные  r_bx, r_cx, r_dx,
r_si, r_di и  вызывает C-функцию с  номером, передаваемым через  регистр ax.
После возврата из функции обработчик переписывает обменные переменные в  ре-
гистры и возвращает управление  Multi-Edit. Для разрешения работы  таймера и
внешних прерываний, командой sti разрешаются аппаратные прерывания. Процеду-
ра контролирует недопустимый номер  функции по двум критериям:  выход номера
функции за максимальный номер и несуществующий адрес (нулевой). В обоих слу-
чаях функция не вызывается и в регистре ax возвращается код ошибки, равный 1.

  Обработчик прерываний компилируется программой tasm и связывается с основ-
ной и вызываемыми функциями на этапе редактирования связей программой tlink.
Так как, обработчик не зависит от числа вызываемых функций, то нужно скомпи-
лировать его один раз и пользоваться в дальнейшем объектным файлом.

  Теперь разберем более  подробно механику вызова  C++ функций из  макросов.
Во-первых, необходимо получить вектор прерывания. Это лучше всего сделать  в
одном их стартовых макросов Multi-Edit. Номер вектора можно сохранить в гло-
бальной целой переменной:

  def_int(me_vector);                           { объявление переменной }
  .........
  val(me_vector, get_environment('ME_VECTOR')); { получение знач. вектора  }
  set_global_int('me_vector', me_vector);       { установка глоб. перемен. }
  .........

  Синтаксис вызова C++ функции из любого макроса:

  def_int(me_vector);
  me_vector := global_int('me_vector');
  .......
  { установка регистров r_bx, r_cx, r_dx, r_si, r_di если это требуется }
  r_ax := номер_функции_на_C++;
  intr(me_vector);
  if (r_ax <> 0) then { ошибка }
  else                { нормальное завершение }
  end;

   Таким образом, мы разобрали, как создавать функции на языке C++, как  за-
пускать Multi-Edit, чтобы эти функции были ему доступны и как обращаться  из
макросов макроязыка к  функциям C++ и  получать от них  результаты. Отметим,
что C++ и  макроязык рассматриваются в  данном контексте как  равноправные и
дополняющие друг друга системы. Очевидно, что вместо Turbo C++ можно исполь-
зовать любой другой подходящий язык. Наибольшая компактность кода и скорость
выполнения получается, естественно, при использовании ассемблера. В заключе-
ние отмечу следующее: несмотря  на то, что приводимые  программные фрагменты
являются отлаженными рабочими программами, к ним нужно относиться как к  ил-
люстрации описываемого  подхода, изменяя  или дополняя  в каждом  конкретном
случае.


        3. Общий план построения прикладной программной системы

   Для раскрутки прикладной  программной системы сначала  нужно сформировать
для нее собственный каталог программного проекта и переписать в него базовую
часть интегрированной системы:

   программы:         me.exe
                      memac.exe
   базовые макросы:   dvmenu.mac
                      exit.mac
                      meerror.mac
                      mehelp.mac
                      mesys.mac
                      meutil1.mac
                      meutil3.mac
                      mouse.mac
                      setup.mac
                      userin.mac
   служебные макросы: init.mac
                      keymap.mac
   базы данных:       meconfig.db
                      keymap.db
                      printers.db

Для заставки,  отображаемой при  запуске программы  пишется макрос logo.mac.
Переход к основному меню прикладной программной системы можно выполнять  че-
рез   стартовый   макрос,   имеющий   в   Multi-Edit  зарезервированное  имя
startup.mac. Начальные установки, на мой взгляд, лучше всего выполнять в ма-
кросе, вызываемом до startup.mac: имя этого макроса задается в разделе осно-
вного меню Install  ( Display setup,  Screen layouts). Для  примера  приведу
свой вариант начальных установок:

{ ********************* макрос начальных установок *********************** }
$macro gsv_stat from EDIT DUMP;
  def_int(vector);
  run_macro('gsv_stat^gsv_install_star'); { Установка "Звездного неба" }
  set_global_str('!help_path!', путь_для_поиска_help_файлов);
  set_global_int('gsv_blink_bit', 0); { Выбор 16-и цветов фона без мигания}
  r_ax := $1003; r_bx := global_int('gsv_blink_bit'); intr($10);
  r_ax := $1900; intr($21);
  set_global_int('gsv_drive',      r_ax and $ff);  { Системные переменные }
  set_global_str('gsv_path',       dir_path);
  set_global_int('gsv_mouse',      mouse);
  set_global_int('gsv_swap_mode',  swap_mode);
  set_global_int('gsv_reduce_mem', reduce_mem);
  val(vector, get_environment('ME_VECTOR'));
  set_global_int('gsv_vector', vector);
{ Прим: gsv - это префикс, который я использую для именования своих макросов,
        переменных и программ в интегрированной среде Multi-Edit
}
end_macro;
{ конец макроса }

    В основном каталоге программного  проекта нужно создать подкаталоги  для
исходных файлов на различных  языках, объектных файлов, подкаталоги  библио-
тек, баз данных, help-файлов и т.д.. Все дальнейшее развитие разработки луч-
ше выполнять по типу нисходящего проектирования с декомпозицией исходной за-
дачи на ряд подзадач, которые,  в свою очередь, подвергаются дальнейшей  де-
композиции.

    На основе описанного подхода мной разрабатывается две большие  программ-
ные системы:

    1. Интегрированная система программирования со сквозным  объектно-ориен-
       тированным стилем проектирования. Система многоязыковая: используются
       C++, Multi-Edit, ассемблер, Lex,  YACC и др.. При  написании программ
       применяется  сходная  русскоязычная  нотация.  Синтаксис используемых
       языков модифицируется, используя пост- и препроцессорную технику. На-
       пример, в  макроязык Multi-Edit  вводятся понятия  массивов, записей,
       констант, перечислимых типов данных и т.д..

    2. Программное  обеспечение  многопроцессорной  аналого-цифровой  модели
       энергосистемы. Модель разрабатывается на кафедре электрических  стан-
       ций  Томского  политехнического института по заказу Тюменской энерго-
       системы.
