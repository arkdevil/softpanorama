                                Корзун Евгений Георгиевич  18.02.92
                                Москва (095) р.231-07-72  д.924-52-73

                      Похвальное слово CLARION-у
                      --------------------------
        Это обращение в основном к тем, кто уже "попал в сети" CLARION
  и, в меньшей  степени, к тем, кто  находится на перепутьи. Я  надеюсь,
  что мои наблюдения (не претендующие конечно на абсолютную истину)  ни-
  кому не повредят. Для определеннности: речь идет о RELEASE 2105.

        Прежде  всего  должен  сказать,  что  почти  все  в CLAROIN меня
  раздражает. Кошмарный ассемблероподобный язык, слабо документированный
  и к тому же  имеющий ряд ошибок. В  нем сильно нехватает средств  типа
  указателя (типа C или ЕС-PL) , неявного (через указание имен  верхнего
  уровня) именования подструктур,слабы средства запроса обстановки и т.д.
        DESIGNER до раздражения "умен", настолько , что почти не  управ-
  ляем, отсутствие механизма пользовательской условной генерации  (прек-
  расно  реализованной, например, в  FOXCODE)  просто  выводит  из себя.
  Результирующие  программы  громадны,  а попытка съэкономить дисковую
  память с помощью RTL-сборки может привести к отказу на этапе  выполне-
  ния. К тому же по скорости доступа к файлам, как мне кажется, CLARION
  заметно уступает FOX 2.10.
        Уже только вышесказанного  было бы достаточно,  чтобы похоронить
  саму идею использования CLARION в промышленных разработках, если бы не
  одно  МЕЛКОЕ  обстоятельство  -  на  сегодня  он  являтся единственным
  средством,   позволяющим выполнить  разработку быстро.  Мое ощущение -
  коэффициент ускорения разработки x3 по сравнению с FOX.
        В связи с этим  Вашему рассмотрению предлагается ряд  изменений,
  проведенных в модельном файле. Их цель - исправление мелких ошибок,  и
  повышение уровня  управления проектированием. Перед этим  позволю себе
  сказать несколько слов о своей "технологии" работы. Основное  средство
  проектирования  -  DESIGNER.  По  мере  возможности  я  старался   все
  текстовые вставки  (типа SETUP,  NEXT, EDIT)  выносить в  INCLUDE.
  При таком подходе в  назначении имени очень важно  соблюдать следующее
  правило -  должно быть  не только  мнемонически понятно,  к какой про-
  цедуре и какому реквизиту относится данная вставка, но и при сортиров-
  ке по имени INCLUDE одной процедуры должны "стоять рядом". В  качестве
  "среды" разработки я использовал MULTI-EDIT (не задерживаюсь здесь  на
  некоторых "доделках"  в нем  для удобства  работы с  CLARION),т.к. ко-
  личество вставок для серьезной разработки очень быстро становится  уг-
  рожающе большим. Не обходится и без OTHER-процедур.

   ----------------
  1.  Проблема  -  трудности  при  необходимости высветки полей "цепных"
  LOOKUP справочников в FORM-процедуре.
  Например F -> A , A-> B , B  -> C ; При работе в F-FORM по значению F
  показать связанные значения A , B , C .
      Использование:описать LOOKUP A <- F, LOOKUP B <- A, LOOKUP C <- B,
  в SETUP задать K_NREDISP# =  3 и сослаться на MODEL  PROCEDURE KKFORM.
  Возможен  и  другой  путь  (например,  когда  нужно  высветить  только
  значение  из  C)  -  в  "хвосте"  какого-нибудь  COMPUTE-поля  сделать
  "ручные" GET по всей цепи LOOKUP , описав C просто как DISPLAY FIELD ,
  но  все  равно  K_NREDISP#  должно  быть  = 2 (умалчиваемое значение в
  KKFORM), т.к. COMPUTE-значения вычисляются после DISPLAY .
   
  2.  Проблема -  при  вводе "новой" записи  взять в качестве  образца
  указанную.
      Использование: - найти в TABLE запись-образец и нажать CTRL_B.
   ----------------
  3.  Проблема  -  использовать  экран  одной  FORM-процедуры в качестве
  "заставки"для вызова другой процедуры.
      Использование: в DESIGNER-е  скопировать исходную  FORM-процедуру,
  сослаться  на  MODEL PROCEDURE  KNFORM  ,  и  указать в ней в качестве
  NEXT PROCEDURE имя той, которая в действительности вызывается.
   ----------------
  4.  Проблема -  обнаружено, что иногда FORM-процедуры "зацикливаются"
  при нажатии CTRL_ENTER (и наличии некоторых ошибок введенных полей).
      Анализ показал, что здесь  "виноват" SELECT без параметров  (нигде
  кстати не описанный) , который  блокирует ввод по ACCEPT при  активном
  SCREEN , и , в случае возникновения ошибки при записи (стандартно  пе-
  реход на первое вводное поле) возникает "мертвый" цикл. Выход из тако-
  го цикла  достигается с  помощью SELECT()  с одним  значением два раза
  подряд.
   ----------------
  5.  Проблема  -  часто "хочется" при вводе в FORM-процедуре значения с
   контролем по справочнику (File Lookup=YES + ENTER-KEY) "заглянуть" в
   справочник, не теряя текущего значения введенного поля.
      Использование: находясь в таком поле нажать SHFT_ENTER
   ----------------
  6.1 Проблема   -    При обычном  (не LOOKUP)  входе в  TABLE-процедуру
  "хочется  попасть"  не  на  первую  запись,  а  на некоторое известное
  значение ключа.
      Использование:   в   SETUP   (или   где-либо   ранее)   установить
  PONTER(FILE) на нужную запись (GET или NEXT).
      Побочный эффект: если не делать установок , то TABLE "запоминает".
   ----------------
  6.2 Проблема  - в TABLE-процедуре "хочется" иметь возможность управлять
  персчетом COUNT-полей после вызова HOT-KEY процедуры.
      Использование:  если  в  HOT-процедуре  проводится  просто  замена
  "суммируемых" полей текущей  записи, то пересчет  автоматический, если
  же необходим  полный пересчет  по TABLE  (например при  добавлении или
  удалении записи/записей в HOT-процедуре)  , надо обеспечить выдачу  на
  выходе HOT-процедуры ACTION=5647.
   ----------------
  7.   Проблема   -   внесение небольшой  задержки при  вводе в SELECTOR
  быстрого поиска для того, чтобы успевать нажимать клавиши.
   ----------------
  8.  Проблема  -  при редактировании записей в разных режимах зачастую
   нужно иметь разный комплект полей "разрешенных" для ввода. Как прави-
  ло, стандартным приемом является создание нескольких FORM-процедур для
  одного  файла,  которые  отличаются  лишь  об"явлением полей ENTRY или
  DISPLAY. К сожалению это ведет к увеличению выходного кода. С  помощью
  SELECT-ов в  теле EDIT-PROCEDURE  можно управлять  последовательностью
  ввода, а данный подход позволяет выбрать первое поле ввода.
      Использование: в SETUP-PROCEDURE задать значение K_FRST_IN# равным
  номеру первого вводимого поля; например:
         .........                         ! Фрагмент SETUP-PROCEDURE
         CASE (MEM:SWITCH)                 ! * MEM:SWITCH описан снаружи
         Of (1)                            ! Начать ввод с FIRST_FIELD
            K_FRST_IN# = ?FFF:FIRST_FIELD
         Of (2)                            ! Начать ввод с SECOND_FIELD
            K_FRST_IN# = ?FFF:SECOND_FIELD
         Else                              ! Только просмотр
            ACTION = 4                     ! Не писать в файл
         End
         ...........
                               С уважением Е.Корзун

   Примечание редактора:
   Остальные файлы, относящиеся к данной заметке помещены в
разделе FORUM\CLA-CLUB.
                                                      Б.Н.Н.
