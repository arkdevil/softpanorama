
                                              Шеховцов Александр


               Уменьшение размера резидентных программ,
                 написанных на Turbo-Pascal 6.0.


  Когда кто-либо говорит, что резидентные программы следует писать  на
ассемблере, я безусловно соглашаюсь. Конечно,  язык  ассемблера  лучше
всего  создан  для  написания   маленьких   резидентных   утилит,   но
попробуйте сделать на нем что-то вроде DISKMON  из  Norton  Utilities.
Программа DISKMON имеет размер около 70 Кб, использует мощную  оконную
библиотеку и, после того как Вы выберете нужные режимы  защиты  диска,
оставляет в памяти резидент размером 8.5 килобайт, который  собственно
и защищает диск. Так неужели ради этих 8.5 Кб  нужно  набирать  70  Кб
программы на ассемблере? Теперь уже можно сказать: нет, не нужно!
  Следуя рекомендациям из данной статьи Вы тоже  сможете  использовать
и интерфейсные библиотеки, и  прочие  удобные  модули,  написанные  на
Turbo-Pascal 6.0, а по окончании работы программы оставлять  в  памяти
компьютера небольшое резидентное тело, не содержащее  ничего  лишнего.
И все это не потребует от Вас знания ассемблера!

  Итак, сначала ответим на ключевой вопрос:


                      1. Что делать.

 Рассмотрим структуру программы на языке Turbo-Pascal:
                                                
               Вершина памяти DOS (640 Кб)      
       ┌───────────────────────────────────────┐
       │           Свободная память            │
       ├───────────────────────────────────────┤
       │             Heap (Куча)               │
       ├───────────────────────────────────────┤
       │            Буфер оверлея              │
       ├───────────────────────────────────────┤
       │               Стек                    │
       ├───────────────────────────────────────┤ <- SSeg:0000
       │        Глобальные переменные          │
       │        Типизованные константы         │
       ├───────────────────────────────────────┤ <- DSeg:0000
       │      Сегмент кода модуля SYSTEM       │
       ├───────────────────────────────────────┤
       │      Сегмент кода первого модуля      │
       ├───────────────────────────────────────┤
                       ...                      
                                                
       ├───────────────────────────────────────┤    
       │      Сегмент кода последнего          │
       │      модуля                           │
       ├───────────────────────────────────────┤
       │      Сегмент кода головной            │
       │      программы                        │
       ├───────────────────────────────────────┤
       │      Program segment prefix (PSP)     │
       └───────────────────────────────────────┘ <- PrefixSeg

        
 Из рисунка видно,  что  проще  всего  избавиться  от  "лишнего"  кода
следующим образом:

      - поместить в начало головного модуля ту резидентную  процедуру,
которая останется в памяти после завершения работы программы;

      - сразу за ней поместить сегмент данных;

      - минимизировать размер сегмента данных, так  как  для  простоты
он берется весь;

      - не использовать в  резидентной  части  программы  динамические
переменные  (так  как  весь  Heap  вместе  с  его монитором   мы  тоже
выбрасываем);

      - указать новый размер резидентной  части  программы:  он  равен
размеру резидентной процедуры+размеру сегмента данных;

      - поскольку значение адреса сегмента  данных  изменилось,  нужно
как-то научиться получать  доступ  к  данным  при  вызове  резидентной
процедуры.

 В результате из нарисованной выше картинки получится:

               Вершина памяти DOS (640 Кб)
       ┌───────────────────────────────────────┐
       │           Свободная память            │
       ├───────────────────────────────────────┤    <──────────────┐р
       │        Глобальные переменные          │                   │е
       │        Типизованные константы         │                   │з
       ├───────────────────────────────────────┤ <- NewDSeg:0000   │и
       │      Сегмент кода головной            │                   │д
       │      программы (не целиком)           │                   │е
       ├───────────────────────────────────────┤                   │н
       │      Program segment prefix (PSP)     │                   │т
       └───────────────────────────────────────┘ <- PrefixSeg  <───┘


 Именно это и будет тем минимальным резидентом, который можно сделать
из программы на Turbo-Pascal.
 А теперь, после многообещающих проектов, не грех и спросить:



                      2. Как это сделать.

  Основную часть забот возьмет на себя процедура Keep. Как Вы  знаете,
в модуле DOS имеется стандартная  процедура  Keep,  которая  завершает
программу, делая ее резидентной. Мы напишем свою,  которая  делает  то
же, но еще и уменьшает размер резидентной части до минимума.
  Однако кое-что придется делать самим, так что давайте  оставим  Keep
напоследок.
  А пока рассмотрим по пунктам, о чем заботимся мы:
___________________________________

     1. Поместить в начало головного модуля ту резидентную  процедуру,
которая останется в памяти после завершения работы программы:

 Это самое простое.  Пусть  резидентная  процедура  называется  MyRes,
тогда нужный результат будет получен так:

program MiniResident;

uses DOS,CRT;          (* Указываете используемые модули,
                          как обычно *)

TYPE  ...              (* Описание типов данных          *)
VAR   ...              (* Описание глобальных переменных *)
CONST ...              (* Описание констант              *)

procedure MyRes; interrupt;

                       (* Самая первая процедура из процедур и функций
                          головного модуля программы      *)

...                    (* Тело процедуры                  *)

end;{MyRes}            (* Конец процедуры                 *)

procedure ...          (* Остальные процедуры и функции головного
                          модуля                          *)

___________________________________

      2. Сразу за ней поместить сегмент данных:

 Этим займется процедура Keep. Она должна быть  последней  по  порядку
из процедур и функций, которые попадут в резидентную часть  программы.
Сразу  за  собой  Keep  поместит  данные,  прописав  их  поверх   тела
остальных процедур и функций, в резиденте не используемых.

 Сама процедура должна быть записана так:


procedure DummyProc; forward;

procedure Keep( Num : word );

 ...                          (* Тело процедуры Keep *)

end;{Keep}

procedure DummyProc;
begin
end;{DummyProc}

 Зная местоположение процедуры DummyProc процедура  Keep  будет  точно
знать,  где  завершается  резидентная   часть   кодов   программы,   и
переместит туда сегмент данных.

 Тело  процедуры  Keep  будет  написано  чуть  позже,  так   как   она
одновременно выполнит и некоторые другие необходимые действия.

___________________________________

     3. Минимизировать размер сегмента данных, так  как  для  простоты
он берется весь:

   Для  уменьшения  размера  сегмента  данных  необходимо  свести   до
минимума количество глобальных  переменных  и  типизованных  констант,
оставив по возможности лишь те, которые Вы используете  в  резидентной
части программы. Особенно это касается массивов. Например:

TYPE  BigArr = ARRAY[1..4096] OF WORD;

(*        Не рекомендуется                      Рекомендуется   *)


                                        TYPE  PBigArr = ^BigArr;
VAR                                    VAR
   BM : BigArr;                           BM : PBigArr;

BEGIN                                  BEGIN
                                          GetMem(BM,SizeOf(BigArr));
   BM[ 1 ] := 24;                         BM^[ 1 ] := 24;

___________________________________

     4. Не использовать в  резидентной  части  программы  динамические
переменные  (так  как  весь  Heap  вместе  с  его монитором   мы  тоже
выбрасываем).

  Если Ваша резидентная процедура использует какой-либо буфер,  то  он
не должен быть указателем, который получил  память  с  помощью  GetMem
или New.
  Следовательно, все  структуры  и  массивы  для  резидентной  утилиты
необходимо описать как глобальные  переменные,  или  как  типизованные
константы. Они будут помещены в сегмент данных.

___________________________________

     5. Указать новый размер резидентной  части  программы:  он  равен
размеру резидентной процедуры+размеру сегмента данных.

  Эту работу в модуле DOS выполняет процедура Keep.  Вот  и  ее  время
пришло. Если Вы  не  особо  разбираетесь  в  ассемблере  и  внутренних
структурах Turbo-Pascal, то воспримите  Keep  как  данность  и  просто
вставьте ее в свою программу.


procedure DummyProc; external;

procedure Keep( ExitCode : byte );
(* Сдвиг сегмента данных вплотную к кодовому сегменту.
   В результате ужимается EXE - файл насколько возможно. *)

VAR
   ResidSize: word; (* размер резидентной части программы в параграфах *)
   NewDS    : word; (* значение сегмента нового DS - сегмента данных  *)
   DataSize : word; (* размер сегмента данных в параграфах            *)


begin
  NewDS := (CSeg + Ofs(DummyProc) DIV 16) +1; (* Новый сегмент данных
                                              начинается сразу после
                                              процедуры Keep *)
  DataSize := SSeg-DSeg;
  ResidSize:= NewDS-PrefixSeg+DataSize;

  asm      (* Запомним значение адреса нового сегмента данных *)
     mov ax,NewDS
     mov cs : word ptr [BufferDS], ax
  end;

  move( MEM[ DSeg:0 ], MEM[ NewDS:0 ], (SSeg-DSeg)*16);
        (* move сдвигает сегмент данных впритык
           к кодам резидентной части программы *)

  ASM                             (* Становимся резидентом *)
    mov ax,[SYSTEM.PREFIXSEG]
    mov es,ax
    mov es,es:[02CH]              (* Сначала освобожу Environment block *)
    mov ah,49H
    int 21H

    mov dx,ResidSize              (* Установим размер резидентной части *)
    mov ah,31H
    mov al,ExitCode               (* Теперь - TSR с кодом возврата ExitCode *)
    int 21H
  END;

end;{Keep}

procedure DummyProc;
begin
end;{DummyProc}


  Для опытных пользователей сообщу, что процедура Keep:

- устанавливает размер резидентной  части  программы,  равный  размеру
кода от начала программы до конца процедуры  Keep  +  размер  сегмента
данных;

- освобождает  DOS  Environment  block,  откуда  берут  свое  значение
функции ParamCount, ParamStr, EnvCount, GetEnv  и  EnvStr.  Этот  блок
расположен отдельно от остальной  программы,  обычно  ниже  ее.  После
загрузки следующей программы ее DOS Environment block почти  наверняка
будет  размещен  в  этом   свободном   месте,   а   значит   получится
дополнительный выигрыш в оперативной памяти.

___________________________________

      6. Поскольку значение адреса сегмента данных  изменилось,  нужно
как-то научиться получать  доступ  к  данным  при  вызове  резидентной
процедуры.

  Внимательный   читатель,   знающий   ассемблер,   может    спросить:
"Погодите, а что такое BufferDS в процедуре Keep и где он описан?".
  Действительно, нужно описать эту  переменную,  чтобы  компилятор  не
"ругался". Эта переменная содержит новый  адрес  сегмента  данных.  Но
чтобы узнать значение любой переменной,  нужно  знать  адрес  сегмента
данных. Следовательно,  для  получения  значения  переменной  BufferDS
нужно знать это значение заранее! Замкнутый круг?
  Нет, есть выход и из него. Поместим переменную  BufferDS  в  кодовый
сегмент.  Для  программистов  на  ассемблере  хранение  переменных   в
кодовом сегменте дело обычное, но Turbo-Pascal так просто сделать  это
не позволит. Пойдем на  хитрость:  опишем  BufferDS  как  процедуру  с
пустым телом, а занимаемое ею место используем для  хранения  значения
"переменной" BufferDS, то есть нового адреса сегмента данных.
  Поскольку BufferDS  пригодится  и  в  резидентной  части  программы,
опишем его перед MyRes.


procedure BufferDS;
begin
end;{BufferDS}

procedure MyRes; interrupt;

...

  Теперь у нас есть  все,  что  нужно.  Осталось  указать  резидентной
процедуре новое значение сегмента данных. Это нужно  сделать  в  самом
начале процедуры с помощью ассемблерных операторов:

procedure MyRes;interrupt;
begin
 ASM
     mov ax, cs : word ptr [BufferDS]
     mov ds,ax
 END;

  ...



                      3. А чем платить?


 Известно,  что  ничего  задаром  не  бывает.  Так,  если  внимательно
посмотреть на алгоритм "выбрасывания лишнего кода",  то  станет  ясно,
что и весь код модуля SYSTEM тоже будет выброшен, то  есть  недоступен
в резидентной утилите. А ведь среди прочего SYSTEM содержит  процедуры
и функции  работы  со  строками,  тригонометрию,  генератор  случайных
чисел, ParamCount, ParamStr, UpCase, Move и FillChar.  Потери  все  же
не слишком велики, так как процедуры и функции DEC,  INC,  Addr,  Seg,
Ofs, SizeOf и прочие аналогичные  им  на  самом  деле  разворачиваются
компилятором  в   ассемблерные   команды   и,   следовательно,   могут
использоваться без ограничений.
 Остальное, что понадобится, придется написать самому и поместить  все
перед процедурой Keep в головном модуле.
 Разумеется, "функцией" DSeg тоже  пользоваться  нельзя,  так  как  на
самом деле это константа,  которая  содержит  старое  значение  адреса
кодового сегмента.
 Есть еще одно тонкое место.  Turbo-Pascal  осуществляет  присваивание
структур  и  строк  с  помощью  процедуры  Move  из   модуля   SYSTEM.
Следовательно, такое  присваивание  недопустимо  в  резидентной  части
программы и его следует заменить на вызов процедуры  Move,  написанной
Вами:

Type BigRecord = record
                    A1 : word;
                    S1 : string;
                  ...
                 end;{BigRecord}
Var
   SourceRec,DestRec : BigRecord;

 ...

procedure Move( VAR Source, Dest; Count : word );
(* Для того, чтобы не использовать move из модуля SYSTEM *)

TYPE
   Bytes = array[1..MaxInt] of byte;
VAR
   I : word;
begin

   FOR I := 1 TO Count DO Bytes(Dest)[I] := Bytes(Source)[I];

end;{Move}

procedure MyRes; interrupt;
begin
 ASM
     mov ax, cs : word ptr [BufferDS]
     mov ds,ax
 END;

(* SourceRec := DestRec; {Так в резидентной утилите делать нельзя!} *)

   Move( SourceRec,DestRec, SizeOf( BigRecord ) ); {Нужно делать только так}

 ...

end;{MyRes}




                      4. Послесловие.


 Все же автор немного схитрил - знание  ассемблера  желательно?  Иначе
как разобраться в его алгоритме?
 Нет, можно и без ассемблера. К  статье  прилагается  демонстрационная
программа,  в  которой  показано  использование  всех  описанных  выше
трюков, а также даны тексты наиболее часто употребимых процедур  Move,
Sound и NoSound для использования их  вместо  аналогичных  из  модулей
SYSTEM и CRT. Берите эту  программу  и  используйте/модифицируйте  без
ограничений. Надеюсь, в результате Ваши резидентные программы  заметно
похудеют.

 Ну а напоследок - традиционные  благодарности.  Спасибо  за  то,  что
дочитали  статью  до  конца,  двойное  спасибо  если  используете  мой
алгоритм в своих программах и верх благодарности  -  если  дадите  мне
знать, что он Вам пригодился.

 Статья написана  автором  антивирусного  пакета  Вирусный  Локатор  и
нескольких программок защиты файлов от заражения, а дисков  от  порчи.
В этих программках я использовал описанные выше идеи.

 Чтобы связаться  со  мной,  высказать  свои  замечания  и  пожелания,
получить  свежую  версию  Локатора  и  его  утилит,  звоните  по  тел.

                 (8-044) 266-70-28 (рабочий телефон)

или пишите по адресу:

            252142 Киев-142, ул. Семашко, д. 10, кв. 16
                        Шеховцову Александру Людвиговичу
