
     ▒▒▒▒▒▒▒▒▒▒▒▒                                         ▒▒▒
      ▒▒        ▒                                          ▒▒
      ▒▒                                                   ▒▒
      ▒▒    ▒      ▒▒▒▒▒▒     ▒▒▒ ▒▒▒▒▒▒    ▒▒▒▒▒▒▒▒▒▒▒▒   ▒▒ ▒▒▒▒▒▒
      ▒▒▒▒▒▒▒     ▒▒    ▒▒     ▒▒▒▒   ▒▒▒   ▒    ▒▒    ▒   ▒▒▒▒    ▒▒
      ▒▒    ▒    ▒▒      ▒▒    ▒▒                ▒▒        ▒▒       ▒▒
      ▒▒         ▒▒      ▒▒    ▒▒                ▒▒        ▒▒       ▒▒
      ▒▒         ▒▒      ▒▒    ▒▒                ▒▒        ▒▒       ▒▒
      ▒▒          ▒▒    ▒▒     ▒▒                ▒▒        ▒▒       ▒▒
     ▒▒▒▒          ▒▒▒▒▒▒     ▒▒▒▒              ▒▒▒▒      ▒▒▒▒     ▒▒▒▒


               Copyright (C), 1991 by The Golden Porcupine Software


               █▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀█
 ▄▄▄▄▄▄▄▄▄▄▄▄▄▄█  * * *      I M P O R T A N T      * * *  █▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄
 █             █▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄█              █░░
 █                                                                        █░░
 █                 ┌────────────────────────────────────┐                 █░░
 █                 │  Версия 92.9 - Сентябрь 1992 года  │                 █░░
 █                 └────────────────────────────────────┘                 █░░
 █                                                                        █░░
 █    Комплект файлов Форт-системы :                                      █░░
 █                                                                        █░░
 █       1. forth.com         - Форт-транслятор                           █░░
 █       2. vlist.com         - программа  для  просмотра   содержимого   █░░
 █                              библиотечных модулей формата .FRL и ис-   █░░
 █                              полняемых Форт-программ                   █░░
 █       3. crt.frl           - подключаемый библиотечный  модуль,  со-   █░░
 █                              держащий слова для работы  с  текстовым   █░░
 █                              экраном, функции  оконного  интерфейса,   █░░
 █                              редактирования строки, работы  с  гори-   █░░
 █                              зонтальным меню,  обработки  символьных   █░░
 █                              строк в ASCIIz-формате                    █░░
 █       4. dos.frl           - библиотечный модуль,  включающий  слова   █░░
 █                              для работы с файловой системой DOS        █░░
 █       5. music.frl         - библиотечный модуль,  содержащий  слова   █░░
 █                              для работы с динамиком, для  проигрыва-   █░░
 █                              ния заданных мелодий параллельно с  ра-   █░░
 █                              ботой основной программы                  █░░
 █       6. graph.frl         - библиотека для работы с графикой.  Под-   █░░
 █                              держиваются графические адаптеры : CGA,   █░░
 █                              EGA, VGA, MCGA, Hercules                  █░░
 █       7. random.frl        - библиотека, содержащая слова для  гене-   █░░
 █                              рации псевдослучайных чисел               █░░
 █       8. mouse.frl         - библиотека,   содержащая   элементарные   █░░
 █                              слова для работы с "мышкой"               █░░
 █       9. kbdcodes.frl      - библиотечный  модуль,  содержащий  кон-   █░░
 █                              станты  для работы с  драйвером  клави-   █░░
 █                              атуры BIOS                                █░░
 █      10. forth.doc         - описание языка, библиотек и прочая  до-   █░░
 █                              кументация                                █░░
 █      11. forthasm.inc      - для тех, кто владеет языком ассемблера,   █░░
 █                              этот файл поможет писать Форт-слова  на   █░░
 █                              этом языке                                █░░
 █      12. fs.frt            - небольшая программа, написанная на Фор-   █░░
 █                              те, позволяющая сгенерировать  диалого-   █░░
 █                              вую версию Форт-транслятора               █░░
 █  ╔═════════════╗                                                       █░░
 █  ║ ЭТО ВАЖНО ! ║    Если  Вы  не  хотите,  чтобы  после  копирования   █░░
 █  ╚═════════════╝ Форт-система утратила свою работоспособность,  соб-   █░░
 █                  людайте следующее правило :                           █░░
 █                                                                        █░░
 █                     Даже если назначение некоторых файлов из вышепе-   █░░
 █                  речисленных для Вас сомнительно, копируйте ВСЕ фай-   █░░
 █                  лы - они не займут много места.                       █░░
 █                                                                        █░░
 █▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄█░░
   ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░


    Прежде, чем Вы начнете читать этот файл, хотелось бы принести свои  изви-
 нения за некоторую путаность, непоследовательность изложения материала.  От-
 дельные извинения приношу тем, кто знаком с английским языком,  и,  возможно
 испытает искреннее возмущение, пытаясь понять, что же именно я хотел сказать
 англоязычными сообщениями. Если у Вас возникнут какие-либо вопросы по  проч-
 тении этого текста - пишите, звоните. Кроме того, объем информации,  который
 мне хотелось уместить в файл документации, оказалось явно не по  силам  наб-
 рать одному человеку, поэтому местами текст может показаться Вам слишком ла-
 коничным. Данная реализация  очень  незначительно  отличается  от  стандарта
 Форт-83, да и то, как мне кажется, не в худшую сторону, поэтому  большинство
 примеров, приведенных в литературе, в том числе  и  переводной,  Вы  сможете
 попробовать на предлагаемой Вам версии Форт-транслятора. Заранее  благодарен
 за любые сообщения об ошибках в трансляторе или неточностях в  документации.
 Буду рад, если Форт Вас заинтересует, не обязательно, даже, именно  эта  ре-
 ализация. Могу пообещать, что Форт в состоянии дать Вам гораздо больше,  чем
 Вы сейчас, возможно, от него ожидаете. Приятной работы.

                    С уважением  -  Александр Ларионов
                                    Москва, 103473,
                                    3-ий Самотечный переулок,
                                    дом 10, кв. 52
                                    телефон в Москве: 288-26-60
                                                 или: 28-82-66-0


          *. Об условиях распространения Форт-транслятора
          1. Что такое Форт?
          2. Описание библиотечных слов
             2.1  Стандартные слова
             2.2  Работа с файлами
             2.3  Работа с ASCIIz-строками
             2.4  Оконный интерфейс
             2.5  Музыкальное оформление программ
             2.6  Работа с графикой
             2.7  Работа с памятью
             2.8  Манипулятор "мышь".
             2.9  Обработка прерываний и резидентные программы на Форте
             2.10 Генерация псевдослучайных чисел
             2.11 Адресный интерпретатор или как работает Форт-система
             2.12 Интерфейс с языком ассемблера
             2.13 Словарь Форт-системы
             2.14 Генерация независимых программ
             2.15 Генерация новых версий Форт-системы
          3. ESC-последовательности
          4. Некоторые неочевидные ошибки в Форт-программах
          5. Карта памяти Форт-программы
          6. Оценка эффективности программ
          7. Примеры программ
          8. Утилита VLIST.COM
          9. Сообщения транслятора об ошибках
         10. Список литературы

      *. Об условиях распространения Форт-транслятора

   Данная версия Форт-транслятора распространяется как FREEWARE  продукт.  Вы
можете  создавать  любое  количество  резервных  копий,  свободно  копировать
Форт-транслятор Вашим друзьям и знакомым. При  этом  предполагается,  что  ни
один из файлов, составляющих Форт-транслятор, не будет изменен, и ЛЮБАЯ копия
этого продукта будет содержать ВСЕ его файлы. Переименование отдельных файлов
- не допускается. За право продажи программ,  написанных  для  данной  версии
(версия 92.9) Форт-транслятора, необходимо заплатить взнос в размере 100 руб-
лей. Любое использование Форт-транслятора для получения коммерческой  выгоды,
кроме написания программ для продажи - запрещается.  Генерация  новых  версий
Форт-транслятора допускается только стандартными Форт-средствами и только для
личного использования. Несколько слов о новых версиях  Форт-транслятора:  они
выходят приблизительно один раз в месяц. Если у Вас нет знакомых,  у  которых
всегда есть последняя версия всего, что Вас  теоретически  может  заинтересо-
вать, можно попробовать связаться (устно или письменно) с автором. Кроме  то-
го, если Вы учитесь в МГУ, можно обратиться к студенту факультета ВМК - Дени-
су Быструеву (телефон в Москве: 344-93-15).


      1. Что такое Форт?

   Вы слышали о языке программирования Форт? Если нет - ничего  удивительного
в этом нет. В нашей стране (я имею в виду бывший Советский Союз) о Форте слы-
шали очень немногие. Между тем в мире популярность Форта растет. Пускай, рас-
тет несколько более сдержанно, чем в свое время популярность языка Си, но, на
мой взгляд, это связано с некоторой необычностью Форта, его нестандартностью,
а так же с тем, что Форт на первый взгляд кажется слишком сложным.
   Если Вы не знакомы с Фортом - у Вас есть возможность с  ним  познакомится;
если знакомы - попробуйте "что-нибудь" написать. По своим  возможностям  Форт
далеко обходит такие языки программирования, как Паскаль и Си. В нем  сочета-
ются компактность кода, красота программ, поразительная гибкость, и  достоин-
ства таких языков, как Лисп и Пролог.  Стоит  только  повнимательней  к  нему
приглядеться. Форт очень близок Лиспу, хотя не сомневаюсь,  что  программист,
проработавший некоторое время на Лиспе, при первом знакомстве с Фортом  попы-
тается опровергнуть это утверждение. Форт чрезвычайно гибок, и посвященный  в
него лишь усмехнется, услышав, как какой-нибудь "студент"  рассказывает  соб-
равшейся вокруг него аудитории о гибкости языка Си. Программа на Форте  сред-
них размеров и написанная грамотно вполне может обойти по  компактности  кода
аналогичную программу, реализованную на языке ассемблера. Еще  в  стародавние
времена, когда я работал на 8-разрядной персоналке "Корвет", меня чрезвычайно
поразил факт, что встроенный в Форт-систему ассемблер, написанный на Форте  в
оттранслированном виде занимал в памяти менее 1.5К! Выберите язык  программи-
рования, машину, и попробуйте уместить в полтора килобайта ассемблер для про-
цессора i8080. Если Вы не поверили приведенному примеру или Вас просто  заин-
тересовал исходный текст на Форте ассемблера i8080, попробуйте достать  книгу
С.Н.Баранова и Н.Р.Ноздрунова "Язык Форт и его реализации". В этой  прекрасно
написанной книге приведено немало и других интересных  примеров,  из  которых
Форт-ассемблер, конечно, является самым совершенным. Признаюсь, таких  краси-
вых программ на Форте мне больше видеть не приходилось.
   Форт предоставляет программисту практически неограниченные возможности,  и
не пытается вести тотальный контроль за корректностью  его  действий.  Нужные
Вам средства контроля Вы сможете сделать сами.
   В то время как другие языки программирования по мере расширения их возмож-
ностей теряют свое лицо, превращаясь в монстров, Форт остается простым и ком-
пактным. Он способен поддержать практически любую идеологию программирования,
оставаясь при этом самим собой. Причиной этому - расширяемость Форта. Вы  мо-
жете "достроить" компилятор самостоятельно и в нужном Вам направлении.
   Итак, что же такое Форт? Форт многогранен. Его можно рассматривать как
      *  язык высокого уровня
      *  язык низкого уровня
      *  операционную систему
      *  мощную среду для создания системных программ
      *  некоторую концепцию разработки програмного обеспечения
   Название Форт происходит от английского слова Forth (вперед), и,  одновре-
менно, как сокращение от Fourth (четвертый). Такое странное название  связано
со следующим фактом из истории Форта:
   Изобретатель Форта Чарльз Мур, закончивший  работу  над  языком  в  начале
1970-х годов, работал в то время с моделью IBM-1130 - ЭВМ третьего поколения.
Полученные результаты показались ему настолько значительными, что он посчитал
язык "языком машин четвертого поколения" и назвал бы его Fourth, если бы  мо-
дель 1130 допускала шестибуквенные идентификаторы. Таким образом Fourth прев-
ратился в Forth - своеобразная игра слов.
   "Сохранять простоту языка" - так сформулировал свой принцип сам Чарльз Мур
в предисловии к книге Лео Броуди "Starting Forth", которая, кстати,  вышла  в
1990 году в издательстве "Финансы и статистика".
   Описание языка, приведенное в этом тексте, конечно же,  не  претендует  на
полноту. Подробнее узнать о Форте, Вы сможете из любой из книг, приведенных в
списке литературы в конце текста.
  Примеры, приведенные в литературе, расчитаны на диалоговую версию Форт-сис-
темы. Чтобы Вы могли их попробовать,  в  комплект  поставки  Форт-транслятора
включена программа FS.FRT. Скомпилировав ее, Вы  получите  диалоговую  версию
Форта в файле FS.COM. Вы можете также включать файл FS.FRT словом  INCLUDE  в
своих программах на Форте для того, чтобы написанные Вами  слова  можно  было
отладить в диалоговом режиме. В этом случае слово INCLUDE должно располагать-
ся в конце Вашей программы вместо слова BUILD. Результат компиляции Вы  полу-
чите в файле FS.COM.

   2. Список библиотечных слов

      2.1 Стандартные слова

EMIT ( Char --> )
   Слово выводит символ на экран, код которого снимает со стека. Версия слова
из стандартной библиотеки компилятора использует вызов функции DOS, что  поз-
воляет переназначить вывод в файл или на принтер.  После  подключения  модуля
CRT программе становится доступна  другая, более мощная версия  этого  слова.
Она  не  допускает  переназначения  вывода,  способна  обработать   несколько
ESC-последовательностей, поддерживает все функции оконного интерфейса из это-
го же модуля, способна работать с виртуальным экраном.  Ниже  приводятся  все
обрабатываемые ESC-последовательности.

KEY ( --> Char )
   Ожидает ввода символа с клавиатуры. Оставляет на стеке код введенного сим-
вола. В CRT модуле также содержится новая версия этого слова, которая работа-
ет не совсем так, как версия из стандартной библиотеки. Отличие заключается в
обработке нажатия клавиш, возврвщающих  расширенный  код  ASCII.  Стандартная
версия KEY получает очередной символ через фунцию  DOS.  Поэтому  расширенный
код ASCII она передает программе в два этапа. Программа должна  проанализиро-
вать возвращенное ей значение, и, в случае, если это 0, вызвать KEY еще  раз.
Версия KEY из CRT модуля получает очереднолй символ,  вызывая  функцию  BIOS,
которая сразу возвращает расширенный код ASCII.  Младший  байт  возвращаемого
значения при этом равен нулю, а старший определяет  нажатую  клавищу.  Строго
говоря, стандартная версия слова берет очередной символ не с клавиатуры, а со
стандартного устройства CON, которое в общем случае может переназначено и  не
соответствовать клавиатуре.

S>D ( N --> D )
   Слово преобразует число с вершины стека  из  короткого  (двубайтового),  в
длинное (четырехбайтовое) с сохранением знака. Слова,  выполняющего  обратное
преобразование в Forth-системе не существует. В простейшем случае, когда чис-
ло, представленное четырьмя байтами, может поместиться в два  байта, обратное
преобразование осуществляется словом DROP.

EXIT ( --> )
   Слово выполняет выход из слова, определенного через  двоеточие.  Полностью
аналогично процедуре EXIT из Турбо-Паскаля. Слово можно использовать только в
режиме компиляции. При попытке использовать его в режиме исполнения сообщение
об ошибке не выдается. Последствия : остаток строки исходного текста програм-
мы будет проигнорирован.

BRANCH ( --> )
   "Обыкновенные" Forth-программы обычно явно не используют  это  слово.  Оно
компилируется в шитый код словами IF-ELSE-THEN, BEGIN-WHILE-REPEAT и другими.
Скомпилированное слово реализует безусловный переход в  пределах  определения
через двоеточие. Вслед за словом в шитый код компилируется двубайтовое смеще-
ние, которое определяет дальность перехода. Не пытайтесь выполнить это  слово
в режиме исполнения. Последствия такой попытки не определены.

?BRANCH ( Flag --> )
   Слово, скомпилированное в шитый код, выполняет условный переход, если зна-
чение на вершине стеке - False. Все применения этого слова и ограничения,  на
него накладываемые, те же, что и для слова BRANCH.

(.ASCIIZ) ( --> )
   Слово, скомпилированное в шитый код, при исполнении выполняет печать стро-
ки в формате ASCIIz, скомпилированной в шитый код вслед за этим  словом.  Не-
посредственное выполнение слова не  приведет  к  желаемым  результатам,  если
только Вы не хотите просто "повесить" машину.

EXPECT ( Addr MaxLength --> )
   Стандартное Forth-слово, выполняющее ввод строки с  клавиатуры.  Введенная
строка запоминается в памяти с адреса Addr. MaxLength  -  максимальная  длина
вводимой строки. Так как после последнего введенного символа записывается ну-
левой символ, отведенная под строку область памяти должна быть по крайней ме-
ре на один байт длиннее, чем максимальная  длина  строки.  Фактическая  длина
введенной строки запоминается в системной переменной SPAN и может  быть  про-
анализирована программой.

+ ( N1 N2 --> N3=N1+N2 )
   Стандартное Forth-слово, реализующее сложение двух чисел. Слово снимает со
стека два числа, складывает их, результат оставляет на стеке.

- ( N1 N2 --> N3=N1-N2 )
   Слово, реализующее вычитание. Число с вершины стека вычитается  из  числа,
находящегося под ним. Результат оставляется на стеке.

TRUE ( --> -1 )
   Константа. Оставляет на стеке стандартное значение ИСТИНА.

FALSE ( --> 0 )
   Константа. Оставляет на стеке стандартное значение ЛОЖЬ.

UMIN ( N1 N2 --> N3=Min(N1,N2) )
   Со стека снимаются два числа, сравниваются, как числа без знака.  На  стек
кладется меньшее из этих двух чисел.

UMAX ( N1 N2 --> N3=Max(N1,N2) )
   Работает аналогично UMIN, но на стеке остается большее из чисел.

= ( N1 N2 --> Flag )
   Слово-предикат, реализующее сравнение двух чисел, снимаемых со стека. Если
числа равны на стеке остается ИСТИНА, иначе - ЛОЖЬ.

0< ( N --> Flag )
   Снимает со стека число и сравнивает его с нулем. Оставляет на стеке значе-
ние ИСТИНА, если слово меньше нуля.

0> ( N --> Flag )
   Работает аналогично 0<, но ИСТИНА оставляется на стеке, если число  с  его
вершины больше нуля.

0= ( N --> Flag )
   Работает аналогично двум приведенным выше словам. ЛОЖЬ (или  0)  на  стеке
заменяется ИСТИНОЙ (или числом -1), ИСТИНА (любое число, отличное от нуля)  -
ЛОЖЬЮ. В связи с этим это слово часто используется как логическое  отрицание,
правильно работающее даже не со стандарными логическими значениями. (Стандар-
тным значением ИСТИНА является число -1; любое другое число, отличное от нуля
- "нестандартное" значение ИСТИНА).

< ( N1 N2 --> Flag )
   Сравнение двух чисел. ИСТИНА остается на стеке, если  число  под  вершиной
стека меньше числа на его вершине.

> ( N1 N2 --> Flag )
   Сравнение двух чисел. ИСТИНА остается на стеке, если  число  под  вершиной
стека больше числа на его вершине.

HERE ( --> Addr )
   Оставляет на стеке адрес первого не занятого словарем байта.

ALLOT ( N --> )
   Резервирует N байт в словаре, увеличивая на N указатель  вершины  словаря.
При отрицательном N указатель словаря уменьшается, освобождая тем самым выде-
ленную ранее память. Необходимо отметить, что перед вызовом этого  слова  для
выделения памяти было бы не плохо вызвать HERE, чтобы выяснить, с какого  ад-
реса будет начинаться блок памяти, который Вам выделит ALLOT.

@ ( Addr --> N )
   Стандартное Форт-слово, предназначенное для получения значения двубайтовой
переменной (или просто для чтения содержимого памяти). Снимает со стека адрес
переменной и замещает его на стеке словом памяти, записанным по данному адре-
су. (Под адресом в данной реализации Форта понимается смещение в сегменте ко-
да. В связи с этим с помощью слова @ можно получить доступ к не более, чем 64
К. Это, однако не означает отсутствия средств работы с  памятью,  лежащей  за
пределами сегмента кода).

C@ ( Addr --> Char )
   Стандартное слово, работающее аналогично слову @, но не со словами памяти,
а с байтами. Таким образом, оставленное на стеке  число  не  может  превышать
255. т.е. его старшие 8 бит - нулевые.

! ( N Addr --> )
   Стандартное слово, действие которого обратно действию слова @.  В  отличие
от него слово ! не читает значение переменной, а  записывает  его.  Со  стека
последовательно снимаются адрес памяти, и то значение, которое необходимо за-
писать по этому адресу.

C! ( Char Addr --> )
   Стандартное слово, аналогичное слову !, но работающее с байтами. Это озна-
чает, что старшие 8 бит параметра Char будут проигнорированы, и в  память  по
адресу Addr будет записан только один байт.

LIT ( --> N )
   Одно из самых важных Форт-слов. Скомпилированное в  шитый  код, оно  после
своего выполнения оставляет на стеке двубайтовое  число,  скомпилированное  в
шитый код следом за этим словом. Слово LIT активно используется Форт-компиля-
тором, когда необходимо создать код, оставляющий после себя на стеке  некото-
роую константу. Например: если Вы при написании программы использовали следу-
ющий фрагмент: 0 0 79 24 MakeWindow , то для того, чтобы  его  скомпилировать
Форт-компилятору необходимо 4 раза скомпилировать слово LIT  (по  одному  для
каждого числа). Попытка просто выполнить это слово, скорее всего, ни  к  чему
особенно интересному Вас не приведет. Наиболее вероятно, что  компьютер  "по-
виснет".

DLIT ( --> D )
   Слово, полностью аналогичное слову LIT, но работающее  с  четырехбайтовыми
числами.

DUP ( N --> N N )
   Простейшее, но тем не менее важное Форт слово. Оно и  несколько  следующих
за ним в данном списке слов обеспечивают  Форт-выражениям  их  эффективность.
Слово просто дублирует на стеке число, снятое с его вершины.

DROP ( N --> )
   Слово снимает со стека число, находящееся на его вершине. Несмотря на  ка-
жущуюся бесполезность, это слово достаточно часто используется при  написании
практически любых программ.

SWAP ( N1 N2 --> N2 N1 )
   Меняет местами вершину стека и число, расположеное под ней.

OVER ( N1 N2 --> N1 N2 N1 )
   Дублирует на стеке число, находящееся под вершиной стека.

PRESS ( N1 N2 --> N2 )
   Слово, удаляющее со стека число, находящееся под его вершиной.

ROT ( N1 N2 N3 --> N2 N3 N1 )
   Слово производит ротацию (вращение) трех верхних элементов стека.

2DUP ( D --> D D )
   Аналогично слову DUP, но работает со числами двойной  длины.  Слово  можно
определить как:
: 2DUP OVER OVER ;

2DROP ( D --> )
   Аналогично слову DROP, но снимает со стека не одно, а два числа (или  одно
число двойной длины). Его можно определить как:
: 2DROP DROP DROP ;

2SWAP ( D1 D2 --> D2 D1 )
   Меняет местами на стеке числа двойной длины. Может быть определено как:
: 2SWAP >R ROT ROT R> ROT ROT ;

2OVER ( D1 D2 --> D1 D2 D1 )
   Работает аналогично слову OVER, но с числами двойной длины. Может быть оп-
ределено как:
: 2OVER >R >R 2DUP R> R> 2SWAP ;

2PRESS ( D1 D2 --> D2 )
   Слово удаляет из стека число двойной длины, находящееся под его  вершиной.
(Здесь вершина стека - два числа одинарной длины или одно число двойной  дли-
ны). Можно определить как:
: 2PRESS >R PRESS PRESS R> ;

* ( N1 N2 --> N3=((N1*N2)mod65536) )
   Умножение двух чисел, находящихся на вершине стека. Правильно работает как
с числами со знаком, так и без знака. Если результат умножения не  помещается
в 2 байта, никакой диагностики не выдается. Старшие 2 байта произведения  те-
ряются.

M* ( N1 N2 --> D=N1*N2 )
   Умножение двух чисел одинарной длины  с  получением  произведения  двойной
длины. Таким образом, у Вас есть возможность сохранить старшие 2 байта произ-
ведения, если существует вероятность того, что в  результате  действия  может
получиться число, не помещающееся в 16 бит. (Напомню, что  на  стеке  младшие
два байта числа двойной длины располагаются под старшими байтами. Это сделано
для того, чтобы переход от числа двойной длины к числу одинарной длины,  если
он вообще возможен, мог быть осуществлен одной командой DROP. В памяти  числа
двойной длины располагаются следующим образом: младшие 2  байта  по  старшему
адресу, старшие два байта - по младшему; причем в каждой  паре  байт  младший
байт находится по младшему адресу, старший -  по  старшему.  Приведу  пример:
число   067B543Fh   в   памяти   будет   располагаться   следующим   образом:
7Bh,6,3Fh,54h. Следует отметить, что подобное расположение в памяти  четырех-
байтовых чисел отличается от общепринятого, поэтому если Вам необходимо обра-
ботать некоторое длинное число, возвращенное Вам DOS, не забудьте дать  слово
SWAP. Оно поменяет местами младшую и старшую часть длинного  числа.  Обратное
преобразование выполняется аналогично).

/ ( N1 N2 --> N3=N1/N2 )
   Деление. Если N2=0, генерируется ошибка с кодом 0. N3 - целая  часть  час-
тного. Остаток теряется. Правильно работает как с числами со  знаком,  так  и
без знака.

MOD ( N1 N2 --> N3=N1modN2 )
   Остаток от деления. Частное теряется. Остаток имеет знак делимого.

>R ( N --> )
   Переносит число с арифметического ("нормального") стека на стек возвратов.
Будьте вимательны, когда работаете со стеком возвратов. Помните, что при каж-
дом вызове слова на стек возвратов кладется одно  число  (его  условно  можно
назвать адресом возврата), внутри цикла со счетчиком DO ... LOOP или  DO  ...
+LOOP на стек возвратов кладется три числа. Чтобы слово, написанное Вами  ра-
ботало корректно, соблюдайте следующее правило: все,  что  было  положено  на
стек возвратов внутри одного слово должно быть снято с него до выхода из это-
го слова. Последствия того, что на стеке возвратов остались данные, после то-
го, как слово уже отработало могут быть самые печальные. Фактически это озна-
чает, что управление будет передано по случайному адресу,  и,  скорее  всего,
программа "повиснет".

R> ( --> N )
   Переносит число со стека возврптов на арифметический стек.

R@ ( --> N )
   Дублирует на арифметическом стеке число, находящееся на вершине стека воз-
вратов. От предыдущего слова отличается тем, что оно не удаляет число со сте-
ка возвратов.

BASE ( --> Addr )
   Системная переменная, содержащая текущую систему счисления, в  котороой  в
данный момент выполняется ввод и вывод чисел.

STATE ( --> Addr )
   Системная переменная, содержащая флажок-состояние текстового интерпретато-
ра. Текстовой интерпретатор - программа, написанная на Форте и входящая в мо-
дуль FORTH.COM, которая управляет вводом исходного текста программы, его ком-
пиляцией и исполнением. Текстовый интерпретатор может находиться в двух  сос-
тояниях: в состоянии исполнения, когда переменная STATE содержит 0, и в  сос-
тоянии компиляции, когда переменная STATE содержит  любое  отличное  от  нуля
значение (обычно -1).

LPRINT ( StringAddress --> )
   Слово выводит на печатающее устройство строку символов, заданную в  памяти
строкой с явно заданной длиной. Символы CR и LF после вывода строки на печать
не выдаются.

CLI ( --> )
   Слово запрещает маскируемые прерывания в  Форт-программе. Следует, однако,
отдавать отчет в том, что слово не в состоянии повлиять на обработку прерыва-
ний, запрос на которые поступил во время работы какой-либо сервисной програм-
мы, например, обработчика прерывания DOS Int 21h, который, хоть  тресни,  все
равно разрешит маскируемые прерывания сразу, как получит управление.

STI ( --> )
   Слово разрешает обработку прерываний, запросы на которые приходят  в  про-
цессор по линии INT.

DROPALL ( N1 N2 ... --> )
   Слово полностью сбрасывает арифметический стек. Очень рекомендую!  Чрезвы-
чайно полезное слово! Бывают случаи, когда поиск ошибки в программе очень из-
матывает. Это слово, конечно не в состоянии исправсить любую Вашу ошибку,  но
ошибки, связанные с нарушением  баланса  стека,  исправляет  запросто.  Самое
главное - успеть его вовремя вызвать,  не дожидаясь того момента, когда не  в
меру разросшийся стек "испортит" часть памяти.
   Вообще, переполнение стека (когда на стек положено слишком много) в данной
реализации гораздо менее опасно, чем исчерпание стека (когда  Ваша  программа
снимает со стека больше, чем туда заталкивала). В первом случае сперва  зати-
рается экранный стек, находящийся в том же сегменте, что и арифметический,  и
занимающий меньшие адреса внутри сегмента. В большинстве  программ  он  имеет
довольно не малый размер, и у Вашей программы есть некоторый запас прочности,
до исчерпания которого  все неприятности могут  ограничиться  видеоэффектами.
Их, кстати, в ряде случаев может не быть, если, например, Вы испортили экран-
ный  стек настолько основательно,  что слова,  работающие с ним,  это заметят
(они иногда контролируют корректность своих действий).
   Во втором же случае портится стек возвратов, значительно более важный  для
Форт-программ, и, к тому же, гораздо  меньший  по  размеру  экранного  стека.
Здесь видеоэффектами дело не закончится.

RDROPALL ( --> )
   Это слово полностью сбрасывает стек возвратов.  Нормальному  человеку  эта
функция требуется горвздо реже, чем сброс арифметического стека, да и пользо-
ваться ей  надо  с  большей  осторожностью.  Помните,  что  попытка  покинуть
Форт-слово (неявно, или явно словом EXIT), вызывавшее во время  своей  работы
слово RDROPALL, но не принявшее никаких действий по подготовке адреса возвра-
та, скорее всего, ни к чему хорошему не приведет.

DEBUG ( --> Addr )
   Это - одна из системных переменных, управляющих процессом компиляции. Если
ее значение отлично от нуля, (т.е. переменная  содержит  логическое  значение
ИСТИНА) то при формировании выполняемого модуля словом BUILD,  все  использу-
емые в Вашей Форт-программе слова будут компилироваться вместе с полями  име-
ни, атрибутов, связи. Это сделает выполняемый файл немного длиннее, но позво-
лит Вам использовать отладчик (в настоящее время он еще не  реализован)  или,
что является очень важной возможностью, вызывать Форт-слова по имени на этапе
работы скомпилированной программы. По умолчанию значение переменной нулевое.

STACKSIZE ( --> Addr )
   Эта переменная влияет на объем памяти отводимой под стек в выполняемых мо-
дулях. Необходимо отметить, что стек, являющийся арифметическим для Форт-сис-
темы, для других сервисных программ, возможно, перехвативших некоторые преры-
вания DOS или BIOS, к которым Ваша программа наверняка будет обращаться,  яв-
ляется обыкновенным рабочим стеком. В связи с этим необходимо соответствующим
образом заботиться о его размере. Он должен быть никак не менее килобайта.  А
еще лучше, изменяйте значение этой переменной только в том  случае,  если  Вы
хотите УВЕЛИЧИТЬ размер арифметического стека.

RETURNSTACKSIZE ( --> Addr )
   В этой переменной содержится размер стека возвратов в выполняемых модулях.
Если Вы фанат рекурсии, неплохо помнить о существовании этой переменной. Каж-
дый вложенный рекурсивный вызов требует двух байт стека возвратов. Кроме  то-
го, стек возвратов - чрезвычайно удобное место для сохранения переменных  при
рекурсивном вызове. Если же Вы соберетесь и напишете библиотеку для работы  с
локальными структурами данных и решите размещать их (данные) на стеке возвра-
тов, не забывайте, что стек возвратов адресуется через сегментный регистр SS,
растет по напрвлению к меньшим адресам памяти, а его указатель хранится в ре-
гистре BP. Внутри Форт-программ значение регистра SS  кладет  на  стек  слово
StackSegment, а обращаться к данным, расположенным в  сегменте,  отличном  от
сегмента данных, можно используя слова: A@ AC@ A! AC!.
   Если Вы установите в эту переменную значение 65535, то под стек  возвратов
память будет выделяться таким образом, чтобы сегмент стека Форт-системы зани-
мал ровно 64 килобайта. Если Вы пишете резидентную программу, очень  рекомен-
дую установить RETURNSTACKSIZE = 65535. На  объем  памяти,  занимаемый  Вашей
программой это не повлияет, зато будет гарантия,  что  слово  TSR  не  потрет
DOS-овские блоки MCB.

SCREENSTACKSIZE ( --> Addr )
   При компиляции программ, использующих оконный интерфейс из Crt модуля  не-
малое значение имеет эта переменная. Она определяет  размер  экранного  стека
для сохранения окон с виртуального экрана и другой информации экранного драй-
вера. Этот стек также находится в сегменте стека, и растет по  направлению  к
меньшим адресам памяти. Его указатель находится в системной переменной с име-
нем SSP.

MEMORYSIZE ( --> Addr )
   От значения этой Форт-переменной зависит размер динамической памяти в  вы-
полняемом модуле Форт программы, отводимой словом ALLOT. Эта память отводится
в сегменте кода Форт-программы, а потому сумма  значения  этой  переменной  и
размера выполняемого Форт-модуля в байтах не должна превышать 64 килобайта.
   Специальный случай: когда в  момент  инициализации  Форт-системы  значение
этой переменной равно 65535, под динамическую память выделяется  максисмально
возможный кусок, таким образом, что сегмент Форт-кода занимал в  точности  64
килобайта. Значение этой переменной по умолчанию = 65535.

-- ( --> )
   Если, вдруг, Вы написали в своей жизни хотя бы одну программу на языке Ада
(мне, к сожалению, не приходилось), наверное, Вас обрадует наличие  в  данной
реализации слова --. Весь остаток строки исходного текста,  следующего  вслед
за этим словом, оно считает комментарием и игнорирует.

\ ( --> )
   Это слово, реализованное в некоторых версиях  Форт-систем,  работает  пол-
ностью аналогично предыдущему. Мне  почему-то  оно нравится несколько  больше
слова --.

A" ( --> StringAddress ) - В режиме исполнения
   ( --> )               - В режиме компиляции
   Это слово предназначено для задания  в  Форт-программах  констант-строк  в
формате ASCIIz (аналогично представлению сторок в стандарте  языка  Си).  Ис-
пользовать это слово Вы можете в следующем контексте:
   A" Строка, которую Вы хотите использовать в программе"
   Обратите внимание на тот факт, что слово A" отделяется от строки пробелом,
который не является частью строки и не входит в ее длину. Однако, если пробе-
лов вначале строки будет два или более, все они, кроме одного  (как  правило,
первого), будут частью строки.
   Если Вы используете приведенную Выше конструкцию в режиме  компиляции,  то
после исполнения скомпилированного кода,  на  стеке  останется  адрес  данной
строки. Если же Вы используете это слово в режиме  исполнения,  адрес  строки
будет положен на стек сразу.
   Существует один момент, на который хочется обратить внимание: если Вы  ис-
пользуете слово BUILD для построения выполняемых модулей,  строки  в  формате
ASCIIz ни в коем случае не должны содержать внутри себя символов с кодом 0. В
противном случае слово BUILD не сможет правильно определить длину скомпилиро-
ванной в памяти строки и вычислить адрес следующей в Форт-коде программы. Оно
выдаст ошибку, но номер ошибочной строки нисколько не поможет Вам ее  локали-
зовать.
   Здесь же надо упомянуть о том, как вставлять в строки (не  только  формата
ASCIIz) символы, ASCII-код которых меньше 32. Если в строке встретился символ
\, то следом за ним должно следовать число в  ДЕСЯТИЧНОЙ  системе  счисления,
завершающееся символом "точка с запятой". На  их  (символов  \...;)  месте  в
строку помещается символ, код которого задается десятичным числом.

$ ( --> N ) - В режиме исполнения
  ( --> )   - В режиме компиляции
   Вообще говоря, Форт имеет мощные средства для ввода/вывода чисел  в  любых
системах счисления, но иногда бывает очень лень их переключать, засылая в пе-
ременную BASE новое значение. Для ввода чисел в шестнадцатеричной  системе  в
данную реализацию включено слово $. Если Вы работали на  Турбо  Паскале,  Вы,
наверное знаете о представлении шестнадцатеричных чисел в этом языке.
   Здесь Вы можете указать после слова $ число в шестнадцатеричной системе, и
Форт-система воспримет его точно так же, как если бы значение переменно  BASE
было равно 16. Главное - не забыть поставить пробел между словом $ и числом.

DSQRT ( D --> N )
   Слово извлекает квадратный корень из числа двойной длины, снятого со  сте-
ка. Результат одинарной длины и округленный до целого в меньшую  сторону  ос-
тавляется на стеке.

DS/MOD ( D1 N1 --> D2 N2)
   Слово выполняет деление с остатком числа двойной длины D1 на число одинар-
ной длины N1. Частное двойной длины D2 и остаток от деления  одинарной  длины
N2 оставляются на стеке.

*****************************************************************************
   К сожалению, время не позволяет описать все базовые слова Форта. Их описа-
ние можно найти в любой из книг, приведенных в литературе. В следующих верси-
ях Форт-компилятора описание слов  будет  продолжено.  Некоторые  специальные
слова, разобраться с которыми, по  мнению  разработчика  несложно,  приведены
лишь со стековой нотацией, без описания. При возникновении сложностей -  зво-
ните по телефону в Москве 288-26-60 или пишите по адресу, указанному в начале
документа.
*****************************************************************************

      2.2 Работа с файлами

FCREATE ( ASCIIzName FileAttributes --> FileHandle True )
        ( ASCIIzName FileAttributes --> False )
   Создает файл с именем ASCIIzName и атрибутами FileAttributes. Если в стро-
ке ASCIIzName не указана явно директория, файл создается в текущей. После за-
вершения работы слова на вершине стека - флажок успешности.  В  случае,  если
файл создан удачно - на вершине стека оставлено значение True, под ним  нахо-
дится число, называемое в DOS описателем файла. Его  необходимо  сохранить  в
переменной, и в дальнейшем использовать для доступа к файлу. Если по каким-то
причинам создать файл невозможно, на вершине  стека  оставляется  False,  код
ошибки, возвращенный функцией DOS заносится в системную переменнeю ERRNO, ко-
торую необходимо проанализировать в этом случае сразу после вызова слова, ес-
ли, конечно, Вас интересует причина сбоя, а не просто его наличие.

FOPEN ( ASCIIzName FileMode --> FileHandle True )
      ( ASCIIzName FileMode --> False )
   Открывает существующий файл. ASCIIzName - имя файла. FileMode - режим  от-
крытия файла. Поддерживаются все режимы, допустимые в Вашей версии DOS. С не-
которой гарантией можно пользоваться следующими режимами:
   0 - Открыть файл только для чтения. Любая попытка  записи  в  файл  словом
       FWRITE будет возвращать ошибку "Доступ отвергнут". Ее код будет  зане-
       сен в переменную ERRNO.
   1 - Открыть файл только для записи. Будут отвергаться попытки чтения файла
       словом FREAD.
   2 - Открыть файл для чтения и записи.
Не жадничайте - не используйте режим 2, только потому, что он существует. Па-
раметры, возвращаемые этим словом, полностью аналогичны параметрам, возвраща-
емым словом FCREATE.

FCLOSE ( FileHandle --> SuccessFlag )
   Закрыть файл, созданный словом FCREATE или открытый словом FOPEN. Если  Вы
писали в файл - обязательно закройте его, иначе - DOS не гарантирует, что вся
записанная Вами информация занесется в файл. Вообще  говоря,  закрывать  надо
любые файлы (открытые Вашей программой), даже если они  были  открыты  только
для чтения - в памяти могут находиться программы,  отслеживающие  открытие  и
закрытие файлов (например -  антивирус-монитор),  и  не  стоит  провоцировать
ошибки в работе этих программ.

FSEEK ( FileHandle StartPosType LowFileOffset HighFileOffset -->
              NewLowFileOffset NewHighFileOffset True )
      ( FileHandle StartPosType LowFileOffset HighFileOffset --> False )
   Позиционирование файла. В DOS с каждым открытым файлом связано четырехбай-
товое число, называемое указателем файла. Он показывает смещение в байтах от-
носительно начала файла, с которого следующей операцией чтения будет читаться
информация (или командой записи - писаться).  При  перемещении  указателя  по
файлу DOS позволяет программам задавать смещение не только от  начала  файла,
но и от его конца, а также от текущей позиции указателя. Слово FSEEK реализу-
ет эти функции в Форт-программах. FileHandle - открытый файл  (точнее  -  его
описатель, возвращенный словами FCREATE или FOPEN). Параметр StartPosType за-
дает относительно какой позиции в файле необходимо произвести  позиционирова-
ние:
   0 - относительно начала файла
   1 - относительно текущей позиции, определяемой указателем файла, известным
       DOS
   2 - относительно конца файла. Естественно, в этом случае число,  определя-
       ющее, на сколько байт от конца файла установить его указатель, обязано
       быть отрицательным.
   Параметры LowFileOffset и HighFileOffset - соответственно младшая и  стар■
шая двубайтовые части, определяющие, на сколько  изменится  указатель  файла.
Возвращенные значения NewLowFileOffset и NewHighFileOffset  определяют  новое
(после позиционирования) значение указателя файла. На вершине  стека,  как  и
для всех файловых операций, оставляется флажок успешности.

FREAD ( FileHandle MemoryOffset MemorySegment BytesCount -->
                    BytesRead True)
      ( FileHandle MemoryOffset MemorySegment BytesCount --> False )
   Читает блок из файла, открытого словом  FREAD.  Параметры  MemoryOffset  и
MemorySegment определяют соответственно смещение и сегмент в памяти, где дол-
жен быть сохранен прочитанный блок памяти. BytesCount - длина блока. В случае
успешного чтения под флажком True возвращается количество реально прочитанных
байт, и, если оно меньше, чем Вы пытались прочесть, значит - достигнут  конец
файла.

FWRITE ( FileHandle MemoryOffset MemorySegment BytesCount -->
                    BytesWritten True )
       ( FileHandle MemoryOffset MemorySegment BytesCount --> False )
   Входные параметры этого слова полностью аналогичны входным параметрам сло-
ва FREAD. А возвращаемое в случае успешности записи число BytesWritten - чис-
ло байт, для которых на диске хватило места. Если оно меньше, чем Вы пытались
записать, значит - диск переполнен - принимайте меры.

FINDFIRST ( ASCIIzFileSpec FileAttributes BufferAddr --> FoundFlag )
   Слово, начинающее поиск файлов в оглавлении. ASCIIzFileSpec - адрес строки
в формате ASCIIz, определяющей шаблон имени файла для поиска. Эта строка  мо-
жет содержать символы '*' и '?'. FileAttributes - это маска атрибутов  файла.
Если в этой маске некоторый атрибут сброшен в 0, то файлы, у  которых  данный
атрибут установлен, найдены не будут. BufferAddr - адрес  буфера,  в  который
необходимо записывать информацию о найденных файлах. После успешного заверше-
ния этой функции (FoundFlag = True), этот буфер заполнен данными и имеет сле-
дующий формат:
Смещение  Длина  Содержимое
   0       21      Эти байты резервируются DOS и служат для продолжения поис-
                   ка файлов
   21       1      Атрибут найденного файла. Формат этого числа:
                   7  6  5  4  3  2  1  0
                   *  *  *  *  *  *  *  *
                         │  │  │  │  │  └── файл только для чтения
                         │  │  │  │  └───── скрытый файл
                         │  │  │  └──────── системный файл
                         │  │  └─────────── не файл, а метка тома
                         │  └────────────── не файл, а директория
                         └───────────────── архивный атрибут
   22       2      Время последней модификации файла.  Отдельные  биты  этого
                   числа имеют следующее назначение:
                   15 14 13 12 11 10  9  8  7  6  5  4  3  2  1  0
                    *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *
                    └─────┬─────┘  └───────┬──────┘  └─────┬─────┘
                          │                │               │
                          │                │            [секунды/2] (0..30)
                          │                └─────────── минуты (0..59)
                          └──────────────────────────── часы (0..23)
   24       2      Дата последней модификации файла. Назначение отдельных бит
                   этого числа следующее:
                   15 14 13 12 11 10  9  8  7  6  5  4  3  2  1  0
                    *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *
                    └────────┬────────┘  └────┬───┘  └─────┬─────┘
                             │                │            │
                             │                │         день месяца (1..31)
                             │                └──────── месяц (1..12)
                             └───────────────────────── год-1980 (0..119)
   26       4      Размер файла - длинное число. После его  получения  словом
                   2@ не забудьте, что в Форте, числа двойной длины  хранятся
                   в памяти в виде, несколко отличным от  общепринятого.  Для
                   того, чтобы Ваша программа "узнала" длину файла - поменяй-
                   те местами младшую и старшую  части  полученного  значения
                   словом SWAP.
   30      13      Имя найденного файла в формате ASCIIz. Для  его  красивого
                   отображения недостаточно просто напечатать эту строку: имя
                   не дополняется пробелами до 13 символов автоматически. Ес-
                   ли Вы собираетесь выводить на экран имена файлов вместе  с
                   их расширениями в виде таблицы, необходимо написать  слово
                   форматного вывода.

FINDNEXT ( BufferAddr --> FoundFlag )
   Продолжения поиска файла в оглавлении, начатого  словом  FINDFIRST.  Адрес
буфера для записи информации должен быть тем же, что  и  для  поиска  первого
файла. Если очередной файл найден - параметн FoundFlag = True, а буфер запол-
нен информацией о файле.

FRENAME ( OldASCIIzName NewASCIIzName --> SuccessFlag )
   Это слово реализует стандартную функцию переименования файлов в DOS. Пара-
метры OldASCIIzName и NewASCIIzName - это соответственно адреса строк в  фор-
мате ASCIIz, описывающих старое и новое имя файла.  При  помощи  этого  слова
можно реализовать одну занятную функцию: перемещение файла из одной  директо-
рии в другую в пределах одного логического диска. Для выолнения подобной опе-
рации Вы можете в строках, определяющих старое и новое  имена  файла  указать
так же и директории, и, если они будут разными для нового  и  старого  имени,
файл будет перемещен и попутно переименован.

FDELETE ( ASCIIzName --> SuccessFlag )
   Удаление файла. Единственный параметр задает адрес стороки  (возможно  ис-
пользование пути), определяющей имя файла, который необходимо удалить.

FSETATTR ( ASCIIzName NewFileAttributes --> SuccessFlag )
   Установка атрибутов файла. Первый параметр - имя  файла  (точнее  -  адрес
строки), второй параметр - байт атрибутов файла. О назаначении конкретных би-
тов этого байта Вы можете узнать заглянув в описание слова FINDFIRST,  или  в
любой мало-мальски приличный справчник по DOS (смотря по тому, какому из  ис-
точников Вы больше доверяете).

FGETATTR ( ASCIIzName --> FileAttributes True )
         ( ASCIIzName --> False )
   Это слово позволяет узнать, каким образом установлены биты в байте атрибу-
тов интересующего Вас файла. Если Вы дочитали документацию до этого места, Вы
наверняка сможете понять назначение входных и выходных параметров  слова  без
дополнительных коментариев.

MAKEDIR ( ASCIIzName --> SuccessFlag )
   Создает поддиректорию в текущей  директории.  Имя  директории  -  задается
строкой ASCIIzName. SuccesFlag здесь, как и везде, определяет успешность  вы-
полнения слова.

REMOVEDIR ( ASCIIzName --> SuccessFlag )
   Удаление поддиректории. Входной параметр - ее имя (возможно  использование
пути). Выходной параметр - флажок успешности. Если Вы хотите иметь  основания
полагать, что слово выполнится успешно, потрудитесь перед удалением поддирек-
тории удалить все ее содержимое: и файлы, и поддиректории.

GETCURRENTDIR ( BufferAddr --> SuccessFlag )
   Для каждого логического диска DOS хранит строку в формате ASCIIz,  опреде-
ляющую рабочую директорию. Узнать какая же директория  является  текущей  для
текущего диска Вы сможете использовав это слово. Его входной параметр - адрес
буфера, куда DOS занесет строку. Помните, Вы не  гарантированы  от  серьезных
ошибок и сбоев, если поскупились на память и  выделили  под  буфер  менее  64
байт.

CHANGEDIR ( ASCIIzName --> SuccessFlag )
   Это слово позволяет сменить рабочую директорию для текущего  диска.  Пара-
метр ASCIIzName полностью аналогичен параметру команды CD в DOS,  кроме,  ко-
нечно случая, когда ASCIIzName указывает на пустую строку.

GETCURRENTDISK ( --> CurrentDisk )
   Это слово поможет Вам получть имя логического диска, принятого  в  DOS  по
умолчанию в данный момент. Если возвращенный параметр равен  нулю  -  активен
диск A: ; единице - B: и так далее.

EXEC ( ASCIIzName CommandLineAddr EnvironmentSegment --> SuccessFlag )
   Слово, позволяющее выполнять .COM и .EXE файлы. Параметр ASCIIzName задает
имя запускаемой программы. (Честно говоря, расширение  запускаемой  программы
не обязано быть .COM или .EXE. Вы можете запускать любые файлы, в  работоспо-
собности которых Вы не сомневаетесь). CommandLinrAddr - адрес строки, которая
будет передана запускаемой программе в виде командной строки.  Будьте  внима-
тельны: длина этой строки задается первым ее байтом - это не строка в формате
ASCIIz. Самый "ненужный" параметр - это EnvironmentSegment. В DOS  полагается
перед запуском программы подготовить для нее окружение. Если Вам  это  делать
лень - просто задайте этот параметр равным нулю. Если после  себя  это  слово
оставило True - значит все Ok.

FTELL ( FileHandle --> LowFileOffset HighFileOffset True )
      ( FileHandle --> False )
   Наконец, последнее слово, реализующее работу с файловой системой DOS  поз-
волит Вам получть текущее значение указателя файла. Параметры, хочется  наде-
яться, в коментариях не нуждаются.

      2.3 Работа с ASCIIz-строками

DELETE* ( Source Destination StartPosition BlockLength --> )
   Удаление из строки Source подстроки длиной BlockLength начиная  с  позиции
StartPosition. Строка, получившаяся после удаления  подстроки,  помещается  в
память с адреса Destination. Исходная строка, кроме случая,  когда  Source  =
Destination не изменяется. Символы в ASCIIz-строках нумеруются с нуля. Здесь,
как и далее, при задании начальной позиции, выходящей за пределы строки слово
не выполняет никаких действий.

COPY* ( Source Destination StartPosition BlockLength --> )
   Копирование подстроки строки Source начиная с позиции StartPosition и дли-
ной BlockLength символов в память по  адресу  Destination.  Исходная  строка,
кроме случая, когда Source = Destination, не изменяется.

INSERT* ( Source Destination StringForInsert StartPosition --> )
   Вставка строки StringForInsert в строку Source  с  позиции  StartPosition.
Результирующая строка размещается  в  памяти  с  адреса  Destination.  Строка
Source не изменится, если параметры Source и Destination не совпадают.

COMPARE* ( ASCIIz1 ASCIIz2 --> CompareCode )
   Сравнение двух строк в формате ASCIIz. Если после выполнения слова на сте-
ке остался ноль - строки  совпадают.  Отрицательное  число  -  вторая  строка
"больше" первой. Иначе - первая строка "больше" второй. Понятие "больше"  от-
носится ни в коем случае не к длине строки, а к кодам ее символов.  Используя
это понятие можно реализовать сортировку массива строк (точнее -  указателей)
в  алфавитном порядке.  Например:  строка  "This is a String"  больше  строки
"This is a Second String", так как, код символа 't' в  слове  'String' первой
строки больше кода символа 'e' в слове 'Second' второй строки.

CONCAT* ( First Second Destination --> )
   Соединение строк. В памяти по адресу Destination формируется строка,  сос-
тавленная из строк First и Second. Строка First изменится только в  том  слу-
чае, если First = Destination. Случай Second  =  Destination  с  вероятностью
100% приведет к сбою в работе всей программы, если не "подвесит" компьютер.

POS* ( Where What StartPosition --> PositionIfFound )
     ( Where What StartPosition --> -1 )
   Поиск строки What внутри строки Where  начиная  с  позиции  StartPosition.
После выполнения слова на стеке остается или позиция,  начиная  с  которой  в
строке  Where  содержится  строка  What,  или  -1,  если  начиная  с  позиции
StartPosition Строка What не входит в строку Where.

>ASCIIZ ( StringInLENSTRformat --> )
   Переводит строку, длина которой задана ее первым байтом в  формат  ASCIIz.
Адрес строки остается тем же - новая строка замещает старую на ее же месте  в
памяти. Прежде, чем использовать это слово, неплохо было  бы  убедиться,  что
исходная строка не содержит символов с кодом 0.

ASCIIZ> ( ASCIIz --> )
   Слово, выполняющее перевод строки из формата ASCIIz в строку с явно задан-
ной длиной. Если исходная строка длиннее 255 символов (для строки  в  формате
ASCIIz это допустимо), в корректности перевода можно смело сомневаться.

ASCIIZLEN ( ASCIIz --> Length )
   Определение длины строки в формате ASCIIz. Слово снимает  со  стека  адрес
строки и оставляет на стеке ее длину.

NULLSTRING ( --> Addr )
   Константа, оставляющая на стеке адрес пустой строки.  Будьте  внимательны:
никогда не используйте в качестве пустой строки конструкции типа a" " или " "
. Это может плохо кончится. Вероятнее всего, Вы весь день проищете непонятную
ошибку, и так ее и не найдете. Чтобы понять, в чем дело, вспомните, как рабо-
тает слово WORD.

      2.4 Оконный интерфейс

VRAM ( --> Addr )
   Переменная, содержащая сегмент, считающийся сегментом видеопамяти. Вы  мо■
жете работать с виртуальным экраном, всего лишь изменив значение  этой  пере■
менной.

PUTCHAR ( Character Attribute X Y --> )
   Вывести символ с кодом Character и атрибутом Attribute на виртуальный  эк-
ран в позицию, определяемую координатами X и Y.

GETCHAR ( X Y --> Character Attribute )
   Прочесть символ с виртуального экрана. Character и Attribute -  это  соот-
ветственно символ, расположенный на экране в позиции с координатами X и Y,  и
его атрибут.

HIGHLIGHT ( X Y HighBlockLength Attribute --> )
   Это слово используется для вывода "широкого курсора" для  различного  вида
меню. X и Y - координаты начальной позиции  курсора.  HighBlockLength  -  его
длина (в символах). Параметр Attribute определяет цвет символов и цвет фона в
тех позициях, которые "закрывает" курсор.

>S ( N --> )
   Переместить число с арифметического стека на экранный стек.

S> ( --> N )
   Переместить число с экранного стека на арифметический.

SETWINDOW ( X1 Y1 X2 Y2 --> )
   Установить активную область на экране. Далее экранный драйвер  будет  счи-
тать указанную прямоугольную область - рабочим окном, в которое  будет  выво-
диться информация. После этого слова  необходимо  выполнить  слово  HOME  или
CLEARWINDOW для перемещения курсора в  верхней  левый  угол  рабочей  области
(слово CLEARWINDOW производит, кроме того заполнение области  текущим  цветом
фона).

GETWINDOW ( --> X1 Y1 X2 Y2 )
   Получить координаты текущей активной области на виртуальном экране.

COLOR ( TextColor TextBackGround --> )
   Установить цвет  символов  и  цвет  фона  для  дальнейшего  вывода.  Здесь
TextColor - цвет символов. TextBackGround - цвет фона.

GETCOLOR ( --> TextColor TextBackGround )
   Получить текущие значения цвета символов и цвета фона для вывода на экран.

PUSHWINDOW ( X1 Y1 X2 Y2 --> )
   Проталкивает указанную прямоугольную область с экрана в экранный стек. Об-
ласть проталкивается на экранный стек сверху вниз. Каждая  строка  области  -
слева направо. Каждое проталкиваемое слово состоит из символа  (младший байт)
и его атрибута  (старший байт).  Затем на экранный стек  кладется информация,
определяющая размеры записанной области  по горизонтали и вертикали в  симво-
лах, а поверх этой информации - число 1232h.  Переполнение экранного стека не
контролируется:  при компиляции Вашей программы Вы должны сами позаботиться о
необходимом Вам размере экранного стека.

POPWINDOW ( X1 Y1 --> )
   Выталкивает прямоугольную область с экранного стека, помещенную туда  сло-
вом PUSHWINDOW.

EXCHANGEWINDOW ( X1 Y1 --> )
   Почти аналогично слову POPWINDOW, только на место вытолкнутой с  экранного
стека области проталкивается область того же размера, находящаяся  на  экране
на месте выталкиваемой области.

BORDER ( X1 Y1 X2 Y2  StringInLENSTRformat Attribute --> )
   Нарисовать рамку на экране. Параметр StringInLENSTRformat - строка с  явно
заданной длиной, содержащая символы, которые должны составлять рамку на экра-
не. Порядок символов в строке следующий:
  12222222222222223
  4  ЭТА ОБЛАСТЬ  5         Символы в строке нумеруются с 1.
  4 НА ЭКРАНЕ -   5         Пример :
  4 НЕ ИЗМЕНЯЕТСЯ 5         0 0 79 24 " ╔═╗║║╚═╝" 15 Border
  67777777777777778
Параметр Attribute определяет цвет рамки.

FILLWINDOW ( Character Attribute X1 Y1 X2 Y2 --> )
   Заполнить символом Character с атрибутом Attribute  прямоугольную  область
на виртуальном экране. Координаты области - последние четыре параметра.

WHEREX ( --> CursorXPosition )
   Оставляет на стеке  горизонтальную  координату  курсора  (номер  столбца).
Столбцы на экране нумеруются с нуля.

WHEREY ( --> CursorYPosition )
   Оставляет на стеке Y-координату курсора. Самая верхняя строка экрана имеет
нулевую координату.

SHOW ( BufferOffset BufferSegment BufferStartXShow BufferStartYShow
         BufferXSize ScreenX1 ScreenY1 WindowSizeX WindowSizeY --> )
   Это слово, по-видимому, относится к рекордсменам по количеству входных па-
раметров. Их изобилие просто пугает. К счастью, нельзя сказать, что это слово
- предмет первой необходимости. Хорошо, если у Вас хотя бы раз появится повод
его использовать.
   Пусть у Вас в памяти (точнее - в памяти компьютера) хранится прямоугольный
массив, каждый элемент которого занимает два байта. Пусть первый байт  задает
некоторый символ, второй - его атрибут. Обратите внимание, что данный  массив
может храниться в любой области памяти, а не только в видеобуфере.  Параметры
BufferOffset и BufferSegment определяют начальный адрес данного массива,  ко-
торый, кстати, хранится в памяти строка за строкой.  Параметр  BufferXSize  -
количество двубайтовых элементов в строке прямоугольного массива.
   Слово SHOW копирует прямоугольную область из  данного  массива,  начальные
координаты которой задаются параметрами BufferStartXShow и  BufferStartYShow,
а размер по горизонтали (X) и  вертикали  (Y)  -  параметрами  WindowSizeX  и
WindowSizeY на виртуальный экран. Начальные  коородинаты  образа  области  на
виртуальном экране задаются параметрами ScreenX1 и ScreenY1.
   Напоследок, после словесных наворотов, остается напомнить, что все коорди-
наты измеряются от нуля.

SHOWTEXT ( BufferOffset BufferSegment BufferStartXShow
         BufferStartYShow BufferXSize ScreenX1 ScreenY1
         WindowSizeX WindowSizeY Attribute --> )
   Это экзотическое слово - близкий родственник предыдущего. Отличие заключа-
ется лишь в том, что элементы прямоугольного массива - однобайтовые, т.е.  не
содержат байта атрибутов. На виртуальном экране копируемая область "разбавля-
ется" атрибутами Attribute. Все остальные параметры - абсолютно идентичны.

INKEY ( --> False )
      ( --> Character )
   Слово, аналогичное функции INKEY$ из Бейсика. На стеке остается  либо  код
нажатой клавиши, либо ноль, если нажатий на клавиши не зафиксировано.

HOME ( --> )
   Переместить курсор в верхний левый угол текушей рабочей области на  вирту-
альном экране. Это слово можно определить как:
: HOME 12 EMIT ;

PUSHSTATE ( --> )
   Проталкивает на экранный стек текущее состояние драйвера экрана: координа-
ты активной рабочей области, положение и форму курсора, текущий  цвет  симво-
лов.

POPSTATE ( --> )
   Выталкивает с экранного стека параметры, запомненные словом PUSHSTATE.

CURSOROFF ( --> )
   Выключает курсор, переключаясь на драйвер #0. Это слово  можно  определить
как:
: CURSOROFF 27 EMIT C" C EMIT 0 EMIT ;

CURSORON ( --> )
   Включает жесткий аппаратный курсор, переключаясь на первый экранный  драй-
вер. Определяется следующим образом:
: CURSORON 27 EMIT C" C EMIT 1 EMIT ;

SELECTCURSOR ( Driver# --> )
   Выбрать драйвер экрана. О том, чем первый драйвер отличается от второго  и
прочую информацию на эту тему Вы сможете найти в описании  ESC-последователь-
ностей.

SCROLLUP ( --> )
   Сдвинуть рабочую область на экране на один символ вверх.

SCROLLDOWN ( --> )
   Сдвинуть рабочую область на экране на один символ вниз.

SCROLLLEFT ( --> )
   Сдвинуть рабочую область на экране на одну позицию влево.

SCROLLRIGHT ( --> )
   Сдвинуть рабочую область на экране на один символ вправо.

MOVEUP ( --> )
   Если курсор находится не в верхней строке текущей рабочей области экрана -
он перемещается на один символ вверх. Символы на экране здесь, как и в следу-
ющих трех Форт-словах, не затираются.

MOVEDOWN ( --> )
   Если курсор находится не на последней (нижней) строке рабочей области,  он
перемещается на один символ вниз.

MOVELEFT ( --> )
   Курсор - на позицию левее.

MOVERIGHT ( --> )
   Курсор - на символ вправо.

CLEARWINDOW ( --> )
   Заполнить текущую рабочую область символом с кодом 0 с атрибутом, установ-
ленным для вывода символов по умолчанию. Иными словами, это  слово  выполняет
функцию оператора CLS из языка Бейсик.

SETCURSIRLINES ( StartLine EndLine --> )
   Для первого и третьего экранных драйверов устанавливает начальную и конеч-
ную строки курсора. После выполнения этого слова  курсор  будет  занимать  ту
часть позиции символа, которая расположена  со  строки  StartLine  до  строки
EndLine. Если Вы еще не догадались - здесь "строка" - часть матрицы  символа.
Строки нумеруются с нуля и сверху вниз. Не забывайте, что разные дисплеи поз-
воляют оперировать с разным количеством строк курсора и по-разному  интерпре-
тируют значения параметров.

SETCURSORCOLOR ( CursorColor CharUnderCursorColor --> )
   Это слово включает второй экранный драйвер и  устанавливает  по  умолчанию
следующие параметры: CursorColor - цвет курсора. CharUnderCursorColor -  цвет
символа, находящегося в позиции курсора.

EMITSPEC ( Character --> )
   Слово позволяет вывести на экран  образ  символа,  код  которого  экранный
драйвер интерпретирует как некоторую собственную команду. Используя это  сло■
во, Вы можете "напечатать" символы с кодами 8,10,12,13,27, которые,  при  по■
пытке вывести их на экран словом EMIT, вынудят  экранный  драйвер  произвести
некоторые управляющие действия. Для "неспециальных" символов это слово  рабо■
тает полностью аналогично слову EMIT.

MAKEWINDOW ( X1 Y1 X2 Y2 --> )
   Слово можно определить следующим образом:
: MAKEWINDOW PushState SetWindow GetWindow PushWindow PushState Home ;

REMOVEWINDOW ( --> )
   Слово определено как:
: REMOVEWINDOW PopState GetWindow 2Drop PopWindow PopState ;

GOTOXY ( X Y --> )
   Слово перемещает курсор в позицию с координатами (X,Y) на экране.  Причем,
при работе с первым и третьим драйвером экрана курсор перемещается  на  физи■
ческом экране, а для нулевого и второго драйвера  -  на  виртуальном.  Будьте
внимательны: начальная координата - ноль; и отсчитываются координаты  относи■
тельно верхнего левого угла экрана, а не относительно текущей рабочей  облас■
ти.

MAKEBORDER ( StringInLENSTRformat Color BackGround --> )
   Слово определено следующим образом:
: MAKEBORDER ( String Color Back --> )
   16 * +  >r >r GetWindow r> r> Border
   GetWindow >r >r >r 1+ r> 1+ r> 1- r> 1- SetWindow ;
Кроме того, будьте внимательны: слово изменяет координаты текущей рабочей об-
ласти на виртуальном экране. (Координаты X1 и Y1 увеличиваются на единицу, X2
и Y2 - уменьшаются).

STDBORDER ( Border# Color BackGround --> )
   Для того, чтобы при написании программ, использующих слова оконного интер-
фейса, не приходилось каждый раз задавать графические  символы,  определяющие
внешний вид рамки окон, в реализацию включено это слово. Оно  "рисует"  рамку
из некоторого стандартного набора. Осторожно, это слово  изменяет  координаты
текущей рабочей области (точнее - оно вызывает слово  MAKEBORDER,  которое  и
выпоняет это изменение). Параметры Color  и  BackGround  задает  цвет  рамки,
Border# - номер рамки из стандартного набора.
   Доустимы следующие значения Border#
╔═══╗   ┌───┐   ╬═══╬   ┼───┼   ■■■■■   ▄▄▄▄▄   ▐▀▀▀▌   █▀▀▀█
║ 1 ║   │ 2 │   ║ 3 ║   │ 4 │   ■ 5 ■   ▌ 6 ▐   ▐ 7 ▌   █ 8 █
╚═══╝   └───┘   ╬═══╬   ┼───┼   ■■■■■   ▀▀▀▀▀   ▐▄▄▄▌   █▄▄▄█
   Значение параметра от 9 до 12 включительно рисует некоторые достаточно эк-
зотические рамки, а любые другие значения приводят к тому,  что  нарисованная
рамка будет состоять из пробелов.

EDITSTRING ( EditStringStructure --> )
   Слово, выполняющее редактирование строки, представленной в формате ASCIIz.
Для работы этого слова перед его запуском необходимо заполнить данными струк-
туру, приведенную ниже и передать этому слову  адрес  этой  структуры.  Слово
EXPECT из CRT модуля вызывает это слово и пользуется всеми его  достоинства-
ми.
   Формат структуры данных, передаваемой слову EDITSTRING
   Смещение Длина  Поле
     0      2      адрес ASCIIz строки для редактирования
     2      2      Максимальная длина строки
     4      1      Y - координата на экране для отображения строки
     5      1      X1 - левая граница на экране для отображения строки
     6      1      X2 - правая граница на экране для отображения строки
     7      1      Экранный атрибут, определяющий цвет редактируемой строки
     8      1      Резервируется
     9      1      Флажок режима вставки (0 - Overwrite)
    10      2      Адрес  процедуры,  возвращающей код нажатой  клавиши.  Нет
                   необходимости в написании собственной процедуры, Вы можете
                   воспользоваться стандартным словом KEY из CRT модуля  (На-
                   помню, что адрес слова - это адрес его поля кода. Он может
                   быть получен, например, так: ['] KEY или [']  USERKEY  где
                   USERKEY - Ваша собственная  процедура,  написанная  взамен
                   процедуры  KEY.  Ее  стековая  нотация:  USERKEY   (   -->
                   Character ) Название для такой процедуры, естественно,  Вы
                   вольны придумать самостоятельно).
    12      1      Номер клавиши из списка, приведенного в этой же  структуре
                   данных по смещению 14, по нажатию которой был  осуществлен
                   выход из процедуры редактирования строки. Это поле - един-
                   ственное,  не  требующее   установки   до   вызова   слова
                   EDITSTRING. Его необходимо проанализировать  после  выхода
                   из этого слова.
    13      1      N = Количество клавиш, нажатие которых должно вызывать вы-
                   ход из процедуры редактирования строки
    14     N*2     Здесь приводится список  кодов  этих  клавиш. Используются
                   расширенные ASCII коды.  Если  код  клавиши занимает  один
                   байт, для записи в этот  список  его  необходимо дополнить
                   старшим нулевым байтом. Иными словами, для записи кода ЛЮ-
                   БОЙ клавиши необходимо использовать два байта.

HMENU ( ASCIIzMenuItems KeyProcPointer HighAttribute
        ScreenX1 ScreenX2 ScreenY --> ItemNo CrPressedFlag/NoESC/ )
   Это слово позволяет Вам организовывать горизонтальные меню.  Первый  пара-
метр - это строка, содержащая пункты  меню,  разделенные  символами  пробела.
Например:
a" ^Write^over^the^old^file^  ^Make^backup^copy^   ^Cancel^"
При работе слова HMENU символ ^ отображается пробелом.
   Параметр KeyProcPointer - это адрес слова, возвращающего код нажатой  кла-
виши. Если Вам эта возможность не требуется - используйте адрес слова KEY.
   HighAttribute -  атрибут  на  экране  выделенного  пункта  меню.  ScreenX1
ScreenX2 ScreenY - позиция на экране, куда необходимо "втиснуть" данное меню.
ItemNo - номер выбранного пользователем пункта (начиная с нуля). И,  наконец,
последний параметр - False, если была нажата  клавиша  ESC,  и  True  -  если
Enter.

CENTER ( ASCIIz X1 X2 Y --> )
   "Втиснуть" строку в указанные координатами позиции на экране.

      2.5 Музыкальное оформление программ

SOUND ( Hz --> )
   Генерировать звук частотой Hz герц. Обратите внимание  -  слово  нуждается
только в одном параметре. Длительность звучания тона должна интересовать Вас.
Как только звук перестанет быть Вам нужен (например, если  Ваши  коллеги  уже
обратили на Вас внимание) - выполните слово NOSOUND. Изменяя  параметр  слова
SOUND в цикле можно добиться интересных эффектов: сирена, пулеметная очередь,
соловьиная трель...

NOSOUND ( --> )
   Без этого слова нельзя было бы пользоваться предыдущим словом (без  ущерба
для собственного авторитета в глазах коллег). Не забывайте, что звук, генери-
руемый словом SOUND не перестанет звучать даже после завершения работы  Вашей
программы, если Вы не выполните слово NOSOUND.

PLAY ( ASCIIz --> )
   Единственный параметр этого слова - адрес строки в формате ASCIIz,  содер-
жащий "программу" для проигрывания необходимой Вам мелодии. Слово PLAY актив-
но работает с прерыванием по таймеру, и будет лучше, если  Вы  в  программах,
претендующих на перехват этого прерывания не будете использовать  это  слово.
Если все же это необходимо - не меняйте вектор прерывания 1ch во время проиг-
рывания мелодии. Кроме того, как бы это не выглядело заманчиво, не используй-
те это слово в резидентных программах - ведь задача, на  фоне  которой  Вашей
резидентной программе вдруг вздумается проигрывать мелодию, вряд ли будет ра-
ботать надежнее, если в промежутках, когда она прерывается по сигналу от тай-
мера, вектора прерываний 1ch будет меняться.
   Отдельные команды "музыкального языка" приведены ниже.
C, D, E, F, G, A, B - соответственно До, Ре, Ми, Фа, Соль, Ля, Си
# - после ноты означает повышение ноты на половину тона; иначе - игнорируется
              │   │   │ │   │   │   │   │ │   │ │   │   │
              │   │   │ │   │   │   │   │ │   │ │   │   │
              │   │   │ │   │   │   │   │ │   │ │   │   │
              │   │   │ │   │   │   │   │ │   │ │   │   │
              │   │   │ │   │   │   │   │ │   │ │   │   │
              │   │C# │ │D# │   │   │F# │ │G# │ │A# │   │
              │   └─┬─┘ └─┬─┘   │   └─┬─┘ └─┬─┘ └─┬─┘   │
              │     │     │     │     │     │     │     │
              │     │     │     │     │     │     │     │
              │  C  │  D  │  E  │  F  │  G  │  A  │  B  │
              └─────┴─────┴─────┴─────┴─────┴─────┴─────┘
* - в начале строки указывает на необходимость прервать  мелодию,  проигрыва-
    емую в данный момент, и, если * отсутствует, то данная мелодия становится
    в "очередь" и ожидает пока доиграет предыдущая. (Однако не обольщайтесь -
    емкость очереди - всего одна мелодия, и, кроме того Ваша программа не бу-
    дет выполняться, пока это единственное место в очереди занято).
P - специальная нота без звука - пауза
T - смена длительности. Играет роль только в режиме #2 После T следует специ-
    альный символ, определяющий длительность:
    \1; - 1/16
    \2; - 1/8
    \4; - 1/4
    \8; - 1/2
    \16; - 1
O - смена октавы. a" o\1;t\4;cdefgab" PLAY  - этот пример проигрывает
    первую октаву
M1, @1 - установить режим #1
    В этом режиме параметр, заданный после T - игнорируется, а  после  каждой
ноты (или паузы) необходимо указать индивидуальную длительность
M2, @2 - установить режим #2 (принятый по умолчанию)
    В этом режиме длительность звучания ноты определяется параметром T

      2.6 Работа с графикой

SETVIDEOMODE ( Mode --> )
   Установить видеорежим. В качестве параметра Mode возможно использование
следующих констант:
TEXT40*25          =  1 - Текстовый режим 40*25 символов, CGA, EGA, VGA, MCGA
TEXT80*25          =  3 - Текстовый режим 80*25 символов, CGA, EGA, VGA, MCGA
GRAPH320*200*4     =  4 - Графика 320*200 точек, 4 цвета, CGA, EGA, VGA, MCGA
GRAPH640*200*2     =  6 - Графика 640*200 точек, 2 цвета, CGA, EGA, VGA, MCGA
TEXT80*25MONO      =  7 - Текстовый монохромный режим, TTL-монохромная плата
GRAPH720*348       =  8 - Графика 720*348 точек, монохромный режим, Hercules
HGCGRAPH           =  8 - Полностью аналогична предыдущей константе
GRAPH320*200*16    = 13 - Графика 320*200 точек, 16 цветов, EGA, VGA, MCGA
GRAPH640*200*16    = 14 - Графика 640*200 точек, 16 цветов, EGA, VGA, MCGA
GRAPH640*350*16    = 16 - Графика 640*350 точек, 16 цветов, EGA, VGA, MCGA
GRAPH640*350*4     = 16 - Графика 640*350 точек, 4 цвета, EGA, VGA, MCGA
GRAPH640*480*2     = 17 - Графика 640*480 точек, 2 цвета, VGA, MCGA
GRAPH640*480*16    = 18 - Графика 640*480 точек, 16 цветов, VGA, MCGA
GRAPH320*200*256   = 19 - Графика 320*200, 256 цветов, VGA
Небольшая заминка с видеорежимом 8:
   Согласно официальной версии, этот режим зарезервирован  и  используется  в
PcJr. Вообще говоря, PcJr - компьютер-призрак, и никто из моих  знакомых  его
ни разу не видел даже на картинках. В связи с этим было решено заставить гра■
фический драйвер из файла GRAPH.FRL перехватывать установку этого видеорежима
и инициализировать графику для достаточно широко распространенного  монохром■
ного адаптера Hercules. (На компьютерах,  которыми  я  пользовался,  BIOS  не
обеспечивала установку графического видеорежима - поэтому  пришлось  проявить
инициативу и  устанавливать  регистры  6845  самостоятельно).  И  еще:  фирма
MicroSoft взяла за правило поставлять со всеми своими продуктами  резидентную
программу MSHERC, одной из функций  которой  является  возможность  работы  с
Hercules в графическом режиме. Конфликт возникает в  следующем  месте:  когда
драйвер из Форт-модуля переключается в графический режим, он  соответствующим
образом устанавливает переменные BIOS, чтобы все культурные  программы  могли
получить элементарную информацию о видорежиме. Программа MSHERC - "некультур■
ная", и видеорежим она определяет по своим  собственным  переменным,  которые
Форт-драйвер, претендующий на звание культурной программы, изменять не  имеет
морального права. Поэтому, будьте осторожны: пользуйтесь либо только вызовами
BIOS (что бесполезно, если в памяти нет программы MSHERC), либо только встро■
енным графическим драйвером. Единственным достоинством вызова  BIOS  является
возможность вывода текста на экран - ведь графический драйвер из Форт  модуля
не содержит шрифтов.

PUTPIXEL ( X Y Color --> )
   Установить точку на графическом  экране  с  координатами  (X,Y)  и  цветом
Color. Точка (0,0) во всех видеорежимах расположена в верхнем левом углу  эк-
рана, а значения координат возрастают по направлению к нижнему и правому кра-
ям экрана. Если значения координат или цвета выходят из допустимого  диапазо-
на, большой катастрофы произойти не должно, но лучше лишний раз не провоциро-
вать графический драйвер, и все  параметры  задавать  корректно:  минимальное
значение любого параметра - 0,  а  максимальное  возвращается  словами  MaxX,
MaxY, MaxColor.

READPIXEL ( X Y --> Color )
   Это слово используется для того, чтобы  получить цвет точки экрана, задан-
ной координатами (X,Y).

GETVIDEOMNODE ( --> Mode )
   Получить текущий видеорежим.

SETCGAPALETTE ( Pallete# --> )
   Выбрать палитру CGA. Слово рекомендуется вызывать в режиме 320*200  точек,
4 цвета. Что произойдет, если это условие не будет  соблюдено  -  зависит  от
версии BIOS, но скорее всего - ничего  страшного.  Параметр  может  принимать
следующие значения:
   0 - цвет 1 - зеленый, цвет 2 - красный, цвет 3 - коричневый (желтый)
   1 - цвет 1 - бирюзовый, цвет 2 - лиловый, цвет 3 - белый

SETEGAPALETTE ( Color# NewValue ---> )

LINE ( X1 Y1 X2 Y2 Color --> )
   Рисует линию цвета Color из точки (X1;Y1) в точку (X2;Y2)

BOX ( X1 Y1 X2 Y2 Color --> )
   Рисует  прямоугольник  цветом  Color,  координаты  противоположных  вершин
которого определяются парами параметров X1, Y1 и X2, Y2.

BOXFULL ( X1 Y1 X2 Y2 Color --> )
   Рисует закрашенный прямоугольник цветом Color, координаты  противоположных
вершин которого определяются парами параметров X1, Y1 и X2, Y2.

CIRCLE ( X Y Radius Color --> )
   Окружность с центром в точке X, Y, радиуса Radius и цвета Color.

GRAPHX ( --> Addr )
   Содержит текущую X-координату графического курсора для слова DRAW

GRAPHY ( --> Addr )
   Содержит текущую Y-координату графического курсора для слова DRAW

GRAPHSCALE ( --> Addr )
   Содержит текущий масштаб для слова DRAW

GRAPHCOLOR ( --> Addr )
   Содержит текущий цвет для слова DRAW

MAXX ( --> MaxX )
   Оставляет на стеке максимальное значение X-координаты пикселя

MAXY ( --> MaxY )
   Оставляет на стеке максимальное значение Y-координаты пикселя

MAXCOLOR ( --> MaxColor )
   Оставляет на стеке максимальное значение цвета для текущего видеорежима

MOVETO ( X Y --> )
   Перемещает графический курсор для слова DRAW

DRAW ( ASCIIz --> )

      2.7 Работа с памятью

A@ ( Offset Segment --> Value )
   Слово, позволяющее Вашей программе читать память, находящуюся за пределами
сегмента кода. Параметры Offset и Segment определяют соответственно  смещение
и сегмент слова памяти. Слово памяти (в данном случае термин "слово"  исполь-
зуется для обозначения машинного слова, а не слова Форт-системы), находящееся
по данному адресу кладется на стек.

AC@ ( Offset Segment --> Character )
   Работает  аналогично  предыдущему  слову,  но  старший  байт  в  параметре
Character - всегда нулевой.

A! ( Value Ofset Segment --> )
   Записывает два байта в память по указанному адресу, определяемому  сегмен-
том и смещением.

AC! ( Character Offset Segment --> )
   Записывает младший байт параметра Character в память по указанному адресу.

MFILL ( Offset Segment Count Byte --> )
   Заполнение памяти константой. Первые два  параметра  определяют  начальный
адрес блока памяти. Count - длину блока памяти в байтах. Byte - значение, ко-
торым необходимо заполнить данный блок.

CMOVE ( SourceOffset SourceSegment DestOffset DestSegment Count --> )
   Пересылка блока памяти. SourceOffset и  SourceSegmrnt  -  адрес  исходного
блока памяти. Два следующих параметра определяют адрес, по которому необходи■
мо разместить скопированный блок. Count - длина копируемого блока.  Пересылка
блока выполняется от меньших адресов - к большим.

SEARCH ( StartOffset SearchSegment AreaLength BlockAddr BlockLength -->
            FoundOffset FoundSegment True )
       ( StartOffset SearchSegment AreaLength BlockAddr BlockLength -->
            False )
   Поиск в области памяти, расположенной в сегменте SearchSegment начиная  со
смещения StartOffset и длиной AreaLength блока памяти, совпадающего с блоком,
записанным в сегменте Форт-кода по адресу BlockAddr и длиной BlockLength. Ес-
ли поиск прошел успешно, т.е. блок найден, на стеке располагается его  полный
адрес (сегмент + смещение) и флажок ИСТИНА.  Иначе  -  на  стеке  оставляется
только флажок ЛОЖЬ.

DECODE ( TableOffset TableSegment BlockOffset BlockSegment BlockLength --> )
   Слово выполняет перекодировку блока памяти, адрес и длина которого опреде-
ляют параметры BlockOffset, BlockSegment и BlockLength по таблице длиной  256
байт, адрес которой задается параметрами TableOffset и TableSegment. В  пере-
кодируемом блоке памяти каждый байт заменяется на байт, расположенный в  таб-
лице со смещением относительно ее начала, равным первоначальному байту. Слово
удобно использовать для конвертирования символьных данных больших объемов.
   Действия, выполняемые данным словом, аналогичны действиям машинной команды
XLAT процессора i8086.

      2.8 Манипулятор "мышь"

?MOUSE ( --> Flag )
   Слово оставляет на стеке значение ИСТИНА, если драйвер манипулятора  нахо-
дится в памяти. Очень рекомендую в начале Вашей программы вызвать это  слово,
и, если оно вернет False, не пытаться вызывать  другие  слова,  работающие  с
"мышью". Еще: это слово инициализирует мышиный драйвер.

BUTTONS ( --> N )
   N - количество кнопок "мышки". Обычно это слово возвращает 2 или 3, кроме,
конечно, случая, когда мышиный драйвер не инсталлирован. Кроме того, это сло-
во также инициализирует мышиный драйвер.

PUTMOUSEPOINTER ( --> )
   Это слово делает видимым мышиный курсор на экране дисплея.  Следует  отме-
тить, что по умолчанию, т.е. после инициализации, курсор невидим.

HIDEMOUSEPOINTER ( --> )
   Скрыть мышиный курсор на экране дисплея. Приятная особенность этого слова,
в том, что для того, чтобы скрыть курсор, достаточно  один  раз  вызвать  это
слово, а не столько же раз, сколько выполнялось слово PUTMOUSEPOINTER.

WHEREMOUSEY ( --> Y )
   Получить вертикальную координату мышиного курсора. В отличие  от  мышиного
драйвера, который для текстового режима возвращает координату, умноженную  на
8, здесь возвращается настоящая координата.

WHEREMOUSEX ( --> X )
   Получить горизонтальную координату мышиного курсора. Как и предыдущее сло-
во, работает верно для текстового режима.

MOVEMOUSEPOINTER ( X Y --> )
   Позиционирование мышиного курсора. X и Y - координаты на текстовом  экране
позиции, в которую необходимо переместить мышиный курсор.

?CENTERBUTTON ( --> Flag )
   Оставляет на стеке True, если нажата центральная клавиша "мыши"

?RIGHTBUTTON ( --> Flag )
   Оставляет на стеке True, если нажата правая клавиша "мыши"

?LEFTBUTTON ( --> Flag )
   Оставляет на стеке True, если нажата левая клавиша "мыши"

EMULATEKEY ( --> Addr )
   Переменная. Если содержит True, то необходима эмуляция клавиатуры  "мышью"
(не наоборот!). О подробностях эмуляции смотрите следующие семь слов.

RIGHTKEY ( --> Addr )
   Переменная, содержащая клавиатурный ASCII код, (можно расширенный),  кото-
рый генерируется по перемещению "мыши" вправо.

LEFTKEY ( --> Addr )
   Переменная, содержащая клавиатурный ASCII код, (можно расширенный),  кото-
рый генерируется по перемещению "мыши" влево.

DOWNKEY ( --> Addr )
   Переменная, содержащая клавиатурный ASCII код, (можно расширенный),  кото-
рый генерируется по перемещению "мыши" вниз.

UPKEY ( --> Addr )
   Переменная, содержащая клавиатурный ASCII код, (можно расширенный),  кото-
рый генерируется по перемещению "мыши" вверх.

CENTERBUTTONKEY ( --> Addr )
   Переменная, содержащая клавиатурный ASCII код, (можно расширенный),  кото-
рый генерируется по нажатию средней мышиной клавиши.

RIGHTBUTTONKEY ( --> Addr )
   Переменная, содержащая клавиатурный ASCII код, (можно расширенный),  кото-
рый генерируется по нажатию правой мышиной клавиши.

LEFTBUTTONKEY ( --> Addr )
   Переменная, содержащая клавиатурный ASCII код, (можно расширенный),  кото-
рый генерируется по нажатию левой мышиной клавиши.

SETTEXTMASK ( AndMask XorMask --> )
   Это слово позволяет задать цвет мышиного курсора. Первый  параметр  задает
маску для логического умножения с атрибутом символа, в позиции которого нахо-
дится мышиный курсор, второй - маску для последующего исключающего логическо-
го сложения. После того, как курсор перемещается в другую позицию, цвет  сим-
вола автоматически восстанавливается.

SETYRANGE ( MinY MaxY --> )
   Задает вертикальный диапазон на экране, вне которого не  может  находиться
мышиный курсор.

SETXRANGE ( MinX MaxX --> )
   Задает горизонтальный диапазон на экране, вне которого не может находиться
мышиный курсор.

      2.9 Обработка прерываний и резидентные программы на Форте

HOOKINT ( Int# *InterruptProc ReturnStackSize StackSize ScreenStackSize --> )
   Самое важное слово из раздела "Обработка прерываний". Оно позволяет перех-
ватить прерывание с указанным номером, и в качестве нового обработчика перех-
ваченного прерывания установить слово, написанное на Форте. При  этом  Вашему
обработчику будут доступны все регистры, получаемые на входе данного прерыва-
ния, Вы сможете устанавливать практически все регистры на выходе из  прерыва-
ния, у Вас будет возможность выполнять стандартный обработчик  перехваченного
Вами прерывания как без изменения значений регистров, так и с их  изменением.
Параметр Int# - номер перехватываемого Вами прерывания. *InterruptProc - ука-
затель на слово-обработчик. Следующие три параметра определяют  соотвественно
размеры стека возвратов, арифметического стека и экранного  стека,  локальных
для данного обработчика. Вы можете перехватывать даже прерывания,  вызываемые
рекурсивно (например - int 21h) или прерывания, которые не предполагают  воз-
врата в точку вызова (например - int 20h, int 27h, функции 0 и 4ch прерывания
int 21h).
   Необходимо  отметить,  что  значения  переменных  Форт-системы  STACKSIZE,
RETURNSTACKSIZE, SCREENSTACKSIZE и MEMORYSIZE никоим  образом  не  влияют  на
размеры стеков процедур обработки прерывания.
   Здесь мне хочется принести извинения за самоуверенные заявления в предыду-
щих  редакциях  документа  об  отсутствии  ошибок  в  этом  слове.  В  версии
Форт-транслятора 92.8, хочется верить, они уже исправлены.

EXECUTEINT ( --> )
   Выполнить стандартный обработчик прерывания. Это  слово  должно вызываться
(прямо или косвенно) только из слова обработки прерывания. Не используйте это
слово, если не ожидаете возврата управления от стандартного обработчика, как,
например, при выполнении функции 4ch прерывания  int  21h.  Перед выполнением
этого слова Вы, возможно, захотите изменить значения регистров, полученных на
входе в прерывание или просто их проанализировать. Получить доступ к значени-
ям регистров можно следующим образом:
   В данной реализации  Форт-системы  введена  структура  данных,  называемая
структурой типа REGISTERS. Длина структуры - 28 байт. Создать такую структуру
можно, выполнив следующий  контекст:  REGISTERS  <ИМЯ-СТРУКТУРЫ>  После  чего
<ИМЯ-СТРУКТУРЫ> становится полноправным словом Форт-системы. При его выполне■
нии на стеке остается собственно адрес структуры (Аналогично, при  выполнении
слова, описывающего переменную, на стеке остается ее адрес). Получить  доступ
к отдельным полям структуры можно используя такие Форт-слова, как AX BX CX DX
SI DI SP BP FLAGS IP CS DS ES SS , определенные приблизительно так:

   : AX 0 + ;   : SI  8 + ;   : CS 20 + ;   : FLAGS 16 + ;
   : BX 2 + ;   : DI 10 + ;   : DS 22 + ;   : IP 18 + ;
   : CX 4 + ;   : SP 14 + ;   : ES 26 + ;
   : DX 6 + ;   : BP 12 + ;   : SS 24 + ;
   Эти слова прибавляют к базовому адресу структуры смещение конкретного  по-
ля. После их использования на стеке  лежит  "адрес  16-разрядного  регистра".
Внутри  процедуры  обработки  прерывания  Вы  можете  использовать  структуру
INTREGS для доступа к текущему значению  регистров  центрального  процессора.
Внимание! Эта структура локальна для каждого входа в  обработчик  прерывания.
Вы можете не только анализировать значения регистров, но и изменять их на лю-
бом этапе работы.

FINISHINT ( --> )
   Это слово аналогично слову EXIT, но вызывает выход не только  из  текущего
выполняемого Форт-слова, но и из всего обработчика прерывания. Вы можете выз-
вать это слово как из собственно обработчика, так и из слова, вызванного  об-
работчиком.

RELEASEINT ( --> )
   "Отпустить" прерывание, перехваченное  словом  HOOKINT.  Прерывание  будет
"отпущено" только в том случае, если после перехвата средствами Форта его еще
не успела перехватить какая-нибудь "шустрая" программа.

ENDINTPROC ( --> )
   Это слово работает аналогично слову EXECUTEINT за тем небольшим исключени-
ем, что просто передает управление  стандартному  обработчику  перехваченного
прерывания, снимая с себя всякую ответственность. На первый взгляд, ненужное,
это слово позволяет обрабатывать прерывания, возврат из которых  в  вызвавшую
их точку программы не ожидается.

PUSH ( N Regs --> )
   Слово позволяет "затолкать" в стек,  опредкляемый  регистровой  структурой
Regs число N. Указатель стека (поле SP в  регистровой  структуре)  изменяется
соответствующим образом.

POP ( Regs --> N )
   Слово выполняет действия, обратные по отношению к слову  PUSH.  Из  стека,
определяемого регистровой структурой, снимается число и оставляется на  ариф■
метическом стеке Форт-системы.

TRACEOFF ( --> )
   Иногда, например, при написании резидентных программ-антивирусов, требует-
ся обеспечить "непроходимость" обработчика прерывания, с использованием режи-
ма трассировки процессора i8086. Это поможет сделать слово  TRACEOFF.  Вполне
естественно, что 100-процентную "непроходимость" обработчика не сможет  обес-
печить ни одно средство, но для простейших трассировщиков  слово  TRACEOFF  -
непроходимый барьер. Трассировщик попросту потеряет управление, когда попыта-
ется выполнить это Форт-слово.

FDOS ( Regs --> )
   Выполнить Int 21h, загрузив предварительно регистры из регистровой  струк-
туру Regs. После выполнения функции DOS значения,  возвращенные  в  регистрах
процессора, записываются обратно в структуру.

INTR ( Int# Regs --> )
   Выполнить прерывание с номером Int#, загрузив предварительно  регистры  из
структуры. После того, как прерывание отработает, Вы сможете прочесть возвра-
щенные значения в той же регистровой структуре.

REGISTERS ( --> )
   Слово,  создающее  структуру  типа  REGISTERS.  Используется  в  контексте
REGISTERS <ИМЯ-СТРУКТУРЫ>. После выполнения слова <ИМЯ-СТРУКТУРЫ>,  на  стеке
остается адрес соответствующей регистровой структуры.

TSR ( --> )
   Слово оставляет программу резидентной в  памяти,  соответствующим  образом
корректируя  объем  памяти  ею  занимаемый.  Значения  переменных  STACKSIZE,
SCREENSTACKSIZE и RETURNSTACKSIZE во  внимание  не  принимаются.  Учитываются
только значение переменной MEMORYSIZE и размеры всех стеков для всех обработ-
чиков прерываний. Важная особенность: после вызова слова TSR и  корректировки
объема памяти, Ваша программа не должна занимать больший объем памяти, чем до
корректировки. Слово TSR этого условия не проверяет, оставляя его  соблюдение
на Вашей совести. Если Вы его не выполнили, оно просто потрет блоки MCB, выз-
вав недовольство DOS (с зависанием). Чтобы обеспечить выполнение этого  усло-
вия очень рекомендуется на этапе компиляции резидентной программы  установить
значения 65535 в системные переменные MEMORYSIZE и RETURNSTACKSIZE. Это обес-
печит Форт-программе максимально возможный объем в оперативной памяти на эта-
пе выполнения. А учитывая факт, что значения этих переменных равно 65535 и по
умолчанию, Вы вольны (если доверяете этому документу)  вообще  отказаться  от
их инициализации.


      2.10 Генерация псевдослучайных чисел

   Слова, реализующие генерацию  псевдослучайных  чисел,  вынесены  в  модуль
RANDOM.FRL. Основной принцип, положенный в основу генерации  -  использование
линейной конгруэнтной последовательности. (Точнее - даже двух). Обо всех тон■
костях Вы можете узнать, обратившись ко второму  тому  книги  Дональда  Кнута
"Искусство программирования для ЭВМ". А если не вдаваться в теорию, то  изло■
жить суть этого метода можно так:
   Датчик случайных чисел, основанный на линейной конгруэнтной последователь-
ности полностью определяется коээффициентами A, C, M формулы
   X(n+1) = ( A * X(n) + C ) mod M
где X(n) - предыдущее случайное число,    X(n+1) - очередное случайное число.
При достаточно хорошем подборе коэффициентов можно обеспечить  длину  периода
псевдослучайной последовательности равной M.
   В данной реализации используется две линейных конгруэнтных  последователь-
ности. Их коэффициенты хранятся в переменных XA, XC, XM, YA, YC, YM.  Послед-
ние выданные случайные числа хранятся в переменных LASTRANDX и  LASTRANDY,  а
слова RANDX и RANDY вычисляют, запоминают в переменных и выдают на стек  оче-
редные члены последовательностей. Теперь пару слов о том, почему  решено  ис-
пользовать два генератора. Дело в том, что получить безукоризненные случайные
числа с помощью линейной конгруэнтной последовательности  достаточно  трудно,
но существует очень интересный способ, позволяющий из двух "плохих" генерато-
ров сделать один "хороший" (на самом деле, безусловно, таких способов гораздо
больше). Пусть, мы завели массив из 100 элементов, и запомнили в его  ячейках
первые 100 случайных чисел, выданных последовательностью Y. Тогда новое  слу-
чайное число "хорошей" последовательности будем вычислять следующим образом:
   Заставим последовательность X сгенерировать случайное число от  0  до  99.
Оно будет определять тот элемент вектора (того самого, из 100 элементов), со-
держимое которого и будет "очень хорошим" случайным числом. После этого обно-
вим содержимое этого элемента, записав в него новое случайное число, выданное
последовательностью Y.

RANDOM ( MaxValue --> RandomNumber )
   Это слово и есть тот "хороший" генератор. Обратите внимание, что в отличие
от языка Турбо Паскаль, где одноименная функция  возвращает  число  от  0  до
MaxValue-1, RANDOM оставляет на стеке число из диапазона [0..MaxValue].

RANDOMIZE ( --> )
   Это слово инициализирует последовательности X и Y  значениями,  зависящими
от системного времени. Это слово имеет атрибут START  и  поэтому  запускается
каждый раз перед стартом Вашей программы (если, конечно, Вы подключили модуль
RANDOM.FRL).


      2.11  Адресный интерпретатор, или как работает Форт-система

   Адресный интерпретатор - небольшая программа, написанная на  языке  ассем-
блера, которая управляет работой всей Форт-системы. Компактность  этой  прог-
раммы (в данной реализации Форт-системы адресный интерпретатор занимает всего
17 (семнадцать!) байт), ее простота в значительной степени определяют красоту
и стиль Форта. При чем здесь интерпретатор? Все очень просто. Дело в том, что
код, генерируемый Форт-транслятором, вообще говоря, не является машинным  ко-
дом, понятным процессору i8086. Для выполнения этого кода и  служит  адресный
интерпретатор. Скорее всего, при слове "интерпретатор" у Вас возникли ассоци-
ации с интерпретатором языка Бейсик, работающим "в час по чайной ложке".  Ни-
чего подобного! Адресный интерпретатор Форта выполняет  "свой"  код  быстрее,
чем процессор i8086 выполняет код, созданный компиляторами с таких языков вы-
сокого уровня, как Си или Паскаль. Проверить  этот,  как  кажется  с  первого
взгляда, совсем не очевидный факт, можно, проведя небольшие расчеты с исполь-
зованием данных о времени выполнения машинных команд в процессоре  i8086.  Вы
сможете сами в этом убедиться, после прочтения этой  главы  просчитав  время,
затрачиваемое Форт-системой на вызов слова, написанного на  языке  ассемблера
(вызов такого слова выполняется быстрее), и слова, представленного в Форт-ко-
де, и сравнив эти данные с временем вызова процедур Паскаля и функций Си. Те-
перь о том, как выглядит код, выполняемый адресным интерпретатором. Этот  код
является разновидностью шитого кода. Для тех, кто знаком с принципами  работы
Форт-систем, и знает, каких разновидностей бывает шитый код, стоит  сообщить,
что в данной реализации Форт-транслятора используется прямой шитый код.  Каж-
дая команда такого кода - это адрес, занимающий два байта, по которому  необ-
ходимо передать управление. У команды могут  быть  операнды  -  байт,  слово,
двойное слово, строка со счетчиком символов, занимающим один байт, строка  со
счетчиком, занимающим два байта, строка, представленная в  формате  ASCIIz  и
адрес, представленный в виде смещения  относительно  указателя  интерпретации
(аналог регистра IP для шитого кода) и занимающий два байта. В других  реали-
зациях Форт-систем операндами может  быть,  вообще  говоря,  абсолютно  любая
структура данных. Единственное условие - команда должна "знать" или уметь вы-
числять длину своих операндов. В данной реализации Форт-транслятора все  воз-
можные форматы операндов - перечислены выше. Тем не менее,  это  не  является
ограничением - ведь параметры (операнды) можно передавать слову  через  стек.
Зато, приняв это ограничение, Вы сможете воспользоваться глвным достоинтством
этой реализации Форт-транслятора: возможностью создавать независимые выполня-
емые модули, работающие под управлением DOS. Не любая Форт-система может этим
похвастаться. Если же для Вас является более важным отсутствие каких бы то ни
было ограничений, пусть  даже  самых пустяковых, у Вас  есть  возможность  их
игнорировать. Только в этом случае механизм создания независимого выполняемо-
го модуля будет несколько другим, да и  модуль  не  будет  столь  компактным.
Правда, он все равно получается, почему-то в большинстве  случаев  компактнее
Си-модулей, но это - другой вопрос... Команды (или слова), написанные на язы-
ке ассемблера, являются для Форт-кода аналогами микропрограмм.  Любое  слово,
получив управление, если только у него есть операнд,  компилируемый  в  шитый
код, должно обработать его (на него указывает указатель интерпретации  -  ре-
гистр SI), и передвинуть указатель интерпретации так, чтобы  он  указывал  на
адрес следующей команды. Иными словами, необходимо прибавить  к  регистру  SI
длину операнда.
   О том, как создать выполняемый модуль без указанных выше ограничений, мож-
но прочесть в разделе "Генерация новых версий Форт-системы".

   Ниже приводится адресный интерпретатор
callr:          ; Точка CALL адресного интерпретатора В эту точку  управление
                ; передается для того, чтобы начать интерпретацию  очередного
                ; Форт-слова Так  как  управление  сюда  передается  командой
                ; CALL, за которой сразу следует шитый код, адрес, с которого
                ; необходимо начать интерпретацию шитого  кода  находится  на
                ; вершине арифметического стека (Его указатель - регистр SP)
                ; ***********************************************************
                dec             bp                ; Уменьшим указатель  стека
                dec             bp                ; возвратов - регистр BP
                mov             word ptr [bp],si  ; Сохраним на стеке возвра-
                                                  ; тов старое значение  Ука-
                                                  ; зателя  интерпретации   -
                                                  ; регистра SI
                pop             si                ; Восстановим  с  арифмети-
                                                  ; ческого стека новое  зна-
                                                  ; чение указателя интерпре-
                                                  ; тации,  сохраненное   там
                                                  ; машинной командой CALL на
                                                  ; точку CALL интерпретатора
next:           ; Точка NEXT адресного интерпретатора Управление сюда переда-
                ; ется командой JMP Точка  инициирует  выполнение  очередного
                ; слова
                cld                               ; Сбросим флажок направления
                lodsw                             ; Считаем в регистр AX  ад-
                                                  ; рес следующего слова, ко-
                                                  ; торое   надо   выполнить,
                                                  ; продвинем  указатель  ин-
                                                  ; терпретации
                jmp             ax                ; И  передадим   управление
                                                  ; этому слову
return:         ; Точка RETURN адресного интерпретатора (иногда  ее  называют
                ; точкой EXIT) Эта точка завершает  выполнение  Форт-слова  В
                ; данной реализации она сведена в слово EXIT
                mov             si,word ptr [bp]  ; Восстановим старое значе-
                                                  ; ние указателя интерпрета-
                                                  ; ции,    сохраненное   при
                                                  ; входе в слово точкой CALL
                                                  ; на стеке возвратов
                inc             bp                ; Увеличим указатель
                inc             bp                ; стека возвратов
                jmp             short next        ; И - на точку NEXT продол-
                                                  ; жить работу по выполнению
                                                  ; слова, вызвавшего  только
                                                  ; что завершившееся слово

Например, слово, рассчитывающее дискриминант квадратного  уравнения,  опреде-
ленное как:
: DIS ( A B C --> B^2-4*A*C ) SWAP DUP * ROT ROT * 4 * - ;
в шитом коде может быть представлено следующим образом:

dis:            call            callr             ; Запустить   интерпретатор
                                                  ; для выполнения слова DIS
                dw              swap              ; Адрес SWAP
                dw              dup               ;       DUP
                dw              mult              ;       *
                dw              rot               ;       ROT
                dw              rot               ;       ROT
                dw              mult              ;       *
                dw              lit               ; Слово, операнд которого -
                                                  ; двубайтовое число,  кото-
                                                  ; рое  необходимо  положить
                                                  ; на арифметический стек
                dw              4                 ; Операнд слова LIT
                dw              mult              ;       *
                dw              mines             ;       -
                dw              exit              ;       EXIT
                                                  ; Это слово скомпилировано
                                                  ; словом ; (точка с запятой)

swap:           pop             ax                ; Обменять местами два чис-
                pop             bx                ; ла с арифметического сте-
                push            ax                ; ка
                push            bx
                jmp             next              ; и   передать   управление
                                                  ; точке NEXT  для продолже-
                                                  ; ния интерпретации

dup:            pop             ax                ; продублировать на арифме-
                push            ax                ; тическом  стеке  число  с
                push            ax                ; его вершины
                jmp             next

mult:           pop             ax                ; Умножение  двух  чисел  с
                pop             bx                ; вершины стека
                imul            bx
                push            ax
                jmp             next

rot:            pop             ax                ; Слово ROT
                pop             bx
                pop             cx
                push            bx
                push            ax
                push            cx
                jmp             next

lit:            lodsw                             ; Получим число,  скомпили-
                push            ax                ; рованное в шитый код сле-
                jmp             next              ; дом за вызовом lit
                                                  ; Передвинем указатель  ин-
                                                  ; терпретации, чтобы интер-
                                                  ; претатор не пытался  "вы-
                                                  ; полнить" это число

mines:          pop             ax                ; Вычитание
                pop             bx
                sub             bx,ax
                push            bx
                jmp             next

exit:           jmp             return            ; Слово, организующее  выход
                                                  ; из Форт-слова.  Управление
                                                  ; Передается на точку RETURN
                                                  ; Далее продолжается  выпол-
                                                  ; нение  слова,   вызвавшего
                                                  ; только что завершившееся.

      2.12 Интерфейс с языком ассемблера

   Многие Форт-системы имеют средства, позволяющие включать программы на язы-
ке ассемблера непосредственно в текст Форт-программ. Признаюсь, сначала в мои
планы входило сделать то же для этой версии Форт-системы,  но  позже  выясни-
лось, что встроенный ассемблер не такая уж и тривиальная программа, по  край-
ней мере, для меня. Здесь, не имея четких преставлений о том, как должен выг-
лядеть Форт-ассемблер, как обрабатывать  ассемблерные  метки,  как,  наконец,
проверять соответствие операндов операции, написать что-то похожее на  насто-
ящий Форт-ассемблер, работа с которым не является пыткой, на мой взгляд,  не-
возможно. В связи с соображениями, приведенными в предыдущем абзаце, было ре-
шено предоставить пользователю возможность использовать любой стандартный ас-
семблер для написания слов, работающих под управлением Форт-системы. На  сло-
ва, написанные на языке ассемблера, накладывается одно  ограничение:  они  не
должны содержать машинных команд, оперирующих с фиксированными адресами памя-
ти. Т.е. таких команд, которые делают программу жестко настроенной на некото-
рый адрес внутри сегмента. Пожалуйста, не забывайте,  что  данная  реализация
Форт-системы работает только с одной моделью памяти, классифицировать которую
по общепринятым признакам не представляется возможным. Из-за этого все попыт-
ки написать слово, работающее с несколькими сегментами, скорее всего,  потер-
пят фиаско. Для написания программ на языке ассемблера,  предназначенных  для
выполнения под управлением Форт-системы, вместе с Форт-системой и  ее  библи-
отеками распространяется файл FORTHASM.INC. Он  содержит  описание  доступных
порграмме переменных Форт-системы, некоторые макрокоманды, облегчающие интер-
фейс с Форт-системой. Все слова, написанные на языке ассемблера, которые сос-
тавляют часть какой-то Форт-программы, сводятся в один  ассемблерный  модуль,
после ассемблирования которого получается файл, который  можно  подключить  к
Форт-программе на этапе компиляции командой USE. Внутренний формат ассемблер-
ного модуля нетрудно понять на примере:

; *****************************************************************************
;       Пример подключаемого модуля, написанного на языке ассемблера
; *****************************************************************************
; Для получения из .ASM модуля .FRL модуля используйте
;        tasm <module>
;        tlink <module> /t
;        rename <module>.com <module>.frl
; Где <module> - имя модуля (без расширения)
; *****************************************************************************

                include         forthasm.inc

word1_:         db              5,'WORD1',0
                ;               │  └─┬─┘  │
                ;               │    │    └─── поле атрибутов
                ;               │    │         (см. описание Форт-словаря)
                ;               │    │
                ;               │    └──────── имя слова (желательно -
                ;               │              - заглавными буквами)
                ;               │
                ;               └───────────── длина имени слова
                dw              0
                ;               │
                ;               └───────────── поле связи
                ;                              для первого слова в модуле = 0
_word1:         ; поле кода
                pop             ax              ; снимаем параметры со стека
                pop             bx
                ;               .  .  .  .  .
                push            ax              ; оставляем результаты на стеке
                next            ; макрокоманда - переход на точку NEXT
                ; Так должно заканчиваться каждое слово
                ; Пожалуйста, не ставтьте RET в конце слова

word2a_:        db              6,'WORD2A',0
                dj              word1_          ; поле связи
                ;│                                - для всех слов, кроме 1-го
                ;└───────────── макрокоманда из файла FORTHASM.INC
_word2a:        ;               .  .  .  .  .
                next

word2b_:        db              6,'WORD2B',0
                dj              word2a_
_word2b:        ;               .  .  .  .  .
                next

finalword_:     db              9,'FINALWORD',0
                dj              word2b_
_finalword:     ; ВНИМАНИЕ !!!
                ; Последнее слово из модуля запускается сразу после подключе-
                ; ния модуля прямо на этапе компиляции. Оно  должно  произво-
                ; дить, по необходимости, нужную инициализацию  модуля  после
                ; его подключения, может выдать сообщение о том,  что  модуль
                ; подключен, проанализировать остаток строки исходного файла,
                ; командой USE из которого подключен модуль. Если инициализа-
                ; ция не требуется, последнее слово может содержать одну мак-
                ; рокоманду NEXT, завершающую его.
                next

                ; Последняя часть подключаемого модуля - это его "заголовок".
                ; По этой части модуля транслятор делает выводы  о  том,  что
                ; подключенный файл - действительно Форт-модуль, проверяет на
                ; совместимость с этим модулем версию компилятора,  связывает
                ; слова из модуля в единый Форт-список. Кроме того, если  мо-
                ; дуль содержит слова, написанные  на  Форте,  то  необходимо
                ; настроить эти слова на тот адрес,  с  которого  они  теперь
                ; расположены в памяти. Информация для настройки так  же  со-
                ; держится в "заголовке". Длина заголовка модуля - 8 байт.

; Начальный адрес (смещение), с которого находился в памяти данный модуль  во
; время его формирования. Это поле служит для настройки  модуля,  содержащего
; Форт-слова на адрес, с которого он загружен. Условимся для модулей, сформи-
; рованных на языке ассемблера устанавливать этот адрес равным 100h.
                dw              100h

; Смещение относительно начала модуля поля имени последней словарной  статьи.
; В нашем случае - поля имени слова FINALWORD. Так как модуль  формируется  в
; .COM файле, то для получения смещения относительно начала модуля необходимо
; из смещения внутри сегмента вычесть 100h.
                dw              (offset finalword_)-100h

; Номер версии компилятора, для которого формировался модуль. Сравнивается  с
; двубайтовым числом, расположенным в памяти в сегменте кода по адресу  103h.
; Для версии компилятора 92.9 первый байт версии = 92; второй = 9.
                db              92,9

; Идентификатор Форт-модуля. "Пароль". В следующих  версиях  компилятора  его
; предполагается сохранить.
                dw              1231h

; Псевдокоманда ассемблера END должна иметь такой вид:
                end             module
; ***************************************************************************

      2.13 Словарь Форт-системы

   Словарь состоит из отдельных словарных статей, связанных в список.  Каждая
словарная статья состоит из следующих частей :
   1) Поле имени - строка символов, первый байт которой задает ее длину.
   2) Поле атрибутов - нестандартное поле, введенное только в  этой  реализа-
      ции. Длина поля атрибутов - 1 байт. Каждый бит этого байта отвечает  за
      определенный признак.

         Бит 0 - равен нулю, если слово написано на языке ассемблера и не ис-
                 пользует вызов других слов. Равен 1, если слово написано  на
                 Форте.
         Биты 1-3 - задают код операнда для данного слова. Операнд - понятие,
                 так же введенное с этой версии. Он определяет, какая  струк-
                 тура следует в шитом коде за каждым вызовом данного слова.
                 000 - операнд отсутствует
                 001 - число (2 байта)
                 010 - длинное число (4 байта) старшее слово  -  по  младшему
                       адресу
                 011 - строка (длина задается первым байтом)
                 100 - строка в формате ASCIIz
                 101 - длиная строка (длина задается словом)
                 110 - байт
                 111 - смещение
         Бит 4 - именной атрибут. Если он установлен  в  1,  то  слово  будет
                 включено в исполняемый файл вне зависимости от того, вызыва-
                 ется оно или нет. Вместе с кодом, соответствующим этому сло-
                 ву,  в исполняемый модуль вставляются поля имени,  атрибутов
                 связи. Слова, скомпилированные данным образом, могут  выпол-
                 няться (или компилироваться) на этапе работы программы. Дру-
                 гое использование этого атрибута - выполнение слова по  име-
                 ни.
                 Бит устанавливается последовательностью:
                    SETNAME <ИМЯ-СЛОВА>
                 Сбрасывается
                    CLEARNAME <ИМЯ-СЛОВА>
         Бит 5 - атрибут инициализации.  Наиболее частое его использование  -
                 в пользовательских модулях.  Слово,  у  которого  установлен
                 данный бит, будет включено в исполняемый код и на него будет
                 сформирована ссылка, которая заставит это слово  выполниться
                 перед запуском основной программы. Установить у  слова  этот
                 атрибут можно следующим образом:
                    SETSTART <ИМЯ-СЛОВА>
         Бит 6 - для слов,  написанных  на языке ассемблера,  установка этого
                 бита  в 1 заставляет после  построения  выполняемого  модуля
                 словом  BUILD  разместить это  слово в памяти  со  смещения,
                 кратного 16. Т.е. выровнять на границу параграфа.
         Бит 7 - стандартный признак IMMEDIATE
   3) Поле связи - смещение относительно поля кода поля имени предыдущей сло-
      варной статьи. Первая словарная статья в словаре содержит 0 в поле свя-
      зи. (То же и в пользовательских модулях). Длина - 2 байта.
   4) Поле кода - для слов, написанных на Форте, это  поле  содержит  команду
      внутрисегментного перехода с возвратом на точку CALL  адресного  интер-
      претатора. Для слов, созданных создающими словами (кроме ":"), это поле
      содержит команду внутрисегментного перехода на  поле  кода  исполняющей
      части создающего слова. Если у создающего слова отсутствовала  исполня-
      ющая часть, то вместо ее адреса берется точка NEXT адресного  интерпре-
      татора. Слова, для которых словом REPLACE была установлена  новая  вер-
      сия, содержат в поле кода машинную команду  безусловного  внутрисегмен-
      тного перехода к полю кода новой версии слова. И,  наконец,  для  слов,
      написанных на языке ассемблера, в поле кода начинается тот код, который
      и определяет действие данного слова. Такие слова должны завершаться бе-
      зусловным переходом на точку NEXT адресного интерпретатора. (Для справ-
      ки: адрес точки NEXT адресного интерпретатора содержится в текущем сег-
      менте кода по смещению 105h. Таким образом слово может завершаться сле-
      дующей командой : jmp word ptr  ds:[105h].  Единственным  ограничением,
      накладываемым на такие слова, является следующее требование: слова, на-
      писанные на языке ассемблера, не должны зависеть от смещения, с которо-
      го начинается их код в текущем сегменте. Иными словами, код  этих  слов
      не должен содержать абсолютных адресов, кроме, может быть,  стандартных
      адресов Форт-переменных, либо должен самостоятельно настраивать все та-
      кие адреса при КАЖДОМ вызове слова. В частности, это ограничение делает
      несколько неудобным использование  переменных,  локальных  для  данного
      слова, и очень трудным использование переменных, общих для этого и  не-
      которого другого слова. Для использования). Длина поля кода - 3 байта.

   5) Поле параметров - для слов, написанных на языке ассемблера, в поле  па-
      раметров продолжается исполняемый код, начало которого находится в поле
      кода. Для Форт-слов, определенных через ":", поле параметров состоит из
      последовательности ссылок на поля кода тех слов, в  исполнении  которых
      состоит действие данного слова. После каждой ссылки, занимающей 2  бай-
      та, следует операнд ( если этого требует то слово, на которое указывает
      ссылка). Последовательность ссылок завершается  ссылкой  на  поле  кода
      слова EXIT, действие которого заключается в передаче управления на точ-
      ку RETURN адресного интерпретатора. Это приводит к  выходу  из  данного
      слова и передаче управления слову, которое его вызвало. Так  как  слово
      EXIT  программист, написавший программу на Форте, мог использовать  яв-
      но, то в одном слове может содержаться несколько ссылок  на  поле  кода
      слова EXIT. Следовательно, встретившаяся в поле  параметров  ссылка  на
      слово EXIT еще не гарантирует того, что  поле  параметров  закончилось.
      Длина поля параметров определяется следующим образом : из  адреса  поля
      имени слова, следующего в словаре за данным словом (т.е.  определенного
      позже) вычитается адрес поля параметров данного слова.  В  том  случае,
      если данное слово идет в словаре последним, и, следовательно, для  него
      отсутствуют слова, определенные позже, то вместо адреса поля имени сло-
      ва, следующего в словаре за данным, необходимо взять адрес вершины сло-
      варя.

      2.14 Генерация независимых программ

   Форт-транслятор способен генерировать компактные, быстро работающие испол-
няемые модули. Форт-транслятор создает выполняемые файлы типа .COM, и  следо-
вательно, не может генерировать модули, длиннее 64К. Это, однако, не является
существенным ограничением для написания программ, так как грамотно написанная
программа на Форте в оттранслированном виде занимает  гораздо  меньше  места,
чем ее исходный текст. Собственно  генерацию  выполняемых  модулей  выполняет
слово BUILD. Это - самое сложное слово из всей Форт-системы - на его  отладку
я затратил около трех месяцев. Оно же -  главная  достопримечательность  этой
реализации Форт-системы. Написанное на языке ассемблера с использованием  ре-
курсивных вызовов своих внутренних подпрограмм, это слово выполняет  довольно
неплохую оптимизацию Форт-кода, удаляя из него все Форт-слова, вызовы которых
отсутствуют в главной программе, а также (если не оговорено противное), и все
поля имени, атрибутов, связи для каждого Форт-слова, которое прямо  или  кос-
венно вызывается главной Форт-программой.  Все  внутренние  ссылки,  грамотно
скомпилированные, корректируются. Использовать слово BUILD Вы  можете  следу-
ющим образом:
   BUILD  <ИМЯ-.COM-ФАЙЛА>  <ИМЯ-.MAP-ФАЙЛА>
   Обязательно укажите расширения файлов. Параметр <ИМЯ-.MAP-ФАЙЛА> -  необя-
зательный. При его отсутствии соответствующий файл не создается. Если  же  Вы
собираетесь отлаживать полученную Форт-программу в  привычном  Вам  отладчике
(им может быть и AFD и Turbo Debugger), непременно создайте .MAP  файл.  Этот
текстовый файл сожержит таблицу, распечатав которую, Вы сможете получить дос-
таточную для отладки Вашей программы информацию.
   Необходимо отметить, что, при всей своей сложности, это слово, по моим по-
дозрениям, не содержит ошибок, что, однако, не означает, что  Ваше сообщение,
опровергающее мое наблюдение, не будет проверено.

      2.15 Генерация новых версий Форт-системы

   Кроме генерации независимых выполняемых модулей, Ваш Форт-транслятор обла-
дает способностью генерировать свои новые версии, дополненные  Форт-словами в
нужном Вам направлении. Если, например, Вы достали  книгу  "Проектирование  и
програмная реализация экспертных систем на персональных ЭВМ" (авторы -  К.Та-
унсенд и Д.Фохт), Вам, вероятно, захочется реализовать для  собственных  нужд
слова обработки списков. Вы можете выбрать любой из нижеперечисленных путей:
   1) Записать слова обработки списков в отдельный текстовый файл, и для каж-
      дой Вашей программы, использующей эти слова,  "вклеивать"  их  исходный
      текст в текст Вашей программы, используя возможности Вашего  текстового
      редактора.
   2) Подключать тот же файл, содержащий описания, словом INCLUDE.
   3) Создать подключаемую библиотеку словом MAKEUNIT и по необходимости под-
      ключать ее словом USE.
   4) Сгенерировать новую версию Форт-системы, в состав базовых слов  которой
      входят слова обработки списков.
Последняя из перечисленных возможностей может быть реализована следующим спо-
собом:
   Вы создаете файл, содержащий описания слов, которые необходимо добавить  в
Форт-систему, и в его конце (в самой последней строчке) ставите команду:
SAVE <НОВОЕ-ИМЯ-ФАЙЛА-С-ФОРТ-СИСТЕМОЙ>
Не забутьте указать расширение .COM.
   Помимо добавления Форт-слов, в новой версии Форт-системы, Вы можете также,
переписать некоторые стандартные Форт-слова. Можете (используя слово RESTART)
указать Форт-системе, какое слово будет запущено сразу после ее  старта.  Эти
простые возможности позволят Вам создавать Форт-системы практически на  любой
вкус. Вы можете добавить к Форт-системе  "Турбо"-среду,  текстовый  редактор,
собственные оптимизаторы кода.

   3. ESC-последовательности, обрабатываемые словом EMIT
      из CRT модуля

   ESC A <n> - Установить рабочий атрибут для дальнейшего вывода символов.
   ESC B <n> - Установить
                  для драйвера #2 - атрибут курсора. Т.е. цвета, которые  бу-
                  дут определять, как должен выглядеть символ в позиции  кур-
                  сора.
                  для драйвера #0 - игнорируется.
                  для драйверов #1 и #3 - определяет форму (высоту)  курсора.
                  Старшая тетрада (4 бита) <n> должна содержать номер началь-
                  ной строки курсора. Младшая - номер конечной строки. Строки
                  курсора нумеруются от нуля (самая верхняя строка) и вниз.
   ESC C <n> - Выбрать драйвер экрана. В модуле CRT содержится четыре драйвера
               экрана. Ниже приведены их особенности :
        #0 - Драйвер без курсора. Не обращается к процедурам  BIOS.  Работает
             быстро. В графических режимах - не действует. Попытки  применить
             его в графическом режиме, скорее всего,  выведут  на  экран  ка-
             кой-нибудь мусор, но могут закончиться и более неприятно.
        #1 - Драйвер с жестким мигающим  курсором,  реализованным  аппаратно.
             Работает достаточно быстро. В графических режимах - неприменим.
        #2 - Драйвер с мягким немигающим курсором произвольного цвета. (Уста-
             новкой цвета курсора управляет предыдущая ESC  -  последователь-
             ность). Работает достаточно быстро, но - только в текстовых  ре-
             жимах.
        #3 - Драйвер, использующий стандартные вызовы функций BIOS. В тексто-
             вом режиме либо имеет мигающий курсор, цвет которого определяет-
             ся цветом символа, на котором он находится, либо совсем не имеет
             курсора. Единственный драйвер, позволяющий выводить текст в гра-
             фическом режиме. Скорость работы очень сильно зависит от  машины
             и намного меньше скоростей работы предыдущих драйверов. В графи-
             ческих режимах не имеет курсора.
   ESC D U - Сдвинуть рабочее окно на один символ вверх
   ESC D D - Сдвинуть рабочее окно на один символ вниз
   ESC D L - Сдвинуть рабочее окно на один символ влево
   ESC D R - Сдвинуть рабочее окно на один символ вправо
   ESC F <n> - Вывести специальный символ <n>
             (Такой, например, как 8,9,0ah,0ch,0dh,1bh в символьном
             изображении)
   ESC G <x> <y> - переместить курсор в указанную позицию. Используются
      абсолютные координаты. Верхний левый угол экрана имеет координаты
      (0,0).
   ESC H U - Переместить курсор на символ вверх
   ESC H D - Переместить курсор на символ вниз
   ESC H L - Переместить курсор на символ влево
   ESC H R - Переместить курсор на символ вправо

   4. Некоторые неочевидные ошибки

   1) Использование пустой строки.
Пустая строка - строка, не содержащая ни одного символа. Не пытайтесь обозна-
чать ее как " " (две кавычки, между которыми находится пробел). В общем  слу-
чае такое обозначение будет давать Вам отнюдь не  пустую  строку,  а  строку,
состоящую из тех Форт-слов, которые идут в исходном тексте программы за  тем,
что Вы считаете обозначением пустой строки. Эта ошибка довольно трудно  обна-
ружима, но достаточно вспомнить, как работает слово WORD, выделяющее слова из
входного потока, как все становится на свои  места.  Для  обозначения  пустой
строки пользуйтесь словом NULLSTRING.
   2) Некорректное использование стека возвратов.
Не забывайте, что все, что Вы положили на стек возвратов внутри одного слова,
должно быть извлечено из него до выхода из этого  слова.  Помните,  что  стек
возвратов лучше не использовать для передачи  параметров  внутрь  вызываемого
слова. Если же Вам неппременно хочется это сделать, обеспечьте к  этим  пара-
метрам корректный доступ. Будьте вниматиельны, если вместе с работой со  сте-
ком возвратов Вы используете циклы со счетчиком DO ... LOOP или DO ... +LOOP:
Внутри  этого цикла на стек  возвратов кладется три дополнительных параметра,
которые автоматически удаляются с него после окончания цикла или  при  выходе
из него словом LEAVE.
   3) Некорректное использование арифметического стека
Если Ваша программа некоторое время работает нормально,  но  потом  почему-то
"виснет", начинает выдавать видеоэффекты или производить действия, необъясни-
мые с точки зрения здравого смысла, то, скорее  всего,  дело  в  переполнении
арифметического стека. Для меня поиск такого рода ошибок в программе -  заня-
тие крайне утомительное: поэтому я решил упростить жизнь и бороться не с при-
чиной, а со следствием. Слово DROPALL, которое можно использовать  достаточно
часто, лучше всего - внутри "большого" цикла, очищает арифметический стек, и,
таким образом, нейтрализует возможные ошибки. Конечно, это  не  самый  лучший
способ написать надежную программу, но все же он достаточно приемлем во  мно-
гих случаях.
   4) Невнимательная работа с переменной BASE
Перед тем, как ввести или вывести число, подумайте - в какой системе  счисле-
ния Вы хотите это сделать. А еще лучше - всегда работайте в десятичной систе-
ме счисления, переключаясь на другие лишь по мере надобности.
   5) Нестандартная реализация слова EXPECT
В данной реализации слово EXPECT вводит с клавиатуры строку в формате ASCIIz.
Это означает, что зарезервированный под строку блок  памяти  должен  быть  по
меньшей мере на один байт больше, чем предполагаемая максимальная длина стро-
ки. Как и в стандартном Форте, EXPECT заносит длину введенной строки в  пере-
менную SPAN.
   6) Неверно скомпилированная строка с управляющими символами
Для большей гибкости в данную реализацию Форта включена возможность  задавать
строки со специальными управляющими символами, аналогичная  подобной  возмож-
ности в языке Си. Любители Си, помните:
a) Если Вы хотите задать символ его кодом, то  не  забывайте:  данная  версия
   Форта поддерживает здесь только десятичную систему счисления.
b) После кода символа поставьте символ ; (точка с запятой)
c) Символически могут быть заданы следующие управляющие сиволы:
   \b = \8;
   \t = \9;
   \r = \13;
   \n = \10;
   \e = \27;
   \\ = \92;
d) Символ \0; не может быть задан внутри строки в формате ASCIIz
Ошибки этого типа обнаружить чрезвычайно трудно. Это связано с тем, что сооб-
щение об ошибке выдается не на ошибочной строке, а на строке со словом BUILD.
e) Если  Вы в  Вашей программе указываете путь  к файлу в виде строки в  фор-
мате ASCIIz, не забывайте о том, что символ \, используемый в DOS для  разде-
ления подкаталогов, имеет другое значение в данной реализации Форта.  Строка,
задающая путь должна выглядеть, примерно, так:
A" c:\\lang\\asm\\tasm\\myprogs\\lib\\protect\\sys"
   7) Неверное завершение слов, написанных на языке ассемблера
Ассемблерные  слова,  написанные для работы  под  управлением   Форт-системы,
должны заканчиваться не машинной командой RET, а макрокомандой NEXT,  опреде■
ленной в файле FORTHASM.INC и выполняющей переход на точку NEXT адресного ин■
терпретатора.
   8) Некорректное использование цикла со счетчиком
Не забывайте, в каком порядке следуют на стеке параметры слова DO, начинающе-
го цикл со счетчиком. Если их поменять местами, то в лучшем случае  -  Вы  не
получите желаемого результата по завершению работы цикла. Хуже - если в цикле
прозводится запись в память - в этом случае, скорее всего, окажутся испорчен-
ными либо Форт-система, либо блоки управления  памятью  DOS,  либо  "простые"
данные.
   9) Некорректное использование регистров в словах, написанных на языке  ас-
      семблера
Помните, что в Форт системе регистры SS, SP, BP, SI, DS  не  могут  содержать
произвольные числа.  После завершения работы ассемблерного слова, пожалуйста,
восстанавливайте эти регистры, если Вы их изменили. Регистр DS  сохранять  не
обязательно. При восстановлении его достаточно сделать  равным  регистру  CS.
Остальные же из перечисленных регистров изменять можно только, если  Вы  зна-
ете, зачем это нужно, и уверены, что это не приведет к порче Форт-системы.

   5. Карта памяти Форт-программы

      Сегмент стека.
      Хранится в сегментном регистре SS
      Оставляется на стеке словом STACKSEGMENT

      ┌───────────────┐ <─────── Хранится в переменной R0
      │ Стек возвратов│
      ├───────┬───────┤ <─────── Оставляется на стеке словом RP@
      │       V       │          Хранится в регистре BP
      │               │
      │               │
      ├───────────────┤ <─────── Хранится в переменной S0
      │     Стек      │
      ├───────┬───────┤ <─────── Оставляется на стеке словом SP@
      │       V       │          Хранится в регистре SP
      │               │
      │               │
      ├───────────────┤ <─────── Хранится в переменной SS0
      │ Экранный стек │
      ├───────┬───────┤ <─────── Хранится в переменной SSP
      │       V       │
      │               │
      │               │
      └───────────────┘

      Сегмент кода.
      Находится в сегментных регистрах CS, DS.
      Все слова, написанные на языке ассемблера, должны
      восстанавливать DS=CS или не изменять его.
      Оставляется на стеке словом CODESEGMENT.

      ┌───────────────┐
      │ "Регистровый" │
      │ стек          │
      ├───────┬───────┤ <────── Оставляется на стеке словом INTREGS
      │       V       │
      │               │
      │               │
      │       ^       │
      ├───────┴───────┤ <────── Оставляется на стеке словом HERE
      │    Словарь    │
      ├─────┬─────────┤ <────── 100h
      │     │ Входной │
      │     │ буфер   │
      │ PSP ├─────────┤ <────── 80h
      │     │         │
      │     │         │
      └─────┴─────────┘ <────── 0


   6. Оценка эффективности программ

   Существует достаточно простой и вместе с тем точный  способ  количественно
оценить стиль программирования на Форте: попробуйте сжать выполняемый .COM  -
файл, созданный Форт-транслятором при компиляции Вашей программы, таким  упа-
ковщиком выполняемых модулей, как,  например,  PKLITE.  Высшая  оценка  стиля
программирования - сообщение "File could not be compressed".
   В действительности, такой высокой оценки довольно трудно добиться, и можно
полагать, что программа хорошо написана, если процент сжатия выполняемого мо-
дуля не превышает 10%.
   Как же писать такие программы? Самый верный способ - это забыть о том, что
текстовый редактор, в котором Вы работаете, имеет функции копирования блоков,
или, что еще лучше, пользоваться текстовым редактором, не имеющим таких  фун-
кций.


   7. Примеры программ

      7.1 Использование рекурсии

( Слово, считающее факториал )
: FACT ( N --> N! )
   Dup 1 >                    ( N Flag     --> )
   If                         ( N          --> )
      \ Рекурсивная формула N! = N * (N-1)!
      Dup 1-                  ( N N-1      --> )
      Recurse                 ( N (N-1)!   --> )
      *                       ( N!         --> )
   Else
      \ если N=0 или N=1, то N!=1
      Drop                    (            --> )
      1                       ( 1          --> )
   Then
;

      7.2 Работа с файловой системой и пример оформления программы

( *********************************************************************** )
(                   Программа, аналогичная команде TYPE                   )
(     Вы можете "вырезать" эту программу из документации, и попробовать   )
(                        поэкспериментировать с ней                       )
( *********************************************************************** )

200 StackSize !                \ требуемый размер арифметического стека
50  ReturnStackSize !          \ размер стека возвратов
0   ScreenStackSize !          \ размер экранного стека
100 MemorySize !               \ размер динамической памяти

Use DOS.frl                    \ Подключение функций работы с файлами

0 Constant READONLY            \ Режим открытия файла
128 Constant BUFSIZE           \ Размер буфера для чтения
1 Constant STDOUT              \ Стандартный описатель файла

Create BUFFER BufSize Allot    \ Отведем память под буфер
                               \ - не лучшим образом, но наглядно

Variable HANDLE                \ Переменная для хранения описателя

: ERRQUIT ( --> )              \ Выход из программы по ошибке
   ." \r\nExiting . . .\r\n"
   Bye
;

: MAIN                         \ Главная программа
   Bl Word                     \ Выделить слово из командной строки,
                               \ ограниченное пробелом
                               \ ( Bl - константа со значением 32 )
   Dup >ASCIIz                 \ Перевести в формат ASCIIz,
                               \ сохранив адрес строки на стеке
   ReadOnly FOpen              \ Открыть файл для чтения
   IfNot                       \ Ошибка при открытии файла
                               \ ( Код ошибки - в переменной ERRNO )
      ." \r\nCannot open source file"
      ErrQuit                  \ Выход из программы
   Then
   Handle !                    \ Запомним описатель
   Begin
      \ Читать BufSize байт из файла с описателем,
      \ хранящимся в переменной Handle
      \ в память по адресу CodeSegment:Buffer
      Handle @ Buffer CodeSegment BufSize FRead
      IfNot                    \ Ошибка при чтении из файла
         ." \r\nSource file read error"
         ErrQuit               \ Выход из программы
      Then
      Dup >r                   \ Запомним реальную длину прочитанного
                               \ блока на стеке возвратов
      If                       \ Прочли больше нуля байт ?
         \ Писать количество прочтенных байт из
         \ памяти по адресу CodeSegment:Buffer
         \ в файл с описателем StdOut
         StdOut Buffer CodeSegment r@ FWrite
         2Drop                 \ Не анализируем флаг ошибки и
                               \ количество реально записанных байт
                               \ Ошибки быть не могло
      Then
      r>                       \ Восстановим длину прочитанного блока
                               \ со стека возвратов
      BufSize <                \ Меньше размера буфера ?
   Until                       \ Да - конец файла, нет - продолжим
   Handle @ FClose             \ Закроем исходный файл
   Drop                        \ Ошибки при закрытии файла, в
                               \ который не было записи - нас не
                               \ интересуют
;
False Messages !               \ Сообщения об ошибках -
                               \ в выполняемый файл не включать
\ Создадим выполняемый файл type2.com
\ Главной программой считается последнее определенное слово
\ в нашем случае - MAIN
\ Информацию о распределении памяти в выполняемом
\ модуле - в текстовый файл type2.map
Build type2.com type2.map
( *********************************************************************** )

   8. Утилита VLIST.COM

   Используя утилиту VLIST.COM, Вы сможете ознакомиться с  содержимым  любого
библиотечного Форт-модуля, собственно модуля FORTH.COM, а также любой  выпол-
няемой Форт-программы, если, конечно, она не сжата упаковщиком PKLITE,  и  ее
автор позаботился о включении в ее словарь каких-либо Форт-слов.
   Если Вы хотите использовать утилиту VLIST.COM, для того,  чтобы  выяснить,
например, как точно пишется данное  Форт-слово,  приблизительно  "прикинуть",
сколько оно займет памяти, а также узнать некоторые подробности о заинтересо-
вавшем Вас слове - не сжимайте файл FORTH.COM программой PKLITE или аналогич-
ной ей.
   Обращение к утилите: VLIST <имя-модуля-или-программы>
   Возможен запуск программы VLIST с ключами:
      /P - для задержки после вывода на экран очередной  страницы  информации
           до нажатия клавиши
      /W - для получения менее полной  информации  о  содержимом  модуля  или
           программы - тольно имена слов
      /H - для получения краткой подсказки. Эта опция действует, если обраще-
           ние к утилите произведено некорректно

   9. Сообщения транслятора об ошибках

*****************************************************************************
Код  Сообщение
*****************************************************************************
 0   Попытка деления на 0 или извлечения корня из отрицательного числа
 1   Неверное число или синтаксическая ошибка
 2   Исчерпание стека. Попытка воспользоваться данными, которых нет на стеке
 3   Непарное использование управляющих конструкций
 4   Сбой стека. Вызван неумелым вмешательством в процесс компиляции
     или непарными управляющими конструкциями
 5   Слово требует режима исполнения
 6   Слово требует режима компиляции
 7   Во входном потоке нет слова для определения
 8   Переполнеие. Число не помещается в 4 байта
 9   Не хватает памяти
10   Во входном потоке отсутствует имя файла
11   Код испорчен. Самая коварная ошибка. Возможно, Вы не установили
     необходимый атрибут у слова с операндом.
12   Диск переполнен
13   Отсутствует десятичная (двоичная, троичная, девятеричная) точка
14   Ошибка чтения библиотечного модуля
15   Неверный формат библиотечного модуля
16   Модуль создавался несовместимой версией компилятора
17   Попытка создать модуль, не содержащий определений слов
18   Неверное использование числа двойной длины
19   Переименование невозможно. Слова разной длины
20   Сбой компиляции
21   Файл не найден
22   Вы используете испорченный компилятор
*****************************************************************************

   10 . Список литературы

   1) С.Н.Баранов, Н.Р.Ноздрунов.  Язык Форт и его реализации.
      Санкт-Петербург "Машиностроение" 1988
   2) Ф.Ю.Бураго, В.А.Кириллин, И.В.Романовский. Язык Форт для
      микропроцессоров. Санкт-Петербург 1989
   3) К.Таунсенд, Д.Фохт. Проектирование и програмная реализация
      экспертных систем на персональных ЭВМ.
      Москва "Финансы и статистика" 1990
   4) Ю.А.Семенов. Программирование на языке Форт.
      Москва "Радио и связь" 1991
   5) Л.Броуди. Начальный курс программирования на языке Форт.
      Москва "Финансы и статистика" 1990

                          █▀▀▀▀▀▀▀▀▀▀▀▀▀▀█
                          █ Желаю успеха █
                          █▄▄▄▄▄▄▄▄▄▄▄▄▄▄█
