{*******************************MULTI-EDIT MACRO*************
 *Назначение  : Простая программа управления БАЗОЙ ДАННЫХ.
 *----------------------
 *Формат файла: Три разных куска :Комментарий, Заголовок и собственно БАЗА.
 *   - КОММЕНТАРИЙ - строка начинающаяся со *, количество - не ограничено
 *   - ЗАГОЛОВОК : по одной строке на каждое поле,первое поле - КЛЮЧ записи
 *       Описание полей - структура базы;
 *          /DBF= уникальный идентификатор поля
 *          /TP=  тип поля(0-умолчание) : 0 - символьное
 *                                        1 - целое
 *                                        2 - REAL (? как симв.?)
 *                                        3 - целое - меню         *** ISTR
 *                                        4 - целое HEX
 *                                        5 - BOOLEAN - TRUE/FALSE *** ISTR
 *          /T=   имя поля (человеческое название)
 *          /W=   Видимая ширина поля при вводе
 *          /KL=  Размер ключа в оглавлении (и уник. длина для ключа)
 *          /ML=  Максимальный размер поля при вводе
 *          /L=   Номер строки в BOX вводе поля (1-23)
 *                   ** рекомендуется располагать описания заголовков в порядке
 *                      возрастания строк в BOX (для удобства ввода)
 *          /C=   Номер колонки в BOX вводе поля(с учетом длины имени и поля)
 *          /DA=  разделитель - признак включить данное поле в оглавление
 *       *** В конце строки Заголовка могут присутствовать:(для ЗНАЮЩИХ DATA_IN):
 *          /ISTR=   Параметры для DATA_IN ввода данного поля
 *          /IINT=   Параметры для DATA_IN ввода данного поля
 *       Признаком окончания заголовка является строка ****START****
 *   - Далее следуют записи БАЗЫ.
 *                             --------------------
 *              !!! При вводе не используйте скобки и знак / . !!!
 *                             --------------------
 *                    See PHONE.DB for a sample note card file.
 *                             --------------------
 *     (C) Copyright 1988 by American Cybernetics, Inc. 
 *     (C) Copyright 1990 Корзун Е.Г.   МОСКВА  924-52-73
 *                                                v.m. от  15.03.90 16:30 К.Е.Г.
 *                             --------------------
 *                    Для вызова из DOS - P.BAT ; параметр -имя файла
 *                             --------------------
******************************************************************************}

$macro db;
   Def_Int(Tmp_i, Old_Ins, Tmp_Ins, Key_Len, Count_DA);
   Def_Str(Tmp_s, Tmp_s1, Tmp_s2, SPACE);
   def_int( x, y, field_count, max_record_count, tp, old_id,
               record_count, Bad_record, jx, ix, need_rebuild, end_field );
   def_str( tstr[1000], tstr2, tstr3 );
   max_record_count := 0;
   field_count := 0;
   Count_DA := 0;

   Tmp_Ins := Insert_Mode;
   Old_Ins := Insert_Mode;
   refresh := false;
   old_id := window_id;
   create_window;
   Insert_Mode := TRUE ;               {Это то,что нужно для правильной работы}

                                       { Вычисление места для  BOX            }
   x := parse_int('/X=', mparm_str);
   y := parse_int('/Y=', mparm_str);
   if x <= 0 then
      x := 2;
   end;
   if y <= 0 then
      y := 3;
   end;

                                       { Имя файла-базы из параметра          }
                                       { по умолчанию - ME_PATH PHONE.DB      }
   ix := 0;
   tstr := parse_str('/F=', mparm_str);
   If (tstr = '') Then
      tstr := 'PHONE';
   End;
   if get_path(tstr) = '' then
      tstr := me_path + tstr;
   end;
   if get_extension(tstr) = '' then
      tstr := tstr + '.DB';
   end;
 RETRY:
   If NOT(File_Exists(tstr)) then
      ++ix;
      If (ix = 1) Then                 { Нет об"явленного в PARM имени        }
         run_macro('USERIN^VERIFY /C=2/L=6'
               + '/T=Нет справочника=' + CAPS(TSTR)
               + ',Продолжить с ' + CAPS(me_path) + 'PHONE.DB' + ' ?');
         If (Return_Int) Then
            tstr := CAPS(me_path) + 'PHONE.DB';
            goto RETRY;                { Попытаемся загрузить телефонный спр. }
         Else
            goto Exit;
         End;
      End;
      Set_Global_Int('K_MESSTR',8);
      Set_Global_Str('K_IDENT',' K_DB.SRC 15.03.90 16:31');
      Set_Global_Str('K_MESSAGE','Нет файла=' + tstr);
      Run_Macro('K_Edit_4^K_MESSAG ');
      goto exit;
   end;                                { ---- конец выбора файла - базы ---   }
   load_file( tstr );

   need_rebuild := true;               { Признак - переделать GLOBAL-список   }
   call build_fields;                  { Сформировать список полей-реквизитов }

   SPACE := '';
   jx := 0;
   While (jx < Key_Len) Do             { В Key_Len - MAX значимая длина ключа }
      ++jx;
      SPACE := SPACE + ' ';            { Заполнитель для коротких ключей      }
   End;

   max_record_count := 0;
   Bad_record   := 0;
                                       { Попытка восстановить посл.установку  }
   return_str := global_str( 'DB#' + truncate_path(file_name));

 main_loop:
   call build_record_list;             { Высветить оглавление - список        }

   if return_int = 0 then              { Был нажат <ESC> В оглавлении         }
      goto exit;
   end;

   if return_int = 1 then              { Высветка выбранной записи            }
      call find_data;                  { Поиск (по Return_Str)                }
      call display_fields;             { Корректировка и занесение в базу     }
      goto main_loop;
   end;


   if return_int = 2 then              { Создание новой записи                }
                                       { В Return_Str - введенный ключ        }
      tstr := '√' + parse_str('/DBF=', { по нему - формирование записи        }
                            global_str('IPARM_1')) + '=' + return_str;
      call insert_rec;                 { Занесение в алфавитном порядке КЛЮЧА }
      need_rebuild := true;
      call display_fields;             { Дозапись реквизитов и перезапись     }
      goto main_loop;
   end;


   if return_int = 3 then              { Удаление заказанной записи           }
      call find_data;                  { Поиск (по Return_Str)                }
      del_line;
      need_rebuild := true;
      goto main_loop;
   end;

   goto main_loop;

{------------------------- Подпрограммы --------------------------------------}

                                       { Занесение заголовка файла - базы     }
                                       { в DATA_IN GLOBAL                     }
build_fields:                          { В IPARM_. - содержание DEF полей     }
   field_count := 0;                   { Количество строк заголовка           }
   tof;
   jx := 0;                            { Под MAX номер строки BOX             }
   Count_DA := 0;                      { Под количество доп. реквизитов       }

   tstr := get_line;
   While (XPOS('*',TSTR,1)=1) AND NOT(At_Eof) Do { Пропустить Комментарий     }
      Down;
      tstr := get_line;
   End;

   Key_Len := Parse_Int('/KL=', tstr); { Ключ - первая запись ЗАГОЛОВКА       }
   If (Key_len =0) Then                { Длина ключа не указна явно           }
      Key_Len := Parse_Int('/W=', tstr);         { используем всю длину       }
   End;
   While NOT((XPOS( '****START****',tstr,1) = 1) or (At_Eof)) Do
      ++field_count;
      set_global_str('IPARM_' + str(field_count), tstr);

      If (jx < Parse_Int('/L=', tstr) ) Then     { MAX номер строки BOX       }
         jx := Parse_Int('/L=', tstr);
      End;
                                       { Если в HEADER есть эти поля          }
      ix := XPOS('/ISTR=', tstr,1);
      If (ix > 0) Then
         set_global_str('ISTR_' + str(field_count),
                        STR_DEL(tstr,1,ix+5));
      End;
      ix := XPOS('/IINT=', tstr,1);
      If (ix > 0) Then
         set_global_str('IINT_' + str(field_count),
                        STR_DEL(tstr,1,ix+5));
      End;
      down;
      tstr := get_line;
      If (XPOS('/DA=', tstr,1)) Then   { Не для ключевых полей                }
         ++Count_DA;                   { Счет дополнительных полей            }
                                       { ИМЯ этого реквизита  в записи БАЗЫ   }
         Set_Global_Str('K_N_DA' + str(Count_DA), Parse_Str('/DBF=', tstr));
                                       { Значение разделителя                 }
         Set_Global_Str('K_T_DA' + str(Count_DA), Parse_Str('/DA=', tstr));
      End;
   End;

   end_field := c_line;                { Последняя  строка в заголовке        }

   if field_count <= 0 then            { Нет заголовка - уходим               }
      goto exit;
   end;
   down;
   ++jx;                               { На строку ниже, чем МАХ строка BOX   }
   Set_Global_Str( 'IHELP1',           { HELP для DATA_IN - выбор поля        }
      '/H=═════ <ESC>-окончание ввода ══════/C='+STR(x+19) + '/L=' + STR(jx));
   Set_Global_Str( 'IHELP2',           { HELP для DATA_IN - коррекция поля    }
      '/H= <ESC>-отмена, ENTER-принять поле /C='+STR(x+19) + '/L=' + STR(jx));
   ret;
 {----------------------------------------------------------------------}
                                       { Если необходимо, то создать и        }
build_record_list:                     { Высветить список = КЛЮЧ + доп. поля  }
   if need_rebuild then                { Переформирование набора GLOBAL       }
      goto_col(1);
      goto_line(end_field + 1);        { Место начала "значений" в файле      }
                                       { Имя реквизита - ключа                }
      tstr   := parse_str('/DBF=', global_str('IPARM_1') );
      Bad_record   := 0;
      record_count := 0;
      while not(at_eof) do
         Tmp_s := Get_Line;            { Формирование записи - оглавления     }
         Tmp_s1 := parse_str('√' + tstr + '=', Tmp_s);
         If (SVL(Tmp_s1)) Then         { А законная ли запись ?               }
            Tmp_s1 := Copy(Tmp_s1 + SPACE,1,Key_Len);
            ++record_count;
            ix := 0;
            While (ix < Count_DA) Do   { Добавление доп.полей с разделителями }
               ++ix;
               Tmp_s2 := Parse_Str('√' +Global_Str('K_N_DA'+ str(ix)) 
                                    + '=',Tmp_s);
               If (SVL(Tmp_S2)) Then   { У этого поля есть значение ?         }
                  Tmp_s1 := Tmp_s1 + Global_Str('K_T_DA' + str(ix)) + Tmp_s2;
               End;
            End;                       { ----- of добавления полей -------    }
            Tmp_s := Copy( Tmp_s1,1,Screen_Width);
            set_global_str('@@' + str(record_count), Tmp_S );
         Else                          { В записи нет ключа ?                 }
            ++Bad_record;
         End;                          { -- If .. Else ..                     }
         down;
      end;
      need_rebuild := false;
   end;
   if record_count > max_record_count then
      max_record_count := record_count;{ Нужно запомнить для чистки GLOBAL @@.}
   end;

   Tmp_i := 1;                         { подготовка строки по "умолчанию"     }
   While (Tmp_i <= record_count) Do
      If (POS(Return_Str,Global_Str('@@'+ STR(Tmp_i))) = 1) Then
         Return_Str := Global_Str('@@'+ STR(Tmp_i));
         Tmp_i := record_count ;
      End;
      ++Tmp_i;
   End;

   Insert_Mode := Tmp_Ins ;            { Восстановить то, что было при ВВОДЕ  }
                                       { Собственно высветка окна-оглавления  }
   run_macro('USERIN^DVMENU /P=@@/X=' + str(x) + '/Y=' + str(y)
         + '/CT=Введите НОВОЕ значение для поля: '
                  + parse_str('/T=', global_str('IPARM_1') )
         + '/W=70/NR=1/C=1/D=1/EC=1/ED=1/S=' + return_str
         + '/T=' + CAPS(file_name)
         + '   Всего записей = ' + STR(record_count)
         + '/H=XX/B=1/K=1/I=%/#=' + str(record_count));

   Tmp_Ins := Insert_Mode;             { Режим, установленный при ВВОДЕ       }
   Insert_Mode := TRUE ;               {Это то,что нужно для правильной работы}

   Tmp_s := COPY(Return_Str ,1,Key_Len);         {Выделение КЛЮЧА в Return_Str}
   While (Str_Char(Tmp_s,SVL(Tmp_s)) = ' ' ) Do  { Срезание хвостовых пробелов}
      Tmp_s := STR_DEL(Tmp_s,SVL(Tmp_s) ,1);
   End;
   Return_Str := Tmp_s;
   ret;
  {----------------------------------------------------------------------}

find_data:                             { Поиск указанной записи, ключ         }
                                       { которой в Return_Str,описание-1 поле }
   goto_line(end_field + 1);           { Встать на начало базы                }
   if search_fwd('√' + parse_str('/DBF=', global_str('IPARM_1'))
                  + '=' + return_str, 0) then
   else
      eof;
      Down;                            { На всякий случай                     }
   end;
   ret;
  {----------------------------------------------------------------------}
display_fields:                        { Корректировка/Ввод записи            }
   call get_data;                      { Подготовка полей для ввода/коррект.  }
   Insert_Mode := Tmp_Ins ;            { Восстановить то, что было при ВВОДЕ  }
   run_macro('USERIN^DATA_IN /X=' + str(x) + '/Y=' + str(y)
                        + '/NC=1/'
                        + '/T=' + CAPS(file_name)
                        + '   Всего записей = ' + STR(record_count)
                        + '/A=2' + '/#=' + str(field_count));
   Tmp_Ins := Insert_Mode;             { Режим, установленный при ВВОДЕ       }
   Insert_Mode := TRUE ;               {Это то,что нужно для правильной работы}
   call set_data;                      { Занесение полей в запись             }
   return_str := global_str('ISTR_1'); { Ключ для установки на текущую запись }
   ret;
  {----------------------------------------------------------------------}
get_data:                              { Выборка полей из текущей записи      }
   jx := 0;                            { занесение их в GLOBAL для DATA_IN    }
   tstr := get_line;
   while jx < field_count do
      ++jx;
      tp := parse_int('/TP=', global_str('IPARM_' + str(jx)));
      if (tp = 0) or (tp = 8) then
         set_global_str('ISTR_' + str(jx),
            parse_str('√' + parse_str('/DBF=', global_str('IPARM_' + str(jx)))
                     + '=', tstr ));
      else
         if (tp = 1) or (tp = 3) or (tp = 4) or (tp = 5) or (tp = 7) then
            set_global_int('IINT_' + str(jx),
               parse_int('√' + parse_str('/DBF=', global_str('IPARM_' + str(jx)))
                     + '=', tstr ));
         end;
      end;
   end;
   ret;
  {----------------------------------------------------------------------}

set_data:                              { Выборка полей из глобальных после    }
   jx := 0;                            { DATA_IN и занесение их в файл        }
   tstr := '';
   while jx < field_count do
      ++jx;
      tp := parse_int('/TP=', global_str('IPARM_' + str(jx)));
      if (tp = 0) or (tp = 8) then
         if global_str('ISTR_' + str(jx)) <> '' then
            tstr := tstr + '√' + parse_str('/DBF=', global_str('IPARM_' + str(jx))) + '=' +
                     global_str('ISTR_' + str(jx));
         end;
      end;
      if (tp = 1) or (tp = 3) or (tp = 4) or (tp = 5) or (tp = 7) then
         if global_int('IINT_' + str(jx)) <> 0 then
            tstr := tstr + '√' + parse_str('/DBF=', global_str('IPARM_' + str(jx))) + '=' +
                     str(global_int('IINT_' + str(jx)));
         end;
      end;
   end;
   if (tstr <> get_line) then          { А было-ли какое-нибудь изменение ?   }
      del_line;                        { Удалить старое значение              }
      call insert_rec;                 { Занесение в алфавитном порядке       }
   end;
   ret;

 {----------------------------------------------------------------------}
insert_rec:                            { Занесение в алфавитном порядке       }
      goto_line(end_field+1);          { К началу базы                        }
      tstr2 := '√' + parse_str('/DBF=', global_str('IPARM_1')) + '=';
      tstr3 := parse_str(tstr2,tstr);
      goto_col(1);
      while not(at_eof) and (parse_str(tstr2,get_line) < tstr3) do
         down;
      end;
      if not(at_eof) then
         cr;
         up;
      end;
      put_line(tstr);
      need_rebuild := true;
   ret;
 { -------------------------------------------------------------------- }
{----------------------------------------------------------------------}
 exit:
   If (Bad_record) Then
      Set_Global_Int('K_MESSTR',8);
      Set_Global_Str('K_IDENT', CAPS(File_Name));
      Set_Global_Str('K_MESSAGE','-' + STR(Bad_Record)
                     + ' Записей без ключа ?');
      Run_Macro('K_Edit_4^K_MESSAG ');
   End;                                { -- If ..                             }
   if file_changed then                { Были изменения - сохраним            }
      save_file;
   end;
                                       { Запомним последнюю установку         }
   set_global_str( 'DB#' + truncate_path(file_name), return_str );
                                       { Зачистка globals из памяти           }
   jx := 0;
   while jx <= max_record_count do     { - 1 - высветки оглавления            }
      ++jx;
      set_global_str('@@' + str(jx), '');
   end;
   jx := 0;
   while jx < field_count do           { - 2 - описания полей  ЗАГОЛОВКА      }
      ++jx;
      set_global_str('IPARM_' + str(jx), '');
      set_global_str('ISTR_' + str(jx), '');
      set_global_int('IINT_' + str(jx), 0);
   end;
   ix := 0;
   While (ix < Count_DA) Do            { - 3 - описания доп. полей оглавления }
      ++ix;
      Set_Global_Str('K_N_DA'+ str(ix) ,'');
      Set_Global_Str('K_T_DA'+ str(ix) ,'');
   End;                                { ----- of зачистки Global -------     }
   Insert_Mode := Old_Ins ;            { Восстановить то, что было на входе   }

   delete_window;
   if switch_win_id(old_id) then end;  { Возврат в "вызывавшее" окно          }
end_macro;                             { K_DB  - DB.MAC                       }