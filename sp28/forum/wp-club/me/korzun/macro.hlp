* MULTI-EDIT 4.0 MACRO LANGUAGE REFERENCE GUIDE
                            ┌───────────────────┐
                            │  @INTRO[!A. ]INTRODUCTION  │
 ┌──────────────────────────┴─────────┬─────────┴───────────────────────────┐
 │@MACROCOMPILE[!B. ]КОМПИЛЯЦИЯ  МАКРО                │ @REALEXP[!M. ]ДЕЙСТВИТЕЛЬНЫЕ ВЫРАЖЕНИЯ         │
 │@MACROSTRUCT[!C. ]СТРУКТУРА МАКРОСОВ               │ @UNCONDBRANCH[!N. ]БЕЗУСЛОВНЫЕ ПЕРЕХОДЫ             │
 │@MACROEXEC[!D. ]ВЫПОЛНЕНИЕ МАКРОСОВ              │ @CONDBRANCH[!O. ]УСЛОВНЫЕ ПЕРЕХОДЫ                │
 │@LABELS[!E. ]МЕТКИ                            │ @PARMPASS[!P. ]ПЕРЕДАЧА ПАРАМЕТРОВ И РЕЗУЛЬТАТА │
 │@COMMENTS[!F. ]КОММЕНТАРИИ                      │ @KEYSYNTAX[!Q. ]СИНТАКСИС КОДОВ КЛАВИШ           │
 │@DATATYPES[!G. ]ТИПЫ ДАННЫХ                      │ @PROCS[!R. ]ПРОЦЕДУРЫ И ФУНКЦИИ              │
 │@LOCALVARS[!H. ]ОПРЕДЕЛЕНИЕ ЛОКАЛЬНЫХ ПЕРЕМЕННЫХ │ @SYSVAR[!S. ]СИСТЕМНЫЕ ПЕРЕМЕННЫЕ             │
 │@CONSTANTS[!I. ]КОНСТАНТЫ                        │ @ERRORS[!T. ]ОШИБКИ МАНИПУЛИРОВАНИЯ           │
 │@DEFGLOBAL[!J. ]ОПРЕДЕЛЕНИЕ ГЛОБАЛЬНЫХ ПЕРЕМЕННЫХ│ @COMPERRORS[!U. ]ОШИБКИ КОМПИЛЯЦИИ                │
 │@INTEXP[!K. ]ЦЕЛЫЕ ВЫРАЖЕНИЯ                  │ @RUNERRORS[!V. ]ОШИБКИ ВЫПОЛНЕНИЯ                │
 │@STREXP[!L. ]СТРОКОВЫЕ ВЫРАЖЕНИЯ              │                                     │
 └───────────┬────────────────────────┴─────────────────────────┬───────────┘
             │ @FUNCTIONS[!1. ]ФУНКЦИИ И ОПЕРАЦИИ ПО КАТЕГОРИЯМ              │
             │ @USERIN.HLP^*[!2. ]ИНТЕРФЕЙС ПОЛЬЗОВАТЕЛЯ МАКРО-СИСТЕМЫ          │
             │ @MAC_CMND.HLP^*[!3. ] ^B**^b Полный список КОМАНД ME 4.00a и т.д. ^B**^b   │
             └──────────────────┬───────────────────┬───────────┘
				│ @INDEX[!X. ]ИНДЕКС         │
				│ @PEREV[!Z. ]О ПЕРЕВОДЕ     │
				└───────────────────┘

PEREV О ПЕРЕВОДЕ
Перевод  справочного  файла  MACRO.HLP  выполнил  Найдек Андрей (293-68-14),
подготовку текста Коротченко Людмила и Власюк Михаил (220-56-37).  В  данном
тексте отсутствует ссылка СТРОКИ в разделе СТРОКОВЫЕ ВЫРАЖЕНИЯ (не найдена и
в   оригинальном   тексте).  Продолжается  работа  по  переводу   ИНТЕРФЕЙСА
ПОЛЬЗОВАТЕЛЯ МАКРО-СИСТЕМЫ (файл USERIN.HLP). Ваши  замечания и  предложения
по улучшению  читаемости данного    текста     сообщайте    по     указанным
телефонам.  Дата  последнего редактирования 13.04.90.
^B**^b Ряд исправлений , а также
   Дополнения по кодам команд ME 4.00a внес Корзун Е.Г. 18.09.90 14:09
FUNCTIONS ФУНКЦИИ И ОПЕРАЦИИ ПО КАТЕГОРИЯМ

   ╔═════════════════════════════════╤═══════════════════════════════════╗
   ║ @BLOCKOP[ОПЕРАЦИИ С БЛОКАМИ              ]│ @MISCOP[ДРУГИЕ ОПЕРАЦИИ                   ]║
   ║ @COLORS[ЦВЕТА                           ]│ @TABOP[ТАБУЛЯЦИЯ И ОТСТУПЫ               ]║
   ║ @CURSOROP[ОПЕРАЦИИ ПОЗИЦИОНИРОВАНИЯ КУРСОР]│ @SCREENOP[ОПЕРАЦИИ С ЭКРАНОМ                ]║
   ║ @DISPLAYCONFIG[КОНФИГУРАЦИЯ ДИСПЛЕЯ            ]│ @SEARCHOP[ОПЕРАЦИИ ПОИСКА И ЗАМЕНЫ          ]║
   ║ @DOSSHELLOP[ОПЕРАЦИИ СВЯЗИ С ДОС            ]│ @STROP[ОПЕРАЦИИ СО СТРОКАМИ              ]║
   ║ @FILEOP[ОПЕРАЦИИ С ФАЙЛАМИ              ]│ @TABOP[ТАБУЛЯЦИЯ И ОТСТУПЫ               ]║
   ║ @FUNCLABELOP[ОПЕРАЦИИ С МЕТКАМИ ФУНКЦИОНАЛЬНЫ]│ @TEXTOP[ОПЕРАЦИИ С ТЕКСТОМ                ]║
   ║ @KEYOP[НАЗНАЧЕНИЯ КЛАВИШ               ]│ @UNDO[ОПЕРАЦИИ ВОССТАНОВЛЕНИЯ (ОТКАТ)   ]║
   ║ @KEYMACOP[МАКРОСЫ НАЖАТИЯ КЛАВИШ          ]│ @USEROP[ПОЛЬЗОВАТЕЛЬСКИЙ ВВОД И ИНТЕРФЕЙС ]║
   ║ @MACHOP[СВЯЗЬ НА МАШИННОМ УРОВНЕ        ]│ @WINOP[ОПЕРАЦИИ С ОКНАМИ                 ]║
   ║ @MACROOP[MAКРООПЕРАЦИИ                   ]│ @WPOP[ОПЕРАЦИИ ОБРАБОТКИ СЛОВ           ]║
   ╚═════════════════════════════════╧═══════════════════════════════════╝

INTRO Введение
Макроязык   редактора  Multi-Edit  представляет  собой  компилируемый   язык
программирования  схожий  по  синтаксису   с  Паскалем  или  Модулой-2.   Он
позволяет  пользователю   настраивать  и   добавлять  сложные,   специальные
функции  в  Multi-Edit.  Хотя  макроязык  Multi-Edit  не  такой  полный  как
полностью структурированные языки Си, Паскаль или Модула-2, он имеет:

        o       конструкции IF THEN, и WHILE DO.
        o       переменные типов: строковые, целые, символьные и с
                плавающей точкой.
        o       локальные и глобальные переменные определяемые
                пользователем.
        o       передачу параметров и возвращение результатов.
        o       расчет сложных вложенных выражений.
        o       оверлейные возможности.
        o       полный доступ ко всем функциям Мulti-Edit.
        o       легкий доступ к экрану и клавиатуре.
MACROSTRUCT СТРУКТУРА МАКРОСОВ

Исходный   макро-файл   может   содержать   любое   число  макросов.  Каждый
макрос определяется следующим образом:

        $MACRO имя [TO ключ] [FROM режим] [атрибуты];
              <тело макроса>
        END_MACRO;

Имя макроса может содержать до 16 символов.

Параметры   в   квадратных   скобках   ('[]')   являются    необязательными.
Параметр 'TO   ключ'   определяет   клавиши,   с   которыми   макрос   будет
связан.   Параметр   "FROM    режим"   определяет    режим,   из    которого
макрос   будет вызываться.  Допустимые    режимы:  EDIT,   DOS_SHELL,   TERM
и  ALL.   Если параметр FROM не определен, то подразумевается режим EDIT.
^B**^b В версии 4.00a  (не Professional) режим TERM не воспринимается.

Атрибутами  может   являться  любая   комбинация  из   "TRANS",  "DUMP"    и
"PERM".

Атрибут  "TRANS"  определяет  нерезидентный  макрос.   Он загружается с диска
только  во  время  выполнения.   По  завершению  работы  нерезидентный макрос
удаляется из памяти до следующего вызова (в памяти остается только заголовок).
Это позволяет загрузить много макросов, занимая малый объем памяти.

Атрибут  "DUMP"  определяет  макрос,  который  должен  быть полностью удален
   из памяти после его выполнения.
Атрибут  "PERM"   определяет  макрос,   который  не   может  быть   загружен
   другим макросом с тем же именем.

^B**^b Существуют еще и не описанные: "HIDDEN" , "TRANS2" и "NOSWAP".

ЗАМЕЧАНИЯ:
        A. Макро-язык Multi-Edit не чувствителен к регистру букв.
        B. Расширение имени файла с исходным текстом макроса .SCR.
        C. Расширение имени файла с компилированным макросом .MAC.

Следующий  пример  макроса   будет  подсчитывать  количество   отсутствующих
фигурных скобок { и } в исходном файле на языке Си:

        $MACRO Bracecnt TO <AltB> FROM Edit TRANS;
           DEF_INT( count );                  { Объявление целой
                                                переменной}
           Tof;                               { Идти в начало файла }
           Count := 0;                        { Начальное значениe
                                                переменной}
           WHILE Search_Fwd( '[{}]', 0 ) DO   { Поиск  '{' или '}' }
             IF Cur_Char = '{' THEN           { Определение найденного
                                                символа}
               ++Count := Count;              { Увеличение счетчика,
                                                если символ '{' }
                   ELSE
               --Count;                       { Уменьшение счетчика,
                                                если символ '}' }
             END;
           END;
                                              { Показать результат }
           Make_Message( 'Excess { count = ' + Str( Count ) );
        END_MACRO;

Как  видно,  исходный  макрофайл  может  содержать  любое  число   макросов.
При  компиляции  все   макросы  исходного  файла   будут  включены  в   один
.МАС-файл.   Имя   создамнного   МАС-файла   совпадает   с   именем  первого
макроса  в  файле.  Если  вы  хотите  присвоить  МАС-файлу  другое  имя  или
компилировать   его   в   заданную   директорию,   вы   должны  использовать
команду  $MACRO_FILE  перед  тем  как  определить  любой  макрос  в исходном
файле.

        ПРИМЕР:

                $MACRO_FILE \PROJ1\SOURCE\PASCAL;

                {Паскаль - смещение макрос}
                $MACRO Pas_Ind;
                   <тело>...
                END_MACRO;

                {Паскаль BEGIN/END - проверка макрос}
                $MACRO Pas_Find;
                   <тело>...
                END_MACRO;

Замечания: длина строки-константы в макрофайле ограничена 254 символами.

MACROCOMPILE КОМПИЛЯЦИЯ  МАКРО

Макросы  компилируются  с   помощью  макрокомпилятора  программ   MEMAC.EXE,
полностью  интегрируемого  с  редактора  Multi-Edit  командой  COMPILE   (по
умолчанию - это <CtrlF8> или с использованием Support-меню).

После  компиляции   макросов  их   выполняемый  (в   среде  Multi-Edit)    код
автоматически сохраняется на диске с именем первого макроса исходного файла  и
расширением  .MAC.   Для   изменения  имени  файла  (директория)   пользуйтесь
оператором $MACRO_FILE.  Если оператор MACRO_FILE не использовался,  .MAC-файл
будет записан в последней директории, где расположены файлы.

Также  вы  можете  компилировать  макросы  из  ДОСа.  Это  иногда необходимо
из-за  недостатка  памяти  компьютера.   Командная  строка  для   компиляции
имеет формат:

        MEMAC <имя файла> -P<путь> -D<отладка и макроимя>

Опция-Р  позволяет  вам  определить  директорию,  в  которую  будет  записан
результирующий  .MAC-файл.  Опция  отладки  -  D  будет  объяснена в разделе
"Ошибки выполнения".

        ПРИМЕР:

                MEMAC PASCAL -Pc:\me

Файл PASCAL.SCR будет компилироваться в C:\ME\PASCAL.MAC.

MACROEXEC ВЫПОЛНЕНИЕ МАКРОСОВ

Макрос может быть выполнен одним из следующих способов:

1.      Может быть вызвана функция RUN MACRO и введено полное имя макроса.

2.      Если   макрос  связан   с  какими-либо  клавишами макрос  может быть
        выполнен при  нажатии  этих  клавиш   (если  редактор  находится   в
	режиме, предусмотренном в макросе).

3.         Один  макрос  может  быть  вызван  из другого с помощью оператора
        RUN_MACRO.

4.         Макрос  может  быть  выполнен  автоматически  в  том случае, если
        Multi-Edit вызывался из ДОС с опцией /R. Например:

                        C:ME /R SETUP

        ЗАМЕЧАНИЕ: между опцией /R и именем макроса нужен пробел.

5.         При  запуске  Multi-Edit  ищется  файл  STARTUP.MAC  (сначала   в
        текущей   директории,   затем    в   директории   Multi-Edit)    для
        выполнения.  Файл   STARTUP.MAC  может   содержать  любые   команды,
        включая    загрузку    -     выполнение    макросов,     необходимые
        пользователю.

LABELS МЕТКИ

Метки  используются  для  обозначения  заданных  мест  в  тексте  программы.
Метка  -  это  строка   символов  из  набора  [a-z,A-Z,_,0-9]   максимальной
длины  в  20  символов,  оканчивающаяся  двоеточием.  При  ссылке  на  метку
двоеточие  отсутствует.   ЗАМЕЧАНИЕ:  метка  является  локальной  для   того
макроса,  в  котором  она  определена.  Различные  макросы,  объединенные  в
один исходный файл, могут иметь одинаковые метки.

        ПРИМЕР:

                $MACRO TEST_MAC;
                    {Зацикливание}
                    TEST_LABEL:
                       GOTO TEST_LABEL;
                END_MACRO;

COMMENTS КОММЕНТАРИИ

Комментарии заключаются в фигурные скобки и могут быть ^Bвложенными^b.

        ПРИМЕР:
                {Эта строка пропустится компилятором}

                {Это пример вложенных комментариев. }

  { 1 }                       {  Строки 2-4  - "работают"    }
  { 2 }            IF JX <> 0 THEN
  { 3 }                       {Если JX не равен 0 идти дальше}
  { 4 }               Call KILL_LINES;
  { 5 }                       {{ Из-за вложенности строки 6-8 не "работают" }
  { 6 }            ELSE
  { 7 }                       {Если JX = 0, то печатать oшибку}
  { 8 }               Make_Message( 'ERROR' );
  { 9 }                       { Строка 10 - уже не комментарий !  } }
  {10 }            END;
  {11 }

DATATYPES ТИПЫ ДАННЫХ

В макроязыке имеется 4 типа переменных:

                      ┌───────────┐
                      │@INTVARS[ целые     ]│
                      │@STRINGVARS[ строковые ]│
                      │@CHARVARS[ символьные]│
                      │@REALVARS[ действит. ]│
                      └───────────┘

Смешение   типов   переменных   (кроме   символьных   со   строковыми)    не
допускается.   Например,   попытка   присвоить   целое   значение  строковой
переменной приведет к ошибке компиляции.

ЗАМЕЧАНИЕ: @BOOLEANVARS[Двоичные переменные] можно моделировать.

INTVARS ЦЕЛЫЕ
Целые  переменные  всегда   занимают  32  бита (слово)  и  могут  принимать
любое значение из интервала от -2147483648 до 2147483647.

См.@LOCALVARS[ОПРЕДЕЛЕНИЕ ЛОКАЛЬНЫХ ПЕРЕМЕННЫХ] и @INTEXP[ЦЕЛЫЕ ВЫРАЖЕНИЯ] и
@BOOLEANVARS[ДВОИЧНЫЕ ПЕРЕМЕННЫЕ]
STRINGVARS СТРОКОВЫЕ
Строка  -  это  массив  8-битовых  символов.   Максимальная  длина  строки -
2048  символов.   При  ссылке  на  положение  символа  в  строке  (например,
при операции COPY) целое число 1 соответствует первому символу строки.

Если    строковая    переменная    имеет    более    2048    символов   (см.
@LOCALVARS[ОПРЕДЕЛЕНИЕ ЛОКАЛЬНЫХ ПЕРЕМЕННЫХ]), то она укорачивается.

Строковые переменные имеют внутренне представление:

        Слово 1( байты 1 и 2 ) содержит длину строки.
        Слово 2( байты 3 и 4 ) содержит максимальную длину.
        Байты 5..maкс_длина содержат текст строки.

См. также @STREXP[СТРОКОВЫЕ ВЫРАЖЕНИЯ] и @STROP[ОПЕРАЦИИ СО СТРОКАМИ].

CHARVARS СИМВОЛЬНЫЕ ВЫРАЖЕНИЯ
Один   символ   занимает   один   байт,   символьная   переменная  полностью
совместима  со   строковой,  она   рассматривается  как   строка   единичной
длины.  Если  вы  описали  строку  неединичной  длины  как  символьную,   то
будет  использоваться  только  первый  байт  строки.  Если вы описали пустую
строку   (строку   нулевой   длины)   как   символьную,   ей   присваивается
значение 0 (ASCII NULL).

См.также @LOCALVARS[ОПРЕДЕЛЕНИЕ ЛОКАЛЬНЫХ ПЕРЕМЕННЫХ] и
@STREXP[СТРОКОВЫЕ ВЫРАЖЕНИЯ]

REALVARS ДЕЙСТВИТЕЛЬНЫЕ ЧИСЛА
Диапазон   действительных   чисел:   от   1Е-38   до   1E+38   с  мантиссой,
включающей до 11 цифр.
^B**^b    Внутреннее представление - 6 байт:
      1   - порядок  ( 8 бит);
      2-6 - мантисса ( последний бит-знак числа).

См.также @LOCALVARS[ОПРЕДЕЛЕНИЕ ЛОКАЛЬНЫХ ПЕРЕМЕННЫХ] и
@REALEXP[ДЕЙСТВИТЕЛЬНЫЕ ВЫРАЖЕНИЯ]

BOOLEANVARS ДВОИЧНЫЕ ПЕРЕМЕННЫЕ
Переменных  чисто  двоичного  типа  (истина  или  ложь)  не   предусмотрено.
Вместо  истинных  или  ложных  выражений  и  переменных  используются  целые
результаты ненулевого или нулевого значения соответственно.

См.также @LOCALVARS[ОПРЕДЕЛЕНИЕ ЛОКАЛЬНЫХ ПЕРЕМЕННЫХ] и
@INTEXP[ЦЕЛЫЕ ВЫРАЖЕНИЯ]

LOCALVARS ОПРЕДЕЛЕНИЕ ЛОКАЛЬНЫХ ПЕРЕМЕННЫХ
Программист     на      макроязыке     может      определить      переменные
@STRINGVARS[СТРОКОВОГО],    @INTVARS[ЦЕЛОГО],    @CHARVARS[СИМВОЛЬНОГО]    и
@REALVARS[ДЕЙСТВИТЕЛЬНОГО]   типов    с   именами,    содержащими   до    20
символов.  Имена  переменных  формируются  по   тем  же  принципам,  что   и
метки.

Дейcтвие локальных переменных ограничивается только тем макросом, в
котором они определены.

Перед   использованием   переменных   их   необходимо   описать.   Если   вы
попытаетесь  использовать   переменную  без   предварительного   объявления,
это приведет к ошибке компиляции.

Переменные объявляются операторами:

                DEF_STR( имя_пер1, имя_nер2, ... );

                DEF_INT( имя_nер1, имя_nер2, ... );

                DEF_CHAR( имя_nер1, имя_nер2, ... );

                DEF_REAL( имя_nер1, имя_nер2, ... );

ОПИСАНИЕ СТРОКОВЫХ ПЕРЕМЕННЫХ

Описание  строковой  переменной  может  содержать  необязательный   параметр
длины в виде:

	        DEF_STR( имя_nер1[длина], имя_nер2[длина], ... );

Длина  строковой  переменной  может  быть  от  1  до  2048.  Если  длина  не
задана, то подразумевается 254.

ПРИМЕР:

                DEF_STR( Test_String,
                         Output_String[20],
                         Input_String[1000]
                        );
                DEF_INT( BCount );
                DEF_CHAR( Char1, Char2, Code);
                DEF_REAL( RX, RY );

PROCS ПРОЦЕДУРЫ И ФУНКЦИИ

Процедуры только выполняются и не возвращают никаких результатов.

        ПРИМЕР:    Create_Window;  {Процедура создания окна}
                               IF Error_Level <> 0 then
                      Run_Macro('MEERROR');
                    END;

Функции  возвращают  результаты,  но  не  могут  выполняться  самостоятельно
(в отличие от процедур).

        EXAMPLE:      {Switch to Window_Id 1 if it exists}
                    IF Switch_Win_Id( 1 ) THEN
                      Goto Do_More;
                    ELSE
                      Goto Exit;
                    END;

                    JX := Window_Id;    {Store the current window id}

См.также @SYSVAR[СИСТЕМНЫЕ ПЕРЕМЕННЫЕ].

SYSVAR СИСТЕМНЫЕ ПЕРЕМЕННЫЕ
Системные   переменные,   как   и    локальные   переменные,   могут    быть
изменяемыми.  Однако,   в  отличие   от  локальных   переменных,   системные
переменные могут непосредственно осуществлять операции.

Системные  переменные   ^Bне  могут   использоваться^b  в   роли  параметров   в
процедурах и функциях.

См.также @LOCALVARS[ОПРЕДЕЛЕНИЕ ЛОКАЛЬНЫХ ПЕРЕМЕННЫХ],
@PROCS[ПРОЦЕДУРЫ И ФУНКЦИИ] и @DATATYPES[ТИПЫ ДАННЫХ]

CONSTANTS КОНСТАНТЫ
Целые константы вводятся в десятичном формате.

        ПРИМЕР:        Test_Integer := 27;
                        IF Test_Integer = -346 THEN
                           Test_Integer := 346;
                        END;

Шестнадцатиричным    константам    предшествует     знак    доллара     '$'.
Максимальное число цифр в шестнадцатиричных константах - 4.

Действительные  константы  вводятся  в  десятичном  формате,  причем слева и
справа от десятичнй точки должно быть хотя бы по одному символу.
Допускается запись с ^Bпорядком^b , но без знака порядка.

        ПРИМЕР:        Test_Real := 123.0;
                        If Test_Real = 0.2343 THEN
                           Test_Real := 9.0134;
                           Test_Real := Test_Real * 1.03e10 ;
                        END;

        ПРИМЕР:        Test_Integer := $A9F7;

Строковые константы должны заключаться в одиночные кавычки.

        ПРИМЕР:        'Это строковая константа'

Любой  ASCII-  символ  может  быть  введен  в  строку, используя символ '|'.
Это  необходимо   для  ввода   непечатаемых  или   управляющих  символов   в
строку.

        ПРИМЕРЫ:
                        '|13' будет переводить строку (возвращать
                              каретку)
                        '|12|10' будет прогонять страницу и переводить
                                 строку
                        '||' будет символом '|' .

Две одиночные кавычки соответствуют одной одиночной кавычке в строке.

ЗАМЕЧАНИЯ:   текущая   версия   Multi-Edit   не   поддерживает    константы,
определяемые пользователем.

См.также @PREDCONST[ПРЕДОПРЕДЕЛЕННЫЕ КОНСТАНТЫ] и @DATATYPES[ТИПЫ ДАННЫХ]

PREDCONST ПРЕДОПРЕДЕЛЕННЫЕ КОНСТАНТЫ

Список имен предопределенных констант:

        TRUE = 1                EDIT = 0
        FALSE = 0               DOS_SHELL = 1
        BLACK = 0               ALL = 255
        BLUE = 1                DARKGRAY = 8
        GREEN = 2               LIGHTBLUE = 9
        CYAN = 3                LIGHTGREEN = 10
        RED = 4                 LIGHTCYAN = 11
        MAGENTA = 5             LIGHTRED = 12
        BROWN = 6               LIGHTMAGENTA = 13
        LIGHTGRAY = 7           YELLOW = 14
        WHITE = 15              TERM = 3

DEFGLOBAL ОПРЕДЕЛЕНИЕ ГЛОБАЛЬНЫХ ПЕРЕМЕННЫХ

Multi-Edit  поддерживает  строковые  и   целые  переменные,  которые   могут
передаваться между макросами.  Доступ к глобальным переменным осуществляется
не так как к @LOCALVARS[локальным переменным], а через следующие процедуры и
функции:

^BGLOBAL_STR( Имя_Строки ) строковая функция^b

    ВОЗВРАЩАЕТ:   строковое   значение   глобальной   строковой  переменной,
                заданной  Именем_Строки.  Если  переменная  не   определена,
                возвращается пустая строка.

    ПРИМЕР:     Str_Var := GLOBAL_STR( 'Поиск_Стр' );

^BGLOBAL_INT( Имя_Строки )  целая функция^b

    ВОЗВРАЩАЕТ:   целое  значение  глобальной  целой  переменной,   заданной
		Именем_Строки.  Если переменная не определена,  возвращается
		0.

    ПРИМЕР:     Int_Var := GLOBAL_INT( 'Общая_Строка' ) + 234;

^BSET_GLOBAL_STR( Имя_Строки, Строковое_Значение)  процедура^b

    ДЕЙСТВИЕ:     присваивает  глобальной  переменной  Имя_Строки   величину
                Строковое_Значение.   Если    до   этого    переменная    не
                существовала, она создается.

    ПРИМЕР:     SET_GLOBAL_STR( 'Поиск_Стр', 'END;' );

^BSET_GLOBAL_INT( Имя_строки, Целое_значение)  процедура^b

    ДЕЙСТВИЕ:          присваивает    глобальной    переменной    Имя_Строки
                Целое_Значение.    Если    до     этого    переменная     не
                существовала, она создается.

    ПРИМЕР:     SET_GLOBAL_INT( 'Общая_Строка', 234 );

^BFIRST_GLOBAL( Локальная целая_переменная )  строковая функция^b

    ВОЗВРАЩАЕТ:   имя   первой   глобальной   переменной,   находящейся    в
                памяти.   Целая_переменная    (определенная    пользователем
                как  локальная)   получит  значение   1,  если    глобальная
                переменная   целая,   и   0,   если   глобальная  переменная
                строковая.    Эта    функция     совместно    с     функцией
                NEXT_GLOBAL   позволяет   получить   полный   список    всех
                глобальных переменных в памяти.

^BNEXT_GLOBAL( локальная целая_переменная )  строковая функция^b

    ВОЗВРАЩАЕТ:   имя    следующей   глобальной    переменной   в    памяти.
                Возвращает  нулевую   строку,  если   в  списке   глобальных
                переменных,  находящихся   в  памяти,   больше  нет    имен.
                Целая_переменная  получит   значение  1,   если   глобальная
                переменная   целая,   и   0,   если   глобальная  переменная
                строковая.

ЗАМЕЧАНИЕ: имена глобальных переменных не чувтсвительны к величине
символов.
INTEXP ЦЕЛЫЕ ВЫРАЖЕНИЯ

Операция присваивается целым переменным:

        Целая_переменная := Целое_выражение;

Целое_выражение может быть целой функцией, переменной или выражением.

К целым переменным применимы следующие арифметические операции:

        +               Сложение
        -               Вычитание
        *               Умножение
        /               Деление
        AND             Логическое и поразрядное И
        OR              Логическое и поразрядное ИЛИ
        SHL             Поразрядный сдвиг влево.ПРИМЕР: (JX:=JX SHL 4)
        SHR             Поразрядный сдвиг вправо.
        MOD             Взятие модуля.

К целым переменным применимы следующие логические операции:

        =               Равно
        >               Больше
        <               Меньше
        >=              Больше или равно
        <=              Меньше или равно
        <>              Не равно

Логические выражения возвращают 1, если они истинны, и 0, если они
ложны.

        ПРИМЕР:
                        INT_VAR := 1 > 2;

        { INT_VAR будет присвоено значение 0 (ложь) }

Скобки могут использоваться для изменения порядка вычислений.

        ПРИМЕР:
                        INT_VAR := ((A + B) * C) / D;

См.также @INTVARS[ЦЕЛЫЕ]
STREXP СТРОКОВЫЕ ВЫРАЖЕНИЯ

Операция присваивания строковым переменным:

        Строковая_переменная := Строковое_выражение;

Строковое_выражение может быть строковой функцией, переменной или
выражением.

Оператор "+" обозначает конкатенацию строк.  ПРИМЕР:

                Str_Var := 'This is a test' + Str_Var2 + File_Name;

К строкам применимы следующие логические операции:

                =               Равно
                <>              Не равно

Логические выражения возвращают 1, если они истинны, и 0, если ложны.

ЗАМЕЧАНИЕ: операции сравнения строк чувствительны к величине символов

        ПРИМЕР:

        IF Str_Var = 'ON' THEN
          Make_Message( 'ON');
        ELSE
          IF Str_Var <> 'OFF' THEN
            Make_Message( 'UNKNOWN' );
          ELSE
            Make_Message( 'OFF' );
          END;
        END;

См.также @STRVARS[СТРОКИ]
REALEXP ДЕЙСТВИТЕЛЬНЫЕ ВЫРАЖЕНИЯ

Операция    присваивания     действительным    переменным     осуществляется
следующим образом:

     Действительная_Переменная := Действительное_выражение;

Действительное_выражение может быть действительной функцией,
переменной или выражением.

К действительным переменным применимы следующие арифметические
операции:

        +               Сложение
        -               Вычитание
        *               Умножение
        /               Деление

К действительным переменным применимы следующие логические операции:

        =               Равно
        >               Больше
        <               Меньше
        >=              Больше или равно
        <=              Меньше или равно
        <>              Не равно

Скобки могут использоваться для изменения порядка вычислений.

        ПРИМЕР:

                REAL_VAR := ((A + B) * C) / D;

См.также @REALVARS[ДЕЙСТВИТЕЛЬНЫЕ ЧИСЛА] и @REALOP[ДЕЙСТВИТЕЛЬНЫЕ
ОПЕРАЦИИ]

REALOP ДЕЙСТВИТЕЛЬНЫЕ ОПЕРАЦИИ

^BREAL_I( Целое )  действительная функция^b

    ВОЗВРАЩАЕТ: действительное число, преобразованное из целого.

    ПРИМЕР:     Real_Var := 124.023 + REAL_I(Int_Var);

^BINT_R( Действительное)  целая функция^b

    ВОЗВРАЩАЕТ: целое число, преобразованное из действительного.

    ПРИМЕР:     Int_Var := INT_R( Real_Var ) + 12;

^BRSTR( действительное, целое 1, целое 2 )  строковая функция^b

    ВОЗВРАЩАЕТ:    строковое     представление    действительного     числа.
                Действительное    -    это    преобразованное    в    строку
                действительное  число.  Целое   1  -  количество   символов,
                на  которые  слева  будет   выравнена  строка.  Целое  2   -
                количество цифр после десятичной точки.


    ПРИМЕР:         {Преобразование   Test_Real  в   строку,  содержащую   6
                значимых     цифр     и     4     цифры     после    точки.}
                Test_Str := RSTR( Test_Real, 6, 4 );

^BRVAL( действительное, строка )  целая функция^b

    ДЕЙСТВИЕ:        преобразование   строкового   представления   числа   в
                действительное число.

    ВОЗВРАЩАЕТ:  если  нечисловых  символов  в  строке  нет  возвращается 0,
                если есть - позиция первого нечислового символа.

    ПРИМЕР:     Test_Str := '899.25';
                {Преобразование Test_Str в действительное число}
                IF RVal( T_Real, Test_Str ) <> 0 THEN
                {Сообщение об ошибке}
                 Make_Message('ОШИБКА Преобразования');
                ELSE
                  {Ошибки нет}
                 Make_Message( 'Результат:  '  +  RStr( T_Real ));
                END;

См.также @REALVARS[ДЕЙСТВИТЕЛЬНЫЕ ЧИСЛА] и @REALEXP[ДЕЙСТВИТЕЛЬНЫЕ
ВЫРАЖЕНИЯ]
UNCONDBRANCH БЕЗУСЛОВНЫЕ ПЕРЕХОДЫ

CALL метка;
                выполнение подпрограммы

RET;
                выход из подпрограммы (для каждого CALL должен быть
                RET ).

GOTO метка;
                Переход на метку.

См.также @CONDBRANCH[УСЛОВНЫЕ ПЕРЕХОДЫ]
CONDBRANCH УСЛОВНЫЕ ПЕРЕХОДЫ

                WHILE выражение DO
                   оператор;
                   оператор; ...
                END;

                IF выражение THEN
                   оператор;
                   оператор; ...
                END;

                IF выражение THEN
                   оператор;
                   оператор; ...
                ELSE
                   оператор;
                   оператор; ...
                END;

Выражения  могут  быть  простыми  или  сложными.  Все  выражения  возвращают
целые   результаты   (TRVE=1    или   FALSE=0).   Основными    конструкциями
выражений являются:

        x = y,          x <> y, x < y,          x > y,          x <= y,
        x >= y,         x AND y,                x OR y

ПРИМЕРЫ:
        {A useless example of WHILE}
        JX := 12;
        WHILE JX <= JY DO
          JX := JX + 1;
          IF JX > JY THEN
            Make_Message( 'THIS IS THE LAST TIME!' );
          END;
        END;

        IF Our_String = 'This is a test.' THEN
          Make_Message( Our_String );
        ELSE
          IF Our_String = 'This is not a test.' THEN
            Make_Message( 'Why isn't it?' );
          END;
        END;

        IF ((JX + 1) > 4) AND ((Our_String + Your_String) <> 'WHAT?') THEN
          Text('It WORKS!');
        END;

См.также @UNCONDBRANCH[БЕЗУСЛОВНЫЕ ПЕРЕХОДЫ]
MACROOP МАКРООПЕРАЦИИ

^BRUN_MACRO( макро_спецификация )  процедура^b

    ДЕЙСТВИЕ:       Выполняет   макрос.    макро_спецификация   состоит   из
                макро_имени,    необязательного    имени    макро_файла    и
                необязательного      строкового      параметра.       Формат
                макро_спецификации:

                        Имя_макро_файлам^^Макро_имя Строковый_параметр

      Символ каретки "^B^^^b" служит разделителем между Именем_макро_файла  и
      Макро_именем;  пробел  "  "  служит  разделителем  между Макро_именем и
      Строковым_параметром.  Имя_макро_файла  может быть любым,  допустимым в
      ДОС (включая путь).  Когда Multi-Edit выполняет макрос, сначала он ищет
      макрос в памяти. Если макрос  там не найден, он ищется  в поддиректории
      Multi-Edit (определяемой функцией ME-PATH).  Если макрос не найден,  то
      флаг ERROR-LEVEL  устанавливается в  NON-ZERO. По  умолчанию имя  файла
      имеет  расширение  .MAC  .  Имя_макро_файла  может быть опущено , тогда
      поиск  идет  по  Макро_имени  .  В  отличие  от  DOS в Multi_Edit длина
      макро_имени не ограничена 8 знаками, а может достигать 16 знаков .

    ПРИМЕР:     { Выполнить  макрос LOADFILE. Если макроса нет в памяти,  то
		 он загружается из макро-файла MEUTIL1.MAC путем  присвоения
		 численному параметру /P  значение 1 и  строковому параметру
		 /L значение "NEW"}

                Run_Macro( 'MEUTIL1^LOADFILE /P=1/L=NEW');

^BLOAD_MACRO_FILE( Имя_макро_файла )  процедура^b

    ДЕЙСТВИЕ:   загружает макро-файл в память, но не выполняет его.
                Проверяет.

    ПРИМЕР:     {Загрузка макро-файла в память}
                Load_Macro_File('Test');
                {При ошибке - информируется пользователь, иначе
                 макрос выполняется}
                       IF Error_Level <> 0 THEN
                   Beep;
                   Make_Message('Нельзя загрузить макрос!');
                   Error_Level := 0;
                ELSE
                   Run_Macro( 'Test' );
                END;

^BUNLOAD_MACRO( Maкро_имя )  процедура^b

    ДЕЙСТВИЕ:   выгружает макрос из памяти.

    ПРИМЕР:     {Выгрузить макрос из памяти}
                Unload_Macro( 'Test' );

^BINQ_MACRO( Maкро_имя )  целая функция^b

    ВОЗВРАЩАЕТ: True (1), если макрос Макро_имя загружен в память.

    ПРИМЕР:     {Если макроса нет в памяти, загрузить его}
                IF Inq_Macro( 'Test' ) THEN
                   Load_Macro_File( 'Test' );
                   IF Error_Level <> 0 THEN
                      Make_Message( 'Ошибка загрузки макроса.');
                      Error_Level := 0;
                   END;
                END;

^BFIRST_RUN  целая функция^b

    ВОЗВРАЩАЕТ:  True  (1),  если  со  времени  загрузки  макрос  выполнялся
                один раз.

^BFIRST_MACRO  строковая функция^b

    ВОЗВРАЩАЕТ:  имя   макроса  первого   в  памяти.   Выполняется  операция
                NEXT_  MACRO,  открывающая  доступ  ко  списку  макросов   в
                памяти.

^BNEXT_MACRO  строковая функция^b

    ВОЗВРАЩАЕТ:  имя  следующего  макроса   в  списке.  Возвращает   нулевую
                строку, если макросов в списке уже нет.

PARMPASS ПЕРЕДАЧА ПАРАМЕТРОВ И ВОЗВРАЩАЕМЫЕ РЕЗУЛЬТАТЫ

Параметры  могут  передаваться  в  макрос  в  текстовой  форме в виде строки
параметров в процедуру RUN_MACRO:

        Run_Macro( 'Макро_имя строка_параметров');

Общая длина Макро_имени и строки_параметров не должна превышать 254 символа.
Строка_параметров должна быть отделена от Макро_имени пробелом.  Доступ к
строке_параметров возможен и с помощью вызова функции MPARM_STR. Макро_имя
может быть записано в виде: Macro_File^^macro_name (см @MACROOP[МАКРООПЕРАЦИИ]).

Принятой практикой является возврвщать целые  результаты в  системной
переменной RETURN_INT , а  Строковые  результаты  -  в системной  переменной
RETURN_STR . Помните, что RETURN_INT  и  RETURN_STR являются  глобально
доступными  и  могут принять значения в любом месте макроса. Однако можно
использовать и @DEFGLOBAL[глобальные переменные]  для передачи как
результатов , так и параметров между МАКРО-сами , и системные переменные для
обмена информацией внутри макро (например при @UNCONDBRANCH%CALL[!CALL]) .

Для  поиска  строк  и  целых  величин  в  строке вызова макроса используются
функции PARSE_STR и PARSE_INT.

^BMPARM_STR  строковая функция^b

    ВОЗВРАЩАЕТ: строку параметров, передаваемых в макрос.

^BPARSE_STR( строка1, строка2 )  строковая функция^b

    ВОЗВРАЩАЕТ: строку  символов из  строки2, начиная  со строки1.   Строка1
		обычно имеет вид  "/имя=", где имя  - это любой  текст. Если
		строка1 не найдена  в строке2, возвращается  нулевая строка.
		Эта функция чувствительна к размеру символов.

^BPARSE_INT( строка1, строка2 )  целая функция^b

    ВОЗВРАЩАЕТ:  целое  число  из  строки2,  начиная  со  строки1.  Работает
                аналогично  PARSE_STR  с  учетом  того,  что  искомая строка
		должна  быть  числовой,   что  необходимо  для   дальнейшего
		преобразования.

^BRETURN_STR  строковая переменная^b

        Используется для возвращения строковой величины из макроса.

^BRETURN_INT  целая переменная^b

        Используется для возвращения целой величины из макроса.

ПРИМЕР МАКРОСА С ИСПОЛЬЗОВАНИЕМ ПЕРЕДАЧИ ПАРАМЕТРОВ:

        {***********************************************************
          Этот макрос будет создавать новое окно и загружать в него
заданный файл.
          ПАРАМЕТРЫ:    /FN=имя файла
                        /X1=абсцисса верхнего левого угла окна
                        /Y1=ордината верхнего левого угла окна
                        /X2=абсцисса нижнего правого угла окна
                        /Y2=ордината нижнего правого угла окна
          ВОЗВРАЩАЕТ: Return_Int = 0, если успешно, <> 0, если
                      неправильно
        ************************************************************}
        $MACRO GETFILE;
          Def_Str( File_Spec );
          Def_Int( X1, Y1, X2, Y2, Error_Stat );
          Error_Stat := 0;
                       {Поиск параметров}
          File_Spec := Parse_Str( '/FN=', MParm_Str );
          X1 := Parse_Int( '/X1=', MParm_Str );
          X2 := Parse_Int( '/X2=', MParm_Str );
          Y1 := Parse_Int( '/Y1=', MParm_Str );
          Y2 := Parse_Int( '/Y2=', MParm_Str );
          Create_Window;
          {Если все параметры окна возможны, то задать размер окна),
          IF (X2 and Y1 and Y2) then
            Size_Window( X1, Y1, X2, Y2 );
          END;
          {Если указано имя файла, то файл загрузить}
                IF ( File_Spec <> '' ) THEN
            Load_File( File_Spec );
            Error_Stat := Error_Level;
          END;
          Return_Int := Error_Stat;
        END_MACRO;

        $MACRO TEST;
          Run_Macro( 'GETFILE /FN=TEST.DOC/X1=1/Y1=3/X2=80/Y2=25' );
          IF (Return_Int <> 0) THEN
             Make_Message( 'Ошибка при поиске файла.');
          END;
        END_MACRO;

STROP ОПЕРАЦИИ СО СТРОКАМИ

^BASCII( Строка )  целая функция^b

    ВОЗВРАЩАЕТ: целое число ASCII-код первого символа строки. Если
                строка пустая, возвращается 0.

    ПРИМЕР:     JX := ASCII( 'A' ); {ASCII-код символа 'A'}

^BCAPS( Строка )  строковая функция^b

    ВОЗВРАЩАЕТ: строку, записанную заглавными (большими) символами.

    ПРИМЕР:     Good_Str := CAPS(Good_Str);

^BCHAR( Целое)  строковая функция^b

    ВОЗВРАЩАЕТ: символ (строка), соответствующая входному ASCII-коду.

^BCOPY( Строка, Позиция, Число )  строковая функция^b

    ВОЗВРАЩАЕТ:  подстроку  из  Строки,  содержащую заданное Число символов,
		начиная с  Позиции. Если  Позиция больше,  чем длина Строки,
		возвращается пустая строка. Если  Позиция < 1 или  Позиция >
		2048, возвращается строка нулевой длины.

    ПРИМЕР:             {Ввести первые 3 символа Temp_Str}
                        Temp_Str := Copy( Temp_Str, 1, 3 );

^BLENGTH( Строка )  целая функция^b

    ВОЗВРАЩАЕТ: длину строки.

    ПРИМЕР:     If Length(Test_String) > 80 Then
                                Text('Строка слишком велика.');
                        End;

^BSVL( локальная строковая_переменная )  целая функция^b

    ВОЗВРАЩАЕТ:  длину  передаваемой   строковой  переменной.  Эта   функция
                быстрее,  чем  LENGTH,  но  работает  только  со  строковыми
                переменными.


^BXPOS( Подстрока, Строка, Позиция )  целая функция^b

    ВОЗВРАЩАЕТ: номер символа, начиная с которого Подстрока входит в Строку.
		Поиск ведется с заданной Позиции. Если Подстрока не найдена,
		возвращается 0.

    ПРИМЕР:     What_Pos := XPos( 'WHAT', Test_String, 12 );

^BSTR_DEL( Строка, Позиция, Число )  строковая функция^b

    ВОЗВРАЩАЕТ: результат удаления из Строки подстроки, содержащей
                заданное Число символов, начиная с Позиции.

    ПРИМЕР:     Test_String := STR_DEL(Test_String, 9, 4);

^BSTR_INS( Строка1, Строка2, Позиция)  строковая функция^b

    ВОЗВРАЩАЕТ: результат вставки Строки1 в Строку 2, начиная с
                заданной Позиции.

    ПРИМЕР:        {Вставить 'HELP' в строку Test_string в позицию 9}
                Test_Str := STR_INS('HELP',Test_String,9);

^BSTR( Целое )  стоковая функция^b

    ВОЗВРАЩАЕТ: строковое представление целого числа.

    ПРИМЕР:     {Вставить номер текущей строки в строку сообщений}
                Make_Message('Текущая строка: ' + Str(C_Line));

^BVAL( Целое, Строка )  целая функция^b

    ДЕЙСТВИЕ:   преобразует Строку в целое число, запоминаемое в Целом

    ВОЗВРАЩАЕТ: если нет ошибки, то 0, если ошибка есть, то номер
                позиции в строке, в которой она возникла.

    ПРИМЕР:     IF Val(Temp_Value, '1000') = 0 Then
                   New_Value := Old_Value + Temp_Value;
                END;

^BREMOVE_SPACE( Строка )  строковая функция^b

    ВОЗВРАЩАЕТ: строку, в которой удалены все пробелы, стоящие в ее начале и
		конце, и группы (более одного) последовательных пробелов.

^BGET_EXTENSION( Имя_файла)  строковая функция^b

    ВОЗВРАЩАЕТ: строку, содержащую расширение заданного Имени_файла.

    ПРИМЕР:     Extension := Get_Extension(Old_file);

^BGET_PATH( Имя_файла)  строковая функция^b

    ВОЗВРАЩАЕТ: строку, содержащую путь (дисковод и директорию) в
                заданном Имени_файла.

    ПРИМЕР:     If Get_Path(File_Name) <> 'C:\TEST\' Then
                   Enter_Dos_Shell;
                End;

^BTRUNCATE_EXTENSION( Имя_файла)  строковая функция^b

    ВОЗВРАЩАЕТ: строку, содержащую Имя_файла без расширения.

    ПРИМЕР:     New_File := Truncate_Extension(File_Name) + '.NEW';

^BTRUNCATE_PATH( Имя_файла)  строковая функция^b

    ВОЗВРАЩАЕТ: строку, содержащую Имя_файла без пути.

    ПРИМЕР:     New_File := 'B:\NEW\' + Truncate_Path(File_Name);

TEXTOP ОПЕРАЦИИ С ТЕКСТОМ

^BCUR_CHAR  строковая функция^b

    ВОЗВРАЩАЕТ: символ, на котором находится курсор в текущем активном окне.
		Если курсор  находится в  виртуальной области  или за концом
		строки, то возвращается символ с ASCII-кодом, равным 255.

    ПРИМЕР:     Temp_String := Temp_String + Cur_Char;

^BGET_WORD( Строка )  строковая функция^b

    ВОЗВРАЩАЕТ: часть текущей строки, начинающейся с текущей позиции курсора
		и заканчивающейся перед любым из символов из заданной Строки
		или в  конце текущей  строки. Курсор  передвигается в  конец
		возвращаемой строки.

    ПРИМЕР:     {Ввести слово}
                New_Word := Get_Word( ' $*().!{}' );

^BGET_LINE  строковая функция^b

    ВОЗВРАЩАЕТ: копию строки, на которой находится курсор.

    ПРИМЕР:     {Ввести текущую строку в Temp_Str}
                Temp_Str := Get_Line;

^BPUT_LINE( Строка)  процедура^b

    ДЕЙСТВИЕ:   заменить текущую строку на заданную Строку.

    ПРИМЕР:     {Заменить текущую строку новой строкой}
                Put_Line( 'Это новая строка.' );

^BCR  процедура^b

    ДЕЙСТВИЕ:   перевод каретки или переход на новую строку, eсли
                включен режим Insert.

    ПРИМЕР:     {Вставить новую строку}
                Insert_Mode := TRUE; {Включить режим Insert}
                EOL;    {перейти в конец строки}
                CR;     {перевод каретки}

^BTEXT( Строка )  процедура^b

    ДЕЙСТВИЕ:   вставить или заменить Строку в текст в текущей строке.   Эта
		операция чувствительна к режиму "Insert/Overwrite".

    ПРИМЕР:     {Вставить текст}
                Insert_Mode := TRUE;
                Text( 'Это текст.' );

^BDEL_CHAR  процедура^b

    ДЕЙСТВИЕ:   удаляет текущий символ.

^BDEL_CHARS( Число )  процедура^b

    ДЕЙСТВИЕ:   удаляет заданное Число символов, начиная с текущего.

    ПРИМЕР:     Del_Chars( 10 );    {Удаление следующих 10символов}

^BDEL_LINE  процедура^b

    ДЕЙСТВИЕ:   удаляeт текущую строку.

    ПРИМЕР:     {Удаление всех строк до конца файла}
                WHILE NOT( At_Eof ) DO
                   Del_Line;
                END;

^BBACK_SPACE  процедура^b

    ДЕЙСТВИЕ:    передвигает курсор влево.  Если включен режим  "Insert", то
		текущий символ удаляется или, если курсор находится в первом
		столбце, то текущая  строка объединяется с  предыдущей. Если
		включен  режим  "Overwrite",  то  текущий  символ заменяется
		пробелом и объединения строк не происходит.

    ПРИМЕР:     {Соединить текущую строку с предыдущей}
                Insert_Mode := TRUE;
                Goto_Col( 1 );          {Перейти на первый символ}
                Back_Space;             {Вернуться назад}

^BINSERT_MODE  целая переменная^b

        Если этот переключатель установлен в TRUE (1), то редактор находится
	в  режиме  "Insert"  ("Вставка"),  если  в  FALSE (0), то редактор в
	режиме "Overwrite" ("Замена"). Этот переключатель влияет на движение
	курсора.

UNDO ОПЕРАЦИИ ВОССТАНОВЛЕНИЯ
Для  каждого  файла,  загруженного  в  Multi-Edit поддерживается UNDO-буфер.
Каждая восстанавливаемая  последовательность (UNDO-запись)  может  содержать
неограниченное число текстовых изменений, передвижений курсора и операций  с
блоками.  Процедура  восстановления  возвращает  все изменения, хранящиеся в
последней UNDO-записи. Начало  и конец UNDO-записи  определяется процедурами
PUSH_UNDO и POP_UNDO, которые могут иметь до 32767 уровней вложенности.

^BUNDO  процедура^b

    ДЕЙСТВИЕ:   восстанавливает последний набор текстовых операций.

^BREDO  процедура^b

    ДЕЙСТВИЕ:   восстанавливает последнюю UNDO.

^BPUSH_UNDO  процедура^b

    ДЕЙСТВИЕ:  открывает UNDO-запись.

^BPOP_UNDO  процедура^b

    ДЕЙСТВИЕ:   закрывает UNDO-запись.

    ПРИМЕР:     {эти операции могут быть восстановлены одной командой
                UNDO}
                  PUSH_UNDO;              {открыть UNDO}
                Del_Chars( 10 );        {удалить 10 символов}
                Goto_Col( 1 );
                Text( 'Far out' );
                POP_UNDO;               {закрыть UNDO}

^BMAX_UNDO  целая переменная^b

        Устанавливает максимальное число UNDO-записей для одного файла
        (от 0 до 32767).

^BUNDO_STAT  целая переменная^b

        TRUE (1) = глобальное восстановление
        FALSE (0) = неглобальное восстановление

CURSOROP ОПЕРАЦИИ ПОЗИЦИОНИРОВАНИЯ КУРСОРА

^BHOME  процедура^b

    ДЕЙСТВИЕ:   передвигает курсор в установленное начало строки (отступ).

^BEOL  процедура^b

    ДЕЙТСВИЕ:      передвигает  курсор  на   первую  позицию  за   последним
                символом строки.

^BTOF  процедура^b

    ДЕЙСТВИЕ:   передвигает курсор в начало файла.

^BEOF  процедура^b

    ДЕЙСТВИЕ:   передвигает курсор в конец файла.

^BUP  процедура^b

    ДЕЙСТВИЕ:   передвигает курсор на одну строку вверх.

^BDOWN  процедура^b

    ДЕЙСТВИЕ:   передвигает курсор на одну строку вниз.

^BLEFT  процедура^b

    ДЕЙСТВИЕ:     передвигает  курсор  на  один  символ  влево.  Если курсор
                находится  в  первой  позиции,  он  передвигается  в   конец
                предыдущей строки.

^BRIGHT  процедура^b

    ДЕЙСТВИЕ:     передвигает  курсор  на  один  символ вправо. Курсор будет
                передвигаться  на  следующую  строку  только  по  достижении
                2048 позиции.

^BWORD_LEFT  процедура^b

    ДЕЙСТВИЕ:   передвигает курсор влево на одно слово. Будет переходить  на
		предыдущую   строку.   Для   изменения   ограничителей  слов
		используйте переменную WORD_DELIMITS.

^BWORD_RIGHT  процедура^b

    ДЕЙСТВИЕ:   передвигает курсор вправо на одно слово. Будет переходить на
		следующую   строку.   Для   изменения   ограничителей   слов
		используйте переменную WORD_DELIMITS.

^BWORD_DELIMITS  строковая переменная^b

        Определяет символы-ограничители слов, используемые в
        процедурах WORD_LEFT и WORD_RIGHT.

^BFIRST_WORD  процедура^b

    ДЕЙСТВИЕ:   передвигает курсор на первый символ (не пробел)
                строки.

^BMARK_POS  процедура^b

    ДЕЙСТВИЕ:   заносит текущее положение курсора в стек маркеров для
                текущего окна.

    ПРИМЕР:     Mark_Pos;
                IF NOT( Search_Fwd( The_Word, 0 ) ) THEN
                   Goto_Mark;
                END;

^BGOTO_MARK  процедура^b

    ДЕЙСТВИЕ:   восстанавливает  положение курсора по последнему  положению,
		хранящемуся  в  стеке  маркеров.  Удаляет  это  положение из
		стека.

^BPOP_MARK  процедура^b

    ДЕЙСТВИЕ:   выбирает маркер из стека без воздействия на курсор.

^BSET_MARK( Номер_маркера)  процедура^b

    ДЕЙСТВИЕ:   устанавливает маркер со случайным доступом. Номер
                маркера длжен быть от 1 до 10.

^BGET_MARK( Номер_маркера)  процедура^b

    ДЕЙСТВИЕ:     передвигает  курсор  в  положение  ,  хранящееся в маркере
                со  случайным  доступом  Номер_маркера.  Если  такой  маркер
                не установлен, изменений не происходит.

^BGOTO_LINE( Номер_строки )  процедура^b

    ДЕЙСТВИЕ:   передвигает курсор на строку с заданным Номером_строки
                (от 1 до 32767).

    ПРИМЕР:     Goto_Line( C_Line + 10 );

^BGOTO_COL( Номер_столбца)  процедура^b

    ДЕЙСТВИЕ:   передвигает курсор на заданный Номер_столбца (от 1 до
                2048).

    ПРИМЕР:     Goto_Col( 10 );

^BPAGE_UP  процедура^b

    ДЕЙСТВИЕ:   передвигает курсор вверх на длину окна.

^BPAGE_DOWN  процедура^b

    ДЕЙСТВИЕ:   передвигает курсор вниз на длину окна.

^BAT_EOF  целая функция^b

    ВОЗВРАЩАЕТ: True (1), если курсор находится в конце или за концом
                файла в текущем окне.

^BAT_EOL  целая функция^b

    ВОЗВРАЩАЕТ: True (1), если курсор находится в конце или за концом
                строки в текущем окне.

^BC_COL  целая функция^b

    ВОЗВРАЩАЕТ: номер столбца, в котором находится курсор.

    ПРИМЕР:     WHILE C_COL <> 10 DO
                   Right;
                END;

^BC_LINE  целая функция^b

    ВОЗВРАЩАЕТ: номер строки текущего файла, в кторой находится курсор

    ПРИМЕР:     IF C_Line = 10 THEN
                   Down;        {Skip line 10}
                END;

^BC_ROW  целая функция^b

    ВОЗВРАЩАЕТ: номер строки окна, в которой находится курсор. Если
                = 1, то видимой является верхняя строка.

    ПРИМЕР:     {Передвинуть курсор в верх окна}
                WHILE C_Row > 1 DO
                   Up;
                END;

^BNEXT_PAGE_BREAK  процедура^b

    ДЕЙСТВИЕ:   передвигает курсор на строку, находящуюся за следующим
                символом перевода страницы.

^BLAST_PAGE_BREAK  процедура^b

    ДЕЙСТВИЕ:   передвигает курсор на строку, находящуюся за
                предыдущим символом перевода страницы.

^BPAGE_STR  строковая переменная^b

        Определяет символы перевода страниц. Обычно это один символ с
        ASCII-кодом, равным 12, но можно определить любую строку
        длиной до 10 символов.

TABOP ТАБУЛЯЦИЯ И ОТСТУПЫ

^BTAB_RIGHT  процедура^b

    ДЕЙСТВИЕ:   переводит курсор на одну позицию табуляции вправо.

^BTAB_LEFT  процедура^b

    ДЕЙСТВИЕ:   передвигает курсор на одну позицию табуляции влево.

^BINDENT  процедура^b

    ДЕЙСТВИЕ:   выполняется TAB_RIGHT и в текущей позиции
                устанавливается отступ.

^BUNDENT  процедура^b

    ДЕЙСТВИЕ:   передвигает курсор на одну позицию табуляции назад и в
                текущей позиции устанавливается новый отступ.

^BINDENT_LEVEL  целая функция^b

    ВОЗВРАЩАЕТ:  номер  столбца  в  котором  для  текущего файла установлена
                позиция   отступа.    Это   позиция,    в   которую    будет
                перемещаться    курсор    после    перевода    каретки   или
                выполнения HOME.

^BSET_INDENT_LEVEL  процедура^b

    ДЕЙСТВИЕ:   для текущего файла в текущей позиции устанавливает
                отступ.

^BCRUNCH_TABS( локальная строковая_переменная )  процедура^b

    ДЕЙСТВИЕ:      когда   вызывается  GET_LINE,   она  возвращает   строку,
                оканчивающуюся  виртуальными   символами  (ASCII-код=   255)
                CRUNCH-TAB3   удаляет   виртуальные   символы   из   строки.
                Строковая переменная должна быть описана пользователем.

    ПРИМЕР:     Def_Str( TStr );
                TStr := Get_Line;
                Crunch_Tabs( TStr );

^BEXPAND_TABS( локальная строковая_переменная )  процедура^b

    ДЕЙСТВИЕ:     расширение  табуляции  во  входной  строке пробелами (если
                системная  переменная  TAB_EXPAND=FALSE)  или   виртуальными
		символами (если TAB_EXPAND=TRUE) строковая переменная должна
		быть описана пользователем.

    ПРИМЕР:     Def_Str( Tstr );
                Tstr := '|9|9Test paragraph';
                Tab_Expand( TStr );

^BTABS_TO_SPACES( локальная строковая_переменная )  процедура^b

    ДЕЙСТВИЕ:   преобразует все табуляции и виртуальные символы во
                входной строке в пробелы.

    ПРИМЕР:     Def_Str( Tstr );
                Tstr := Get_Line;
                Tabs_To_Spaces( Tstr );

^BTAB_EXPAND  целая переменная^b

        TRUE (1) = Используются символы табуляции и заполнители с
                   виртуальными пробелами
        FALSE (0) = Вместо символов табуляции используются пробелы

BLOCKOP ОПЕРАЦИИ С БЛОКАМИ

^BBLOCK_BEGIN  процедура^b

    ДЕЙСТВИЕ:   отмечает начало строчного блока.

^BCOL_BLOCK_BEGIN  процедура^b

    ДЕЙСТВИЕ:   отмечает начало столбцового блока.

^BSTR_BLOCK_BEGIN  процедура^b

    ДЕЙСТВИЕ:   отмечает начало потокового (поток текста) блока.

^BBLOCK_END  процедура^b

    ДЕЙСТВИЕ:   отмечает конец блока.

^BCOPY_BLOCK  процедура^b

    ДЕЙСТВИЕ:   копирует отмеченный блок текста в текущую позицию
                курсора.

^BMOVE_BLOCK  процедура^b

    ДЕЙСТВИЕ:   перемещает отмеченный блок текста в текущую позицию
                курсора.

^BWINDOW_COPY( Номер_окна )  процедура^b

    ДЕЙСТВИЕ:   копирует отмеченный блок из одного окна в теущее окно.

^BWINDOW_MOVE( Номер_окна )  процедура^b

    ДЕЙСТВИЕ:   перемещает отмеченный блок из одного окна в текущее
                окно.

^BDELETE_BLOCK  процедура^b

    ДЕЙСТВИЕ:   удаляет отмеченный блок текста.

^BBLOCK_STAT  целая функция^b

    ВОЗВРАЩАЕТ: 0, если блок не отмечен.
                1, если отмечен строчный блок.
                2, если отмечен столбцовый блок.
                3, если отмечен потоковый блок.

^BBLOCK_LINE1  целая функция^b

    ВОЗВРАЩАЕТ: номер первой отмеченной строки.

^BBLOCK_LINE2  целая функция^b

    ВОЗВРАЩАЕТ: номер второй отмеченной строки.

^BBLOCK_COL1  целая функция^b

    ВОЗВРАЩАЕТ: номер первого отмеченного столбца.

^BBLOCK_COL2  целая функция^b

    ВОЗВРАЩАЕТ: номер второго отмеченного столбца. Если номер > 2048,
                то блок не столбцовый.

^BMARKING  целая функция^b

    ВОЗВРАЩАЕТ: TRUE, если блок отмечен, иначе FALSE.

^BBLOCK_OFF  процедура^b

    ДЕЙСТВИЕ:   снимает отметку блока.

SCREENOP ОПЕРАЦИИ С ЭКРАНОМ

^BPUT_BOX( ВЛ_Стб, ВЛ_Стр, НП_Стб, НП_Стр,
        Осн_Цвет, Симв_Цвет, Заголовок, Тень )  процедура^b

    ДЕЙСТВИЕ:    изображает прямоугольник  с координатами  (ВЛ_Стб,  ВЛ_Стр,
		НП_Стб, НП_Стр), где ВЛ - верхний левый, НП - нижний правый,
		Стб - столбец, Стр - строка. Осн_Цвет - номер цвета  основы,
		Симв_Цвет   -   номер   цвета   символов.    Осн_Цвет  может
		отсутствовать,  а  Симв_Цвет  содержать  полный атрибут (см.
		@Colors  [Цвета]).  Заголовок  определяет  заглавную строку,
		которая будет написана в центре вверху прямоугольника.  Если
		Тень = True, то вокруг прямоугольника будет тень. Если  тень
		задана, не забудьте увеличить размеры прямоугольника на одну
                вертикальную и две  горизонтальные линии, занимаемые  тенью.
		Участок  экрана,  на  котором  изображается   прямоугольник,
		запоминается в стеке. Его можно удалить операцией Kill-Box.

    ПРИМЕР:     {Изобразить окно для вывода ошибок}
                Put_Box( 5, 4, 62, 12, White, Red, 'ERROR', TRUE );
                   {Приглашение}
                Write( 'Hажмите любую клавишу...',6,5,White, Red );
                   {Ожидание нажатия}
                Read_Key;
                   {Удалить окно}
                Kill_Box;

^BKILL_BOX  процедура^b

    ДЕЙСТВИЕ:   удаляет последнее созданное окно и восстанавливает
                содержимое предыдущего экрана.

    ПРИМЕР:     (see PUT_BOX)

^BBOX_COUNT  целая переменная^b

    Количество окон на экране.

    ПРИМЕР:     {удалить все открытые окна }
                WHILE Box_Count > 0 DO
                  Kill_Box;
                END;

^BWRITE( Строка, Стб, Стр, Осн_Цвет, Симв_Цвет)  процедура^b

    ДЕЙСТВИЕ:    выводит Строку текста  на экран с  координатами (Стб,Стр) в
		цветах Осн_Цвет и Симв_Цвет. Цвет основы Осн_Цвет может быть
		снижен  до  0,  и  цвет  символов  Симв_Цвет может содержать
		полный атрибут (см. @COLORS [Цвета]. Эта процедура не влияет
		на остальной текст, находящийся в окне.

^BMAKE_MESSAGE( строка_сообщений)  процедура^b

    ДЕЙСТВИЕ:   записывает строку_сообщений в строку экрана для
                сообщений (по умолчанию: вторая строка).

    ПРИМЕР:     {Вывести текущий символ}
                Make_Message('Tекущий символ: ' + Cur_Char);

^BDRAW_CHAR( Код, Стр, Стб, Атрибут, Число )  процедура^b

    ДЕЙСТВИЕ:   записывает строку повторяющихся символов на экране.
                Код  - это ASCII-код символа.

^BSCREEN_LENGTH  целая функция^b

    ВОЗВРАЩАЕТ: Число строк экрана.

^BSCREEN_WIDTH  целая функция^b

    ВОЗВРАЩАЕТ: Число символов в строке экрана.

^BWHEREX  целая функция^b

    ВОЗВРАЩАЕТ: действительную физическую координату x курсора на
                экране, не зависящую от положения курсора в окне.

^BWHEREY  целая функция^b

    ВОЗВРАЩАЕТ: действительную физическую координату y курсора на
                экране, не зависящую от положения курсора в окне.

^BGOTOXY( x, y )  процедура^b

   ДЕЙСТВИЕ:    устанавливает курсор в физические координаты окна
                (x, y ).

^BTOGGLE_VIDEO  процедура^b

    ДЕЙСТВИЕ:     переключает  текущий  тектовый  режим  между  режимом с 25
                строками   и   другим   более   плотным   режимом  (если  он
                возможен),  например  EGA  =  43  строки  или  Color  =   50
                строк.

^BVIDEO_CARD  целая функция^b

    ВОЗВРАЩАЕТ: 0 = IBM CGA
                1 = IBM Monochrome
                2 = MONROE Color
                3 = MONROE Monochrome
                4 = Sigma Color 400
                5 = EGA Color
                6 = Hercules Monochrome
                7 = VGA Monochrome
                8 = VGA Color
                9 = EGA Monochrome
                10 = Wyse 700

^BVIDEO_MODE  целая функция^b

    ВОЗВРАЩАЕТ: 0 = 80 x 25 (normal)
                1 = 80 x 50 (Sigma Color 400)
                2 = 80 x 43 (EGA)
                3 = 80 x 50 (VGA)

^BPUT_LINE_NUM( Номер )  процедура^b

    ДЕЙСТВИЕ:   присваивает заданный целый номер строке текущего окна.

^BPUT_COL_NUM( Номер )  процедура^b

    ДЕЙСТВИЕ:   присваивает заданный целый номер столбцу текущего окна

^BWORKING  процедура^b

    ДЕЙСТВИЕ:      активизирует  мигающие  "рабочие"   сообщения  в   строке
                состояния  Multi-Edit.  При  вызове  REDRAW  или  NEW-SCREEN
                сообщения исчезают.

^BSCROLL_BOX_UP( x1, y1, x2, y2, атрибут )  процедура^b

    ДЕЙСТВИЕ:   перемещает область экрана с коэффициентами (x1,y1) - (x2,y2)
		на одну строку вверх. Атрибут - это один байт,  используемый
		для установки цветов  новой строки.   Младшие 4 бита  - цвет
		символов,  следующие  3  бита  -  цвет  основы , старший бит
		определяет состояние мигание/подчеркивание.

    ПРИМЕР:     Scroll_Box_Up(1,1,80,25, (Back_Color shl 4) or
Text_Color);

^BSCROLL_BOX_DN( x1, y1, x2, y2, атрибут )  процедура^b

    ДЕЙСТВИЕ:   перемещает область эрана на одну строку вниз.

^BCLEAR_SCREEN( байт )  процедура^b

    ДЕЙСТВИЕ:     очищает  зкран  и  устанавливает  цвета  так, как задано в
                байте,  где  младшие  4  бита  -  цвет символов, следующие 3
                бита  -  цвет  основы,  старший  бит  определяет   состояние
                мигание/подчеркивание.

^BEXPLOSIONS  целая переменная^b

        TRUE (1) = окна будут удаляться.
        FALSE (0) = окна не будут удаляться.

DISPLAYCONFIG КОНФИГУРАЦИЯ ДИСПЛЕЯ

^BINS_CURSOR  целая переменная^b

        Форма курсора в режиме "Insert":
        0 = подчеркивание
        1 = 1/2 маркера
        2 = 2/3 маркера
        3 = полный маркер

^BOVR_CURSOR  целая переменная^b

        Форма курсора в режиме "Overwrite". Аналогично INS_CURSOR.

^BCTRL_HELP  целая переменная^b

        TRUE (1) = окно помощи "Ctrl-Доп.клавиатура" включено.
        FALSE (0) = окно помощи "Ctrl-Доп.клавиатура" выключено.

^BSTATUS_ROW  целая переменная^b

        TRUE (1) - строка состояния включена.
        FALSE (0) - строка состояния выключена.

^BMESSAGE_ROW  целая переменная^b

        TRUE (1) - строка состояния включена.
        FALSE (0) - строка состояния выключена.

^BMAX_WINDOW_ROW  целая переменная^b

        Максимальное число строк, которое возможно в окне.

^BMIN_WINDOW_ROW  целая переменная^b

        Минимальное число строк, которое возможно в окне.

^BNAME_LINE  целая переменная^b

        TRUE (1) -верхняя строка окна не используется, имя файла в
                  нижней строке.
        FALSE (0) -нижняя строка окна не используется, имя файла в
                   верхней строке.

^BFKEY_ROW  целая переменная^b

        TRUE (1) - строка описания функциональных клавиш включена.
        FALSE (0) - строка описания функциональных клавиш выключена.

^BDISPLAY_TABS  целая переменная^b

        TRUE (1) - символы табуляции изображаются.
        FALSE (0) - символы табуляции не изображаются.

^BEOF_CHAR  целая переменная^b

        Однобайтовая переменная, содержащая ASCII-код символа,
        завершающего каждую строку в окне.

^BSTATUS_MACRO( Строка_макро_имени ) процедура^b

        Представление в строке состояния выполняемого макроса.

^BSTATUS_STR  строковая переменная^b
        Представление заданной Строки в строке состояния.

^BMODE_COL  целая переменная^b
        Позиция индикатора "Режим" в строке состояния.

^BINSERT_COL  целая переменная^b
        Позиция индикатора "Insert/Overwrite" в строке состояния.

^BMEM_COL  целая переменная^b
        Позиция индикатора "Память" в строке состояния.

^BTIME_COL  целая переменная^b
        Позиция индикатора "Время/Дата" в строке состояния.

^BCAPS_COL  целая переменная^b
        Позиция индикатора "Caps Lock" в строке состояния.

^BRECORD_COL  целая переменная^b
        Позиция индикатора "Запись" в строке состояния.

^BLINE_COL  целая переменная^b
        Позиция индикатора "Номер строки" в строке состояния.

^BCOL_COL  целая переменная^b
        Позиция индикатора "Номер столбца" в строке состояния.

^BMESSAGE_COL  целая переменная^b
        Номер столбца, в котором будeт начинаться строка сообщений.

^BMESSAGE_LENGTH  целая переменная^b
        Максимальная длина строки
@SCREENOP%MAKE_MESSAGE([СООБЩЕНИЯ].

^BWORKING_COL  целая переменная^b
        Позиция индикатора "Рабочий" в строке состояния.


См.также @COLORS[ЦВЕТА]

USEROP ПОЛЬЗОВАТЕЛЬСКИЙ ВВОД И ИНТЕРФЕЙС

^BREAD_KEY  процедура^b

    ДЕЙСТВИЕ:   приостанавливает работу и ожидает нажатия клавиши.
                Scan-коды нажатой клавиши возвращаются в KEY1 и KEY2.

    ПРИМЕР:     {Ввод кода клавиши}
                Read_Key;
                {Если key1 = 0, то нажата клавиша с расширенным кодом}
                IF Key1 = 0 AND Key2 = 59 THEN
                   Make_Message('Вы нажали F1!');
                END;

^BCHECK_KEY  целая функция^b

    ВОЗВРАЩАЕТ:  True  (1),  если  клавиша  была  нажата.  Скан-код доступен
                через   функции   KEY1   и   KEY2.   Аналогична    процедура
                READ-KEY без приостановки работы.

    ПРИМЕР:     {Если клавиша была нажата, сообщить пользователю ее
                код}
                IF Check_Key THEN
                   IF Key1 = 0 THEN
                      Make_Message('Вы нажали расширенную клавишу');
                   ELSE
                      Make_Message('Вы нажали обычную клавишу');
                   END:
                END;

^BKEY1  целая переменная^b

    Содержит первый байт кода клавиши, нажатой последней.
    Если = 0, то была нажата клавиша с расширенным кодом.

    ПРИМЕР:     {проверка расширенного кода клавиши}
                IF Key1 = 0 THEN
                   Key_Code := Key2;
                END;

^BKEY2  целая переменная^b

    Содержит второй байт кода расширенной клавиши, нажатой последней.

    ПРИМЕР:     {Если нажато CtrlF1, идти в конец макроса}
                IF Key1 = 0 AND Key2 = 94 Then
                   GOTO End_Of_Mac;
                END;

^BPUSH_KEY( Код_клавиши, Расш_код )  процедура^b

    ДЕЙСТВИЕ:   вводит скан-коды нажатых клавиш в буфер клавиатуры
                редактора (до 16 скан-кодов).

    ПРИМЕР:     {Отфильтровать нерасширенные коды клавиш}
                Read_Key;
                IF (Key1 = 0) THEN
                  Push_Key( Key1, Key2 );
                END;

^BPASS_KEY( Код_клавиши, Расшир_код )  процедура^b

    ДЕЙСТВИЕ:   передает скан-коды, которые выполняют связанные с
                ними какие-либо команды или макросы. Исполъзуется в
                макросе REPEAT.

^BSTRING_IN( Входная_строка, Приглашение,Длина,Стб,Стр,Строка_помощи)
           целая функция^b

    ДЕЙСТВИЕ:   приглашает пользователя ввести строку.

                Приглашение  -   это  строковое   выражение,  обращенное   к
                пользователю.  Входная строка - это строковая переменная,  в
		которой   запоминается   ответ   пользователя.     Длина   -
		максимально допустимое число символов в ответе пользователя.
		Строка_помощи  -  это  индекс  в  файле  помощи (если нажата
		клавиша F1).

    ВОЗВРАЩАЕТ: TRUE (1), если был ввод и нажата клавиши Enter,
                FALSE (0), если был сброс и нажата клавиша ESC.

    ПРИМЕР:     {пригласить пользователя ввести свое имя}
                JX := String_In( Name, 'Введите вамше имя', 20, 2, 2,
                'NM');
                          {Если нажата ESC, то выход}
                IF JX = 0 THEN
                   GOTO EXIT;
                END;

^BHELP( Индекс)  процедура^b

    ДЕЙСТВИЕ:       вызывает   раздел   помощи   (в   ME.HLP),  связанный  с
                Индексом_строкой до 20 символов.  Если индекс не может  быть
		найден, вызывается главное меню помощи.  (См. RETRIEVE_HELP)

    ПРИМЕР:     Help('MA');

^BRETRIEVE_HELP( Индекс, x1, y1, x2, y2,
                Имя_файла,Заголовок )  процедура^b

    ДЕЙСТВИЕ:    вызывает окно  помощи   с координатами  (x1,y1) -  (x2,y2).
		Имя_файла -  имя файла  помощи. Заголовок  - заголовок  окна
		помощи.

                См. @ME.HLP^MEHELP[Система помощи в Multi-Edit].

FUNCLABELOP ОПЕРАЦИИ С МЕТКАМИ ФУНКЦИОНАЛЬНЫХ КЛАВИШ

^BPUSH_LABELS  процедура^b

    ДЕЙСТВИЕ:   вводит новый пустой набор меток функциональных клавиш
                в стек меток клавиш.

    ПРИМЕР:     (See FLABEL below.)

^BPOP_LABELS  процедура^b

    ДЕЙСТВИЕ:   удаляет текущий набор меток функциональных клавиш,
                восстанавливая предыдущий набор.

    ПРИМЕР:     (See FLABEL below.)

^BFLABEL( Строка, Номер_клавиши,Режим )  процедура^b

    ДЕЙСТВИЕ:     изменяет  метку  клавиши.  Строка  -  это  шестисимвольная
                переменная   или    константа.   Номер_клавиши    -    номер
                функциональной     клавиши:     <F1...F10>     =     1...10;
                <ShftF1...ShftF10> = 11...20; <CtrlF1...CtrlF10> =  31...40.
		Все другие  номера игнорируются.  Режим-режим Multi-Edit,  в
		котором метка используется:  0 = EDIT,1  = DOS_SHELL, 255  -
		текущие метки, независимо от режима.

    ПРИМЕР:     {присвоить клавише <F3> в режиме EDIT имя "SAVE"}
                 FLABEL ( "SAVE", 3, EDIT );
                   {Создать новый набор меток}
                PUSH_LABELS;
                   {Присвоить имя клавишам <ShftF5> в текущем наборе
                   меток}
                        FLABEL( 'RUN_DS', 15, 255 );
                   {Ожидание нажатия клавиши}
                READ_KEY;
                   {Ввостановить старые метки}
                POP_LABELS;

WINOP ОПЕРАЦИИ С ОКНАМИ
Окна могут быть заданы двумя способами:

        1.           Каждое  окно   имеет  номер_окна,   который  связан   с
                последовательностью  окон   в  списке   окон.  Этот    номер
                изменяется  тогда,  когда  окно  добавляется  или удаляется.
		Большинство операций с окнами имеют дело с номером_окна.

        2.        Каждому окну  присваивается уникальный  идентификатор окна
		(идентификационный номер). Этот идентификатор не изменяется.
		Окно   можно    активизировать   ,    используя    процедуру
		Switch_Win_Id и идентификатор окна.

^BCREATE_WINDOW  процедура^b

    ДЕЙСТВИЕ:   создает новое окно. Если создано более 100 окон и  редактору
		не  хвататет   памяти  для   нового  окна,   то  ERROR_LEVEL
		становится не равным нулю.
		См.также @ERRORS[ОШИБКИ МАНИПУЛИРОВАНИЯ].

^BSWITCH_WINDOW( Номер_окна )  процедура^b

    ДЕЙСТВИЕ:     активизирует  окно  с  целым Номером_окна. Если Номер_окна
		больше, чем  количество включенных  окон, то  активизируется
		окно 1.

    ПРИМЕР:     {Активизировать второе окно}
                Switch_Window(2);

^BCUR_WINDOW  целая функция^b

    ВОЗВРАЩАЕТ: номер текущего окна.

    ПРИМЕР:     {Активизировать следующее окно}
                Switch_Window( Cur_Window + 1 );

^BSWITCH_WIN_ID( Идентификатор_окна )  целая функция^b

    ВОЗВРАЩАЕТ: TRUE(1),если окно с заданным идентификационным номером
                активизировалось.

^BWINDOW_ID  целая функция^b

    ВОЗВРАЩАЕТ: уникальный идентификационный номер для текущего окна.

^BSIZE_WINDOW( ВЛ_Стб, ВЛ_Стр, НП_Стб, НП_Стр )  процедура^b

    ДЕЙСТВИЕ:     изменяет  размеры  текущего  окна. Размеры окна ограничены
		текущими длиной и шириной экрана и будут уменьшены, если они
		превышают текущие размеры экрана.

		См. @SCREENOP%SCREEN_WIDTH[ШИРИНА_ЭКРАНА] и
@SCREENOP%SCREEN_LENGTH[ДЛИНА ЭКРАНА].
    ПРИМЕР:     {Если в текущем файле не было изменений, то удалить
                текущее окно}.
                Size window(3,1,23,80);

^BDELETE_WINDOW  процедура^b

    ДЕЙСТВИЕ:   удаляет текущее окно. ВСЯ ИНФОРМАЦИЯ ИЗ ОКНА ТЕРЯЕТСЯ!

    ПРИМЕР:     {Если в текущем файле не было изменений, то удалить
                текущее окно}.
                IF File_Changed = 0 THEN
                   Delete_Window;
                END;

^BERASE_WINDOW  процедура^b

    ДЕЙСТВИЕ:   удаляет содержимое окна, но не само окно.

    ПРИМЕР:     {Если в текущем файле не было изменений, то
                  очистить текущее окно}
                IF File_Changed = 0 THEN
                  Erase_Window;
                END;

^BLINK_WINDOW( Номер_окна)   процедура^b

    ДЕЙСТВИЕ:   связывает текущее окно с окном, имеющим заданный
                Номер_окна.

    ПРИМЕР:     {связать текущее окно со следующим окном}
                Link_Window( Cur_Window + 1 );

^BUNLINK_WINDOW  процедура^b

    ДЕЙСТВИЕ:   убрать связи с текущего окна.

^BLINK_STAT  целая функция^b

    ВОЗВРАЩАЕТ: количество окон, с которыми связан текущий буфер.

^BREDRAW  процедура^b

    ДЕЙСТВИЕ:   изменяет вид текущего окна.

^BNEW_SCREEN  процедура^b

    ДЕЙСТВИЕ:   изменяет вид всего экрана.

^BWIN_X1  целая функция^b

    ВОЗВРАЩАЕТ: номер верхнего  левого столбца текущего  окна. Если =  0, то
		левая граница окна не изображается. Максимальное значение  =
		ширина экрана - 2.

^BWIN_Y1  целая функция^b

    ВОЗВРАЩАЕТ: номер верхней левой строки текущего окна. Минимальное
                значение = 3. Максимальное значение = длина экрана -3.

^BWIN_X2  целая функция^b

    ВОЗВРАЩАЕТ: номер  нижнего правого  столбца текущего  окна.  Минимальное
		значение = 4. Максимальное значение  = ширина экрана + 1  (в
		случае, если правая граница окна не изображается).

^BWIN_Y2  целая функция^b

    ВОЗВРАЩАЕТ: номер нижней правой строки текущего окна. Минимальное
                значение = 5. Максимальное значение = длина экрана -1.

^BSCREEN_NUM  целая переменная^b

                Содержит  номер  виртуального  экрана, используемого текущим
		окном (от 0 до 32767).  Если SCREEN_NUM установлена в 0,  то
		окно рассматривается таким, как если бы оно занимало  полный
		экран.   См.  @ME.HLP^WINVIRT[ОКНА  И  ВИРТУАЛЬНЫЕ ЭКРАНЫ] в
                Руководстве по Multi-Edit.


^BWINDOW_COUNT  целая функция^b

    ВОЗВРАЩАЕТ: количество активных окон.

    ПРИМЕР:     {Активизировать последнее окно}
                Switch_Window( Window_Count );

^BWINDOW_ATTR  целая переменная^b

        Аттрибуты текущего окна по-битово:

        Bit 0 = (1) скрыто, (0) не скрыто.
        Bit 1 = (1) информация по состоянию не изображается,
                (0) информация по состоянию изображается.
        Bit 2 = (1) границы окна не изображаются,
                (0) границы окна изображаются.
^BREFRESH  целая переменная^b

        Этот ключ устанавливает корректировку изображаемого окна во включено
	(1) или выключено  (0). Установка REFRESH  в 0 значительно  ускоряет
	выполнение большинства макросов.

FILEOP ОПЕРАЦИИ С ФАЙЛАМИ

^BFILE_NAME  строковая переменная^b

        Имя файла, редактируемого в текущем окне (до 65 символов,
        включая путь).
        ПРИМЕР:  File_Name :=  'C:\ME\INIT.SRC';

^BLOAD_FILE( Имя_файла)  процедура^b

    ДЕЙСТВИЕ:   загружает заданный файл в текущее окно. Код ошибки
                передается через переменную ERROR_LEVEL.
                (См. @ERRORS[ОШИБКИ МАНИПУЛИРОВАНИЯ])

    ПРИМЕР:     {Загрузить файл}
                Load_File( 'Test.Txt' );
                   {Если ошибка, выполнить макрос}
                IF Error_Level <> 0 THEN
                   Run_Macro( 'MEERROR' );
                END;

^BSAVE_FILE  процедура^b

    ДЕЙСТВИЕ:   сохранить файл из текущего окна. Код ошибки передается
                через переменную ERROR_LEVEL.
                (См. @ERRORS[ОШИБКИ МАНИПУЛИРОВАНИЯ])

    ПРИМЕР:     {Сохранить текущий файл}
                Save_File;
                   {Если ошибка, выполнить макрос}
                IF Error_Level <> 0 THEN
                   Run_Macro( 'MEERROR' );
                END;

^BFILE_EXISTS( Имя_файла )  целая функция^b

    ВОЗВРАЩАЕТ: True (1), если заданный файл существует.

    ПРИМЕР:     {Если файл существует, то загрузить его}
                FStr := 'TEST.SRC';
                If File_Exists( FStr ) THEN
                   Load_File( Fstr );
                END;
                   {Если ошибка, выполнить макрос}
                IF Error_Level <> 0 THEN
                   Run_Macro( 'MEERROR' );
                END;

^BFIRST_SAVE  целая функция^b

    ВОЗВРАЩАЕТ: True(1), если текущий файл был сохранен по крайней
                мере один раз с начала сеанса редактирования.

^BEOF_IN_MEM  целая функция^b

    ВОЗВРАЩАЕТ: True (1), если конец файла уже в памяти, FALSE (0),
                если конец файла еще на диске.

^BBUFFER_ID  целая функция^b

    ВОЗВРАЩАЕТ: идентификатор буфера файла из текущего окна.

^BTMP_FILE  целая функция^b

    ВОЗВРАЩАЕТ: True, если для этого буфера использовался временный
                файл.

^BTMP_FILE_NAME  строковая функция^b

    ВОЗВРАЩАЕТ: имя временного файла, использовавшегося для этого
                буфера.

^BTEMP_PATH  строковая переменная^b

        Полное наименование  директории, в которой Multi-Edit должен
        хранить временные файлы.
        См. @ME.HLP^VM[ВИРТУАЛЬНАЯ ПАМЯТЬ].

^BBACKUP_PATH  строковая переменная^b

        Полное наименование директории, в которой Multi-Edit должен
        хранить резервные файлы. Эта переменная используется только
        тогда, когда целая переменная BACKUP = 2.
        См. @ME.HLP^BACKUPS[АВТОМАТИЧЕСКОЕ РЕЗЕРВИРОВАНИЕ]

^BFIRST_FILE( Имя_файла)  целая функция^b

    ДЕЙСТВИЕ:   ищет первое появление заданного Имени_файла, которое
                может содержать символы "*", "?" и полный путь.

    ВОЗВРАЩАЕТ: 0, если такой файл найден или ошибку ДОС с кодом 18,
                если файл не найден.

    ПРИМЕР:     (см. NEXT_FILE)

^BNEXT_FILE  целая функция^b

    ДЕЙСТВИЕ:   ищет следующее появление заданного Имени_файла,
                начиная с FIRST_FILE.

    ВОЗВРАЩАЕТ: 0, если такой файл найден или ошибку ДОС с кодом 18,
                если файл не найден.

    ПРИМЕР:     {Найти все файлы с заданным именем и загрузить их}
                TStr := '*.SRC';
                IF FIRST_FILE(TSTR) = 0 THEN
                   TStr := LAST_FILE_NAME;
                   Call Do_Load_File;
                   WHILE (NEXT_FILE = 0) DO
                      TStr := TStr2 + LAST_FILE_NAME;
                          {вызов процедуры загрузки файла}
                      Call Do_Load_File;
                   END;
                END;

^BLAST_FILE_NAME  строковая функция^b

    ВОЗВРАЩАЕТ: последнее имя файла, найденное с помощью FIRST_FILE
                или NEXT_FILE.

    ПРИМЕР:     (См. NEXT_FILE)

^BFILE_CHANGED  целая переменная^b

        Если этот переключатель = 1, следовательно, со времени
        загрузки  или записи файл был изменен. Сохранение файла
        устанавливает этот переключатель в 0.

^BBACKUPS  целая переменная^b

        0 = резервные файлы не создавать.
        1 = создавать .BAC файлы.
        2 = копировать резервные файлы в директорию, определенную в
            BACKUP_PATH.
        См. @ME.HLP^BACKUPS[АВТОМАТИЧЕСКОЕ РЕЗЕРВИРОВАНИЕ]

^BAUTOSAVE  целая переменная^b

        Если 0, то автоматическое сохранение файла выключено.

        Иначе переменная AUTOSAVE равна количеству секунд, которые
        компьютер должен подождать (время простоя) перед тем, как
        вызвать макрос автоматического сохранения AUTOSAVE.

^BTRUNCATE_SPACES  целая переменная^b

        TRUE (1) = во время загрузки Multi-Edit будет усекать все
                   конечные пробелы в строках
        FALSE (0) = усечения конечных пробелов не будет.

^BREAD_ONLY  целая переменная^b

        TRUE (1) = позволяет просматривать файл без редактирования
        FALSE (0) = позволяет нормальное редактирование.

SEARCHOP ОПЕРАЦИИ ПОИСКА И ЗАМЕНЫ
Для дополнительной информации по регулярным выражениям
ЗАМЕЧАНИЕ:  См. @ME.HLP^SR[ПОИСК И ЗАМЕНА] в главном справочнике
Multi-Edit.

^BSEARCH_FWD( Строка, Число )  целая функция^b

    ДЕЙСТВИЕ:   осуществляет поиск вперед заданной Строки среди
                заданного Числа строк, начиная с текущей строки. Если
                Число = 0, поиск выполняется до конца файла. Если
                Строка найдена, то курсор устанавливается на первый
                символ найденной строки. Помните, что для
                установления чувствительности этой функции к величине
                букв служит системная переменная IGNORE_CASE.

    ВОЗВРАЩАЕТ: 1 - если Строка найдена, 0 - если Строка не найдена.

    ПРИМЕР:     (См. @SEARCHOP%REPLACE([ЗАМЕНА])

^BSEARCH_BWD( Строка,Число )  целая функция^b

    ДЕЙСТВИЕ:   аналогично SEARCH_FWD, но осуществляет поиск назад.
                Если Число = 0, поиск выполняется до начала файла.

    ВОЗВРАЩАЕТ: TRUE (1) - если Строка найдена,
                FALSE (0) - если Строка не найдена.

^BREPLACE( Строка )  процедура^b

    ДЕЙСТВИЕ:   строка, найденная последней операцией поиска,
                заменяется заданной Строкой. Положение курсора влияние
                не оказывает, но со времени последнего поиска курсор
                не должен передвигаться.

    ПРИМЕР:      {Найти все строки  'WHAT' или 'WHERE' и заменить их
                  на 'WHY', игнорируя размеры букв}
                Ignore_Case := True;
                WHILE Search_Fwd('{WHAT}||{WHERE}', 0 ) DO
                  Replace( 'WHY' );
                END;

^BIGNORE_CASE  целая переменная^b

        Если = TRUE (1), то размер букв при поиске игнорируется.

^BREG_EXP_STAT  целая переменная^b

        True (1) = регулярные выражения допустимы
        True (0) = регулярные выражения не допустимы.

DOSOP ОПЕРАЦИИ СВЯЗИ С ДОС

^BSHELL_TO_DOS( Строка, Ключ )  процедура^b

    ДЕЙСТВИЕ:   осуществляет выход в ДОС и выполнение команды,
                записанной в Строке. Если Ключ = 1, то для выполнения
                команды используется СОММАND.CJV, если Ключ = 0, то
                Multi-Edit пытается выполнить команду непосредственно.
                Для выполнения любых внутренних команд, таких как DIR,
                или COPY, Ключ должен быть = TRUE. Если Строка = "
                (пустая строка), то просто выполняется CОMMAND.COM.
                Если @MISCOP%EMS_STAT[Подгрузка EMS] включена и
                REDUCE_MEM = TRUE, то будет подкачиваться по
                мере освобождения области данных.

    ПРИМЕР:     {Скопировать файл}
                SHELL_TO_DOS( 'COPY ME.HLP A:', TRUE );

^BEXIT_CODE  целая функция^b

    ВОЗВРАЩАЕТ: код выхода ДОС после выполнения SHELL_TO_DOS. Если вы
                используете COMMAND.COM (т.е. Ключ = TRUE), то код
                выхода возвращается COMMAND.COM, а не той командой,
                которая определяется в Строке. См. SHELL_TO_DOS.

^BREDUCE_MEM  целая переменная^b

    TRUE(1) =   вся доступная память при выполнении SHELL_TO_DOS
                освобождается.

    FALSE(0) =  память редактора при выполнении SHELL_TO_DOS не
                освобождается.

^BCOMSPEC  строковая функция^b

    ВОЗВРАЩАЕТ: строку, содержащую путь доступа к COMMAND.COM.

    ПРИМЕР:     {Выполнить COMMAND.COM}
                SHELL_TO_DOS( Comspec, FALSE );

^BGET_ENVIRONMENT( Имя_точки_входа )  строковая функция^b

    ВОЗВРАЩАЕТ: анализирует среду ДОС для заданного Имени_точки_входа
                и возвращает строку, связанную с ним.

    ПРИМЕР:     Tstr := Get_Environment( 'ME_PATH=' );

^BREST_DOS_SCREEN  процедура^b

    ДЕЙСТВИЕ:   восстанавливает на экране изображение,
                предшествовавшее загрузке редактора Multi-Edit или при
                последнем выполнении SAVE_DOS_SCREEN.

    ПРИМЕР:     (См. SAVE_DOS_SCREEN)

^BSAVE_DOS_SCREEN  процедура^b

    ДЕЙСТВИЕ:   сохраняет текущее состояние экрана.

    ПРИМЕР:     {Восстановить предыдущее изображение}
                RESTORE_DOS_SCREEN;
                   {Выполнить командный файл}
                SHELL_TO_DOS( 'MAKE_LST', TRUE );
                   {Сохранить экран}
                SAVE_DOS_SCREEN;

^BDATE  строковая функция^b

    ВОЗВРАЩАЕТ: строку, содержащую текущую дату в формате: мм/дд/чч.

    ПРИМЕР:        {Вставить дату}
                Text('Дата этого документа:' + Date);

^BTIME  строковая функция^b

    ВОЗВРАЩАЕТ: строку, содержащую текущее время в формате: чч/мм/сс
                (am - до полудня или pm - после полудня).

    ПРИМЕР:     {Приветствие}
                IF Time = '07:35:00am' THEN
                   Beep;
                   Make_Message('Доброе утро тов.Найдек!');
                END;

^BME_PATH  строковая функция^b

    ВОЗВРАЩАЕТ: строку, содержащую путь доступа к оверлейным файлам
                Multi-Edit.

^BQUIT( Код )  процедура^b

    ДЕЙСТВИЕ:   выход из Multi-Edit. Код - это целый код возврата,
                который может быть вычислен с помощью операции DOS
                ERRORLEVEL. Помните, что если в текущем файле были
                сделаны изменения и файл не был сохранен на диске, то
                информация будет потеряна.

    ПРИМЕР:        {Сохранить текущий файл}
                Save_File;
                   {Если ошибок нет, то конец}
                IF Error_Level = 0 THEN
                   Quit;
                END;

^BPARAM_COUNT  целая функция^b

    ВОЗВРАЩАЕТ: число параметров командной строки при вызове редактора
                из ДОС.

    ПРИМЕР:     (См. PARAM_STR)

^BPARAM_STR( Число )  строковая функция^b

    ВОЗВРАЩАЕТ: строку, содержащую заданное Число параметров командной
                строки при вызове Multi-Edit.

    ПРИМЕР:        {Прочитать первый параметр командной строки,
                    если бы он был}
                IF Param_Count > 0 THEN
                   Test_Parameter := Param_Str(1);
                END;

^BDOS_VERSION  целая функция^b

    ВОЗВРАЩАЕТ: целое, содержащее номер версии ДОС в формате:
                младший байт = основной номер версии;
                старший байт = дополнительный номер версии.

    ПРИМЕР:     {вывести номер версии ДОС}
                JX := DOS_VERSION;
                JL := JX AND $00FF;
                JH := JX SHR 8;
                Make_Message('Версия ДОС = ' + Str(JL) + '.' +
                             Str(JH));

                {Если JX = 2003, cледовательно ДОС версии 3.20}

^BDOS_BACK  целая функция^b

    ВОЗВРАЩАЕТ: цвет основы, который использован перед запуском Multi
                - Edit.

^BDOS_COLOR  целая функция^b

    ВОЗВРАЩАЕТ: цвет символов, который использовался перед запуском
                Mult-Edit.

^BCHANGE_DIR( путь )  процедура^b

    ДЕЙСТВИЕ:   изменяет текущую директорию (выход в ДОС не
                требуется). При возникновении ошибки ERROR-LEVEL будет
                ненулевой.

    ПРИМЕР:     Change_Dir( '\DOCUMENT' );
                IF Error_Level <> 0 THEN
                  Make_Message( 'Ошибка изменения директории' );
                  Error_Level := 0;
                END;

^BDEL_FILE( имя_файла )  процедура^b

    ДЕЙСТВИЕ:   удаляет заданный файл (выход в ДОС не требуется). При
                возникновении ошибки ERROR_LEVEL будет ненулевой.

^BWRITE_SOD( строка )  процедура^b

    ДЕЙСТВИЕ:   выводит Строку на стандартное устройство вывода.

    ПРИМЕР:     {Вывести сообщение CR/LF}
                Write_SOD( 'Поздравляю!|13|10' );

См.также @MACHOP[СВЯЗЬ НА МАМШИННОМ УРОВНЕ]

MACHOP СВЯЗЬ НА МАШИННОМ УРОВНЕ

^BINTR( номер_прерывания)  процедура^b

    ДЕЙСТВИЕ:   выполняет прерывание программы. Передает результаты в
                регистровые переменные, перечисленные ниже. Возвращает
                результаты в тех же переменных.

^BR_AX, R_BX, R_CX, R_DX, R_SI, R_DI, R_DS, R_ES, R_FLAGS  целые
переменные^b

                Регистровые переменные, используемые INTR.
                Используются только младшие 16 битов каждой
                переменной.

^BCPU  целая функция^b

    ВОЗВРАЩАЕТ: тип процессора 0 = 8086/8088
                1 = 80186/80188
                2 = 80286
                3 = 80386


^BMEMB( Адрес,Значение )  процедура^b

    ДЕЙСТВИЕ:   устанавливает по заданному ^ВАдресу^b в заданное
                Значение. ^ВАдрес^b - зто 32-битовое целое число,
                которое содержит сегмент (старшее слово) и смещение
                (младшее слово). Над адресом могут выполняться
                арифметические операции в тех границах, пока изменение
                смещения не приведет к изменению сегмента.

^BMEMW( Адрес,Значение)  процедура^b

    ДЕЙСТВИЕ:   устанавливает слово по заданному ^ВАдресу^b в заданное
^ВЗначение^b.

^BMEMP( Адрес, Значение)  процедура^b

    ДЕЙСТВИЕ:   устанавливает указатель (32-битовое целое, состоящее
                из сегмента и смещения) по заданному ^ВАдресу^b в
                заданное ^ВЗначение^b.

^BMEMB( Адрес )  целая функция^b

    ВОЗВРАЩАЕТ: значение байта по заданному ^ВАдресу^b.

^BMEMW( Адрес )  целая функция^b

    ВОЗВРАЩАЕТ: значение слова по заданному ^ВАдресу^b.

^BMEMP( Адрес )  целая функция^b

    ВОЗВРАЩАЕТ: значение указателя по заданному ^ВАдресу^b.

^BMEMSTR( Адрес, Число )  строковая функция^b

    ВОЗВРАЩАЕТ: строку, состоящую из заданного ^ВЧисла^b символов
                (байтов), начиная с заданного ^ВАдреса^b.

^BPOKE( Cегмент, Смещение, Значение )  процедура^b

    ДЕЙСТВИЕ:   устанавливает байт по адресу ^ВСегмент:Смещение^b в
                заданное Значение. Эта процедура определена для
                компьютеров с 8086-процессором. Для ЭВМ других типов и
                архитектур лучше использовать MEMB, MENW и MEMP.

^BPEEK( Сегмент, Смещение )  целая функция^b

    ВОЗВРАЩАЕТ: байт с адресом ^ВСегмент:Смещение^b. Эта процедура
                также определена для компьютеров с 8086-процессором.

^BSEG( локальная_переменная )  целая функция^b

    ВОЗВРАЩАЕТ: сегмент адреса передаваемой локальной переменной
                любого типа.

^BOFS( локальная_переменная )  целая функция^b

    ВОЗВРАЩАЕТ: смещение адреса передаваемой локальной переменной
                любого типа.

WPOP ОПЕРАЦИИ ОБРАБОТКИ СЛОВ

^BWORD_WRAP_LINE  процедура^b

    ДЕЙСТВИЕ:   начало процесса переноса непомещающихся слов на новую
                строку, начиная с текущей строки. Используется для
                переформатирования строки или абзаца.

^BC_PAGE  целая функция^b

    ВОЗВРАЩАЕТ: номер текущей страницы, начиная с 1. Используется в
                режиме "Документ".

^BPG_LINE  целая функция^b

    ВОЗВРАЩАЕТ: номер строки, но не номер строки в файле, а смещение
                относительно начала текущей страницы. Используется в
                режиме "Документ".

^BFORMAT_LINE  строковая переменная^b.

        Строка форматирования для текущего файла до 2048 символов. Для
        представлений позиции табуляции используется символ с кодом
        16. Для указания правой границы строки может быть вставлен
        символ "R" (См. переменную RIGHT_MARGIN). Другие символы в
        строке форматирования не используются.

^BFORMAT_STAT  целая переменная^b

        TRUE (1) = сохранить строку форматирования файла вместе с
                   файлом
        FALSE (0) = не сохранять строку форматирования файла вместе с
                    файлом

^BWRAP_STAT  целая переменная^b

        TRUE (1) = в текущем окне производится перенос непомещающихся
                   слов на другую строку
        FALSE (0) = в текущем окне не производится перенос
                    непомещающихся слов на другую строку

^BDOC_MODE  целая переменная^b

        TRUE (1) = Multi-Edit в режиме "Документ".
        FALSE (0) = Multi-Edit в режиме "Редактор".

^BRIGHT_MARGIN  целая переменная^b

        Правая граница строк в текущем файле. Используется для
        переноса непомещающихся в строке слов.

^BINDENT_STYLE  целая переменная^b

        Тип отступа для текущего файла:
        0 = ручной отступ
        1 = автоматический отступ
        2 = "интеллектуальный" авто-отступ.

DOSSHELLOP ОПЕРАЦИИ ПРИ ВЫХОДЕ В ДОС

^BOPEN_DIR( Число_дир)  процедура^b

    ДЕЙСТВИЕ:   открывает окно директории. Число_дир должно быть от 1
                до 5.

^BCLOSE_DIR( Число_дир)  процедура^b

    ДЕЙСТВИЕ:   закрывает окно директории. Число_дир должно быть от 1
                до 5.

^BSWITCH_DIR( Число_дир)  процедура^b

    ДЕЙСТВИЕ:   активизирует окно директории. Число_дир должно быть от
                1 до 5.

^BDIR_ACTIVE( Число_дир )  целая функция^b

    ВОЗВРАЩАЕТ: TRUE, если директория открыта.

^BDIR_MODE  целая переменная^b
                0 = полное представление директории
                1 = широкое, в нескольких колонках представление
                    директории.

^BDIR( Строка_дир )  процедура^b

    ДЕЙСТВИЕ:   представляет файлы, определенные в Строке_дир.

    ПРИМЕР:        {Выход в ДОС}
                        Enter_Dos_Shell;
                           {Ввести директорию}
                        Dir( C:\TEST\*.* );

^BDOS_UP  процедура^b

    ДЕЙСТВИЕ:   перемещает курсор ДОС вверх на одно имя файла.

^BDOS_DOWN  процедура^b

    ДЕЙСТВИЕ:   перемещает курсор ДОС вниз на одно имя файла.

^BDOS_RIGHT  процедура^b

    ДЕЙСТВИЕ:   перемещает курсор на вход следующей директории.

^BDOS_LEFT  процедура^b
    ДЕЙСТВИЕ:   перемещает курсор на вход предыдущей директории.

^BDOS_TOF  процедура^b

    ДЕЙСТВИЕ:   перемещает курсор каталога в начало списка директории.

^BUPDATE_DIR  процедура^b

    ДЕЙСТВИЕ:   приводит к корректировке списка каталога.


^BDIR_MASK  строковая функция^b

    ВОЗВРАЩАЕТ: строку, содержащую полный путь директории (включая
                любые символы), которая демонстрируется.

^BDIR_ENTRY  строковая функция^b

    ВОЗВРАЩАЕТ: строку, содержащую строку имя текущего файла, на
                котором находится курсор в списке директории.

^BDIR_NUM  целая функция^b

    ВОЗВРАЩАЕТ: номер файла в списке директории, на котором находится
                курсор.

^BDIR_TOTAL  целая функция^b

    ВОЗВРАЩАЕТ: общее число входов в список текущей директории,
                включая  '.' и '..'.

^BDIR_PATH  строковая функция^b

    ВОЗВРАЩАЕТ: строку, содержащую  путь текущей директории.

    ПРИМЕР:     IF Dir_Path = 'A:\TEST\*.*' THEN
                           Dir('A:\TEST\TEXT\*.TXT');
                        END;

^BFILE_MARKED  целая функция^b

    ВОЗВРАЩАЕТ: True, если файл, на котором находится курсор, уже
                отмечен.

^BMARK_FILE  процедура^b

    ДЕЙСТВИЕ:   изменяет состояние отмеченного файла.

^BDOS_FILE_ATTR  целая функция^b

    ВОЗВРАЩАЕТ: атрибут отмеченного файла:

                                $01 = только для чтения
                                $02 = скрытый
                                $04 = системный файл
                                $08 = метка диска
                                $10 = директория
                                $20 = архив

KEYOP НАЗНАЧЕНИЯ КЛАВИШ

^BMACRO_TO_KEY( Код, Макрос, Режим )  процедура^b

    ДЕЙСТВИЕ:   связывает Макрос с заданной клавишей определенной
                Кодом для заданного режима редактора. При нажатии этой
                клавиши Multi-Edit будет выполнять Макрос так, как
                если бы запускалась функция Run-Macro. Код - это любой
                допустимый код клавиши или группы клавиш.
                (См. @KEYSYNTAX[СИНТАКСИС РАСШИРЕННЫХ КЛАВИШ] для
                полного списка кодовых констант.
                Макрос - это строка, содержащая имя макроса,
                необязательные имя файла с макросом и параметры:

                        Имя_файла^^Имя_макроса Строка_параметров

                Символ ^B^^^b разделяет Имя_файла с макросом и
                Имя_макроса, а пробел разделяет Имя_макроса и Строку
                параметров.
                Режим - это режим редактора EDIT, DOS_SHELL или ALL
                  (См.@PREDCONST[Предопределенные КОНСТАНТЫ] и @MACROSTRUCT[структура MACRO])

    ПРИМЕР:     MACRO_TO_KEY( <AltF9>, 'RUNPROG', Edit);

^BCMD_TO_KEY( Код, Команда, Режим )  процедура^b

    ДЕЙСТВИЕ:   аналогично MACRO_TO_KEY за исключением того, что
                клавиша связывается не с именем макроса, а с
                Командой. Полный список допустимых имен команд
                приведен  в @KEYCOMMANDS[КОМАНДЫ, СВЯЗЫВАЕМЫЕ С КЛАВИШАМИ].

    ПРИМЕР:       {Связать команду WORD_RIGHT с клавишами
                   Ctrl+Курсор-вправо в режиме EDIT}
                CMD_TO_KEY( <CtrlRT>, WORD_RIGHT, Edit);

^BUNASSIGN_KEY( Код, Режим )  процедура^b

    ДЕЙСТВИЕ:   отменяет связывание заданной клавиши в заданном режиме
                с любым макросом или командой.


^BINQ_KEY( код1, код2, режим ) строковая функция^b

    ВОЗВРАЩАЕТ: строку, содержащую имя макроса, связанного с клавишей,
                имеющей заданный код (код1, код2). Если INQ_KEY
                возвращает пустую строку, то клавиша не связана.
См.также @KEYSYNTAX[СИНТАКСИС РАСШИРЕННЫХ КЛАВИШ]

KEYMACOP МАКРОСЫ НАЖАТИЙ КЛАВИШ

^BKEY_IN( Строка_нажатий_клавиш) процедура^b

Используется для передачи нажатий клавиш в редактор. Строка_нажатий
_клавиш записывается без кавычек.

    ПРИМЕР:
                        KEY_IN(That is TEXT string <ENTER>);

будет вводить строку, заканчивающуюся символом перевода каретки.
Строки нажатий клавиш смогут заключать в себе любое число строк.
^B**^b К сожалению компилятор ME не разрешает вводить руские буквы в KEY_IN.

^BPLAY_KEY_MACRO( kод1, kод2 )  процедура^b

    ДЕЙСТВИЕ:   запускает макрос, связанный с клавишей, имеющей код
                (код1, код2). Для чтения присвоений используются
                READ_KEY или CHECK_KEY.

^BKEY_RECORD  процедура^b

    ДЕЙСТВИЕ:   запускает или останавливает запись макроса нажатий
                клавиш.

См.также @KEYSYNTAX[СИНТАКСИС РАСШИРЕННЫХ КЛАВИШ]
??? @>MEMENUS[Запуск меню Multi-Edit]
KEYSYNTAX ║Name           ║  Code      │     <Shft..>    │   <Ctrl..>   │Alt..
         ---------------------------------
         ^B СИНТАКСИС РАСШИРЕННЫХ КОДОВ КЛАВИШ^b
         ---------------------------------

Название кодов клавиш образуется путем указания наименования клавиши
и дополнительного префикса Shft, Ctrl, или Alt. Например:

       <F1>   <ShftF1> <CtrlF1> <AltF1>
        a     <ShftA>  <CtrlA>  <AltA>

Имена клавиш "чувствительны" к регистру символов. Так, если вы
хотите связать макрос или команду с большой буквой А, вы должны
указать <Shfta> или <A> , а с малой - <a> .
╔═══════════════╦════════════╤═════════════════╤══════════════╤════════════╗
║Name           ║  Code      │     <Shft..>    │   <Ctrl..>   │    <Alt..> ║
╠═══════════════╬════════════╪═════════════════╪══════════════╪════════════╣
║<F1>           ║   0, 59    │      0, 84      │    0, 94     │     0, 104 ║
║<F2>           ║   0, 60    │      0, 85      │    0, 95     │     0, 106 ║
║<F3>           ║   0, 61    │      0, 86      │    0, 96     │     0, 106 ║
║<F4>           ║   0, 62    │      0, 87      │    0, 97     │     0, 107 ║
║<F5>           ║   0, 63    │      0, 88      │    0, 98     │     0, 108 ║
║<F6>           ║   0, 64    │      0, 89      │    0, 99     │     0, 109 ║
║<F7>           ║   0, 65    │      0, 90      │    0, 100    │     0, 110 ║
║<F8>           ║   0, 66    │      0, 91      │    0, 101    │     0, 111 ║
║<F9>           ║   0, 67    │      0, 92      │    0, 102    │     0, 112 ║
║<F10>          ║   0, 68    │      0, 93      │    0, 103    │     0, 113 ║
║<F11>          ║   0, 133   │      0, 135     │    0, 137    │     0, 139 ║
║<F12>          ║   0, 134   │      0, 136     │    0, 138    │     0, 140 ║
║<ENTER>        ║  13, 28    │     ------      │   10, 28     │     0, 28  ║
║<TAB>          ║   9, 15    │      0, 15      │    0, 148    │     0, 165 ║
║<ESC>          ║  27, 1     │     ------      │   ------     │     0, 1   ║
║<BS>           ║   8, 14    │     ------      │  127, 14     │     0, 14  ║
║<UP>           ║   0, 72    │     56, 72      │    0, 141    │    ------  ║
║<DN>           ║   0, 80    │     50, 80      │    0, 145    │    ------  ║
║<LF>           ║   0, 75    │     52, 75      │    0, 115    │    ------  ║
║<RT>           ║   0, 77    │     54, 77      │    0, 116    │    ------  ║
║<PGUP>         ║   0, 73    │     57, 73      │    0, 132    │    ------  ║
║<PGDN>         ║   0, 81    │     51, 81      │    0, 118    │    ------  ║
║<INS>          ║   0, 82    │     48, 82      │    0, 146    │    ------  ║
║<DEL>          ║   0, 83    │     46, 83      │    0, 147    │    ------  ║
║               ║            │                 │              │            ║
║<GREY->        ║  45, 74    │     ------      │    0, 142    │     0, 74  ║
║<GREY+>        ║  43, 78    │     ------      │    0, 144    │     0, 78  ║
║<GREY*>        ║  42, 55    │     ------      │    0, 150    │     0, 55  ║
║<GREY/>        ║  47, 224   │     ------      │    0, 149    │     0, 164 ║
║<GreyENTER>    ║  13, 224   │     ------      │   10, 224    │     0, 166 ║
║<ScrollLockOn> ║   0, 238   │     ------      │   -------    │    ------- ║
║<ScrollLockOff>║   0, 239   │     ------      │   -------    │    ------- ║
║               ║            │                 │              │            ║
║<a>            ║  97, 30    │     65, 30      │    1, 30     │     0, 30  ║
║<b>            ║  98, 48    │     66, 48      │    2, 48     │     0, 48  ║
║<c>            ║  99, 46    │     67, 46      │    3, 46     │     0, 46  ║
║<d>            ║ 100, 32    │     68, 32      │    4, 32     │     0, 32  ║
║<e>            ║ 101, 18    │     69, 18      │    5, 18     │     0, 18  ║
║<f>            ║ 102, 33    │     70, 33      │    6, 33     │     0, 33  ║
║<g>            ║ 103, 34    │     71, 34      │    7, 34     │     0, 34  ║
║<h>            ║ 104, 35    │     72, 35      │    8, 35     │     0, 35  ║
║<i>            ║ 105, 23    │     73, 23      │    9, 23     │     0, 23  ║
║<j>            ║ 106, 36    │     74, 36      │   10, 36     │     0, 36  ║
║<k>            ║ 107, 37    │     75, 37      │   11, 37     │     0, 37  ║
║<l>            ║ 108, 38    │     76, 38      │   12, 38     │     0, 38  ║
║<m>            ║ 109, 50    │     77, 50      │   13, 50     │     0, 50  ║
║<o>            ║ 111, 24    │     79, 24      │   15, 24     │     0, 24  ║
║<p>            ║ 112, 25    │     80, 25      │   16, 25     │     0, 25  ║
║<q>            ║ 113, 16    │     81, 16      │   17, 16     │     0, 16  ║
║<r>            ║ 114, 19    │     82, 19      │   18, 19     │     0, 19  ║
║<s>            ║ 115, 31    │     83, 31      │   19, 31     │     0, 31  ║
║<t>            ║ 116, 20    │     84, 20      │   20, 20     │     0, 20  ║
║<u>            ║ 117, 22    │     85, 22      │   21, 22     │     0, 22  ║
║<v>            ║ 118, 47    │     86, 47      │   22, 47     │     0, 47  ║
║<w>            ║ 119, 17    │     87, 17      │   23, 17     │     0, 17  ║
║<x>            ║ 120, 45    │     88, 45      │   24, 45     │     0, 45  ║
║<y>            ║ 121, 21    │     89, 21      │   25, 21     │     0, 21  ║
║<z>            ║ 122, 44    │     90, 44      │   26, 44     │     0, 44  ║
║<`>            ║  96, 41    │ <~>126, 41      │   ------     │     0, 41  ║
║<1>            ║  49, 2     │ <!> 33, 2       │   ------     │     0, 120 ║
║<2>            ║  50, 3     │ <@@> 64, 3       │    0, 3      │     0, 121 ║
║<3>            ║  51, 4     │ <#> 35, 4       │   ------     │     0, 122 ║
║<4>            ║  52, 5     │ <$> 36, 5       │   ------     │     0, 123 ║
║<5>            ║  53, 6     │ <%> 37, 6       │   ------     │     0, 124 ║
║<6>            ║  54, 7     │ <^^> 94, 7       │   30, 7      │     0, 125 ║
║<7>            ║  55, 8     │ <&> 38, 8       │   ------     │     0, 126 ║
║<8>            ║  56, 9     │ <*> 42, 9       │   ------     │     0, 127 ║
║<9>            ║  57, 10    │ <(> 40, 10      │   ------     │     0, 128 ║
║<0>            ║  48, 11    │ <)> 41, 11      │   ------     │     0, 129 ║
║<->            ║  45, 12    │ <_> 95, 12      │   31, 12     │     0, 130 ║
║<=>            ║  61, 13    │ <+> 43, 13      │   ------     │     0, 131 ║
║<\>            ║  92, 43    │ <|>124, 43      │   28, 43     │     0, 43  ║
║<[>            ║  91, 26    │ <{>123, 26      │   27, 26     │     0, 26  ║
║<]>            ║  93, 27    │ <}>125, 27      │   29, 27     │     0, 27  ║
║<;>            ║  59, 39    │ <:> 58, 39      │   ------     │     0, 40  ║
║<,>            ║  44, 51    │ <"> 60, 51      │   ------     │     0, 51  ║
║<.>            ║  46, 52    │ <<> 62, 52      │   ------     │     0, 52  ║
║</>            ║  47, 53    │ <>> 63, 53      │   ------     │     0, 53  ║
║               ║            │                 │              │            ║
╚═══════════════╩════════════╧═════════════════╧══════════════╧════════════╝

Кнопки и движения "мыши" тоже имеют коды:

 <MsUP> { "мышь" ввеpх}                    0, 240
 <MsDN> { "мышь" вниз }                    0, 241
 <MsLF> { "мышь" влево}                    0, 242
 <MsRT> { "мышь" вправо}                   0, 243
 <Btn0> { левая кнопка "мышь" }            0, 244
 <Btn1> { правая кнопка "мышь" }           0, 245
 <Btn2> { средняя кнопка "мышь" }          0, 246

KEYCOMMANDS КОМАНДЫ, СВЯЗЫВАЕМЫЕ С КЛАВИШАМИ
Данные команды можно непосредственно назначать для клавиш @KEYOP%CMD_TO_KEY[CMD_TO_KEY].

CR                      TAB_LEFT                MODIFY_WINDOW      ^B*+^b
LEFT                    TAB_RIGHT               UNLINK_WINDOW
RIGHT                   INDENT                  CREATE_WINDOW
UP                      UNDENT                  ENTER_DOS_SHELL    ^B*-^b
DOWN                    DEL_CHAR                CALCULATOR         ^B*-^b
HOME                    DEL_LINE                QUIT               ^B*+^b
EOL                     BACK_SPACE              REDRAW
PAGE_UP                 UNDO                    NEW_SCREEN
PAGE_DOWN               BLOCK_BEGIN             REST_DOS_SCREEN    ^B*+^b
TOF                     BLOCK_END               SAVE_DOS_SCREEN    ^B*+^b
EOF                     COL_BLOCK_BEGIN         KEY_RECORD
NEXT_PAGE_BREAK         COL_BLOCK_END    ^B*-^b     PUSH_UNDO
LAST_PAGE_BREAK         COPY_BLOCK              POP_UNDO
WORD_LEFT               MOVE_BLOCK              DELETE_WINDOW
WORD_RIGHT              DELETE_BLOCK            ERASE_WINDOW
MARK_POS                BLOCK_OFF               ZOOM               ^B*-^b
GOTO_MARK               SAVE_FILE               FIRST_WORD
 ^B*-^b - В ME 4.00a - нет такой команды (см @MAC_CMND.HLP^*[СПИСОК КОМАНД ME 4.00a]).
 ^B*+^b - Команда существует, но не годится для (см. @MAC_CMND.HLP^**[КОМАНДЫ в CMD_TO_KEY]).
MISCOP ДРУГИЕ ОПЕРАЦИИ

^BBEEP  процедура^b

    ДЕЙСТВИЕ:   звуковое предупреждение!

    ПРИМЕР:        {Если возникла ошибка, то сигнал}
                   IF Error_Level <> 0 THEN
                      Beep;
                   END;

^BDELAY( Время )  процедура^b

    ДЕЙСТВИЕ:   задержка на заданное время (в миллисекундах)

    ПРИМЕР:       {Подождать 1/10 секунды}
                Delay( 100 );

^BNOT( целое )  целая функция^b

    ВОЗВРАЩАЕТ: если целое не нулевое, то возвращает 0.
                Если целое равно 0, то возвращает 1.
                (Используется для функции TRUE/FALSE)

^BMODE  целая функция^b

    ВОЗВРАЩАЕТ: целое, соответствующее текущему режиму или
                используемому модулю:

                        0 =  Редактор текстов (Text Editor)
                        1 =  Выход в ДОС (DOS Shell)
                        2 =  (пока не определен)
                        3 =  Коммуникационный модуль.

    ПРИМЕР:     IF Me_Mode = 1 THEN
                   EXIT_DOS_SHELL;
                END;
^BPRINT_STR( Строка )  процедура^b

    ДЕЙСТВИЕ:   посылает Строку на устройство PRN (обычно, принтер).
                Код ошибки доступен через функцию ERROR_LEVEL.(См.
                @ERRORS[ОШИБКИ МАНИПУЛИРОВАНИЯ])

    ПРИМЕР:     Goto_Line(10);
                Goto_Col(1);
                Print_String(Get_Word(''));

^BPRINT_MARGIN  целая переменная^b

        Установленная граница для печати файла или блока.

^BVERSION  строковая функция^b

    ВОЗВРАЩАЕТ: строку, содержащую номер версии Multi-Edit.

^BUSER_ID  строковая функция^b

        Строка (от 0 до 3 символов), содержащая идентификационный код
        для использования в сетях. См.
        @ME.HLP^NETWORK[ПОДДЕРЖКА СЕТЕЙ].

^BMOUSE  целая переменная^b

        Включает (1) и выключает (0) функции "мыши".

^BLOGO_SCREEN  целая переменная^b

        Эффективна только при включении SAVE_SETUP. Установка
        LOGO_SCREEN в 0 приводит к последующему обходу логического
        экрана в последующих сеансах редактора.

^BMOUSE_H_SENSE  целая переменная^b

        Чувствительность "мыши" по-горизонтали. Большее число
        соответствует меньшей чувствительности "мыши".

^BMOUSE_V_SENSE  целая переменная^b

        Чувствительность "мыши" по-вертикали. Большее число
        соответствует меньшей чувствительности "мыши".

^BINIT_VIDEO_MODE  целая переменная^b

        Используется только в макросе INIT для установки начального
        видео режима. Значения такие же как и в функции VIDEO_MODE.

^BEMS_STAT  целая переменная^b

        Бит 0 :  1 = использовать EMS для хранения данных
                 0 = не использовать EMS для хранения данных.
        Бит 1 :  1 = подгружать EMS при @DOSOP%SHELL_TO_DOS[выполнение
                     других программ]
                 0 = не подгружать EMS.
        ПРИМЕР:
                  {Отключить подгрузку EMS}
                EMS_Stat := EMS_Stat AND $FD;

COLORS ЦВЕТА
Ниже перечислены целые системные переменные, содержащие данные о цвете
символов (первые 4 бита) и цвете основы (вторые 4 бита):

        W_T_COLOR       По умолчанию цвет текста в окне
        W_H_COLOR       По умолчанию цвет выделенного текста в окне
        W_B_COLOR       По умолчанию цвет границы окна
        W_C_COLOR       По умолчанию цвет изменяемого текста в окне
        W_S_COLOR       По умолчанию цвет состояния окна
        W_EOF_COLOR     По умолчанию цвет маркера конца файла

        M_T_COLOR       Цвет текста меню
        M_S_COLOR       Цвет состояния меню
        M_B_COLOR       Цвет границы меню
        M_H_COLOR       Цвет выделенного текста меню

        D_T_COLOR       Цвет текста при выходе в ДОС
        D_S_COLOR       Цвет состояния при выходе в ДОС
        D_B_COLOR       Цвет границы при выходе в ДОС
        D_H_COLOR       Цвет выделенного текста при выходе в ДОС

        H_T_COLOR       Цвет текста помощи
        H_S_COLOR       Цвет состояния помощи
        H_B_COLOR       Цвет границы помощи
        H_H_COLOR       Цвет выделенного текста помощи
        H_R_COLOR       Цвет индексов помощи
        H_F_COLOR       Цвет функциональных клавиш помощи
        H_T1_Color      Цвет атрибута 1 определяемого текста
        H_T2_Color      Цвет атрибута 2 определяемого текста
        H_T3_Color      Цвет атрибута 3 определяемого текста

        FKEY_COLOR      Цвет меток функциональных клавиш
        FNUM_COLOR      Цвет номера функциональной клавиши
        STAT1_COLOR     Цвет строки состояния
        STAT2_COLOR     Цвет выделенных элементов строки состояния
        MESSAGE_COLOR   Цвет строки сообщений
        WORKING_COLOR   Цвет индикатора "Работа"
        ERROR_COLOR     Цвет индикации ошибок
        SHADOW_COLOR    Цвет тени
        SHADOW_CHAR     Символ для тени

Каждое окно имеет собственный набор атрибутов. Они доступны с помощью
системных переменных макро-языка:

        T_Color         цвет текста
        B_Color         цвет границы
        S_Color         цвет состояния
        C_Color         цвет изменения
        H_Color         цвет выделения
        EOF_COLOR       цвет маркера конца файла

        Системная переменная Window_Color_Stat используется для
        определения какой набор цветов (собственный или по-умолчанию)
        используется в окне. Если вы используете собственные цвета, то
        установите эту переменную в TRUE. Это будет предотвращать
        замену ваших цветов с помощью макроса Color Setup.

См. @PREDCONST[ПРЕДОПРЕДЕЛЕННЫЕ КОНСТАНТЫ] со списком дополнительных
цветов.

ERRORS ОШИБКИ МАНИПУЛИРОВАНИЯ
Большинство  операций,  такие  как  операции  с  файлами, могут генерировать
сообщения  об  ошибках.  Эти  операции  присваивают  переменной  ERROR_LEVEL
код  ошибки  (эта  переменная  относится  к  редактору Multi-Edit и не имеет
отношения   к   функции   ДОС   ERROR_LEVEL).   Если   код   ошибки   =   0,
следовательно ошибки не произошло.

Всякий  раз  когда  выполняется  операция  ,  при  которой  может возникнуть
ошибка,  переменная  ERROR_LEVEL  проверяется  на  ненулевое  значение.  При
обнаружении  ненулевого   значения  ошибка   обрабатывается  и    переменная
ERROR_LEVEL   снова  устанавливается  в  0.  Для  вывода  всей   необходимой
информации в строку сообщений может быть запущен макрос ME_ERROR.


    ПРИМЕР:
        {Загрузить файл}
        Load_File('C:\ME\INIT.SRC');
        {Если ошибка, то запуск ME-ERROR и выход}
        IF Error_Level <> 0 THEN
          Run_Macro('MEERROR');
          Goto EXIT;
        END;

^BERROR_LEVEL  целая переменная^b
        Целая переменная, содержащая код последней ошибки.

                     ^BКоды ошибок в Multi-Edit^b

1001    Нельзя открыть окно. СREATE_WINDOW вызвана тогда, когда уже
        существует 100 окон.

1002    Не хватает памяти для завершения операции.

1003    Достигнута максимальная длина строки (2048 символов).

1004    Операция не поддерживается.

1006    Неправильный числовой ввод.
                При числовом вводе был введен нечисловой символ или
                число, превышающее допустимые границы.

1007    ME.HLP не найден.
        Операция HELP не нашла файл ME.HLP.

1010    Неправильная строка поиска.
                Были вызваны SEARCH_FWD или SEARCH_BWD при
                неправильном синтаксисе регулярного выражения.

1011    Входной файл не найден.
                Было выполнено SAVE_FILE, но исходный файл не найден.
                Такая ситуация возникает тогда, когда файл был удален
                из DOS SHELL.

1012    Файл отмечен только для чтения.
                Вы стремитесь сохранить фамйл, предназначенный только
                для чтения.

1013    Запись, прерванная пользователем.
                Возникает только тогда, когда возникла ошибка нехватки
                пространства на диске и пользователь прервал операцию.

1015    Oперация, прерванная пользователем.
                Возникает тогда, когда операция прервана нажатием
                клавиш <Ctrl Break>.

1016    Не хватает памяти для UNDO-буфера.
                Mожет возникнуть, если для сохранения изменяемого
                текста не хватает свободной памяти в UNDO-буфере.

1017    Ошибка записи резервного файла.
                Обычно возникает тогда, когда директория, выделенная
                для резервных файлов, не создана.

1030    Неправильный номер окна директории.
                Возникает тогда, когда операция DOS Directory Shell
                была выполнена с неправильным номером окна.

1031    Окно директории не открыто.
                Возникает тогда, когда операция DOS Directory shell
                была выполнена при не открытом еще окне.

2002    Принтер не готов.

3002    Файл не найден. Эту ошибку генерирует LOAD_FILE.

3003    Путь доступа не найден.

3005    Доступ невозможен.

3007    Блоки управления памятью испорчены.

3008    Не хватает памяти.
                Эту ошибку может генерировать SHELL_TO_DOS.

3010    Неправильное окружение (оборудование).

3015    Неправильное имя дисковвода.

3018    Файлов больше нет.
                Эту ошибку может порождать FIRST_FILE и NEXT_FILE.

3021    Дисковод не готов.

3031    Общий отказ.

3150    Защищено от записи.

3152    Устройство не готово.

3153    Неизвестная команда (ошибка ДОС).

3154    Ошибка данных.

3158    Сектор не найден.

3159    Нет бумаги в принтере.

3160    Не записано.

3161    Не прочитано.

3162    Общий отказ.

3241    Диск полон.
                Эту ошибку может генерировать SAVE_FILE.

5001    Макрос не найден.
                Multi-Edit не может найти .МАС-файл.

5005    Загружается макрос несовместимой версии.
                Возникает при попытке загрузить макрос,
                скомпилированный ранней версией макро-компилятора.

RUNERRORS ОШИБКИ ВЫПОЛНЕНИЯ
При возникновении ошибки выполнения на экране появляется окно, куда
выводится имя макроса, в котором обнаружена ошибка и содержимое
программного счетчика (в шестнадцатиричной форме). Для нахождения
положения выполнения вам нужно вызвать компилятор следующей командной
строкой:

                MEMAC Имя_файла -DПр Си Имя_макроса

    ПРИМЕР:
                MEMAC LANGUAGE -D002A TEMPLATE

В этом примере ищется ошибка выполнения со значением программного
счетчика (Пр Си) 002А в макросе TEMPLATE в исходном файле
LANGUAGE.SRC.

                      ^КОДЫ ОШИБОК ВЫПОЛНЕНИЯ^b

02      Попытка RET без соответствующего CALL.
                Возникает , если CALL-стек пуст. Может возникнуть,
                если макрос обращается по GOTO к процедуре,
                завершенной с помощью RET.

03      Деление на нуль.

04      Неправильное преобразование действительного в целое.
                Возникает, если результат функции R_INT выходит за
                границы (-32768, 32767).

05      Попытка вложения более , чем 10 клавишных макросов.
                Может возникнуть тогда, когда KEY-IN активизирует
                макрос, выполняющий оператор KEY_IN, активизирующий
                ... и т.д. 10 уровней вложенности.

07      Неверный код макроса.
                Может возникнуть только по вашей вине!

101     Ошибка загрузки макроса с диска.

102,103,104
        Недостаточно памяти.

COMPERRORS ОШИБКИ КОМПИЛЯЦИИ

Формат сообщения об ошибке компиляции:

                Имя_файла(Стр, Стб): ERROR номер: сообщение

    ПРИМЕР:
                LANGUAGE.SRC(92,22): ERROR 1: Syntax Error: 'THIN'

                      КОДЫ ОШИБОК КОМПИЛЯЦИИ

01      Syntax Error: <оператор>.
                Компилятор не понимает этот оператор

02      <разделитель> expected.
                Должен быть разделитель (скобка,запятая и т.п.), но
                его нет.

04      ; expected.
                Должна быть точка с запятой, но ее нет.

05      Label to long.
                Метка длиной более 20 символов.

06      Too many labels.
                В макросе задано более 500 меток.

07      '(' expected.
                Должна быть левая скобка.

08      ',' expected.
                Должна быть запятая.

09      ')' expected.
                Должна быть правая скобка.

10      Duplicate label.
                Метки в макросе не должны повторяться.

13      Variable expected.
                Должна быть переменная (не константа, или
                выражение).

14      Label <имя метки> not found.
                Метка, на которую есть ссылка не существует.

15      Type mismatch or syntax error.
                Константы, выражения, переменные не соответствуют друг
                другу (несоответствие типов) или имеют синтаксическую
                ошибку.

16      Macro name must be <= 16 characters long.
                Имя макроса превышает 16 символов.

17      Out of variables.
                Определено более 200 локальных переменных.

18      String variable expected.
                Должна быть локальная строковая переменная,
                определенная пользователем.

24      Keycode expected.
                Должна быть строка с кодом клавиши.
                См. @KEYMACOP[МАКРОСЫ НАЖАТИЯ КЛАВИШ].

25      Mode expected.
                Должен быть задан режим Multi-Edit.

27      END statement not found.
                Операторов END меньше, чем IF и WHILE.

28      $command expected.
                Должно быть $MACRO или $MACRO_FILE .

29      Out of memory for compiler.
                Не хватает памяти для компиляции. Вероятно нужно выйти
                из редактора и компилировать макросы из ДОС.

30      $MACRO_FILE already defined.
                Для каждого исходного макро-файла допускается только
                одно определение $MACRO_FILE .

31      String constant too long.
                Длина Строковой константы не должна превышать 254
                символа.

32      Multi-Edit command expected.
                Связывание с клавишей неразрешенной команды.  См.
                @KEYCOMMANDS[КОМАНДЫ, ВСЯЗЫВАЕМЫЕ С КЛАВИШАМИ]

33      Operator expected.
                Должно быть ";" или арифметический оператор.

34      Длина строки не должна превышать 2048 символов.

35      Invalid hex constant.
                Шестнадцатиричные числа должны содержать только
                символы из набора "0123456789ABCDEF".

100     Premature end of file.
                Файл закончился еще до оператора END_MACRO.

101     File not found.
                Исходный файл не найден.

102     Output file error.
                Ошибка при записи выходного файла.

103     Invalid debugging PC.
                Программный счетчик в опции -D Пр Си неверен
                См. @RUNERRORS[ОШИБКИ ВЫПОЛНЕНИЯ].

104     Macro name needed for debugging.
                При наличии опции -D необходимо имя макроса.

200     Run time error found.
                Найдена ошибка, определенная в опции - D.
                См. @RUNERRORS[ОШИБКИ ВЫПОЛНЕНИЯ].

EXAMPLE ПРИМЕР МАКРОСА

{***************************************************
 ---ИНТЕЛЛЕКТУАЛЬНЫЙ ОТСТУП В ПРОГРАММАХ НА СИ---
 Mакрос для смещения вправо курсора при переводе строки
 или нажатии клавиши Enter.
***************************************************}

$MACRO C_IND;
   DEF_STR( C_STR );            {Запомнить слово для контроля за
                                отступом}
   DEF_INT( T_COL,              {Положение первого слова в строке}
            T_COL2 );           {Исходное положение}
   T_COL2 := C_COL;             {Запомнить текущее положение}
   FIRST_WORD;                  {Передвинуть курсор на первое слово
                                 строки}
   T_COL := C_COL;              {Запомнить положение}
   IF T_COL2 < T_COL THEN       {Если курсор был перед первым словом}
     T_COL := T_COL2;           {Перейти в исходное положение}
     GOTO_COL(T_COL);           { Для того, чтобы отступ был здесь,}
   END;                         { а не на первом слове}

   IF NOT( At_Eol) THEN         {Если не конец строки,}
      SET_INDENT_LEVEL;         { то установить отступ }
   END;                         { в текущем положении курсора }
   T_COL := C_COL;              {Запомнить текущее положение}
                                {Ввести первое слово строки,
                                 удаляя любые посторонние пробелы}
   C_STR := REMOVE_SPACE( GET_WORD('; (,\') );
   GOTO_COL(T_COL2);            {Возвратить  курсор в исходное
                                 положение}
   CR;                          {Выполнить перевод строки}
                                {Если слово, запомненное в C_STR
                                 соответствует любому из списка, и
                                 исходное положение не на первом
                                 символе первого слова, то выполнить
                                 отступ}
   IF (T_COL <> T_COL2) AND LENGTH(C_STR) <> 0) AND
        (POS(C_STR,    ' if while do for { switch ') <> 0) THEN
     INDENT;
   END;
END_MACRO;

INDEX MACRO LANGUAGE REFERENCE GUIDE - INDEX
@STROP%ASCII[ASCII]
@CURSOROP%AT_EOF[AT_EOF]
@CURSOROP%AT_EOL[AT_EOL]
@FILEOP%AUTOSAVE[AUTOSAVE]
@FILEOP%BACKUPS[BACKUPS]
@FILEOP%BACKUP_PATH[BACKUP_PATH]
@TEXTOP%BACK_SPACE[BACK_SPACE]
@MISCOP%BEEP[BEEP]
@BLOCKOP[BLOCK OPERATIONS]
@BLOCKOP%BLOCK_BEGIN[BLOCK_BEGIN]
@BLOCKOP%BLOCK_COL1[BLOCK_COL1]
@BLOCKOP%BLOCK_COL2[BLOCK_COL2]
@BLOCKOP%BLOCK_END[BLOCK_END]
@BLOCKOP%BLOCK_LINE1[BLOCK_LINE1]
@BLOCKOP%BLOCK_LINE2[BLOCK_LINE2]
@BLOCKOP%BLOCK_OFF[BLOCK_OFF]
@BLOCKOP%BLOCK_STAT[BLOCK_STAT]
@BOOLEANVARS[BOOLEAN]
@SCREENOP%BOX_COUNT[BOX_COUNT]
@FILEOP%BUFFER_ID[BUFFER_ID]
@STROP%CAPS[CAPS]
@DOSOP%CHANGE_DIR[CHANGE_DIR]
@CHARVARS[CHARACTERS]
@STROP%CHAR[CHAR]
@USEROP%CHECK_KEY[CHECK_KEY]
@SCREENOP%CLEAR_SCREEN[CLEAR_SCREEN]
@DOSSHELLOP%CLOSE_DIR[CLOSE_DIR]
@KEYOP%CMD_TO_KEY[CMD_TO_KEY]
@COLORS[COLORS]
@BLOCKOP%COL_BLOCK_BEGIN[COL_BLOCK_BEGIN]
@KEYCOMMANDS[COMMANDS THAT ARE DIRECTLY ASSIGNABLE TO A KEY]
@COMMENTS[COMMENTS]
@COMPERRORS[COMPILER ERRORS]
@MACROCOMPILE[COMPILING]
@DOSOP%COMSPEC[COMSPEC]
@CONDBRANCH[CONDITIONAL BRANCHING]
@CONSTANTS[CONSTANTS]
@STROP%COPY[COPY]
@BLOCKOP%COPY_BLOCK[COPY_BLOCK]
@MACHOP%CPU[CPU]
@WINOP%CREATE_WINDOW[CREATE_WINDOW]
@TABOP%CRUNCH_TABS[CRUNCH_TABS]
@TEXTOP%CR[CR]
@DISPLAYCONFIG%CTRL_HELP[CTRL_HELP]
@CURSOROP[CURSOR OPERATIONS]
@TEXTOP%CUR_CHAR[CUR_CHAR]
@WINOP%CUR_WINDOW[CUR_WINDOW]
@CURSOROP%C_COL[C_COL]
@CURSOROP%C_LINE[C_LINE]
@WPOP%C_PAGE[C_PAGE]
@CURSOROP%C_ROW[C_ROW]
@DOSOP%DATE[DATE]
@MISCOP%DELAY[DELAY]
@BLOCKOP%DELETE_BLOCK[DELETE_BLOCK]
@WINOP%DELETE_WINDOW[DELETE_WINDOW]
@TEXTOP%DEL_CHARS[DEL_CHARS]
@TEXTOP%DEL_CHAR[DEL_CHAR]
@DOSOP%DEL_FILE[DEL_FILE]
@TEXTOP%DEL_LINE[DEL_LINE]
@DOSSHELLOP%DIR[DIR]
@DOSSHELLOP%DIR_ACTIVE[DIR_ACTIVE]
@DOSSHELLOP%DIR_ENTRY[DIR_ENTRY]
@DOSSHELLOP%DIR_MASK[DIR_MASK]
@DOSSHELLOP%DIR_MODE[DIR_MODE]
@DOSSHELLOP%DIR_NUM[DIR_NUM]
@DOSSHELLOP%DIR_PATH[DIR_PATH]
@DOSSHELLOP%DIR_TOTAL[DIR_TOTAL]
@DISPLAYCONFIG[DISPLAY CONFIGURATION]
@DISPLAYCONFIG%DISPLAY_TABS[DISPLAY_TABS]
@WPOP%DOC_MODE[DOC_MODE]
@DOSSHELLOP[DOS SHELL OPERATIONS]
@DOSOP%DOS_BACK[DOS_BACK]
@DOSOP%DOS_COLOR[DOS_COLOR]
@DOSSHELLOP%DOS_DOWN[DOS_DOWN]
@DOSSHELLOP%DOS_FILE_ATTR[DOS_FILE_ATTR]
@DOSSHELLOP%DOS_LEFT[DOS_LEFT]
@DOSSHELLOP%DOS_RIGHT[DOS_RIGHT]
@DOSSHELLOP%DOS_TOF[DOS_TOF]
@DOSSHELLOP%DOS_UP[DOS_UP]
@DOSOP%DOS_VERSION[DOS_VERSION]
@CURSOROP%DOWN[DOWN]
@SCREENOP%DRAW_CHAR[DRAW_CHAR]
@MISCOP%EMS_STAT[EMS_STAT]
@CURSOROP%EOF[EOF]
@DISPLAYCONFIG%EOF_CHAR[EOF_CHAR]
@FILEOP%EOF_IN_MEM[EOF_IN_MEM]
@CURSOROP%EOL[EOL]
@WINOP%ERASE_WINDOW[ERASE_WINDOW]
@ERRORS[ERROR HANDLING]
@ERRORS%ERROR_LEVEL[ERROR_LEVEL]
@EXAMPLE[EXAMPLE MACRO]
@MACROEXEC[EXECUTING]
@DOSOP%EXIT_CODE[EXIT_CODE]
@TABOP%EXPAND_TABS[EXPAND_TABS]
@SCREENOP%EXPLOSIONS[EXPLOSIONS]
@KEYSYNTAX[EXTENDED KEY SYNTAX]
@FILEOP[FILE OPERATIONS]
@FILEOP%FILE_CHANGED[FILE_CHANGED]
@FILEOP%FILE_EXISTS[FILE_EXISTS]
@DOSSHELLOP%FILE_MARKED[FILE_MARKED]
@FILEOP%FILE_NAME[FILE_NAME]
@FILEOP%FIRST_FILE[FIRST_FILE]
@DEFGLOBAL%FIRST_GLOBAL[FIRST_GLOBAL]
@MACROOP%FIRST_MACRO[FIRST_MACRO]
@MACROOP%FIRST_RUN[FIRST_RUN]
@FILEOP%FIRST_SAVE[FIRST_SAVE]
@CURSOROP%FIRST_WORD[FIRST_WORD]
@DISPLAYCONFIG%FKEY_ROW[FKEY_ROW]
@FUNCLABELOP%FLABEL[FLABEL]
@WPOP%FORMAT_LINE[FORMAT_LINE]
@WPOP%FORMAT_STAT[FORMAT_STAT]
@FUNCLABELOP[FUNCTION KEY LABEL OPERATIONS]
@PROCS[FUNCTIONS]
@DOSOP%GET_ENVIRONMENT[GET_ENVIRONMENT]
@STROP%GET_EXTENSION[GET_EXTENSION]
@TEXTOP%GET_LINE[GET_LINE]
@CURSOROP%GET_MARK[GET_MARK]
@STROP%GET_PATH[GET_PATH]
@TEXTOP%GET_WORD[GET_WORD]
@DEFGLOBAL[GLOBAL VARIABLES]
@DEFGLOBAL%GLOBAL_INT[GLOBAL_INT]
@DEFGLOBAL%GLOBAL_STR[GLOBAL_STR]
@SCREENOP%GOTOXY[GOTOXY]
@CURSOROP%GOTO_COL[GOTO_COL]
@CURSOROP%GOTO_LINE[GOTO_LINE]
@CURSOROP%GOTO_MARK[GOTO_MARK]
@USEROP%HELP[HELP]
@CURSOROP%HOME[HOME]
@SEARCHOP%IGNORE_CASE[IGNORE_CASE]
@TABOP%INDENT[INDENT]
@TABOP%INDENT_LEVEL[INDENT_LEVEL]
@WPOP%INDENT_STYLE[INDENT_STYLE]
@MISCOP%INIT_VIDEO_MODE[INIT_VIDEO_MODE]
@KEYOP%INQ_KEY[INQ_KEY]
@MACROOP%INQ_MACRO[INQ_MACRO]
@TEXTOP%INSERT_MODE[INSERT_MODE]
@DISPLAYCONFIG%INS_CURSOR[INS_CURSOR]
@INTEXP[INTEGER EXPRESSIONS]
@INTVARS[INTEGERS]
@MACHOP%INTR[INTR]
@REALOP%INT_R[INT_R]
@KEYOP[KEY ASSIGNMENTS]
@USEROP%KEY1[KEY1]
@USEROP%KEY2[KEY2]
@KEYMACOP[KEYSTROKE MACROS]
@KEYMACOP%KEY_IN[KEY_IN]
@KEYMACOP%KEY_RECORD[KEY_RECORD]
@SCREENOP%KILL_BOX[KILL_BOX]
@LABELS[LABELS]
@FILEOP%LAST_FILE_NAME[LAST_FILE_NAME]
@CURSOROP%LAST_PAGE_BREAK[LAST_PAGE_BREAK]
@CURSOROP%LEFT[LEFT]
@STROP%LENGTH[LENGTH]
@WINOP%LINK_STAT[LINK_STAT]
@WINOP%LINK_WINDOW[LINK_WINDOW]
@FILEOP%LOAD_FILE[LOAD_FILE]
@MACROOP%LOAD_MACRO_FILE[LOAD_MACRO_FILE]
@LOCALVARS[LOCAL VARIABLES]
@MISCOP%LOGO_SCREEN[LOGO_SCREEN]
@MACHOP[MACHINE LEVEL INTERFACE]
@MACROOP[MACRO OPERATIONS]
@KEYOP%MACRO_TO_KEY[MACRO_TO_KEY]
@SCREENOP%MAKE_MESSAGE[MAKE_MESSAGE]
@BLOCKOP%MARKING[MARKING]
@DOSSHELLOP%MARK_FILE[MARK_FILE]
@CURSOROP%MARK_POS[MARK_POS]
@UNDO%MAX_UNDO[MAX_UNDO]
@DISPLAYCONFIG%MAX_WINDOW_ROW[MAX_WINDOW_ROW]
@MACHOP%MEMB[MEMB]
@MACHOP%MEMB[MEMB]
@MACHOP%MEMP[MEMP]
@MACHOP%MEMP[MEMP]
@MACHOP%MEMSTR[MEMSTR]
@MACHOP%MEMW[MEMW]
@MACHOP%MEMW[MEMW]
@DISPLAYCONFIG%MESSAGE_ROW[MESSAGE_ROW]
@DOSOP%ME_PATH[ME_PATH]
@DISPLAYCONFIG%MIN_WINDOW_ROW[MIN_WINDOW_ROW]
@MISCOP[MISCELLANEOUS OPERATIONS]
@MISCOP%MODE[MODE]
@MISCOP%MOUSE[MOUSE]
@MISCOP%MOUSE_H_SENSE[MOUSE_H_SENSE]
@MISCOP%MOUSE_V_SENSE[MOUSE_V_SENSE]
@BLOCKOP%MOVE_BLOCK[MOVE_BLOCK]
@PARMPASS%MPARM_STR[MPARM_STR]
@DISPLAYCONFIG%NAME_LINE[NAME_LINE]
@WINOP%NEW_SCREEN[NEW_SCREEN]
@FILEOP%NEXT_FILE[NEXT_FILE]
@DEFGLOBAL%NEXT_GLOBAL[NEXT_GLOBAL]
@MACROOP%NEXT_MACRO[NEXT_MACRO]
@CURSOROP%NEXT_PAGE_BREAK[NEXT_PAGE_BREAK]
@MISCOP%NOT[NOT]
@MACHOP%OFS[OFS]
@DOSSHELLOP%OPEN_DIR[OPEN_DIR]
@DOSOP[OPERATING SYSTEM INTERFACE]
@DISPLAYCONFIG%OVR_CURSOR[OVR_CURSOR]
@CURSOROP%PAGE_DOWN[PAGE_DOWN]
@CURSOROP%PAGE_STR[PAGE_STR]
@CURSOROP%PAGE_UP[PAGE_UP]
@PARMPASS[PARAMETER PASSING]
@DOSOP%PARAM_COUNT[PARAM_COUNT]
@DOSOP%PARAM_STR[PARAM_STR]
@PARMPASS%PARSE_INT[PARSE_INT]
@PARMPASS%PARSE_STR[PARSE_STR]
@USEROP%PASS_KEY[PASS_KEY]
@MACHOP%PEEK[PEEK]
@WPOP%PG_LINE[PG_LINE]
@KEYMACOP%PLAY_KEY_MACRO[PLAY_KEY_MACRO]
@MACHOP%POKE[POKE]
@FUNCLABELOP%POP_LABELS[POP_LABELS]
@CURSOROP%POP_MARK[POP_MARK]
@UNDO%POP_UNDO[POP_UNDO]
@MISCOP%PRINT_MARGIN[PRINT_MARGIN]
@MISCOP%PRINT_STR[PRINT_STR]
@PROCS[PROCEDURES]
@USEROP%PUSH_KEY[PUSH_KEY]
@FUNCLABELOP%PUSH_LABELS[PUSH_LABELS]
@UNDO%PUSH_UNDO[PUSH_UNDO]
@SCREENOP%PUT_BOX[PUT_BOX]
@SCREENOP%PUT_COL_NUM[PUT_COL_NUM]
@TEXTOP%PUT_LINE[PUT_LINE]
@SCREENOP%PUT_LINE_NUM[PUT_LINE_NUM]
@DOSOP%QUIT[QUIT]
@USEROP%READ_KEY[READ_KEY]
@FILEOP%READ_ONLY[READ_ONLY]
@REALEXP[REAL NUMBER EXPRESSIONS]
@REALOP[REAL NUMBER OPERATIONS]
@REALVARS[REAL NUMBERS]
@REALOP%REAL_I[REAL_I]
@UNDO%REDO[REDO]
@WINOP%REDRAW[REDRAW]
@DOSOP%REDUCE_MEM[REDUCE_MEM]
@WINOP%REFRESH[REFRESH]
@SEARCHOP%REG_EXP_STAT[REG_EXP_STAT]
@STROP%REMOVE_SPACE[REMOVE_SPACE]
@SEARCHOP%REPLACE[REPLACE]
@DOSOP%REST_DOS_SCREEN[REST_DOS_SCREEN]
@USEROP%RETRIEVE_HELP[RETRIEVE_HELP]
@PARMPASS[RETURN VALUES]
@PARMPASS%RETURN_INT[RETURN_INT]
@PARMPASS%RETURN_STR[RETURN_STR]
@CURSOROP%RIGHT[RIGHT]
@WPOP%RIGHT_MARGIN[RIGHT_MARGIN]
@REALOP%RSTR[RSTR]
@RUNERRORS[RUN-TIME ERRORS]
@MACROOP%RUN_MACRO[RUN_MACRO]
@REALOP%RVAL[RVAL]
@MACHOP%R_AX,[R_AX,]
@DOSOP%SAVE_DOS_SCREEN[SAVE_DOS_SCREEN]
@FILEOP%SAVE_FILE[SAVE_FILE]
@SCREENOP[SCREEN OPERATIONS]
@SCREENOP%SCREEN_LENGTH[SCREEN_LENGTH]
@WINOP%SCREEN_NUM[SCREEN_NUM]
@SCREENOP%SCREEN_WIDTH[SCREEN_WIDTH]
@SCREENOP%SCROLL_BOX_DN[SCROLL_BOX_DN]
@SCREENOP%SCROLL_BOX_UP[SCROLL_BOX_UP]
@SEARCHOP[SEARCH AND REPLACE OPERATIONS]
@SEARCHOP%SEARCH_BWD[SEARCH_BWD]
@SEARCHOP%SEARCH_FWD[SEARCH_FWD]
@MACHOP%SEG[SEG]
@DEFGLOBAL%SET_GLOBAL_INT[SET_GLOBAL_INT]
@DEFGLOBAL%SET_GLOBAL_STR[SET_GLOBAL_STR]
@TABOP%SET_INDENT_LEVEL[SET_INDENT_LEVEL]
@CURSOROP%SET_MARK[SET_MARK]
@DOSOP%SHELL_TO_DOS[SHELL_TO_DOS]
@WINOP%SIZE_WINDOW[SIZE_WINDOW]
@DISPLAYCONFIG%STATUS_ROW[STATUS_ROW]
@STREXP[STRING EXPRESSIONS]
@STROP[STRING OPERATIONS]
@STRINGVARS[STRINGS]
@USEROP%STRING_IN[STRING_IN]
@MACROSTRUCT[STRUCTURE]
@STROP%STR[STR]
@BLOCKOP%STR_BLOCK_BEGIN[STR_BLOCK_BEGIN]
@STROP%STR_DEL[STR_DEL]
@STROP%STR_INS[STR_INS]
@STROP%SVL[SVL]
@DOSSHELLOP%SWITCH_DIR[SWITCH_DIR]
@WINOP%SWITCH_WINDOW[SWITCH_WINDOW]
@WINOP%SWITCH_WIN_ID[SWITCH_WIN_ID]
@SYSVAR[SYSTEM VARIABLES]
@TABOP[TABSTOPS INDENTING]
@TABOP[TABSTOPS]
@TABOP%TABS_TO_SPACES[TABS_TO_SPACES]
@TABOP%TAB_EXPAND[TAB_EXPAND]
@TABOP%TAB_LEFT[TAB_LEFT]
@TABOP%TAB_RIGHT[TAB_RIGHT]
@FILEOP%TEMP_PATH[TEMP_PATH]
@TEXTOP[TEXT OPERATIONS]
@TEXTOP%TEXT[TEXT]
@DOSOP%TIME[TIME]
@FILEOP%TMP_FILE[TMP_FILE]
@FILEOP%TMP_FILE_NAME[TMP_FILE_NAME]
@CURSOROP%TOF[TOF]
@SCREENOP%TOGGLE_VIDEO[TOGGLE_VIDEO]
@STROP%TRUNCATE_EXTENSION[TRUNCATE_EXTENSION]
@STROP%TRUNCATE_PATH[TRUNCATE_PATH]
@FILEOP%TRUNCATE_SPACES[TRUNCATE_SPACES]
@DATATYPES[TYPES]
@KEYOP%UNASSIGN_KEY[UNASSIGN_KEY]
@UNCONDBRANCH[UNCONDITIONAL BRANCHING]
@TABOP%UNDENT[UNDENT]
@UNDO[UNDO OPERATIONS]
@UNDO%UNDO[UNDO]
@UNDO%UNDO_STAT[UNDO_STAT]
@WINOP%UNLINK_WINDOW[UNLINK_WINDOW]
@MACROOP%UNLOAD_MACRO[UNLOAD_MACRO]
@DOSSHELLOP%UPDATE_DIR[UPDATE_DIR]
@CURSOROP%UP[UP]
@USEROP[USER INPUT AND INTERFACE]
@MISCOP%USER_ID[USER_ID]
@STROP%VAL[VAL]
@LOCALVARS[VARIABLES]
@MISCOP%VERSION[VERSION]
@SCREENOP%VIDEO_CARD[VIDEO_CARD]
@SCREENOP%VIDEO_MODE[VIDEO_MODE]
@SCREENOP%WHEREX[WHEREX]
@SCREENOP%WHEREY[WHEREY]
@WINOP[WINDOW OPERATIONS]
@WINOP%WINDOW_ATTR[WINDOW_ATTR]
@BLOCKOP%WINDOW_COPY[WINDOW_COPY]
@WINOP%WINDOW_COUNT[WINDOW_COUNT]
@WINOP%WINDOW_ID[WINDOW_ID]
@BLOCKOP%WINDOW_MOVE[WINDOW_MOVE]
@WINOP%WIN_X1[WIN_X1]
@WINOP%WIN_X2[WIN_X2]
@WINOP%WIN_Y1[WIN_Y1]
@WINOP%WIN_Y2[WIN_Y2]
@WPOP[WORD PROCESSING OPERATIONS]
@CURSOROP%WORD_DELIMITS[WORD_DELIMITS]
@CURSOROP%WORD_LEFT[WORD_LEFT]
@CURSOROP%WORD_RIGHT[WORD_RIGHT]
@WPOP%WORD_WRAP_LINE[WORD_WRAP_LINE]
@SCREENOP%WORKING[WORKING]
@WPOP%WRAP_STAT[WRAP_STAT]
@SCREENOP%WRITE[WRITE]
@DOSOP%WRITE_SOD[WRITE_SOD]
@STROP%XPOS[XPOS]