Софтпанорама, No.2, 1990                Составитель Н.Н. Безруков
*****************************************************************

                    =============================
                    =   USER INTERFACE MACROS   =
                    =============================


All of these macros are contained in the file USERIN.MAC.  The source code
is available with Multi-Edit professional.

There are examples of most of these macros in the file EXAMPLE.SRC.  To use it
just load it into the editor, compile it and then run the macro EXAMPLE.

        TOPMENU         Horizontal fixed menu macro.

        SUBMENU         Vertical fixed menu macro.

        XMENU           General purpose fixed menu macro.  Easier to use
                        than TOPMENU or SUBMENU, but less versitile.

        QUERYBOX        Creates a general purpose text or numeric prompt
                        box.

        VERIFY          General purpose "ARE YOU SURE?" macro.

        DATA_IN         Builds multiple field data-entry boxes.

        DVMENU          Variable length menu macro.

        USERSTR         String input macro.  More specific than QUERYBOX.


         +++++++++++++++++
         +    TOPMENU    +
         +++++++++++++++++

Creates a horizontal fixed menu.  This macro is very general purpose.  For
simple menu needs, see XMENU.

Returns:
                RETURN_INT      < 1   if <ESC> was hit.
                                else  the menu Item that was selected.

Parameters:

        /#=nn           The number of menu selections.

        /S=nn           The starting menu selection number.

        /G=str          The prefix used to find the global strings
                        containing the individual menu selection parameters.

        /M=str          The prefix used to find the actual menu name
                        strings.  If this parameter is used then TOPMENU
                        assumes that the menu item names will be contained
                        in separate globals instead of being part of the
                        selection parameters.

        /X=nn           The starting column.

        /Y=nn           The starting row.

        /L=str          The label for the menu

        /B=nn           0 = Create a box for the menu
                        1 = Don't create the box.

        /GCLR=1         Clear all globals on exit;

The individual menu items are passed via global strings defined as the
string passed via /G= plus the number of the menu item.  If "/G=MSTR" then
menu item one would be "MSTR1", item two would be "MSTR2" and so on.

Each menu item parameter string may contain the following:

        /N=str          The name of the menu item.  Use only if /M (above)
                        is NOT used.

        /S=nn           0 = The item has a sub-menu.
                        1 = The item does not have a sub-menu, but do not
                            delete this menu and return to this menu
                            selection if the macro returns 0.
                        2 = The item does not have a sub-menu.  Delete this
                            menu from the screen, execute the macro, do not
                            return to this menu.

        /H=str          Help index string for this menu item.

        /M=str          Macro to run upon selection of this menu item.  This
                        must be the last parameter in the menu string
                        because everything after the /M= is passed to the
                        macro as its parameters.  /X=, /Y= and /BC= are also
                        passed to the macro.  /BC= is the box number above
                        which all boxes are to be removed.



         +++++++++++++++++++
         +     SUBMENU     +
         +++++++++++++++++++

Creates a vertical fixed menu.  This macro is very general purpose.  For
simple menu needs, see XMENU.

Returns:
        RETURN_INT      -1 if <ESC> was hit.
                          0 if the <LEFT> or <RIGHT> keys were hit.
                         >0 if an item was selected.

Parameters:

        /#=nn           The number of menu selections.

        /S=nn           The starting menu selection number.

        /G=str          The prefix used to find the global strings
                        containing the individual menu selection parameters.

        /M=str          The prefix used to find the actual menu name
                        strings.  If this parameter is used then TOPMENU
                        assumes that the menu item names will be contained
                        in separate globals instead of being part of the
                        selection parameters.

        /X=nn           The starting column.

        /Y=nn           The starting row.

        /L=str          The label for the menu

        /B=nn           0 = Create a box for the menu
                        1 = Don't create the box.

        /GCLR=1         Clear all globals on exit;

        /A=nn           0 = Exit if the left or right arrow keys are hit.
                        1 = Ignore left and right arrow keys.

        /BC=nn          The Box number above which all boxes will be removed
                        if a menu item with /S=2 (as a parameter) is
                        selected.  0 if all boxes are to be removed.

The individual menu items are passed via global strings defined as the
string passed via /G= plus the number of the menu item.  If "/G=MSTR" then
menu item one would be "MSTR1", item two would be "MSTR2" and so on.

Each menu item may contain the following:

        /N=str          The name of the menu item.  Use only if /M (above)
                        is NOT used.

        /S=nn           0 = The item has a sub-menu.
                        1 = The item does not have a sub-menu, but do not
                            delete this menu and return to this menu
                            selection if the macro returns 0.
                        2 = The item does not have a sub-menu.  Delete this
                            menu from the screen, execute the macro, do not
                            return to this menu.
                        3 = Run the sub-menu.  Exit this menu with
                            return_int equal to the menu selection.  Don't
                            kill box.

        /H=str          Help index string for this menu item.

        /M=str          Macro to run upon selection of this menu item.  This
                        must be the last parameter in the menu string
                        because everything after the /M= is passed to the
                        macro as its parameters.  /X=, /Y= and /BC= are also
                        passed to the macro.



         +++++++++++++++
         +    XMENU    +
         +++++++++++++++

Generates a vertical or horizontal menu.

Returns:
                RETURN_INT = 0 if <ESC> was hit
                         > 0 then return_int is the number of the select
                             menu item.

Parameters:

        /X=nn           Starting column coordinate

        /Y=nn           Starting row coordinate

        /B=nn           0 = No box
                        1 = Create box.

        /T=nn           0 = Horizontal menu
                        1 = Vertical menu

        /S=nn           Start menu item.

        /L=str          Label for box

        /M=str          The menu string.  Same format as V_MENU and BAR_MENU.
                        Must be the LAST parameter passed.



         ++++++++++++++++++
         +    QUERYBOX    +
         ++++++++++++++++++

Creates a simple text or numeric input box.

Returns:
        If NOT Numeric input then
                Return_Int = 1 if <ENTER> was pressed to accept the input.
                Return_Int = 0 if <ESC> was pressed.
                Return_Str = the inputted string.  Unchanged if Return_Int = 0

        ELSE
                Return_Str = 'TRUE' if <ENTER> was pressed.
                Return_Str = 'FALSE' if <ESC> was pressed.
                Return_Int = The numeric result.  Unchanged if Return_Str =
                                false.

Parameters:

        Return_Str is initialized the default input string value.

        /C=n            The column position

        /L=n            The line number

        /W=n            The maximum width of the string in the box

        /ML=n           The maximum length of the string.

        /T=str          The box title

        /H=str          The help index

        /F2=str         F2 label if one is desired.  If this parm is passed,
                        and F2 is hit, Return_Int will return -1;

        /N=1            Numeric input.  If Numeric input then Return_Int
                        should be initialized to the default value.

        /P=str          Prompt.

        /NK=n           1 = don't kill the box when exiting.  0 = normal.

        /NB=n           1 = don't make a box.  0 = normal.  Offsets for
                        prompt position will still be in effect even if a
                        box is not made.  This facilitates reentering the
                        macro without redrawing the box after not killing
                        the box.

        /MIN=n          For numeric only.  n = minimum legal response value.

        /MAX=n          For numeric only.  n = maximum legal response value.



         ++++++++++++++++
         +    VERIFY    +
         ++++++++++++++++

Creates a simple CONFIRM YES/NO box.

Parameters:   /C=nn   column number to put box.
              /L=nn   line number to put box.
              /H=str  help string.
              /T=str  box title

Returns:      RETURN_INT = True if YES was selected,
                           False if NO was selected or ESC was pressed.



         ++++++++++++++++++
         +    DATA_IN     +
         ++++++++++++++++++

Builds a screen of editable fields.  Each field has its own column and line
setting, as well as its own help and type attributes.  Will build a box
around the fields if /X and /Y are specified.  If the height (/H) or the
width (/W) are not specified then they will be calculated.

Parameters:     /#=nn           the number of fields
                /S=nn           the starting field number
                /PRE=str        The prefix to use for the global var names
                /X=nn           The Upper Right hand column, or x coordinate
                /Y=nn           The Upper Right hand row, or y coordinate
                /H=nn           The height of the box
                /W=nn           The width of the box
                /T=str          The title of the box
                /A=nn           Accept type.
                                  0 = Use ENTER to accept.
                                  1 = Use Field 0 to accept.
                                  2 = Accept no matter what.
                                  3 = Use ACCEPT field defined by type 6.
                /NC=nn          1 = NO Cleanup.  Don't erase global
                                  variables when done.

Returns:    RETURN_INT = 0 if the data was NOT accepted.
            Else RETURN_INT = item that was highlighted when data was
                                accepted.

Global Vars:
  ISTR_1 .. ISTR_x      field string, x = count
  IPARM_1 .. IPARM_x    parameter string,x = count
  IPARM_x = '/C=column/L=line/W=width/ML=max_length
                H=help_str/TP=type/HISTORY=history_list'
         if max length is 0 then max length is equal to width.
        /C=nn           Column offset from left edge of box.
        /L=nn           Line offset from top of box
        /W=nn           Visible width of field.
        /ML=nn          Maximum actual length of field.
        /H=str          Help string.
        /TP=nn          field type.
                        0 = string (default)
                        1 = integer
                        2 = real number
                        3 = Multiple Choice with vertical menu.
                                ISTR_x contains the menu.
                                IINT_x contains the choice number.
                        4 = Hex - same as integer, except display and
                                user input in hex.
                        5 = toggle true or false.
                                ISTR_x = '/T=YES/F=NO'
                                IINT_x = boolean value.
                        6 = Accept field.
                        7 = Run macro, return integer.
                                IPARM=x /M=macro (must be last parameter)
                                The following parameters get passed to the
                                macro:
                                /X=nn
                                /Y=nn
                                /STR=str (the string in ISTR_x)
                        8 = Run macro, return string.
                                IPARM=x /M=macro (must be last parameter)
                                /X=nn
                                /Y=nn
                                /INT=nn (the integer in IINT_x)
        /HISTORY=str    specifies the name of a history list global string.

  IINT_x = value for integer or multiple choice.
  IHELP1  the help string when no field is being edited.
  IHELP1 = '/C=column/L=Line/H=help_str'
  IHELP2  the help string when a field is being edited.
  IHELP2 = '/C=column/L=Line/H=help_str'

Note that if an X and Y coordinate was specified in the parameter line then,
the column and line numbers will be offsets from the X and Y coordinates.


         +++++++++++++++++++++++++++++++++++++++++
         +    DVMENU  (Dynamic Vertical Menu)    +
         +++++++++++++++++++++++++++++++++++++++++

This is a general purpose vertical menu generator that creates a box just
the right size to fit the menu, and returns both the number of the menu
element that was picked, and the string of the menu element in Return_Int
and Return_Str respectively.  The menu is scrollable if the menu is larger
than will fit on the screen.

You must initialize global variables with the menu strings.  If one global
will not hold the entire menu, use as many as you wish.  The format for the
global variable names is:

  Name1
  Name2
  Name3
  etc.

Where name is any name you wish, which is supplied to the program via a
parameter called Menu_Prefix.  The amount of globals is supplied via the /#=
parameter.

Although, for the sake of compatibility, the format of each menu string is
identical to that expected for XMENU, with menu choices separated by help
indexes enclosed in parentheses().  These help indexes are not actually
used.  Instead you must provide the help index string for the entire menu
via the /H= parameter.  If you wish, only the parentheses need to be present
to separate individual menu choices, and you do not even have to use
parentheses if there is only one menu choice per global.

This menu does not have the "Hit the highlighted character to select" feature,
however, there is an incremental search feature which, if an alphanumeric
character is pressed, it will invoke and all subsequent characters will be
appended to the search expression.  Hitting the backspace will right-truncate
the search expression.

One important option to DVMENU is the option to create your own window with
the menu choices already arranged with one choice per line.  Thus, you can
use a window that you create, as a menu.

        Parameters expected:
        /P=     Menu_Prefix   string   the "prefix" of the 3 global
                                       variables defining the 3 menu strings
                                       for the vertical menu
        /H=     Help_Str      string   the 2 character help string for prompts
        /T=     Title         string   the title of the box
        /S=     Choice_Str    string   the string of the default selection
        /SN=                  integer  instead of using /S= for default, use
                                       this.
        /X=     Menu_X        integer  the upper left X coordinate of the box
        /Y=     Menu_Y        integer  the upper left Y coordinate of the box
        /MH=    Menu_Height   integer  If within range, will override the
                                       calculated menu height
        /B=     Make_Box      integer  1=create a box 0=don't
        /K=     Box_Kill      integer  1=kill the box before exiting 0=don't
        /O=     Menu_Modify   integer  1=display modify choice 0=don't
        /C=     Menu_Create   integer  1=display create choice 0=don't
        /CT=    Create_Title  string   If present, will replace the title on
                                       the create box prompt.
        /D=     Menu_Delete   integer  1=display delete choice 0=don't
        /A=     Menu_Add      integer  Similar to create, only this macro is
                                       exited to facilitate another interface,
                                       like another menu from which to choose
                                       the "added" item from.
        /#=     Menu_Index    integer  The number of globals used for menu
        /W=     Max_Width    integer  The maximum allowable string length
                                      for when a user adds a menu item.


       /PRE=                 char     This one was created primarily for the
                                      macro EXTENS.  If present, and the
                                      user creates a new menu item, the item
                                      he enters MUST be preceded by the
                                      defined character.  In EXTENS, the
                                      extension menu items must be preceded
                                      by a period(.).
       /U=                   integer  1=Force upper case on menu item
                                      additions.  0= Normal.
       /EC=                  integer  1=exit this macro upon addition of a
                                      new menu item.  Primarily intended for
                                      situations where processing other than
                                      merely adding to the menu itself is
                                      necessary.
       /ED=                  integer  1=exit this macro upon deletion of a
                                      menu item. Primarily intended for
                                      situations where processing other than
                                      merely deleting from the menu itself
                                      is necessary.
       /ND=                  string   A series of strings, separated by
                                      spaces, that tell DVMENU to disallow
                                      deletion of the contained strings.
                                      Only valid and necessary if /D=1
       /NM=                  string   A series of strings, separated by
                                      spaces, that tell DVMENU to disallow
                                      modification of the contained strings.
                                      Only valid and necessary if /O=1
       /NR=                  integer  No rebuild.  If 1, then DVMENU will
                                      not alter the global menu strings in
                                      the event of a create or delete.
       /I=                   string   A string expression to precede the
                                      incremental search string.  Under
                                      normal circumstances, it should be %
                                      to match the beginning of line.
       /WIN=nn                        The window # to use if we do NOT want
                                      a window created.
       /WW=nn           window width  Desired width only active when using
                                      /WIN.  If not present, /W will be used
                                      instead.
       /SK=nn           skip_over     Enables optional skip over of menu
                                      choices containing '|254' at the end
                                      of the line Only works in conjunction
                                      with /WW= and one menu choice per
                                      global.
       Returns        Return_Int   0 = Escape was pressed.
                                   1 = Return was pressed.
                                   2 = A menu item was added(only if /EC=1)
                                   3 = A menu item was deleted(only if /ED=1)
                                   4 = Modify item was selected.
                                   5 = Add item was selected.
                      Return_Str   If Return_Int = 0, = /S=.
                                   If Return_Int = 1, = The selected item.
                                   If Return_Int = 2, = The added item.
                                   If Return_Int = 3, = The deleted item.
                                   If Return_Int = 4, = The selected item.


         +++++++++++++++++
         +    USERSTR    +
         +++++++++++++++++

This macro creates a scrollable prompt.  Functionally equivalent to the
macro function String_In, except allows scrolling.  Allows user inputs of up
to 254 characters.

System variables and parameters:

Return_Str -  Returns user input if enter is pressed, or default if ESC is
              pressed.
Return_Int -  Returns 1 if enter is pressed, 0 if ESC is pressed, -1 if
              a enabled function key was hit.

Names of parameters are similar to arguments for String_In.
/P=   Prompt string.  If omitted, same as above.
/F2=str  Enables F2.  Assigns str as the label;  Now works for F1 - F12
/L=   Length.  Maximum length of input.
/X=   Col.  Left Column of prompt.
/Y=   Row.  Row of Prompt.
/H=   Help string.  2 character index for help system.
/W=   Input Width.  Width of visible portion of input.
/B=   1 = Create Box;
/BL=  Box Label;
/NK=  1 = don't kill box when done.
/A=   1 = Exit on use of up or down arrow keys with return_int = 1 and
      push the key back on the keyboard stack.


                    =====================================
                    =    Demo   User interface macros   =
                    =====================================

$MACRO_FILE EXAMPLE;
{******************************************************************************
This file contains examples of how to call the Multi-Edit user interface
macros.
******************************************************************************}


$MACRO EXAMPLE;
{******************************************************************************
                                MULTI-EDIT MACRO

Name:	EXAMPLE

Description:  Example of how to use the macro TOP_MENU to create a top level
							menu.

******************************************************************************}
	Set_Global_Str('TX_1','/H=FIXEDMENU/M=SUB_EXAMPLE1');
	Set_Global_Str('XTX_1','Example-1');
	Set_Global_Str('TX_2','/H=FIXEDMENU/M=SUB_EXAMPLE2');
	Set_Global_Str('XTX_2','Example-2');
	Set_Global_Str('TX_3','/H=FIXEDMENU/S=2/M=EXAMPLE_EXIT');
	Set_Global_Str('XTX_3','Exit-menu');

	Run_Macro('USERIN^TOPMENU /GCLR=1/M=XTX_/G=TX_/#=3/X=1/Y=2/S=1/BC=1/L=TOP_MENU EXAMPLE');

	return_int := 100;
END_MACRO;


$MACRO EXAMPLE_EXIT;
{This is truly a do-nothing macro}
END_MACRO;


$MACRO SUB_EXAMPLE1;
{******************************************************************************
                                MULTI-EDIT MACRO

Name:	SUB_EXAMPLE1

Description:  Example of how to use the macro SUB_MENU to create a sub level
							menu.

******************************************************************************}
	Set_Global_Str('SX_1','/H=FIXEDMENU/M=BAR_EXAMPLE');
	Set_Global_Str('XSX_1','XMENU horizontal example');
	Set_Global_Str('SX_2','/H=FIXEDMENU/M=VER_EXAMPLE');
	Set_Global_Str('XSX_2','XMENU Vertical example');
	Set_Global_Str('SX_3','/H=VARMENU/M=VAR_EXAMPLE');
	Set_Global_Str('XSX_3','DVMENU example');

	Run_Macro('USERIN^SUBMENU /GCLR=1/G=SX_/M=XSX_/#=3/S=1/L=SUB_MENU EXAMPLE 1/X=' +
		Parse_Str('/X=',MParm_Str) + '/Y=' + Parse_Str('/Y=',MParm_Str));

END_MACRO;


$MACRO BAR_EXAMPLE;
	Def_Int( kill_count );
	Run_Macro('USERIN^XMENU /B=1/X='+ Parse_Str('/X=',MParm_Str) + '/Y=' +
		Parse_Str('/Y=',MParm_Str) + '/S=1' +
		'/M=Choice1(FIXEDMENU)Choice2(FIXEDMENU)Choice3(FIXEDMENU)');
		{If an item was selected then kill of all of the other menus and
		 then put up a message}
	If (Return_Int > 0) THEN
		kill_count := Parse_Int('/BC=', mparm_str);
		While Box_Count > Kill_Count do
			Kill_Box;
		END;
		Make_Message('XMENU HORIZONTAL: Item ' + str(Return_Int) + ' was selected.');
	END;
END_MACRO;



$MACRO VER_EXAMPLE;
	Def_Int( kill_count );
	Run_Macro('USERIN^XMENU /T=1/B=1/X='+ Parse_Str('/X=',MParm_Str) + '/Y=' +
		Parse_Str('/Y=',MParm_Str) + '/S=1' +
		'/M=Choice1(FIXEDMENU)Choice2(FIXEDMENU)Choice3(FIXEDMENU)');
		{Return_Int will now be < 1 if <ESC> was hit, or it will equal the
		 number of the menu item that was selected}
		{If an item was selected then kill of all of the other menus and
		 then put up a message}
	If (Return_Int > 0) THEN
		kill_count := Parse_Int('/BC=', mparm_str);
		While Box_Count > Kill_Count do
			Kill_Box;
		END;
		Make_Message('XMENU VERTICAL: Item ' + str(Return_Int) + ' was selected.');
	END;
END_MACRO;


$MACRO VAR_EXAMPLE;
	Set_Global_Str('EXAMPLE1','Choice1()Choice2()Choice3()');
	Run_Macro('USERIN^DVMENU /P=EXAMPLE/B=1/K=1/X=' + Parse_Str('/X=',MParm_Str)
		+ '/Y=' + Parse_Str('/Y=',MParm_Str) + '/T=/C=1/D=1/M=1/H=VARMENU/O=1/W=15'
						+ '/#=1/U=1/I=%');
	Set_Global_Str('EXAMPLE1','');
		{Return_Int will now be < 1 if <ESC> was hit, or it will equal the
		 number of the menu item that was selected}
END_MACRO;

$MACRO SUB_EXAMPLE2;
{******************************************************************************
                                MULTI-EDIT MACRO

Name:	SUB_EXAMPLE2

Description:  Example of how to use the macro SUB_MENU to create a sub level
							menu.

******************************************************************************}
	Set_Global_Str('SX_1','/H=FIXEDMENU/M=QUE_EXAMPLE');
	Set_Global_Str('XSX_1','QUERY_BOX example');
	Set_Global_Str('SX_2','/H=FIXEDMENU/M=USE_EXAMPLE');
	Set_Global_Str('XSX_2','USER_STR example');
	Set_Global_Str('SX_3','/H=VARMENU/M=DAT_EXAMPLE');
	Set_Global_Str('XSX_3','DATA_IN example');

	Run_Macro('USERIN^SUBMENU /GCLR=1/G=SX_/M=XSX_/#=3/S=1/L=SUB_MENU EXAMPLE 2/X=' +
		Parse_Str('/X=',MParm_Str) + '/Y=' + Parse_Str('/Y=',MParm_Str));

END_MACRO;


$MACRO QUE_EXAMPLE;
	Def_Int( kill_count );

	Return_Str := 'EXAMPLE';
{Notice we are enabling the history list here with /HISTORY=}
	Run_Macro('USERIN^QUERYBOX /HISTORY=QUE_PASA/H=PROMPTS/C=' + Parse_Str('/X=',MParm_Str) +
	'/L=' + Parse_Str('/Y=',MParm_Str) +
	'/W=10/P=Enter whatever turns you on:/T=QUERYBOX EXAMPLE');

		{If the input was accepted then kill of all of the other menus and
		 then put up a message}
	If (Return_Int > 0) THEN
		kill_count := Parse_Int('/BC=', mparm_str);
		While Box_Count > Kill_Count do
			Kill_Box;
		END;
		Make_Message('The QUERYBOX was accepted');
	END;
END_MACRO;


$MACRO USE_EXAMPLE;

	Return_Str := 'EXAMPLE 1';
{Here again, the history list is enabled, and we have chosen to use the same
history name so that we can "share" with the QUERYBOX example.}
	Run_Macro('USERIN^USERSTR /HISTORY=QUE_PASA/H=PROMPTS/X=' + Parse_Str('/X=',MParm_Str) +
	'/BL=USERSTR EXAMPLE/Y=' + Parse_Str('/Y=',MParm_Str) +
	'/B=1/NK=1/L=20/W=10/P=      After you enter something here:  /T=USERSTR EXAMPLE');
	Return_Str := 'EXAMPLE 2';
	Run_Macro('USERIN^USERSTR /H=PROMPTS/X=' + Str(Parse_Int('/X=',MParm_Str) + 1) +
	'/Y=' + Str(Parse_Int('/Y=',MParm_Str) + 1) +
	'/L=20/W=10/P=Notice the next prompt uses the same box:/T=USERSTR EXAMPLE');
END_MACRO;

$MACRO DAT_EXAMPLE;
	Set_Global_Str('ISTR_1','STRING');
	Set_Global_Str('IPARM_1','/T=Example of a string input field:  /C=1/L=1/W=10/H=DATABOX');
	Set_Global_Int('IINT_2',100);
	Set_Global_Str('IPARM_2','/T=Example of an integer input field:/C=1/L=2/W=3/H=DATABOX/TP=1' );
	Set_Global_Str('ISTR_3','123.456');
	Set_Global_Str('IPARM_3','/T=Example of a real input field:    /C=1/L=3/W=7/H=DATABOX/TP=2');
	Set_Global_Str('ISTR_4','Choice1(DATABOX)Choice2(DATABOX)Choice3(DATABOX)');
	Set_Global_Int('IINT_4',2);
	Set_Global_Str('IPARM_4','/T=Example of a menu field:          /TP=3/C=1/L=4/W=8/H=DATABOX');
	Set_Global_Int('IINT_5',$3F);
	Set_Global_Str('IPARM_5','/T=Example of a hex input field:     /C=1/L=5/W=4/H=DATABOX/TP=4' );
	Set_Global_Str('ISTR_6','/F=Off/T=On');
	Set_Global_Int('IINT_6',1);
	Set_Global_Str('IPARM_6','/T=Example of a toggling field:      /TP=5/C=1/L=6/W=4/H=DATABOX');
	Set_Global_Str('ISTR_7','Hit <ENTER> to accept');
	Set_Global_Str('IPARM_7','/T=Example of an accept:             /TP=6/C=1/L=7/W=21/H=DATABOX');
	Set_Global_Str( 'IHELP1', '/L=8/C=12/H=═══|24|25 to select, <Esc> to exit.═══' );
	Set_Global_Str( 'IHELP2', '' );
	Run_Macro( 'USERIN^Data_In /#=7/S=1/A=2/X=10/Y=12/T=DATA_IN EXAMPLE' );
		{If Return_Int > 0 then the Accept field was selected}
END_MACRO;





                        ======================
                        =   EXAMPLE MACRO    =
                        ======================

{***************************************************
	  --- SMART INDENT FOR C ---
 Multi-Edit macro to perform a semi-smart indent each
 time the Carriage Return or Enter key is pressed.
***************************************************}

$MACRO C_IND;
   DEF_STR( C_STR );		{Stores the word to check for indent}
   DEF_INT( T_COL,		{Position of first word on line}
	    T_COL2 );		{Original position}
   T_COL2 := C_COL;		{Store the current position}
   FIRST_WORD;			{Move cursor to first word on line}
   T_COL := C_COL;		{Store the position}
   IF T_COL2 < T_COL THEN	{If the cursor was before the 1st word}
     T_COL := T_COL2;		{Then goto to the original position}
     GOTO_COL(T_COL);		{ So that indenting occurs at that }
   END;				{ position instead of the first word}

   IF NOT( At_Eol) THEN         {If we are not at the end of the line }
     SET_INDENT_LEVEL;		{ then set the indent level to the }
   END;				{ current cursor position }
   T_COL := C_COL;		{Store the current position}
				{Get the first word on the line,
				 removing any extraneous space}
   C_STR := REMOVE_SPACE( GET_WORD('; (,\') );
   GOTO_COL(T_COL2);		{Return the cursor to the original
				 position}
   CR;				{Perform a carriage return}
				{If the word stored in C_STR matches
				 any in the list, and the original position
				 was not at the first character of the first
				 word, then perform an indent}
   IF (T_COL <> T_COL2) AND LENGTH(C_STR) <> 0) AND
	(POS(C_STR,    ' if while do for { switch ') <> 0) THEN
     INDENT;
   END;
END_MACRO;


