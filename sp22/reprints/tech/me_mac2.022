Софтпанорама, No.2, 1990                Составитель Н.Н. Безруков
*****************************************************************



                    FUNCTIONS AND OPERATIONS BY CATEGORY

   ╔═════════════════════════════════╤═══════════════════════════════════╗
   ║ BLOCK OPERATIONS                │ MISCELLANEOUS OPERATIONS          ║
   ║ COLORS                          │ TAB STOPS AND INDENTING           ║
   ║ CURSOR POSITION OPERATIONS      │ SCREEN OPERATIONS                 ║
   ║ DISPLAY CONFIGURATION           │ SEARCH AND REPLACE OPERATIONS     ║
   ║ DOS SHELL OPERATIONS            │ STRING MANIPULATION OPERATIONS    ║
   ║ FILE OPERATIONS                 │ OPERATING SYSTEM INTERFACE        ║
   ║ FUNCTION KEY LABEL OPERATIONS   │ TEXT MANIPULATION OPERATIONS      ║
   ║ KEY ASSIGNMENTS                 │ UNDO OPERATIONS                   ║
   ║ KEYSTROKE MACROS                │ USER INPUT AND INTERFACE          ║
   ║ MACHINE LEVEL OPERATIONS        │ WINDOW OPERATIONS                 ║
   ║ MACRO OPERATIONS                │ WORD PROCESSING OPERATIONS        ║
   ╚═════════════════════════════════╧═══════════════════════════════════╝



                      ========================
                      =   BLOCK OPERATIONS   =
                      ========================

BLOCK_BEGIN  procedure

    ACTION:     Marks the start of a block of lines at the cursor.

COL_BLOCK_BEGIN  procedure

    ACTION:     Marks the start of a columnar block of text at the cursor.

STR_BLOCK_BEGIN  procedure

    ACTION:     Marks the start of a stream of text block at the cursor.

BLOCK_END  procedure

    ACTION:     Marks the end of a block of text, either line or column orient
                at the cursor.

COPY_BLOCK  procedure

    ACTION:     Copies the currently marked block of text to the current
                cursor position.

MOVE_BLOCK  procedure

    ACTION:     Moves the currently marked block of text to the current
                cursor position.

WINDOW_COPY( window_num )  procedure

    ACTION:     Copies the currently marked block of text from the specified
                window into the current window at the current cursor
                position.

WINDOW_MOVE( window_num )  procedure

    ACTION:     Moves the currently marked block of text from the specified
                window to the current window at the current cursor position.

DELETE_BLOCK  procedure

    ACTION:     Deletes the currently marked block of text.

BLOCK_STAT  integer function

    RETURNS:    0 if no block is marked.
                1 if a line block is marked.
                2 if a columnar block is marked.
                3 if a stream of text block is marked

BLOCK_LINE1  integer function

    RETURNS:    The first marked line number.

BLOCK_LINE2  integer function

    RETURNS:    The second marked line number.

BLOCK_COL1  integer function

    RETURNS:    The first marked column number.

BLOCK_COL2  integer function

    RETURNS:    The second marked column number.  Will be > 2048 if the block
                is not columnar.

MARKING  integer function

    RETURNS:    TRUE if block marking is on. Else FALSE.

BLOCK_OFF  procedure

    ACTION:     Turns the current block off.


                         ===================
                         =     COLORS      =
                         ===================

The following are all system integer variables.  Each contains both a
foreground and a background color.  The lower 4 bits of the variable is
the foreground color.  The next 4 bits is the background color.

        W_T_COLOR       Default window text color
        W_H_COLOR       Default window highlight color
        W_B_COLOR       Default window border color
        W_C_COLOR       Default window changed text color
        W_S_COLOR       Default window status color
        W_EOF_COLOR     Default EOF marker color

        M_T_COLOR       Menu text color
        M_S_COLOR       Menu status (bold) color
        M_B_COLOR       Menu border color
        M_H_COLOR       Menu highlight color

        D_T_COLOR       Dos shell text color
        D_S_COLOR       Dos shell status (bold) color
        D_B_COLOR       Dos shell border color
        D_H_COLOR       Dos shell highlight color

        H_T_COLOR       Help text color
        H_S_COLOR       Help status (bold) color
        H_B_COLOR       Help border color
        H_H_COLOR       Help highlight color
        H_R_COLOR       Help rock (index) color
        H_F_COLOR       Help function key color
        H_T1_Color      Help definable text attribute 1
        H_T2_Color      Help definable text attribute 1
        H_T3_Color      Help definable text attribute 1

        FKEY_COLOR      Function key labels color
        FNUM_COLOR      Function key number color
        STAT1_COLOR     Status line color
        STAT2_COLOR     Status line bold color
        MESSAGE_COLOR   Message line color
        WORKING_COLOR   The color of the "WORKING" indicator.
        ERROR_COLOR     Color used for error messages
        SHADOW_COLOR    Color used for shadows
        SHADOW_CHAR     Character used for shadows

Each window now its own set of color attributes.  These are accessed in the
macro language with the system variables:

        T_Color         text color
        B_Color         border color
        S_Color         status (or bold) color
        C_Color         change color
        H_Color         highlight (as in block) color
        EOF_COLOR       individual window eof marker color

        The system variable Window_Color_Stat is used to determine whether
        or not a window is using the default colors, or its own colors.  If
        you setup a window to have custom colors, then you should set
        Window_Color_Stat to TRUE.  This will prevent the Color Setup macro
        from overriding your new colors (for the window).

See PREDEFINED CONSTANTS for a list of the colors available.

                 ===================================
                 =   CURSOR POSITION OPERATIONS    =
                 ===================================

HOME  procedure

    ACTION:     Moves the cursor to the currently set indent level.

EOL  procedure

    ACTION:     Moves the cursor to the character position after the end of
                the current line.

TOF  procedure

    ACTION:     Moves the cursor to the top of the file.

EOF  procedure

    ACTION:     Moves the cursor to the end of the file.

UP  procedure

    ACTION:     Moves the cursor up one line.

DOWN  procedure

    ACTION:     Moves the cursor down one line.

LEFT  procedure

    ACTION:     Moves the cursor to the left one character.  If the cursor
                was at column 1, then the cursor wraps to the end of the
                previous line.

RIGHT  procedure

    ACTION:     Moves the cursor to the right one character.  NOTE:  The
                cursor does NOT wrap at the end of the line.  The cursor
                WILL wrap after column 2048 is reached.

WORD_LEFT  procedure

    ACTION:     Moves the cursor to the left one word.  Will wrap to the
                previous line.  NOTE that the WORD_DELIMITS variable may be
                used to change the delimiters used to define a word.

WORD_RIGHT  procedure

    ACTION:     Moves the cursor to the right one word.  Will wrap to the
                next line.  NOTE that the WORD_DELIMITS variable may be used
                to change the delimiters used to define a word.

WORD_DELIMITS  string variable

        Defines the word delimiters that are used by WORD_LEFT and
        WORD_RIGHT.

FIRST_WORD  procedure

    ACTION:     Moves the cursor to the first non-white-space character on
                the line.

MARK_POS  procedure

    ACTION:     Pushes the current cursor position onto the position marker
                stack for the current window.

    EXAMPLE:    Mark_Pos;
                IF NOT( Search_Fwd( The_Word, 0 ) ) THEN
                   Goto_Mark;
                END;


GOTO_MARK  procedure

    ACTION:     Restores the cursor position to the last position marked and
                removes that position from the position marker stack.

POP_MARK  procedure

    ACTION:     Pulls a mark of the marker stack without actually affecting
                the cursor.

SET_MARK( mark_num )  procedure

    ACTION:     Sets a random access mark.  Mark_num must be in the range
                1 - 10.

GET_MARK( mark_num )  procedure

    ACTION:     Places the cursor on the position stored in random access mark
                Mark_num.  If the mark has not been set, then no change of
                position will occur.

GOTO_LINE( Line_num )  procedure

    ACTION:     Moves the cursor to the specified line number.  Line_num
                must be between 1 and 32767.

    EXAMPLE:    Goto_Line( C_Line + 10 );

GOTO_COL( Column_pos )  procedure

    ACTION:     Moves the cursor to specified column position. Column_pos
                must be between 1 and 2048.

    EXAMPLE:    Goto_Col( 10 );

PAGE_UP  procedure

    ACTION:     Moves the cursor one window length up.

PAGE_DOWN  procedure

    ACTION:     Moves the cursor one window length down.

AT_EOF  integer function

    RETURNS:    True (1) if the cursor is at or beyond the end of the file
                in the current window.

AT_EOL  integer function

    RETURNS:    True (1) if the cursor is at or beyond the end of the line
                in the current window.

C_COL  integer function

    RETURNS:    An integer containing the current cursor column position the
                cursor is on.

    EXAMPLE:    WHILE C_COL <> 10 DO
                   Right;
                END;

C_LINE  integer function

    RETURNS:    An integer containing the line number the cursor is on in
                the current file.

    EXAMPLE:    IF C_Line = 10 THEN
                   Down;        {Skip line 10}
                END;


C_ROW  integer function

    RETURNS:    An integer containing the current row in the window the
                cursor is on.  1 = the top row currently visible in the
                window.

    EXAMPLE:    {Move cursor to top of window}
                WHILE C_Row > 1 DO
                   Up;
                END;

NEXT_PAGE_BREAK  procedure

    ACTION:     Moves the cursor to the line after the next occurrence of a
                page break string.

LAST_PAGE_BREAK  procedure

    ACTION:     Moves the cursor to line after the previous occurrence of a
                page break string.

PAGE_STR  string variable

        The Page-Break string.  Normally set to a single Form Feed (ASCII
        code 12) character, but may be any string up to 10 characters in
        length.


                    ============================
                    =   DISPLAY CONFIGURATION  =
                    ============================

INS_CURSOR  integer variable

        The cursor shape for the Insert mode cursor.
        0 = Underline
        1 = 1/2 block
        2 = 2/3 block
        3 = Full block

OVR_CURSOR  integer variable

        The cursor shape for the Overwrite mode cursor.  Values are the same
        as INS_CURSOR.

CTRL_HELP  integer variable

        TRUE (1) = Ctrl-keypad help box is on.
        FALSE (0) = Ctrl-keypad help box is off.

STATUS_ROW  integer variable

        The row to display the status line on.  0 = Off.

MESSAGE_ROW  integer variable

        The row to display the message line.  0 = Off.

MAX_WINDOW_ROW  integer variable

        The maximum row that a window may be displayed on.

MIN_WINDOW_ROW  integer variable

        The minimum row that a window may be displayed on.

NAME_LINE  integer variable

        0 = Don't use bottom line of window.  Display filename on top.  1 =
        the opposite.

FKEY_ROW  integer variable

        The row to display the function key labels.  0 = Off.

DISPLAY_TABS  integer variable

        1 = display tab characters.  0 = don't display tab characters.

EOF_CHAR  integer variable

        This is a single byte variable, that contains the ASCII value of the
        pad character to use after the end of a line in a window.

STATUS_MACRO( macro_name_string ) procedure

        Sets a macro to be run to display the status line, instead of
        using the internal status line routine.

STATUS_STR  string variable
        The static string that is to be displayed on the status line.

MODE_COL  integer variable
        The column position on the status line where the mode indicator is
        to be.

INSERT_COL  integer variable
        The column position on the status line where the insert/overwrite
        indicator is to be.


MEM_COL  integer variable
        The column position on the status line where the memory indicator is
        to be.

TIME_COL  integer variable
        The column position on the status line where the time/date is to be.

CAPS_COL  integer variable
        The column position on the status line where the capslock indicator
        is to be.

RECORD_COL  integer variable
        The column position on the status line where the keystroke recording
        indicator is to be.

LINE_COL  integer variable
        The column position on the status line where the line number is to
        be.

COL_COL  integer variable
        The column position on the status line where the column number is to
        be.

MESSAGE_COL  integer variable
        The column position on the message line where the messages are
        to start.

MESSAGE_LENGTH  integer variable
        The maximum length of a MAKE_MESSAGE string.

WORKING_COL  integer variable
        The column position on the statusln where the WORKING indicator will
        be.



                   ===============================
                   =    DOS SHELL OPERATIONS     =
                   ===============================

OPEN_DIR( dir_num )  procedure

    ACTION:     Opens up a directory window.  Dir_num must be in
                the range 1-5;

CLOSE_DIR( dir_num )  procedure

    ACTION:     Closes a directory window.  Dir_num must be in
                the range 1-5;

SWITCH_DIR( dir_num )  procedure

    ACTION:     Makes a directory window active.  Dir_num must be in
                the range 1-5.

DIR_ACTIVE( dir_num )  integer function

    RETURNS:    TRUE if the directory is open.

DIR_MODE  integer variable
                0 = Full display of directory.
                1 = Wide, multiple column display of directory.

DIR( dir_string )  procedure

    ACTION:     Displays the files according to the dir string.

    EXAMPLE:       {Go into the DOS SHELL}
                        Enter_Dos_Shell;
                           {Get a directory}
                        Dir( C:\TEST\*.* );

DOS_UP  procedure

    ACTION:     Moves the DOS Shell cursor up one file name.

DOS_DOWN  procedure

    ACTION:     Moves the DOS Shell cursor down one file name.

DOS_RIGHT  procedure

    ACTION:     Move the cursor to the next directory entry.

DOS_LEFT  procedure
    ACTION:     Move the cursor to the previous directory entry.

DOS_TOF  procedure

    ACTION:     Move directory cursor to the top of the directory list.

UPDATE_DIR  procedure

    ACTION:     Cause the directory shell to update the directory list.


DIR_MASK  string function

    RETURNS:    A string containing the full path name of the directory
                (including any wild cards) that the DOS SHELL directory is
                viewing.

DIR_ENTRY  string function

    RETURNS:    A string containing the current file name that the cursor is
                on in the directory list.

DIR_NUM  integer function

    RETURNS:    The file number (in the directory list) that the cursor is on.

DIR_TOTAL  integer function

    RETURNS:    The total number of entries in the current directory list, inc
                 the '.' and '..' directories.

DIR_PATH  string function

    RETURNS:    A string containing the current directory path.

    EXAMPLE:    IF Dir_Path = 'A:\TEST\*.*' THEN
                           Dir('A:\TEST\TEXT\*.TXT');
                        END;

FILE_MARKED  integer function

    RETURNS:    True if the file that the cursor is on is marked.

MARK_FILE  procedure

    ACTION:   Toggles the marked status of the file that the DOS cursor is on.

DOS_FILE_ATTR  integer function

    RETURNS:    The integer file attribute for the directory entry the
                DIRECTORY SHELL cursor is sitting on.

                Attributes:     $01 = Read Only
                                $02 = Hidden
                                $04 = System file
                                $08 = Volume ID
                                $10 = Directory
                                $20 = Archive



                       ========================
                       =   FILE OPERATIONS    =
                       ========================

FILE_NAME  string variable

        The name of the file being edited in the current window. May be up
        to 65 characters long.  EXAMPLE:  File_Name :=  'C:\ME\INIT.SRC';

LOAD_FILE( Filename )  procedure

    ACTION:     Loads the specified file into the current window.  Get error
                code via the ERROR_LEVEL variable.  (See ERROR HANDLING)

    EXAMPLE:    {Load the file}
                Load_File( 'Test.Txt' );
                   {If error, then run the error macro}
                IF Error_Level <> 0 THEN
                   Run_Macro( 'MEERROR' );
                END;

SAVE_FILE  procedure

    ACTION:     Saves the file in the current window.  Get error code via
                the ERROR_LEVEL variable. (See ERROR HANDLING)

    EXAMPLE:    {Save the current file}
                Save_File;
                   {If error, then run the error macro}
                IF Error_Level <> 0 THEN
                   Run_Macro( 'MEERROR' );
                END;

FILE_EXISTS( filename )  integer function

    RETURNS:    True (1) if the specified file exists.

    EXAMPLE:    {If file exists then load it}
                FStr := 'TEST.SRC';
                If File_Exists( FStr ) THEN
                   Load_File( Fstr );
                END;
                   {If error, then run the error macro}
                IF Error_Level <> 0 THEN
                   Run_Macro( 'MEERROR' );
                END;

FIRST_SAVE  integer function

    RETURNS:    True(1) if the current file has been save at least once
                since the start of the editing session.

EOF_IN_MEM  integer function

    RETURNS:    True (1) if the end of the file is in memory, false (0) if
                the EOF is still on disk.

BUFFER_ID  integer function

    RETURNS:    The ID # of the file buffer that the current window is
                attached to.

TMP_FILE  integer function

    RETURNS:    True if a temporary file is being used for this buffer.

TMP_FILE_NAME  string function

    RETURNS:    The name of the temporary file being used by this buffer.

TEMP_PATH  string variable

        The full directory path where Multi-Edit is to store its temporary
        files.  See VIRTUAL MEMORY.

BACKUP_PATH  string variable

        The full directory path where Multi-Edit is to store backup files.
        This variable is only used if the integer variable BACKUPS is set
        to 2.  See AUTOMATIC BACKUPS

FIRST_FILE( filename )  integer function

    ACTION:     Searches for the first occurrence of the specified filename.
                The filename may include DOS wildcard characters (* and ?)
                and a complete path.

    RETURNS:    Zero if the file was found, else DOS error code 18 is
                returned.

    EXAMPLE:    (see NEXT_FILE)

NEXT_FILE  integer function

    ACTION:     Searches for the next occurrence of the filename started by
                FIRST_FILE.

    RETURNS:    Zero if the file was found, else DOS error code 18 is returned

    EXAMPLE:    {Find all occurrences of a filename string and load them}
                TStr := '*.SRC';
                IF FIRST_FILE(TSTR) = 0 THEN
                   TStr := LAST_FILE_NAME;
                   Call Do_Load_File;
                   WHILE (NEXT_FILE = 0) DO
                      TStr := TStr2 + LAST_FILE_NAME;
                          {call a routine to load the file}
                      Call Do_Load_File;
                   END;
                END;

LAST_FILE_NAME  string function

    RETURNS:    The last filename found by a FIRST_FILE or NEXT_FILE search.

    EXAMPLE:    (See NEXT_FILE)

FILE_CHANGED  integer variable

        If this flag is true (1) then the file has been modified since being
        loaded or saved.  Saving a file will set this flag to false (0).

BACKUPS  integer variable

        0 = Do NOT create backup files.
        1 = Create .BAK files.
        2 = Copy backup files into directory specified by BACKUP_PATH
        See AUTOMATIC BACKUPS

AUTOSAVE  integer variable

        If 0, then automatic file save is off, else AUTOSAVE equals the
        number of seconds that the computer must be idle before the autosave
        macro is invoked.  By idle, we mean a period in which no keystrokes
        or mouse operations are entered.

        The autosave function invokes the macro AUTOSAVE.

TRUNCATE_SPACES  integer variable

        TRUE (1) = Upon loading a file, Multi-Edit will truncate any
                trailing spaces on a line.
        FALSE (0) = don't truncate trailing spaces.

READ_ONLY  integer variable

        TRUE (1) = Allow the file to be viewed but not modified.
        FALSE (0) = Allow normal editing.



                ======================================
                =   FUNCTION KEY LABEL OPERATIONS    =
                ======================================

PUSH_LABELS  procedure

    ACTION:     Pushes a new blank set of function key labels onto the key
                label stack.

    EXAMPLE:    (See FLABEL below.)

POP_LABELS  procedure

    ACTION:     Pops the current set of function key labels off the stack,
                restoring the previous set.

    EXAMPLE:    (See FLABEL below.)

FLABEL( String, Key_num, Mode )  procedure

    ACTION:     Modifies a key label.  String is a six character string
                variable or literal.  Key_num represents the function key
                number.  It is assigned as follows: <F1> through <F10> = 1
                through 10 <ShftF1> through <ShftF10> = 11 through 20
                <CtrlF1> through <CtrlF10> = 21 through 30 <AltF1> through
                <AltF10> = 31 through 40 All other numbers are ignored. Mode
                is the Multi-Edit mode where the label will be used. 0 =
                EDIT, 1 = DOS_SHELL, 255 = the current labels, regardless of
                mode.

  EXAMPLE:   {Assign label to <F3> from EDIT mode (using the constant 'EDIT')
                FLABEL( 'SAVE', 3, EDIT );
                   {Create new set of labels}
                PUSH_LABELS;
                   {Assign label to <ShftF5> within current labels}
                FLABEL( 'RUN_DS', 15, 255 );
                   {Wait for key to be pressed}
                READ_KEY;
                   {Restore old labels}
                POP_LABELS;



                       ======================
                       =   KEY ASSIGNMENTS  =
                       ======================

MACRO_TO_KEY( Key_code, Macro_spec, Mode )  procedure

    ACTION:     Assigns a macro to a specified key from a specified
                Multi-Edit mode.  When the key is hit Multi-Edit will
                attempt to run the macro just as if the Run_Macro function
                had been invoke.

                Key_code is any legal key code constant.
                (see EXTENDED KEY SYNTAX for a complete list of valid key
                code constants).

                Macro_spec is a string which should contain a valid macro
                name, an optional macro file name, and an optional parameter
                string.  The format should be as follows:

                        Macro_file_nameacro_name Parameter_String

                Notice the carat " delimiter between the macro file name
                and the macro name, and the space delimiter " " between the
                macro name and the parameter string.  Mode is the Multi-Edit
                mode from which the macro is to be invoked.  Currently EDIT,
                DOS_SHELL and ALL are supported.

    EXAMPLE:    MACRO_TO_KEY( <AltF9>, 'RUNPROG', Edit);

CMD_TO_KEY( Key_code, Cmd_constant, Mode )  procedure

    ACTION:     Similar to MACRO_TO_KEY except that a Multi-Edit command is
                assigned to a key instead of a macro name.  A complete list
                of all legal command names is listed in
                COMMANDS THAT ARE DIRECTLY ASSIGNABLE TO A KEY.

    EXAMPLE:      {Assign the command WORD_RIGHT to the
                   Control-Right-Arrow key from edit mode}
                CMD_TO_KEY( <CtrlRT>, WORD_RIGHT, Edit);

UNASSIGN_KEY( Key_code, Mode )  procedure

    ACTION:     Removes any macro, command or keystroke macro assignment
                from the specified key in the specified Multi-Edit mode.


INQ_KEY( key1, key2, mode ) string function

    RETURNS:    A string containing the key assigment (as assigned with
                MACRO_TO_KEY) of the specified keycode (key1 and key2).
                If INQ_KEY returns a NUL (empty) string, then there is
                no macro assignment.

See also EXTENDED KEY SYNTAX

            ======================================================
            =   COMMANDS THAT ARE DIRECTLY ASSIGNABLE TO A KEY   =
            ======================================================

CR			TAB_LEFT 		MODIFY_WINDOW
LEFT 			TAB_RIGHT 		UNLINK_WINDOW
RIGHT			INDENT 			CREATE_WINDOW
UP			UNDENT 			ENTER_DOS_SHELL
DOWN			DEL_CHAR		CALCULATOR
HOME			DEL_LINE		QUIT
EOL			BACK_SPACE		REDRAW
PAGE_UP			UNDO			NEWSCREEN
PAGE_DOWN		BLOCK_BEGIN		REST_DOS_SCREEN
TOF			BLOCK_END		SAVE_DOS_SCREEN
EOF			COL_BLOCK_BEGIN		KEY_RECORD
NEXT_PAGE_BREAK		COL_BLOCK_END		PUSH_UNDO
LAST_PAGE_BREAK		COPY_BLOCK		POP_UNDO
WORD_LEFT		MOVE_BLOCK		DELETE_WINDOW
WORD_RIGHT		DELETE_BLOCK		ERASE_WINDOW
MARK_POS	 	BLOCK_OFF		ZOOM
GOTO_MARK		SAVE_FILE		FIRST_WORD



                     ===========================
                     =    KEYSTROKE MACROS     =
                     ===========================

KEY_IN( keystroke string )  procedure

The KEY_IN statement is used to pass keystrokes to editor.  The keystroke
string is entered without quotes.

    EXAMPLE:
                        KEY_IN(This is a test string<ENTER>);

would enter in the string followed by a carriage return. Note that currently s
may not be entered.  Keystroke strings may be any number of lines long.

PLAY_KEY_MACRO( keycode1, keycode2 )  procedure

    ACTION:     Starts the specified keystroke macro playing. The keystrokes
                may then be read via the READ_KEY or CHECK_KEY operations.

KEY_RECORD  procedure

    ACTION:     Starts or stops the recording of a keystroke macro.

See also EXTENDED KEY SYNTAX


                  ==================================
                  =    MACHINE LEVEL INTERFACE     =
                  ==================================

INTR( interrupt_num )  procedure

    ACTION:     Performs a software interrupt.  Passes values in the
                register variables listed next.  Returns values in
                those same variables.

R_AX, R_BX, R_CX, R_DX, R_SI, R_DI, R_DS, R_ES, R_FLAGS  integer variables

                These are the register variables used with INTR.  Only the
                lower 16 bits of each variable are used..

CPU  integer function

    RETURNS:    0 = 8086/8088
                1 = 80186/80188
                2 = 80286
                3 = 80386


MEMB( address, value )  procedure

    ACTION:     Sets the byte at address to value.  Address is a
                32 bit integer, which, on 8086 type hardware contains
                both a segment (the high word) and an offset (the low word).
                Arithmetic operations may be performed on an address as
                long as the operation does not cause the offset to spill
                over into the segment.

MEMW( address, value )  procedure

    ACTION:     Sets the word at address to value.

MEMP( address, value )  procedure

    ACTION:     Sets the pointer (on 8086 type hardware this is a 32 bit
                number and includes both a segment and offset) at
                address to value.

MEMB( address )  integer function

    RETURNS:    Returns the value of the byte at address.

MEMW( address )  integer function

    RETURNS:    Returns the value of the word at address.

MEMP( address )  integer function

    RETURNS:    Returns the value of the 32 bit pointer at address.

MEMSTR( address, count )  string function

    RETURNS:    Returns a  string is create from count characters (bytes)
                starting at address.

POKE( segment, offset, value )  procedure

    ACTION:     Sets a the byte at segment:offset to value.  This procedure
                is 8086 type machine specific.  The MEMB, MEMW and MEMP
                procedures and functions are preferred because they are
                portable to other machine architectures.

PEEK( segment, offset )  integer function

    RETURNS:    The byte at segment:offset.  This function is 8086 type
                machine specific.  The MEMB, MEMW and MEMP procedures and
                functions are preferred because they are portable to other
                machine architectures.

SEG( local variable )  integer function

    RETURNS:    The segment address of the passed local variable (may be
                of any type.

OFS( local variable )  integer function

    RETURNS:    The offset address of the passed local variable (may be of
                any type.


                     ===========================
                     =    MACRO OPERATIONS     =
                     ===========================

RUN_MACRO( Macro_spec )  procedure

    ACTION:     Executes a macro.  Macro_Spec consists of a macro name, an
                optional macro file name, and an optional parameter string.
                The format is as follows:

                        Macro_file_nameacro_name Parameter_string

                Notice the carat " delimiter between the macro file name
                and the macro name, and the space " " delimiter between the
                macro name and the parameter string.  Both the file name and
                macro name may be any valid DOS file name (including a
                path).  When Multi-Edit executes a macro, it first looks for
                the macro in memory.  If it doesn't find it then it checks
                the Multi-Edit subdirectory (found with the ME_PATH
                function).  If the macro cannot be found, then ERROR_LEVEL
                will be set to NON- ZERO.  The '.MAC' file name extension is
                assumed.

    EXAMPLE:    { Run the LOADFILE macro.  If it is not in memory then get
                  it from the macro file MEUTIL1.MAC pass a numeric
                  parameter /P of 1 and a string parameter /L of "NEW"}

                Run_Macro( 'MEUTIL1OADFILE /P=1/L=NEW');

LOAD_MACRO_FILE( Macro_file_name )  procedure

    ACTION:     Loads a macro file into memory, but does not run it.  Check
                the ERROR_LEVEL flag for errors.

    EXAMPLE:    {Load macro file into memory}
                Load_Macro_File('Test');
                 {If an error occurred, then inform user, else run the macro}
                IF Error_Level <> 0 THEN
                   Beep;
                   Make_Message('Can''t load macro!');
                   Error_Level := 0;
                ELSE
                   Run_Macro( 'Test' );
                END;

UNLOAD_MACRO( Macro_name )  procedure

    ACTION:     Dumps a macro from memory.

    EXAMPLE:   {Dump the macro Test from memory}
                Unload_Macro( 'Test' );

INQ_MACRO( Macro_name )  integer function

    RETURNS:    True if the macro specified by Macro_name is loaded into
                memory.

    EXAMPLE:   {If macro is not in memory, then load it}
                IF Inq_Macro( 'Test' ) THEN
                   Load_Macro_File( 'Test' );
                   IF Error_Level <> 0 THEN
                      Make_Message( 'Error on loading macro.');
                      Error_Level := 0;
                   END;
                END;

FIRST_RUN  integer function

    RETURNS:    True (1) if this is the first time a macros been run since
                it was loaded.

FIRST_MACRO  string function

    RETURNS:    The name of the first macro that is in memory.  This
                initiates calls to NEXT_MACRO, allow access to the entire
                list of macros in memory.

NEXT_MACRO  string function

    RETURNS:    The name of the next macro in list.  Returns a NUL string if
                there are no more macros to list.

                ===================================
                =     MISCELLANEOUS OPERATIONS    =
                ===================================

BEEP  procedure

    ACTION:     Guess!!

    EXAMPLE:       {If an error occurred, then beep}
                   IF Error_Level <> 0 THEN
                      Beep;
                   END;

DELAY( Time )  procedure

    ACTION:     Delays for Time milliseconds.

    EXAMPLE:      {Wait for 1/10 second}
                Delay( 100 );

NOT( integer )  integer function

    RETURNS:    If integer is non-zero, then NOT will return 0.
                If integer is zero, then NOT will return 1.
                (Used for true/false type expressions)

MODE  integer function

    RETURNS:    An integer containing the current mode or  module that is
                being used.

                        0 =  Text Editing.
                        1 =  DOS Shell.
                        2 =  (currently undefined)
                        3 =  Communications Module.

    EXAMPLE:    IF Me_Mode = 1 THEN
                   EXIT_DOS_SHELL;
                END;
PRINT_STR( String )  procedure

    ACTION:     Sends the string to the PRN device (usually the printer).
                Get error code via the ERROR_LEVEL function.  (See
                ERROR_HANDLING)

    EXAMPLE:    Goto_Line(10);
                Goto_Col(1);
                Print_String(Get_Word(''));

PRINT_MARGIN  integer variable

        The margin set for printing of a file or block.

VERSION  string function

    RETURNS:    A string containing the Multi-Edit version number.

USER_ID  string function

        A 0 to 3 character string containing the unique machine or user
        identification code to be used in a networking situation.  See
        NETWORK SUPPORT.

MOUSE  integer variable

        Turns recognition of mouse functions on (1) and off (0).

LOGO_SCREEN  integer variable

        Only effective if SAVE_SETUP is invoked.  Setting LOGO_SCREEN to 0,
        then invoking SAVE_SETUP will bypass the logo screen on subsequent
        Multi-Edit sessions.


MOUSE_H_SENSE  integer variable

        The horizontal mouse sensitivity.  The higher the number, the less
        sensitive the mouse will be.

MOUSE_V_SENSE  integer variable

        The vertical mouse sensitivity.  The higher the number, the less
        sensitive the mouse will be.

INIT_VIDEO_MODE  integer variable

        Used strictly by the INIT macro to set the initial video mode.  Same
        values as the function VIDEO_MODE.

EMS_STAT  integer variable

        Bit 0 :  1 = Use EMS for data storage.
                 0 = Do NOT use EMS for data storage.
        Bit 1 :  1 = Swap to EMS when executing other programs.
                 0 = Do NOT swap to EMS.

        EXAMPLE:
                  {Turn EMS swapping OFF}
                EMS_Stat := EMS_Stat AND $FD;


                  ================================
                  =    TABSTOPS AND INDENTING    =
                  ================================

TAB_RIGHT  procedure

    ACTION:     Moves the cursor one Tabstop to the right.  If Insert_Mode =
                TRUE, then a tab stop

TAB_LEFT  procedure

    ACTION:     Moves the cursor one Tabstop to the left.  No characters are
                inserted or deleted.

INDENT  procedure

    ACTION:     Performs a TAB_RIGHT, then sets the indent level to the
                current cursor position.

UNDENT  procedure

    ACTION:     Moves the cursor one Tabstop back and sets the indent level
                to the new position.  No characters are inserted or deleted.

INDENT_LEVEL  integer function

    RETURNS:    The column position of the indent level for the current
                file.  This is the position where the cursor will be taken
                to when a carriage return or a HOME is performed.

SET_INDENT_LEVEL  procedure

    ACTION:     Sets the indent level for the current file to the current
                column position.

CRUNCH_TABS( local string_variable )  procedure

    ACTION:     When GET_LINE is called it returns the line complete with
                virtual characters (255s).  CRUNCH_TABS takes a string
                variable, and will remove the virtual characters from it.
                String_variable must be a user defined string variable.

    EXAMPLE:    Def_Str( TStr );
                TStr := Get_Line;
                Crunch_Tabs( TStr );

EXPAND_TABS( local string_variable )  procedure

    ACTION:     Expands the tabs in the passed string variable to spaces (if
                the system variable TAB_EXPAND is FALSE) or virtual
                characters (if TAB_EXPAND is true).  String_variable must be
                a user defined variable.

    EXAMPLE:    Def_Str( Tstr );
                Tstr := '|9|9Test paragraph';
                Tab_Expand( TStr );

TABS_TO_SPACES( local string_variable )  procedure

    ACTION:     Converts all tabs and virtual characters in the string
                variable to space characters.

    EXAMPLE:    Def_Str( Tstr );
                Tstr := Get_Line;
                Tabs_To_Spaces( Tstr );

TAB_EXPAND  integer variable

        TRUE (1) = Use tab characters and pad with virtual space.
        FALSE (0) = Use space character instead of tabs.


                     ===========================
                     =    SCREEN OPERATIONS    =
                     ===========================

PUT_BOX( UL_Col, UL_Row, LR_Col, LR_Row,
        BG_Color, FG_Color, Title_string, Shadow )  procedure

    ACTION:     Puts a box on the screen of the dimensions specified by
                UL_Col, UL_Row, LR_Col and LR_Row.  BG_Color is the
                background color, and FG_Color is the foreground color.
                BG_Color may be left out, and FG_Color may contain the
                complete attribute (see COLORS).  Title_string specifies a
                title that will be centered on the top of the box.  If
                Shadow is TRUE, then the box will have a shadow around it.
                If a shadow is specified, then remember to include the one
                vertical line and two horizontal spaces that the shadow
                takes up, in the box dimensions.  Note that the section of
                the screen where the box is drawn is saved onto a stack.  It
                may be restored with the Kill_Box operation.

    EXAMPLE:       {Put a box on the screen for error messages}
                Put_Box( 5, 4, 62, 12, White, Red, 'ERROR', TRUE );
                   {Prompt user}
                Write( 'Hit any key to continue...',6,5,White, Red );
                   {Wait for key}
                Read_Key;
                   {Get rid of box}
                Kill_Box;

KILL_BOX  procedure

    ACTION:     Erases the last created box from the screen and restores the
                previous screen contents.

    EXAMPLE:    (see PUT_BOX)

BOX_COUNT  integer variable

    The number of boxes that have been put on the screen.

    EXAMPLE:      {kill all boxes on the screen}
                WHILE Box_Count > 0 DO
                  Kill_Box;
                END;

WRITE( String, Col, Row, BG_Color, FG_Color)  procedure

    ACTION:     Writes a string of text onto the screen at the coordinates
                specified by Col and Row, with background color BG_Color and
                foreground color FG_Color.  BG_Color may be left 0, and
                FG_Color may contain the complete attribute (see COLORS).
                NOTE that this operation does not effect the text in a
                window in any way, it simply writes to the screen.

MAKE_MESSAGE( message_string)  procedure

    ACTION:     Writes a message onto the message line of the screen (by
                default line 2).

    EXAMPLE:    {Display the current character}
                Make_Message('The character is: ' + Cur_Char);

DRAW_CHAR( char_code, line, column, attribute, count )  procedure

    ACTION:     Writes a repeated string of characters to the screen.
                Char_code is an integer value corresponding to an ascii
                code.


SCREEN_LENGTH  integer function

    RETURNS:    An integer containing the number of character rows
                (vertical) displayable on the screen.

SCREEN_WIDTH  integer function

    RETURNS:    An integer containing the number of characters (Horizontal)
                displayable across the screen.

WHEREX  integer function

    RETURNS:    The actual x coordinate of the physical on-screen cursor.
                This has no relationship to a window's virtual cursor
                position.

WHEREY  integer function

    RETURNS:    The actual y coordinate of the physical on-screen cursor.
                This has no relationship to a windows virtual cursor
                position.

GOTOXY( x, y )  procedure

    ACTION:     Positions the physical cursor at the specified x,y
                coordinate on the screen.  NOTE that this command does not
                affect the position of a window's virtual cursor.

TOGGLE_VIDEO  procedure

    ACTION:     Toggles the current video mode between 25 line mode and
                whatever denser mode (if any) is supported by the  installed
                video card  (EGA = 43 lines, Color 400 = 50 lines).

VIDEO_CARD  integer function

    RETURNS:    0 = IBM CGA
                1 = IBM Monochrome
                2 = MONROE Color
                3 = MONROE Monochrome
                4 = Sigma Color 400
                5 = EGA Color
                6 = Hercules Monochrome
                7 = VGA Monochrome
                8 = VGA Color
                9 = EGA Monochrome
                10 = Wyse 700

VIDEO_MODE  integer function

    RETURNS:    0 = 80 x 25 (normal)
                1 = 80 x 50 (Sigma Color 400)
                2 = 80 x 43 (EGA)
                3 = 80 x 50 (VGA)

PUT_LINE_NUM( num )  procedure

    ACTION:     Puts the specified number (num is an integer) into the L[ ]
                display of the current window.

PUT_COL_NUM( num )  procedure

    ACTION:     Puts the specified number (num is an integer) into the C[ ]
                display of the current window.

WORKING  procedure

    ACTION:     Invokes the flashing 'WORKING' message in the Multi-Edit
                status line.  The message goes away when REDRAW or NEW_SCREEN
                is called.


SCROLL_BOX_UP( x1, y1, x2, y2, attribute )  procedure

    ACTION:     Scrolls a region of the screen up 1 line.  Attribute is a
                single byte used to set the colors of the new line.  The
                lower 4 bits are the foreground color, the next 3 bits are
                the background color and the high bit is the blink/underline
                status.

    EXAMPLE:    Scroll_Box_Up(1,1,80,25, (Back_Color shl 4) or Text_Color);

SCROLL_BOX_DN( x1, y1, x2, y2, attribute )  procedure

    ACTION:     Same as Scroll_Box_Up, except that it scrolls the screen
                region down.

CLEAR_SCREEN( attribute_byte )  procedure

    ACTION:     Clears the screen and sets the colors as defined by
                attribute_byte, where the lower 4 bits are the foreground
                color, the next 3 bits are the background color, and the
                high bit is the blink/underline status.

EXPLOSIONS  integer variable

        TRUE (1) = Pop up boxes and windows will explode.
        FALSE (0) = No explosions.


               ======================================
               =    SEARCH AND REPLACE OPERATIONS   =
               ======================================

NOTE:  See the SEARCH AND REPLACE in the main Multi-Edit help for more
information on regular expressions.

SEARCH_FWD( Search_string, Num_lines )  integer function

    ACTION:     Searches forward for Search_string from the current cursor
                position Num_lines number of lines.  If Num_Lines = 0, then
                the search is performed to the end of the file.  If
                Search_string is found, then the cursor will be positioned
                at the first character of the found item.  NOTE that the
                system variable IGNORE_CASE is used to determine whether or
                not the search is case sensitive.

    RETURNS:    1 if the string was found, 0 if not found.

    EXAMPLE:    (See REPLACE)

SEARCH_BWD( Search_string, Num_lines )  integer function

    ACTION:     Searches backward for Search_string from the current cursor
                position Num_lines number of lines.  If Num_lines = 0, then
                the search is performed to the top of the file.  NOTE that
                the system variable IGNORE_CASE is used to determine whether
                or not the search is case sensitive.

    RETURNS:    An integer. 1 (TRUE) if the string was found, 0 if not found.

REPLACE( replace_string )  procedure

    ACTION:     The last Search match is replaced with replace_string.  Does
                not effect the cursor position. NOTE that the cursor must
                not have moved since the Search.

    EXAMPLE:      {Find all occurrences of 'WHAT' or 'WHERE' and
                        replace them with 'WHY', ignoring the case}
                Ignore_Case := True;
                WHILE Search_Fwd('{WHAT}||{WHERE}', 0 ) DO
                  Replace( 'WHY' );
                END;

IGNORE_CASE  integer variable

        Set to TRUE (1) to ignore the case of alpha characters during a
        search.

REG_EXP_STAT  integer variable

        True (1) = Regular expressions enabled.
        True (0) = Regular expressions disabled.


                        REGULAR EXPRESSIONS
                   ------------------------------

Regular expressions are basically sophisticated wild cards.  They provide
the ability to deal with unprintable characters like "beginning of line"
or "end of line", specific sets or "classes" of characters, strings of
unknown length, and multiple groups of characters in a single search
pattern or replace pattern.

                     SEARCH STRING EXPRESSIONS

*       match 0..n occurrences of the previous character or expression.
+       match 1..n occurrences of the previous character or expression.
?       match any character.
[]      match class of characters.  Example:   [a-zA-Z0-9_]
[~]     match any character except the enclosed class.
%       match beginning of line.
$       match end of line.
@       match (or replace) next character literally.
{}      encloses a group of 1 or more expressions.  Max # of groups = 10
|       match previous OR next expression.
                 Example:  {BEGIN}|{END} would match either "BEGIN" or "END";
                 NOTE:  A character is counted as an expression.  Therefore,
                 BEGIN|END would match either "BEGINND" or "BEGIEND".


                        REPLACE STRING EXPRESSIONS

$       Inserts a carriage return.
%       Deletes a character.  May be used to delete an end of line.
&       Insert the original found text.
^       Place cursor at this position in the replaced text.
#n      Insert text matched by group number 'n',  n = 0 through 9.
                 Example:  Search = {POS(}{?*,}{?*,}  Replace = #0#2#1
                 would swap the parameters for the function POS(str1,str2);


                    SEARCH AND REPLACE EXAMPLES
                -----------------------------------

Search = %|[~a-z0-9_][a-z0-9_]          Find next word.
Search = @$                             Find literal "$".
Search = (?*)                           Find parenthesis set.
Search = [=><!@|&]                      Find C relational operator.
Search = {"?*"}|{'?*'}                  Find single or double quotes set.
Search = [~0-9]                         Find any character except a digit.
Search = {wow}+                         Find one or more occurrences of "wow".
Search = {if}|{else}                    Find "if" or "else".

Search = {{this is}|{this is not}} a test
Replace = #0 a pizza                    Find "this is a test" or "this is not
                                        a test" and replace with "this is a
                                        pizza".

Search = %$
Replace = %                             Search for a blank line and delete it.

Search = {;} *{[~ ]?+;}
Replace = #0$#1                         Search for two semi-colon delimited
                                        the line, removing any preceding                                           statements on a single line and break
                                        spaces on the new line.



               ======================================
               =   STRING MANIPULATION OPERATIONS   =
               ======================================

ASCII( String )  integer function

    RETURNS:    An integer containing the ASCII value of the first character
                in the string.  If the string is empty, then the result will
                be 0.

    EXAMPLE:    JX := ASCII( 'A' ); {The ascii value of 'A'}

CAPS( String )  string function

    RETURNS:    The entire string in capitalized form.

    EXAMPLE:    Good_Str := CAPS(Good_Str);

CHAR( Integer_value)  string function

    RETURNS:    A the character (string) equivalent of the passed ASCII
                value.

COPY( String, Pos, Num )  string function

    RETURNS:    A substring (or portion) of String containing Num characters
                starting at position Pos.  If Pos is greater than the length
                of String, an empty string will be returned.  If Pos < 1 or
                Pos > 2048, then a zero length string will be returned.

    EXAMPLE:            {Get the 1st 3 characters of Temp_Str}
                        Temp_Str := Copy( Temp_Str, 1, 3 );

LENGTH( String )  integer function

    RETURNS:    The integer length of the string.

    EXAMPLE:    If Length(Test_String) > 80 Then
                                Text('String is too long.');
                        End;

SVL( local string_variable )  integer function

     RETURNS:   The length of the passed string variable.  This is
                much faster than using LENGTH, but only works on
                local string variables.


XPOS( Substring, String, Start_position )  integer function

    RETURNS:    An integer containing the position of substring in String.
                Returns 0 if substring is not found.  The search will start
                at Start_position in the string.

    EXAMPLE:    What_Pos := XPos( 'WHAT', Test_String, 12 );

STR_DEL( String, Pos, Num )  string function

    Returns:    The result of deleting a substring containing Num characters
                from String starting at position Pos.

    EXAMPLE:    Test_String := STR_DEL(Test_String, 9, 4);

STR_INS( Target_string, Destination_string, Location )  string function

    RETURNS:    The result of inserting the Target_string into the
                Destination_string at the specified Location.

    EXAMPLE:       {Insert 'HELP' into Test_String at position 0}
                Test_Str := STR_INS('HELP',Test_String,9);

STR( Integer_value )  string function

    RETURNS:    A string representation of the integer value.

    EXAMPLE:    {Put the current line number on the message line}
                Make_Message('Processing line: ' + Str(C_Line));

VAL( Result, String )  integer function

    ACTION:     Converts a the string expression String to an integer value,
                stored in Result.

    RETURNS:    0 if no errors are detected, otherwise the position in the
                string of the error is returned.

    EXAMPLE:    IF Val(Temp_Value, '1000') = 0 Then
                   New_Value := Old_Value + Temp_Value;
                END;

REMOVE_SPACE( String )  string function

    RETURNS:    The string, with any preceding and trailing spaces removed,
                and with any occurrences of more than one consecutive space
                removed.

GET_EXTENSION( Filename )  string function

    RETURNS:    A string containing the DOS extension part of Filename.

    EXAMPLE:    Extension := Get_Extension(Old_file);

GET_PATH( Filename )  string function

    RETURNS:    A string containing the DOS path (drive and directory) part
                of Filename string.

    EXAMPLE:    If Get_Path(File_Name) <> 'C:\TEST\' Then
                   Enter_Dos_Shell;
                End;

TRUNCATE_EXTENSION( Filename )  string function

    RETURNS:    A string containing the filename without an extension.

    EXAMPLE:    New_File := Truncate_Extension(File_Name) + '.NEW';

TRUNCATE_PATH( Filename )  string function

    RETURNS:    A string containing the filename without a path.

    EXAMPLE:    New_File := 'B:\NEW\' + Truncate_Path(File_Name);


                ======================================
                =    OPERATING SYSTEM INTERFACE      =
                ======================================

SHELL_TO_DOS( Cmd_string, Cmd_flag )  procedure

    ACTION:	Shells to DOS and executes the command specified in
		Cmd_string.  If Cmd_flag is true then COMMAND.COM is used to
		execute Cmd_string, else Multi-Edit attempts to run
		Cmd_string directly.  In order to execute any of the
		internal dos commands like DIR, DEL or COPY Cmd_flag must be
		true.  If Cmd_string = '' (empty string) then COMMAND.COM is
		simply executed.

                If EMS Swapping is ON and REDUCE_MEM is TRUE then Multi-Edit
		will swap as much of its data area as possible out to
		expanded memory in order to free up room for other programs.

    EXAMPLE:	{Copy a file}
		SHELL_TO_DOS( 'COPY ME.HLP A:', TRUE );

EXIT_CODE  integer function

    RETURNS:	The DOS exit code after a SHELL_TO_DOS has been executed.
		NOTE:  If you use COMMAND.COM (Cmd_Flag = True), then the
		exit code will be whatever COMMAND.COM returns, not what the
		program specified by Cmd_String returned.  See SHELL_TO_DOS.

REDUCE_MEM  integer variable

    TRUE(1) = 	Free up all available memory to DOS when executing
		SHELL_TO_DOS.

    FALSE(0) =  Do NOT free up any of Multi-Edit's memory when executing
		SHELL_TO_DOS.

COMSPEC  string function

    RETURNS:	A string containing the path to find COMMAND.COM.

    EXAMPLE:	{Execute COMMAND.COM}
		SHELL_TO_DOS( Comspec, FALSE );

GET_ENVIRONMENT( entry_name )  string function

    RETURNS:	Parses the DOS environment area for entry_name and returns
		the string associated with it.

    EXAMPLE:	Tstr := Get_Environment( 'ME_PATH=' );

REST_DOS_SCREEN  procedure

    ACTION:	Restores the screen that was saved upon startup of
		Multi-Edit or upon the last call to SAVE_DOS_SCREEN.

    EXAMPLE:	(See SAVE_DOS_SCREEN)

SAVE_DOS_SCREEN  procedure

    ACTION:	Saves the current screen.

    EXAMPLE:	   {Restore the previous screen}
		RESTORE_DOS_SCREEN;
		   {Execute batch file}
		SHELL_TO_DOS( 'MAKE_LST', TRUE );
		   {Save the screen}
		SAVE_DOS_SCREEN;


DATE  string function

    RETURNS:	A string containing the current date according to the system
		clock.  The format is: mm/dd/yy

    EXAMPLE:	   {Insert the date}
		Text('The date of this document is:' + Date);

TIME  string function

    RETURNS:	A string containing the current time according to the system
		clock.  The format is: hh:mm:ssam (or pm)

    EXAMPLE:	{Act like an alarm clock}
		IF Time = '07:35:00am' THEN
		   Beep;
		   Make_Message('Good morning Mr. Phelps!');
		END;

ME_PATH  string function

    RETURNS:	A string containing the DOS path to find the ME overlay files.

QUIT( Return_Code )  procedure

    ACTION:	Exits Multi-Edit.  Return_Code is an integer value, and may
		be evaluated from a batch file with the DOS ERRORLEVEL
		operation.  Note that if changes have been made to files,
		and the files have not been saved, then data will be lost.

    EXAMPLE:	   {Save off current file}
		Save_File;
		   {If no errors, then quit}
		IF Error_Level = 0 THEN
		   Quit;
		END;

PARAM_COUNT  integer function

    RETURNS:	An integer containing the number of parameters passed to
		Multi- Edit on the dos command line.

    EXAMPLE:	(See PARAM_STR)

PARAM_STR( param_number )  string function

    RETURNS:	A string containing the specified command line parameter.
		With DOS Version 3 and above, a param_number value of 0 will
		return the name of the command that invoked Multi-Edit.  DOS
		Version 2 will return an empty string for param_number 0.

    EXAMPLE:	   {Get the first parameter on the command line
		    if the parameter was entered.}
		IF Param_Count > 0 THEN
		   Test_Parameter := Param_Str(1);
		END;

DOS_VERSION  integer function

    RETURNS:	Integer containing the DOS version number as follows:
			Low Byte = Major version number.
			Hi Byte = Minor version number.

    EXAMPLE:	{Get the dos version and display it}
		JX := DOS_VERSION;
		JL := JX AND $00FF;
		JH := JX SHR 8;
		Make_Message('DOS Version = ' + Str(JL) + '.' + Str(JH));

		{If jx equals 2003 hex, then the dos version number would be
		 3.20}


DOS_BACK  integer function

    RETURNS:	The background color (integer) that was being used by DOS
		before entering Multi-Edit.

DOS_COLOR  integer function

    RETURNS:	The foreground color (integer that was being used by DOS
		before entering Multi-Edit.

CHANGE_DIR( path_string )  procedure

    ACTION:	Changes the current directory.  The DOS DIRECTORY SHELL does
		NOT need to be active.  Error_Level will be non-zero if an
		error occurred.

    EXAMPLE:	Change_Dir( '\DOCUMENT' );
		IF Error_Level <> 0 THEN
		  Make_Message( 'Error changing directory' );
		  Error_Level := 0;
		END;

DEL_FILE( filename_string )  procedure

    ACTION:	Deletes the specified file.  Wildcard characters are NOT
		allowed.  The DOS DIRECTORY SHELL does NOT need to be
		active.  Error_Level will be non-zero if an error occurred.

WRITE_SOD( string )  procedure

    ACTION:	Writes the string to the standard output device.

    EXAMPLE:	{Write message + CR/LF to standard output}
		Write_SOD( 'Lots of FUN!|13|10' );

See also MACHINE LEVEL INTERFACE


               ====================================
               =   TEXT MANIPULATION OPERATIONS   =
               ====================================

CUR_CHAR  string function

    RETURNS:    The character that the cursor is sitting on in the currently
                active window.  If the cursor is sitting on virtual space or
                beyond the end of a line then ASCII 255 will be returned.

    EXAMPLE:    Temp_String := Temp_String + Cur_Char;

GET_WORD( Delimit_string )  string function

    RETURNS:    A portion of the current line starting at the current cursor
                position and ending before the occurrence of any character
                in the Delimit string, or the end of the line.  Moves the
                cursor to the end of the returned string.

    EXAMPLE:    {Get a word}
                New_Word := Get_Word( ' $*().!{}' );

GET_LINE  string function

    RETURNS:    A copy of the  entire line the cursor is sitting on.

    EXAMPLE:    {Get the current line and put it in Temp_Str}
                Temp_Str := Get_Line;

PUT_LINE( String )  procedure

    ACTION:     Replaces the line the cursor is sitting on with the string.

    EXAMPLE:    {Replace current line with new string}
                Put_Line( 'This is a new line.' );

CR  procedure

    ACTION:     Performs a carriage return.  Will break a line if Insert
                mode is on.

    EXAMPLE:    {Insert a new line}
                Insert_Mode := TRUE; {Set the insert mode}
                EOL;    {goto the end of the line}
                CR;     {perform the carriage return}

TEXT( String )  procedure

    ACTION:     Inserts (or overwrites) a string of text into the current
                line at the current cursor position.  This operation is
                sensitive to the insert/overwrite mode.

    EXAMPLE:    {Insert some text}
                Insert_Mode := TRUE;
                Text( 'This is some text.' );

DEL_CHAR  procedure

    ACTION:     Deletes the current character.

DEL_CHARS( Count )  procedure

    ACTION:     Deletes Count characters at the current cursor position.

    EXAMPLE:    Del_Chars( 10 );        {Delete the next 10 chars}

DEL_LINE  procedure

    ACTION:     Deletes the current line

    EXAMPLE:    {Delete all lines to the end of the file}
                WHILE NOT( At_Eof ) DO
                   Del_Line;
                END;

BACK_SPACE  procedure

    ACTION:     Moves the cursor to the left. If Insert_Mode is true, then
                the current character is deleted, or if the cursor is at
                column 1, then the current line will be concatenated to the
                previous line.  If Insert_Mode is false (i.e. Overwrite
                mode) then the character is replaced by a space, and no
                concatenation of lines will occur.

    EXAMPLE:    {Attach current line to previous line}
                Insert_Mode := TRUE;
                Goto_Col( 1 );          {Goto first character}
                Back_Space;             {Perform back space}

INSERT_MODE  integer variable

        If this flag is true (1) then the editor is in text insert mode,
        otherwise it is in overwrite mode.  Note that assigning a value to
        this flag will update the Insert/Overwrite display and change the
        cursor shape.


                      =======================
                      =   UNDO OPERATIONS   =
                      =======================

An UNDO Buffer is maintained for each unique file loaded into Multi-Edit.
Each individual undo "record" may contain an unlimited number of text
changes, cursor movements, and block operations.  The UNDO procedure
reverses all changes stored in then most recent undo record.  The beginning
and end of an undo record is defined with the PUSH_UNDO and POP_UNDO
procedures.  PUSH_UNDO and POP_UNDO may be nested up to 32767 levels deep.

UNDO  procedure

    ACTION:     Undoes the last set of text operations.

REDO  procedure

    ACTION:     Undoes the last UNDO.

PUSH_UNDO  procedure

    ACTION:     Starts an undo record. (see POP_UNDO)

POP_UNDO  procedure

    ACTION:     Finishes an undo record.

    EXAMPLE:    {this code may be reversed with a single undo command }
                PUSH_UNDO;              {start undo}
                Del_Chars( 10 );        {delete 10 chars}
                Goto_Col( 1 );
                Text( 'Far out' );
                POP_UNDO;               {stop undo}

MAX_UNDO  integer variable

        Sets the maximum number of UNDO records per file.  May be from
        0-32767;

UNDO_STAT  integer variable

        TRUE (1) = Undo is on globally.
        FALSE (0) = Undo is off globally.


                  ================================
                  =   USER INPUT AND INTERFACE   =
                  ================================

READ_KEY  procedure

    ACTION:     Suspends execution and waits for a keystroke. Returns the
                scan codes of the keystroke in KEY1 and KEY2.

    EXAMPLE:    {Get keycode}
                Read_Key;
                {If key1 = 0, then extended key was hit}
                IF Key1 = 0 AND Key2 = 59 THEN
                   Make_Message('You hit F1!');
                END;

CHECK_KEY  integer function

    RETURNS:    True (1) if a key has been pressed.The scan codes of the
                keystroke are accessed via the functions KEY1 and KEY2.  The
                equivalent of READ_KEY, without suspending execution.

    EXAMPLE:      {If a key has been pressed, then inform user
                    of the type of key}
                IF Check_Key THEN
                   IF Key1 = 0 THEN
                      Make_Message('You hit an extended key.');
                   ELSE
                      Make_Message('You hit a normal key.');
                   END:
                END;

KEY1  integer variable

    An integer containing the first code of the last key that was pressed.
    A value of zero indicates that an extended key was pressed.

    EXAMPLE:    {Check for extended key code}
                IF Key1 = 0 THEN
                   Key_Code := Key2;
                END;

KEY2  integer variable

    An integer containing the second code of the last key that was pressed.

    EXAMPLE:    {If F1 was pressed, then goto end of macro}
                IF Key1 = 0 AND Key2 = 94 Then
                   GOTO End_Of_Mac;
                END;

PUSH_KEY( keycode, scancode )  procedure

    ACTION:     Pushes the passed keycode/scancode combination back onto the
                Multi-Edit keycode buffer.  Up to 16 keycodes may be pushed
                back.

    EXAMPLE:     {Filter out NON extended keys}
                Read_Key;
                IF (Key1 = 0) THEN
                  Push_Key( Key1, Key2 );
                END;

PASS_KEY( keycode, scancode )  procedure

    ACTION:     Passes the keycode/scancode through to Multi-Edit, which
                then performs whatever command or macro is assigned to it.
                This operation is used by the REPEAT macro.


STRING_IN( Input string, Prompt string,Length,
                Col, Row, Help string )  integer function

    ACTION:     Prompts the user to input a string.

                Prompt string is a string expression to serve as a prompt to
                the user.  Input string is the string variable where the
                user response will be stored (one caution is to be sure and
                initialize Input string either to a default response, or to
                an empty string).  Length is the maximum number of
                characters the user may input.  Help string is the index
                into the help file (if <F1> is pressed).

    RETURNS:    An integer containing 1 (TRUE) if the string was inputted
                and enter was pressed or 0 (FALSE) if <ESC> was pressed.

    EXAMPLE:    {Prompt user for his name}
                JX := String_In( Name, 'Enter your name', 20, 2, 2, 'NM');
                   {IF escape was pressed then exit}
                IF JX = 0 THEN
                   GOTO EXIT;
                END;

HELP( Index_str )  procedure

    ACTION:     Brings up the help chapter (in ME.HLP) corresponding to the
                passed 20 character (max) Index_Str.  If the index cannot be
                found, then the main help menu is brought up.  (See
                RETRIEVE_HELP)

    EXAMPLE:    Help('MA');

RETRIEVE_HELP( Index_str, x1, y1, x2, y2,
                Filename, Title )  procedure

    ACTION:     Brings up a help window whose size is specified by x1, y1,
                x2 and y2.  The help file is specified with Filename, and
                the help window may be given a Title.



                      =========================
                      =   WINDOW OPERATIONS   =
                      =========================

Windows have two ways of being identified:

        1.      Each window has a window number.  This number represents
                the windows sequence in the window list.  This number
                may change if windows are deleted or inserted.  Most
                operations that work on windows are passed this number.

        2.      Each window is (upon creation) given a unique Window
                Identification Number.  This number does not change.
                You may switch to a window based upon its Window_Id with
                the Switch_Win_Id procedure.

CREATE_WINDOW  procedure

    ACTION:     Creates a new editing window.  If more than 100 windows are
                created, or Multi-Edit cannot allocate enough memory for a
                new window, then ERROR_LEVEL will be non-zero.
                (See also ERROR HANDLING)

SWITCH_WINDOW( Win_Num )  procedure

    ACTION:     Switches to the window number denoted by the integer
                Win_Num.  If Win_Num is larger than the number of active
                windows, then it will wrap to window 1.

    EXAMPLE:    {Switch to second editing window}
                Switch_Window(2);

CUR_WINDOW  integer function

    RETURNS:    An integer containing the current window number.

    EXAMPLE:    {Switch to next window}
                Switch_Window( Cur_Window + 1 );

SWITCH_WIN_ID( Window_id_number )  integer function

    RETURNS:    TRUE(1) if Window_id_number existed, and Multi-Edit was
                able to switch to the window matching that ID.

WINDOW_ID  integer function

    RETURNS:    The unique window id number for the current window.

SIZE_WINDOW( UL_Col, UL_Row, LR_Col, LR_Row )  procedure

    ACTION:     Changes the dimensions of the current window. The dimensions
                are limited by the current Length and Width of the screen,
                and will be truncated if those values are exceeded.
                (See SCREEN_WIDTH and SCREEN_LENGTH)

    EXAMPLE:    {Change the dimensions of the current window}
                Size window(3,1,23,80);

DELETE_WINDOW  procedure

    ACTION:     Completely deletes the current window.  NOTE THAT ALL DATA
                IN THE WINDOW WILL BE LOST!

    EXAMPLE:    {If no changes detected in the current
                    file then delete the current window}
                IF File_Changed = 0 THEN
                   Delete_Window;
                END;


ERASE_WINDOW  procedure

    ACTION:     Erases the contents of the window, but does not delete the
                window itself.  NOTE THAT ALL DATA IN THE WINDOW WILL BE
                LOST!

    EXAMPLE:      {If no changes detected in the current file
                    then erase the current window}
                IF File_Changed = 0 THEN
                  Erase_Window;
                END;

LINK_WINDOW( Win_Num )  procedure

    ACTION:     Links the current window to the window identified by
                Win_Num;

    EXAMPLE:      {Link the current window to the next window}
                Link_Window( Cur_Window + 1 );

UNLINK_WINDOW  procedure

    ACTION:     Unlinks the current window.

LINK_STAT  integer function

    RETURNS:    The number of windows that the current buffer is linked to.
                0 if the buffer is linked to only one buffer.

REDRAW  procedure

    ACTION:     Updates the display of the current window only.

NEW_SCREEN  procedure

    ACTION:     Redraws the entire screen.

WIN_X1  integer function

    RETURNS:    The upper left hand column of the current window.  If it is
                set to zero, then the left border will not be displayed.
                The maximum value is limited to the width of the screen
                minus 2.

WIN_Y1  integer function

    RETURNS:    The upper left hand row of the current window The minimum
                value is 3.  The maximum value is the length of the screen
                minus 3.

WIN_X2  integer function

    RETURNS:    The lower right hand column of the current window.  The
                minimum value is 4.  The maximum value is the width of the
                screen plus 1 (will cause the right border not to be
                displayed).

WIN_Y2  integer function

    RETURNS:    The lower right hand row of the current window.  The minimum
                value is 5.  The maximum value is the length of the screen
                minus 1.


SCREEN_NUM  integer variable

                This contains the virtual screen number that this
                window is using.  May be from 0 to 32767.  If SCREEN_NUM is
                set to 0, then the window is treated independently, as if
                it took up the whole screen.
                See WINDOWS AND VIRTUAL SCREENS in the Multi-Edit User's
                Guide for an explanation of virtual screens.


WINDOW_COUNT  integer function

    RETURNS:    An integer containing the number of windows  currently
                active.

    EXAMPLE:    {Switch to the very last window}
                Switch_Window( Window_Count );

WINDOW_ATTR  integer variable

        The attributes for the current window.  The bit settings are as
        follows:

        Bit 0 = (1) hidden, (0) not hidden.
        Bit 1 = (1) status info not displayed, (0) status info  displayed.
        Bit 2 = (1) border not displayed, (0) border displayed.

REFRESH  integer variable

        This flag will turn the updating of the window display off or on.
        (1 = On, 0 = Off)  Setting REFRESH to off will significantly
        increase the performance of most macros.


                  ==================================
                  =   WORD PROCESSING OPERATIONS   =
                  ==================================

WORD_WRAP_LINE  procedure

    ACTION:     Starts the wordwrap process from the current line.  Use this
                to reformat a line or paragraph.

C_PAGE  integer function

    RETURNS:    The current page number, starting with 1. (Use in Document
                mode)

PG_LINE  integer function

    RETURNS:    A line number that is not the actual line number in the
                file, but rather an offset from the current page.  (Use in
                Document mode)

FORMAT_LINE  string variable

        The format line string for the current file.  NOTE that ASCII code
        16 is used to represent tab stops in the format line.  An 'R' may be
        imbedded in the line to set the right margin  (See the variable
        RIGHT_MARGIN).  No other characters are treated specially.  The
        format line may be up to 2048 characters long.

FORMAT_STAT  integer variable

        TRUE (1) = Save format line with file.
        FALSE (0) = Do not save format line with file.

WRAP_STAT  integer variable

        TRUE (1) = Wordwrap is on in the current window.
        FALSE (0) = Wordwrap is off in the current window.

DOC_MODE  integer variable

        TRUE (1) = Multi-Edit is in document mode.
        FALSE (0) = Simple text edit mode.

RIGHT_MARGIN  integer variable

        The right hand margin for the current file.  Used for word wrap.

INDENT_STYLE  integer variable

        The indent type for the current file.
        0 = Manual indent.
        1 = Automatic indent.
        2 = Smart Auto-indent.



