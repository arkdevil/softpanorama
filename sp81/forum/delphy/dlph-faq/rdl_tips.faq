                          DELPHI Tips&Tricks N2.03

                                 02.09.1995

  Материал подготовлен в демо-центре
    клиент-серверных технологий. (Epsylon Technologies)
 Материал не является официальной информацией компании Borland.

  E-mail delphi@bor.compnet.ru
           Телефоны: 095-535-0319
                         535-5349

   Источники: Borland International
              Борланд АО
          версии DELPHI FT4,FT5,FT6, релиз Delphi Client-Server 1.0
	                             релиз Delphi Desktop 1.0
          Delphi FAQ от  Graham Mainwaring <graham@mhn.org>
	  различные источники на WWW-серверах,
	  текущая переписка и конференции


     Cоставители: Александр Сергеев        <aes@eps.compnet.ru>
		  Вадим Миллер             <miller@bor.compnet.ru>
                  Dima Kuzmenko            <2:5023/5.13>
		  Олег Кукарцев            <ok@bor.compnet.ru>

 [Примечание: Delphi Tips&Tricks - это коллективный труд, и авторов этого
текста в реальности гораздо больше, чем составителей]

В этом материале могут быть ссылки на материалы семинаров Ассоциации
Пользователей Delphi. Эти материалы доступны как в ДемоЦентре, так и
распространяются по электронной почте (RelCom & FIDO). Например, достаточно
большое число ответов Вы сможете найти в материалах к семинару по BDE
(IDAPI), выпусках электронного журнала Dephi Interactive Journal (выпускается
Сергеем Орликом), и т.д. Все эти материалы Вы можете получить либо в
ДемоЦентре либо на семинарах Ассоциации Пользователей Delphi.


Вопросы, обсуждаемые в этом материале:

1. Вопросы о базах данных

   1.1  Как нужно писать функцию "change password"  для таблицы Парадокса ?
   1.2  Почему возникает ошибка, когда вызывается метод Add для TFieldDefs ?
   1.3  Как узнать, какая ячейка при просмотре TDBGrid текущая?
   1.4  Как выделить цветом текущую строку в TDBGrid?
   1.5  Как создать маску для TDBEdit?
   1.6  Как изменить цвет ячейки в TDBGrid ?
   1.7  Что нужно сделать, чтобы при открытии запароленной таблицы не
        появлялся диалог запроса пароля?
   1.8  Есть ли какая-нибудь процедура для перестройки разрушенного индекса,
        или "ремонта" испорченных таблиц типа TUTILITY.EXE из Pdoxwin?
   1.9  Есть ли какая-нибудь процедура для упаковки таблицы dBASE?
   1.10 Можно ли программным образом добавить псевдоним(alias) в IDAPI.CFG?
   1.11 Как для .dbf таблицы создать индекс по выражению?
   1.12 Хочу узнать номер текущей записи, как это сделать?
   1.13 Как посмотреть удаленные записи в таблице .dbf? А как их
         восстановить?
   1.14 Как узнать, что пользователь перешел на другую запись, например, в
         DBGrid?
   1.15 Хотелось бы иметь для OLE объектов, сохраненных в базе данных,
         компонент вроде TDBImage.
   1.16 Использование псевдонимов в запросе SQL
   1.17 Упаковка таблицы.
   1.18 Ошибка в SQL запросе
   1.19 Ошибка инициализации BDE $2C09
   1.20 Ошибка при загрузке языкового драйвера
   1.21 Что значит ошибка IDAPI $2C08 ?
   1.22 Почему я получаю ошибку 'Index out of range' когда использую
         tTable.FindNearest и tTable.FindKey для таблицы dBASE с индексом по
         выражению?
   1.23 Как программным образом создать таблицу Paradox с автоинкрементным
         полем?
   1.24 Как я могу создать маску для компонента TDBEdit ?
   1.25 Как определить реальный размер поля типа BLOB, которое сохранено в
         таблице?
   1.26 Как осуществить поиск по неиндексированному полю в таблице?
   1.27 Почему я не могу использовать опцию ixUnique при создании индекса в
         таблице Paradox с помощью метода AddIndex компонента TTable?
   1.28 Как определить номер текущей записи для набора данных?
   1.29 Я получаю сообщение от DBEngine при редактировании записи "Multiple
         records found but only one expected".  Что бы это значило?
   1.30 Я безуспешно пытался использовать данные из Microsoft Access
         иначе, нежели просто с помощью TTable.  Используя TQuery я могу
         только читать результат, но не могу редактировать. После "login
         screen" возникает сообщение типа 'Passthrough SQL connection must
         be shared'.
   1.31 Как узнать, что изменилась текущая запись?
   1.32 Как создать таблицу при помощи SQL (или почему не работает
         TQuery.Open) ?
   1.33 Генерация уникальных идентификаторов для локальных таблиц.
   1.34 Как устанавливать собственный цвет или шрифт для столбца DBGrid ?
   1.35 Как работать с таблицами в виде текстовых файлов (ASCII) ?
   1.36 Можно-ли использовать Crystal Report с таблицами формата Paradox 5.0 ?
   1.37 Как удалить генераторы (GENERATORS) из БД InterBase ?
   1.38 Почему указатель ползунка в DBGrid не показывает текущее положение в
         таблице ?
   1.39 Как выбрать протокол при соединении с InterBase из Delphi?
   1.40 Как правильно указать имя сервера Oracle?
   1.41 Что такое транзакции (Transactions)?
   1.42 Как в Delphi управлять транзакциями?
   1.43 Как изменить текст в заголовке столбца TDBGrid ?
   1.44 Где найти информацию о том, как использовать фильтры ?


2. Вопросы программирования

   2.1  Как можно выделить время CPU другим задачам, подобно "DoEvents" в VB?
   2.2  Почему возникает ошибка компиляции при обращении к объекту Sender в
         обработчике события ?
   2.3  Есть ли в Delphi эквивалент массива элементов управления из
         Visual Basic?
   2.4  Как закрыть модальную форму (ShowModal)? И вообще, каков лучший способ
         закрыть любую форму ?
   2.5  Я создают toolbar , у меня есть иконки, но нет картинок в виде bitmap.
         Помогите !
   2.6  Когда используется свойство Glyph, как узнать, какой цвет прозрачный?
   2.7  Как заставить приложение Delphi  отвечать на сообщения Windows?
   2.8  Как можно зааллокировать блоки памяти больше, чем 64 КБ ?
   2.9  Возможно ли написать Screen Saver для Windows в Delphi ?
   2.10 Есть ли простой способ перехватить exception ?
   2.11 Перемещение существующих компонент на Панели, Группe и т.п.
   2.12 Как поместить BLOb Memo в компонент TMemo ?
   2.13 Как включить символ & в надпись (Caption) ?
   2.14 Как сделать окно (TForm) без заголовка (Caption) ?
   2.15 Почему некоторые компоненты типа TPanel и TEdit не
         имеют свойства Canvas?
   2.16 Как получить горизонтальный scrollbar нв ListBox?
   2.17 Как можно добавить новый компонент на страницу
         TTabbedNoteBook во время выполнения программы?  Как нужно определить
         parent для этого компонента?
   2.18 Есть ли у TDBGrid события OnMouseDown, OnMouseUp и OnMouseMove?
   2.19 Можно ли окно, в котором находится форма или изображение
         выравнять по границе байта (byte-aligned)?
   2.20 В каком порядке происходят события при создании и показе окна?
   2.21 Что нужно предусмотреть при разработке приложения, которое будет
         работать при различном разрешении дисплея?
   2.22 Как определить текущую колонку и строку каретки в компоненте TMemo?
   2.23 Как узнать количество точек на дюйм для принтера?
   2.24  Как показать содержимое MEMO поля в DBGrid?
   2.25 Можно ли использовать клавишу ENTER при вводе данных для перехода от
         поля к полю?
   2.26 Как установить фокус на определенное поле в TDBGrid?
   2.27 Как создать форму, которая выглядит одинаково, независимо от того,
         какое разрешение в данный момент?
   2.28 Как считать даты для вычисляемых полей?
   2.29 Как определить из обработчика события OnClick в popup MenuItem, для
         какого объекта это произошло?
   2.30 Как перехватить сообщения Windows и обработать их перед тем, как
         выполнится строка application.run?
   2.31 Как использовать оператор CASE, чтобы определить, какой объект вызвал
         процедуру?
   2.32 Как установить формат для поля таблицы?
   2.33 Включение и выключение подсказок (Hints) для всех элементов на форме.
   2.34 Приложение, написанное на Delphi, не запускается минимизированным.
   2.35 Как обрабатывать события от множества однотипных компонент.
   2.36 Объясните разницу в помещении uses в секцию interface или
         implementation.

   2.37 Как обработать события от других приложений ?
   2.38 Как разделить обработку OnClick и OnDblClick ? Ведь OnClick будет
         вызываться всегда, и перед DblClick.

   2.39 Как писать эксперты, VCS и т.п. ?


3. Проблемы

   3.1  Проблема в использовании компонента TCustomGrid:
   3.2  Проблема с DragDrop для внешних программ.
   3.3  Использование формата Access 2.0 в Delphi
   3.4  Проблемы Delphi с WinG
   3.5  Как спрятать окна MDI Child ?
   3.6  Проблемы с полями класса типа TObject, TTable и т.д.
   3.7  Использование кавычек в параметризированном запросе.
   3.8  Использование TPanel в качестве "индикатора".
   3.9  Конвертация TBasicString (VBX) в string
   3.10 Возврат значения select max() и подобных SQL-выражений.
   3.11 Автоматический подсчет сумм при помощи TQuery.
   3.12 Поиск компонента в форме по имени.
   3.13 Предел буфера редактирования в 32K для TMemo
   3.14 GPF при старте отладки программы, использующей BDE
        ( Error initializing BDE $2C09 или что-то в этом роде)
   3.15 Как обрабатывать WM_DROPFILES (Drag/Drop) ?
   3.16 Почему компонент TGauge так медленно работает (медленнее, чем
         gauge.vbx) ?
   3.17 Я создаю событие по SpeedButton1.OnDblClick, но оно, похоже,
         вообще никогда не возникает. OnClick работает. Что делать?
   3.18 Проблемы с именами таблиц в ODBC-драйверах.
   3.19 GPF в ToolHelp.DLL в Win-OS/2 2.1
   3.20 Проблема с property типа REAL
   3.21 UpCase для русского языка.
   3.22 Почему при уничтожении компонента в методе OnClick происходит GPF ?


4. Полезные хитрости

   4.1  Может ли редактор текстов в Delphi вырезать и вставлять
         прямоугольные фрагменты текста?

------------------------------------------------------------------

1. Вопросы о базах данных.


1.1 Как нужно писать функцию "change password"  для таблицы Парадокса ?

  Нет способа сделать это в пределах Delphi VCL. Кажется, это довольно
  серьезное упущение. Однако, есть возможность сделать это напрямую через
  Borland Database Engine через интерфейс предоставляемый модулями DBIPROCS и
  DBITYPES. Нужно использовать функцию DbiDoRestructure.

1.2 Почему возникает ошибка, когда вызывается метод Add для TFieldDefs ?

  Потому что в документации ошибка. Имеется дополнительный булевский параметр,
  который определяет, может ли поле иметь пустое значение или нет. Правильная
  декларация для TFieldDefs.Add следующая:

     procedure Add(const Name: string; DataType: TFieldType; Size: Word;
                   Required: Boolean);


1.3 Как узнать, какая ячейка при просмотре TDBGrid текущая?

   Здесь процедура для сохранения текущего номера строки и колонки.
   Следующий код в методе MyDBGridDrawDataCell обновляет переменные Col и Row
   (которые не должны быть локальными для этого метода) каждый раз, когда
   таблица перерисовывается. Используя этот код, вы можете считать, что
   Col и Row указывают на текущую колонку и строку соответственно.

       var
         Col, Row: Integer;

       procedure TForm1.MyDBGridDrawDataCell(Sender: TObject; const Rect: TRect;
            Field: TField; State: TGridDrawState);
       var
         RowHeight: Integer;
       begin
         if gdFocused in State then begin
           RowHeight := Rect.Bottom - Rect.Top;
           Row := (Rect.Top div RowHeight) - 1;
           Col := Field.Index;
         end;
       end;


1.4 Как выделить цветом текущую строку в TDBGrid?

   Для TDBGrid в свойстве Options установите dgRowSelect в True.
   Для изменения характеристик столбца TDBGrid см. пункт 1.34


1.5 Как создать маску для TDBEdit?

     Маска относится к полю в таблице (компонент TField) а не к самой TDBEdit.
     Дважды щелкните мышкой на TTable and в FieldEditor'е добавьте все нужные
     вам поля. Когда поле выбрано в списке, его свойства показаны в object
     inspector, включая маску ввода. Связывание TDBEdit и любых других
     компонентов с этим TTable будет вызывать наложение маски на
     соответствующее поле.

     Маску для поля можно определить и в RunTime (не пользуясь FieldEditor).
     Для этого нужно использовать доступ к свойствам конкретного поля метод
     TTable.FieldByName. Например:

     Table1.FielByName('MyField').EditMask:='&&&&&&&';

     или по номеру поля:

     Table1.Fields[1].EditMask:='&&&&&';

1.6 Как изменить цвет ячейки в TDBGrid ?

     Введите следующий код в обработчике события OnDrawDataCell:

     Procedure TForm1.DBGrid1DrawDataCell(Sender: TObject; const Rect: TRect; Field:
       TField; State: TGridDrawState);
     begin
        If gdFocused in State then
           with (Sender as TDBGrid).Canvas do
           begin
              Brush.Color := clRed;
              FillRect(Rect);
              TextOut(Rect.Left, Rect.Top, Field.AsString);
           end;
     end;

     Установите свойство DefaultDrawing в True. Здесь перерисовывается
     только выделенная ячейка. Если установить DefaultDrawing в False,
     то вы должны самостоятельно перерисовать все ячейки аналогично примеру.


1.7  Что нужно сделать, тобы при открытии запароленной таблицы не появлялся
     диалог запроса пароля?

    Просто дайте этот пароль объекту Session перед открытием таблицы:

     Session.AddPassword ('PASSWORD');

     После закрытия таблицы, пароль можно удалить RemovePassword('PASSWORD'),
     можно удалить все пароли: RemoveAllPasswords.


1.8 Есть ли какая-нибудь процедура для перестройки разрушенного индекса,
     или "ремонта" испорченных таблиц типа TUTILITY.EXE из Pdoxwin?

   Для перестройки индексов BDE имеет специальную функцию -
   DbiRegenIndexes().

   TUTILITY.EXE работает только с таблицами Paradox 4.0. Таблицы формата
   Paradox 5.0 пока могут быть исправлены только при помощи самого Paradox
   5.0, т.к. для "ремонта" используется TUTILITY.DLL, а описания ее
   функций нет.

   Для Delphi уже появился набор компонент и интерфейс к TUTILITY.DLL, но его
   автор не предоставил исходных текстов и более того, принял специальные
   меры чтобы компоненты не работали без загруженной среды Delphi.

   Надеемся, что такие средства все-таки будут доступны. По крайней мере,
   для Delphi95 заявлено, что интерфейс TUTILITY будет открыт.


1.9   Есть ли какая-нибудь процедура для упаковки таблицы dBASE?

   В BDE есть функция DbiPackTable().

1.10   Можно ли программным образом добавить псевдоним(alias) в IDAPI.CFG?

   Для этого в BDE есть для этого функция DbiAddAlias().

1.11 Как для .dbf таблицы создать индекс по выражению?

 Нужно использовать процедуру AddIndex, например:
     Table1.AddIndex('NewIndex','Field1*Field2+Field3',[ixExpression]);
   Константа ixExpression не описана в Help, но есть в исходниках.

 Почему-то функции, допустимые для индексов по выражению, нигде не описаны.
 Однако минимальную информацию можно обнаружить в IDDBAS01.DLL - там можно
 увидеть имена функций DTOS, ABS и т.п.

1.12 Хочу узнать номер текущей записи, как это сделать?

 См. пункт 1.28

 Лучше, конечно, этого не делать. Большинство источников данных либо не
 поддерживают номера записей, либо номер записи может меняться в зависимости
 от открытого индекса (для Paradox). Более подробно этот вопрос и конкретные
 особенности форматов dBase и Paradox раскрыты в материалах ДемоЦентра к
 семинару по BDE.

1.13 Как посмотреть удаленные записи в таблице .dbf? А как их восстановить?

     Для того, чтобы удаленные записи были доступны, нужно установить
     соответствующее свойство для курсора с помощью функции BDE:
     dbiSetProp(hObj(Table1.Handle), curSOFTDELETEON, 1);
     Проверка удалена запись или нет производится через функцию чтения
     записи dbiGetRecord. Для восстановления записи применяется функция
     dbiUndeleteRecord.

     Подробный пример можно найти в материалах к семинару по BDE.


1.14 Как узнать, что пользователь перешел на другую запись, например, в
DBGrid?

 На этот случай можно использовать обработчик события OnDataChange
   в компоненте TDataSource.

1.15 Хотелось бы иметь для OLE объектов, сохраненных в базе данных,
компонент вроде TDBImage.

 В стандартном наборе такого компонента действительно нет. Возможно,
   кто-нибудь скоро напишет что-нибудь в этом роде. В принципе, можно
   обойтись и без данного компонента. Например, есть табличка .db с BLOB
   полем для OLE объекта. При движении по записям можно OLE сохранять в
   таблице, уничтожать, создавать новый, считывать из таблицы.
   Чтение/запись OLE:
     - создать поток, связанный с BLOB полем
     - для OLE контейнера выполнить чтение/запись с потоком
   Естественно, OLE объект должен быть Embedded.

   procedure TForm1.Read_OLE(Sender: TObject);
   var
     BlSt : TBlobStream;
   begin
    BlSt:=TBlobStream.Create(Table1.FieldByName('OLE') as TBlobStream,bmRead);
    OLEContainer.LoadFromStream(BlSt as TStream);
    BlSt.Free;
    Close;
   end;

   procedure TForm1.Write_OLE(Sender: TObject);
   var
     BlSt : TBlobStream;
   begin
     if OleContainer.Modified then begin
       Table1.Edit;
       (Table1.FieldByName('OLE') as TBlobField).Clear;
       BlSt:=TBlobStream.Create(Table1.FieldByName('OLE') as TBlobField,
                                bmReadWrite);
       OLEContainer.SaveToStream(BlSt as TStream);
       BlSt.Free;
       Table1.Post;
     end;
   end;

1.16 Использование псевдонимов в запросе SQL
 Я делаю запрос по двум таблицам разных форматов, находящихся
 по разным псевдонимам.

      SELECT DB1.Column1, DB2.Column2
      FROM :Alias1:DB1, :Alias2:DB2

 но в результате получаю ошибку 'неизвестный тип поля "Alias1:DB1"'

 A. На самом деле вы получаете ошибку Unknown keyword, следовательно
 всего-лишь нужно заключить псевдоним и имя таблицы в двойные
 кавычки.

      SELECT D1.Column1, D2.Column2
      FROM ":Alias1:DB1" D1, ":Alias2:DB2" D2

 Вообще экспериментировать с SQL-запросами проще следующим образом -
 создайте запрос QBE, настройте его так, как вам нужно, а затем
 оттранслируйте его в SQL. В результате вы получите _правильный_
 текст нужного вам SQL-запроса.
 Владельцы Delphi Client/Server могут использовать также и Visual
 Query Builder.

 Примечание: не все QBE-запросы могут быть оттранслированы в SQL.


1.17 Упаковка таблицы.

 Упаковать таблицу DBF можно открыв ее компонентом TTable и вызвав
 функцию BDE DbiPackTable.
 Для этого нужно добавить к модулю, где вызывается функция, имена
 DBITypes, DBIProcs, DBIErrs в оператор USES.
 Эатем вызвать в нужном месте функцию:

 Result:=DbiPackTable(Table1.DbHandle, Table1.Handle, nil, szDBase,
 True);


1.18 Ошибка в SQL запросе

   У меня есть TQuery и TDataSource.  В свойстве SQL для TQuery я пишу
     'SELECT * FROM dbo.AnyTable' , база данных на MS SQL Server.
     Когда я устанавливаю Active=True, то получаю ошибку: 'Token not found.
     Token :dbo. line number:1'.  Что не так?

A.   Если свойство RequestLive = True , то имя таблицы нужно брать в скобки:
     SELECT * FROM "dbo.table"

     Если свойство RequestLive = False, скобок не надо:
     SELECT * FROM dbo.table

1.19. Ошибка инициализации BDE $2C09
   Когда я пытаюсь запустить приложение из Delphi, то получаю ошибку
     EDatabaseError и сообщение 'An error occurred while attempting to
     initialize the Borland Database Engine (Error $2C09)'.

   Добавьте SHARE.EXE в AUTOEXEC.BAT или добавьте DEVICE=VSHARE.386
     в раздел [386Enh] файла SYSTEM.INI и перезагрузитесь.

1.20. Ошибка при загрузке языкового драйвера
   У меня есть Quattro Pro 6.0 и IDAPI в сети. После установки Delphi и
   нового IDAPI поверх сетевого IDAPI при запуске Quattro Pro с другой
   машины я получаю ошибку "Could not load Language Driver."

      Добавьте раздел [Borland Language Drivers] в WIN.INI файл для указания
      каталога языкового драйвера. Пример:

      [Borland Language Drivers]
      LDPATH=C:\IDAPI\LANGDRV

1.21 Что значит ошибка IDAPI $2C08 ?

      "Cannot load IDAPI01.DLL". Убедитесь, что в файле WIN.INI правильно
      прописаны пути:

      [IDAPI]
      DLLPATH=C:\IDAPI
      CONFIGFILE01=C:\IDAPI\IDAPI.CFG

1.22 Почему я получаю ошибку 'Index out of range' когда использую
     tTable.FindNearest и tTable.FindKey для таблицы dBASE с индексом по
     выражению?

      FindKey и FindNearest не могут работать с таким видом индексов. Вместо
      этих методов используйте GoToKey и GotoNearest, которые прекрасно
      работают с ними.

1.23 Как программным образом создать таблицу Paradox с автоинкрементным
      полем?
      Я использую TTable.CreateTable, но TFieldType не включает данный тип.

A.   Используйте TQuery и 'SQL CREATE TABLE'.  Пример:

     procedure TForm1.Button1Click(Sender: TObject);
     begin
       with Query1 do
         begin
           DatabaseName := 'DBDemos';
           with SQL do
             begin
             Clear;
             Add('CREATE TABLE "PDoxTbl.db" (ID AUTOINC,');
             Add('Name CHAR(255),');
             Add('PRIMARY KEY(ID))');
             ExecSQL;
             Clear;
             Add('CREATE INDEX ByName ON "PDoxTbl.db" (Name)');
             ExecSQL;
           end;
         end;
     end;

1.24.   Как я могу создать маску для компонента TDBEdit ?

   Маска относится к полю в таблице (компонент TField), а не к TDBEdit.
   Задать маску можно в Fields Editor, для этого дважды щелкните мышкой
   на TTable. Все компоненты, связанные с этим полем будут следовать
   правилам установленной маски.
   Кроме того, существует freeware компонент TDBMaskEdit, он не входит в
   стандартную поставку Delphi.

   Установить маску можно и другим способом - см. пункт 1.43 (замена
   заголовка в столбцах TDBGrid)


1.25.   Как определить реальный размер поля типа BLOB, которое сохранено в
  таблице?

   Ниже приведена функция GetBlobSize, которая возвращает размер данного
     BLOB или MEMO поля. Пример вызова:

     Function GetBlobSize(Field: TBlobField): Longint;
     var B: TBlobStream;
     begin
       B:=TBlobStream.Create(Field, bmRead);
       try
         Result := B.Size;
       finally
         B.Free;
       end;
     end;

     procedure TForm1.Button1Click(Sender: TObject);
     begin
       { This sets the Edit1 edit box to display the size of }
       { a memo field named Notes.                           }
       Edit1.Text := IntToStr(GetBlobSize(Notes));
     end;


     Примечание: Этот способ не будет работать в методе OnCalcFields.


1.26.  Как осуществить поиск по неиндексированному полю в таблице?

  Вы можете добавить следующую функцию в ваш модуль и вызвать, например :

      Locate(Table1, Table1LName, 'Beman');

    Table1 - компонент TTable, Table1LName - TField, который вы добавили
    с помощью Fields Editor и 'Beman' - имя, которое вы хотите найти.

    (* Ищет SValue в неиндексированной таблице *)
    Function Locate( const oTable: TTable; const oField: TField;
    const sValue: String): Boolean;
    var
      bmPos  : TBookMark;
      bFound : Boolean;
    begin
      Locate := False;
      bFound := False;
      If not oTable.Active then Exit;
      If oTable.FieldDefs.IndexOf( oField.FieldName ) < 0 then Exit;
      bmPos := oTable.GetBookMark;
      With oTable do
      begin
        DisableControls;
        First;
        While not EOF do
          if oField.AsString = sValue then
          begin
            Locate := True;
            bFound := True;
            Break;
          end
          else Next;
      end ;
      If (Not bFound) then oTable.GotoBookMark( bmPos);
      oTable.FreeBookMark( bmPos );
      oTable.EnableControls;
    end;

1.27.  Почему я не могу использовать опцию ixUnique при создании индекса в
    таблице Paradox с помощью метода AddIndex компонента TTable?

  Опции, используемые в методе AddIndex компонента TTable зависят от типа
    таблиц. Например, опция ixUnique работает с таблицей dBASE, но не с
    Paradox. Следующая таблица показывает, как эти опции используются для
    таблиц dBASE и Paradox.

    Index Options         dBASE    Paradox
    ---------------------------------------
    ixUnique               *
    ixDescending           *        *
    ixNonMaintained        *        *
    ixPrimary                       *
    ixCaseInsensitive               *

    Поэтому для Paradox вместо ixUnique необходимо использовать константу
    ixPrimary.

1.28.  Как определить номер текущей записи для набора данных?

  Если набор данных основан на таблицах Paradox или dBASE, то номер записи
    можно определить с помощью пары вызовов BDE (как показано ниже). BDE не
    поддерживает номер записи для наборов данных на SQL сервере;
    если ваш сервер поддерживает нумерацию записей, вам нужно обратиться к
    документации.

    !!!!: для таблиц dBASE возвращаемый номер записи - это всегда физический
    номер записи. Так, если набор данных - это TQuery или вы установили
    Range на таблицу, тогда возвращаемый номер записи не обязательно будет
    соответствовать тому, что вы видите.

    uses DbiProcs, DbiTypes, DBConsts;

    function RecordNumber(Dataset: TDataset): Longint;
    var
      CursorProps: CurProps;
      RecordProps: RECProps;
    begin
      { Return 0 if dataset is not Paradox or dBASE }
      Result := 0;

      with Dataset do
      begin
        { Is the dataset active? }
        if State = dsInactive then DBError(SDataSetClosed);

        { We need to make this call to grab the cursor's iSeqNums }
        Check(DbiGetCursorProps(Handle, CursorProps));

        { Synchronize the BDE cursor with the Dataset's cursor }
        UpdateCursorPos;

        { Fill RecordProps with the current record's properties }
        Check(DbiGetRecord(Handle, dbiNOLOCK, nil, @RecordProps));

        { What kind of dataset are we looking at? }
        case CursorProps.iSeqNums of
          0: Result := RecordProps.iPhyRecNum;  { dBASE   }
          1: Result := RecordProps.iSeqNum;     { Paradox }
        end;
      end;
    end;

1.29.  Я получаю сообщение от DBEngine при редактировании записи "Multiple
    records found but only one expected".  Что бы это значило?

  Вам может потребоваться создать уникальный индекс в таблице для того,
    чтобы каждую строку в таблице можно было однозначно идентифицировать.
    Можно сперва изменить структуру таблицы и добавить поле для заполнения
    его уникальными значениями.

1.30.  Я безуспешно пытался использовать данные из Microsoft Access
 иначе, нежели просто с помощью TTable.  Используя TQuery я могу только
 читать результат, но не могу редактировать. После "login screen" возникает
 сообщение типа 'Passthrough SQL connection must be shared'.

  Измените в настройке псевдонима (alias) пункт 'SQLPASSTHRU MODE'
    на 'SHARED AUTOCOMMIT'.

1.31.  Как узнать, что изменилась текущая запись?

  Событие OnDataChanged когда State = dsBrowse.

1.32. Как создать таблицу при помощи SQL (или почему не работает
  TQuery.Open) ?

 A. TQuery.Open возвращает результат в виде курсора, в связи с этим
    он работает только для тех выражений, которые возвращают курсор.
    CREATE TABLE возвращает только результат операции - поэтому для
    выполнения этого выражения необходимо использовать
    TQuery.ExecSQL. Но и это может не сработать, если конкретный
    драйвер БД не поддерживает операцию создания таблиц - для
    получения характеристик драйвера используйте функции BDE
    (DbiOpenDriverList, DbiGetDriverDesc).


1.33. Генерация уникальных идентификаторов для локальных таблиц.

 A. Для получения следующего значения идентификатора (номер заказа,
    товара и т.п.) может быть выполнена следующим способом:

    Предположим, у вас уже есть на форме компонент TTable. Добавьте
    еще один для этой-же таблицы - вы сможете использовать метод
    TTable.Last (таблица должна быть открыта по соответствующему
    индексу). Метод BeforePost первой таблицы должен выглядеть
    следующим образом:


    procedure TForm1.Table1BeforePost(DataSet: TDataset);
    begin
      Table2.Refresh;
      Table2.Last;
      Table1.Fields[0].AsInteger := Table2.Fields[0].AsInteger + 1;
    end;

  В этом случае автоматически увеличивается значение первого поля
  таблицы (а значит и ключевого).

  Вместо Table2 может быть использован компонент TQuery с запросом
  SELECT MAX(FirstField) FROM MyTable для получения максимального
  значения поля, но это будет намного медленнее, т.к. запросу
  возможно придется пересмотреть все записи таблицы.

  Для таблиц Paradox вы можете пользоваться специальными типами
  полей, гарантирующими уникальность значения поля в записи -
  типы AutoIncrement и TimeStamp (DateTime) с использованием функций DateXXX
  (модуль SysUtils)).

  Для более полного ознакомления с этим вопросом обратитесь к статье
  Максима Михеенкова в 1-ом номере российского журнала СУБД за 1995
  год.


1.34. Как устанавливать собственный цвет или шрифт для столбца DBGrid ?

 A. Выключите property DefaultDrawing, и обрабатывайте событие
 OnDrawDataCell.

 Например:

 procedure TForm1.DBGrid1DrawDataCell(Sender: TObject;
                                const Rect  : TRect;
                                      Field : TField;
                                      State : TGridDrawState);
   begin
     if Field.FieldName = 'Name' then
      DBGrid1.Canvas.Font.Style := [fsBold];
     DBGrid1.DefaultDrawDataCell(Rect, Field, State);
   end;


 Это приведет к тому, что содержимое столбца 'Name' будет показываться
 жирным шрифтом.

1.35. Как работать с таблицами в виде текстовых файлов (ASCII) ?

 A. Информацию об этом вы можете найти в каталоге DELPHI\DOC. Файл
    называется ASCIIDRV.TXT.


1.36. Можно-ли использовать Crystal Report с таблицами формата Paradox 5.0 ?

 A. Да, можно, нормально с этим форматом работает последняя версия CR -
    Crystal Report 4.0 Pro.

1.37. Как удалить генераторы (GENERATORS) из БД InterBase ?

 A. Никак, к сожалению в существующих версиях InterBase это невозможно.


1.38. Почему указатель ползунка в DBGrid не показывает текущее положение в
 таблице ?

 A. Дело в том, что DBGrid предполагает многопользовательский доступ к
 таблице. В этом случае другие пользователи этой-же таблицы могут добавлять
 или удалять записи, в результате информация о количестве записей на
 текущий момент становится неопределенной.

 Конечно, в однопользовательском варианте количество записей всегда
 известно, но поскольку DBGrid работает через промежуточный источник данных
 DataSource, ему неизвестен конкретный способ доступа к данным -
 навигационный или SQL. Например, для SQL существует только один способ
 узнать количество записей - выполнить специальный запрос с их подсчетом, а
 на это может потребоваться значительное время.

 По всем этим причинам DBGrid является универсальным средством для
 просмотра таблиц, которое работает во всех случаях и с любыми источниками
 данных.

 Количество записей вы можете узнать, если позволяет источник данных -
 это свойство TDataSet.RecordCount (т.е. это свойство есть у всех наследников
 - TTable, TQuery, TQBE и проч.)


 1.39   Как выбрать протокол при соединении с InterBase из Delphi?

  В Server Manager (ibmgr.exe), Windows interactive SQL (wisql.exe) и
 Communication Diagnostic Tool (comdiag.exe) Вы отдельно задаете имя
 сервера, протокол и 'путь на базу' (локальный путь на сервере, а не путь
 до базы с Вашей машины)

  А в BDE configuration utility все немного не так:
 На странице Drivers у драйвера InterBase есть параметр SERVER NAME
 заполненный как IB_SERVER:/PATH/DATABASE.GDB, а у любого InterBase Alias
 есть параметры SERVER NAME и PATH, но ни у драйвера ни у элиаса нет
 протокола...

 Короче, для
 TCP/IP SERVER NAME = IB_SERVER:PATH\DATABASE.GDB (nt:c:\ib\base.gdb)
                                                  (unix:/ib/base.gdb)
 IPX/SPX SERVER NAME = IB_SERVER@PATH\DATABASE.GDB (nw@sys:ib\base.gdb)
 NETBEUI SERVER NAME = \\IB_SERVER\PATH\DATABASE.GDB (\\nt\c:\ib\base.gdb)


1.40  Как правильно указать имя сервера Oracle?

  Пишите имя по правилам Oracle - перед именем не забудьте поставить @.


1.41  Что такое транзакции (Transactions)?

  SQL database серверы обрабатывают запросы в 'логических единицах работы'
  которые и называются транзакциями. То есть транзакция - это группа
  СВЯЗАННЫХ операций (SQL запросов) которые все должны быть выполнены успешно
  перед тем, как сервер закончит (commit) изменение базы данных.  Либо ВСЯ
  это группа будет выполнена, либо нет. Транзакции обеспечивают целостность
  базы данных ...

1.42  Как в Delphi управлять транзакциями?

  В Delphi может управлять транзакции так:
  1. Implicitly - сам стартует и коммитит транзакции по необходимости, когда
      программа вызывает метод Post.
  2. Explicitly -
   2.1 StartTransaction, Commit & RollBack методы TDatabase.
   2.2 При помощи SQL запросов через TQuery - это зависит от конкретного
        SQL сервера.

  Неявные (1) транзакции выполняют TTable & TQuery.
  Для явных (2.1) транзакций требуется TDatabase.
  Для явных (2.2) транзакций требуется TQuery.

   !!! Очень ВАЖНО !!!
  При определении параметров драйвера SQLPASSTHRU MODE - определяет будут
  ли passthrough SQL (PSQL) & стандартные вызовы BDE (BDEC) использовать
  один и тот же connect к SQL серверу.

   Возможные варианты:
  1. NOT SHARED - PSQL & BDEC используют разные соединения с базой и
  следовательно влияют (интерферируют) друг на друга также как разные
  пользователи одной базы (см. Transaction isolation levels)

  2.1. SHARED AUTOCOMMIT - PSQL & BDEC используют одно соединение с базой,
  каждый PSQL запрос автоматически коммитится.

  2.2. SHARED NOAUTOCOMMIT - PSQL & BDEC используют одно соединение с базой,
  SQL запросы "коммитятся вручную" (способом 2.1).

   !!! ЕЩЕ ВАЖНЕЕ !!!
  Если Вы все-таки решили управлять транзакциями при помощи SQL запросов
  через TQuery, то SQLPASSTHRU MODE ДОЛЖНО БЫТЬ NOT SHARED, иначе Implicit &
  Explicit транзакции могут влиять друг на друга и привести к 'неожиданным
  результатам'!


  Примечание: в Delphi95 (32-х разрядная версия) заявлено, что будут
  поддерживаться транзакции для локальных источников данных (dBase, Paradox).
  Это свойство относится к BDE 3.0, который включен в Delphi95.


1.43 Как изменить текст в заголовке столбца TDBGrid ?

  Конкретно - propery TField.DisplayLabel. Вообще существует несколько
  способов изменения свойств компонент TField.

  1. На компоненте TTable нажать правую кнопку и вызвать FieldEditor -
  В нем добавить все нужные поля кнопкой Add. Затем выбрать поле, и изменить
  любое его свойство. Если Вы меняете DisplayLabel, и к активной таблице
  подключен TDBGrid, то Вы сразу увидите изменения.
  Здесь, например, можно установить для логического поля значения Да/Нет
  вместо Yes/No. В свойстве DisplayValues напишите Да;Нет

  2. Где-нибудь в коде программы (например в методе TTable.AfterOpen)
  обратитесь к свойствам нужных полей по имени полей. Например:

   Table1.FieldByName('Name'):='Название';

  3. В коде программы обращайтесь к свойствам полей через массив
  TTable.Fields:

   Table1.Fields[0].DisplayLabel:='Название';


  Итак, первый и третий метод подходят для тех случаев, когда структура
  таблицы известна, и не будет меняться. Третий метод является самым
  быстрым из трех, но и самым худшим, потому что модифицировать программу
  будет труднее. (разве что если Вы напишете процедуру определения имен и
  номеров полей, и будете пользоваться "относительным" номером, а не
  конкретным).

  Второй способ пригоден для таблиц, структура которых еще не устоялась
  или может меняться. Однако этот способ самый медленный, поскольку поиск
  нужного поля производится перебором. Скорость не имеет значения, если Вы
  меняете только DisplayLabel после открытия таблицы. Другое дело, если Вы
  устанавливаете значения полей или перемещаетесь по таблице.

  Еще одна сложность возникает с SQL-запросами, когда неизвестно, какие
  поля могут быть выбраны или вообще возвращены в ответе, а требуется
  столбцы именовать только по русски. В этом случае можно воспользоваться
  следующим решением:  необходимо создать массив из русских и английских
  названий полей. Элементом массива может быть объект или запись, содержащий
  русское и английское слово, а массивом может послужить TList.
  В начале программы массив инициализируется всеми возможными именами полей
  Вашей БД на русском и английском языках. После того, как таблица/запрос
  открыты, нужно "пробежать" по массиву Fields, и найти для FieldName
  соответствующее русское название в массиве (хорошо, если использован массив
  с сортировкой, и названия отсортированы по английским именам полей) и
  заменить DisplayLabel на русское название.

  Этим-же способом можно заменять русские имена полей на английские в
  SQL-запросе, если SQL-запрос формируется пользователем на русском языке, а
  в таблицах используются только английские имена полей.


1.44 Где найти информацию о том, как использовать фильтры ?

  Эта тема совершенно не рассматривается в документации, и очень слабо
 освещена в документации на Borland Database Engine 2.0. Однако недавно
 появился компонент, позволяющий работать с фильтрами. Этот компонент написан
 Федором Кожевниковым и Сергеем Королевым. Исходные тексты можно получить по
 FIDO, в ДемоЦентре, либо на семинаре Ассоциации Групп Пользователей.


---------------------------------------------------------------------------


2. Вопросы программирования .


2.1 Как может выделить время CPU другим задачам , подобно "DoEvents" в VB ?

  Эквивалент в Delphi - Application.ProcessMessages .

2.2 Почему возникает ошибка компиляции при обращении к объекту Sender в
    обработчике события ?

  Если вы рассматривали декларацию события, объект Sender имеет тип TObject,
  который является классом, который наследуется почти всеми остальными
  объектами. Вы, вероятно, пробуете обращаться к свойству, которое не
  определено в TObject, вроде Text или Caption. По этой причине, выражение
  "Sender.Text" вызовет ошибку, но если (для примера) вы знаете, что Sender
  имеет тип TEdit, тогда вы можете использовать выражение " ( Sender as TEdit
  ).Text ". Если вы не уверены, что объект Sender будет всегда иметь данный
  тип, вы можете проверить это:  "if ( Sender is TEdit) then <...>

  Если Вы достаточно серьъезно программировали на Borland Pascal, то
  возможно, Вам покажется более естественным использовать приведение типов:

  TEdit(Sender).Text:='...

  Однако такой способ приведет к GPF (в лучшем случае), если Sender не
  является классом типа TEdit. Использование is и as позволяет контролировать
  ситуацию.


2.3 Есть ли в Delphi эквивалент массива элементов управления из Visual Basic?

  У всех компонент есть свойство Components, которое позволяет обращаться
  к компонентам по индексу.Однако, имеются три основные причины, почему вы
  хотите использовать их в VB, и для каждой из них есть решение в Delphi.

   Причина 1. Вы хотите использовать один обработчик события для разных
   компонент на форме.

    Это просто. Все, что вы должны сделать - это выбрать тот же самый
    обработчик для каждой визуальной компоненты. Это лучше, чем в случае с
    массивом компонент, потому что вы можете одну и ту же процедуру-обработчик
    события присвоить различным типам компонент; например, кнопка на форме и
    пункт меню могут вызывать ту же самую функцию для обработки события Click.

   Причина 2 . Вы хотите динамически создавать и уничтожать визуальные
   компоненты во время выполнения программы.

   Это также довольно просто в Delphi . Предположим, что на форме есть кнопка,
   и, каждый раз когда она нажимается, вы хотите создавать другую кнопку.
   Следующий пример показывается, как это делать:

   procedure TForm1.Button1Click(Sender: TObject);
   var
     NewButton: TButton;
   begin
     NewButton := TButton.Create(Self);
     NewButton.Parent := Self;
   end;

  Причина 3 . Вам действительно требуется доступ к компонентам по номеру.

  Предположим, что вы решили написать игру вроде Реверси в Delphi. Вам нужно
  разместить 100 объектов TShape на форме, в виде квадрата 10x10. Конечно,
  размещать каждый элемент вручную на экране - задача трудоемкая и
  неинтересная, при этом, в декларации формы появляется 100 строк кода,
  которые, в общем-то, не нужны. Вместо этого можно завести массив вроде
    Board : Array[1..10, 1..10] of TShape;
  Далее в программе нужно создать каждый из этих объекты вызвав
     TShape.Create(Owner);
  указать вручную начальные установки для них.
  Кроме того, в свойстве Parent каждого объекта из массива нужно указать
  ту панель(TPanel) или форму, на которой они располагаются. Это нужно для
  правильной перерисовки объектов.

  Кроме всего перечисленного, Вы можете найти компонент по имени -

   MyComponent:=Form1.FindComponent('SomeComponent');

  Либо организовать цикл в контексте любого метода формы для вызова метода
  или обращения к свойству Вашего компонента:

   for i:=0 to ComponentCount-1 do
    if Components[i] is TMyObject then
     (Components[i] as TMyObject).MyMethod;


  Также, компоненты имеют свойство ComponentIndex, которое содержит номер
  компонента в массиве Components его владельца.


2.4 Как закрыть модальную форму (ShowModal)? И вообще, каков лучший способ
    закрыть любую форму ?

  Вообще говоря, нужно вызывать метод Close для формы. Close вызывает событие
  OnClose (обработчик которого может решить, что форму нельзя закрывать,
  например, если имеются несохраненные данные). Close не освобождает память,
  связанную с формой, если вы, конечно, не поместите в обработчик события
  вызов метода Release.
  Если вы хотите уничтожить форму без вызова события OnClose, используйте
  метод Release. Этот метод работает подобно Free, но позволяет всем
  обработчикам событий данной формы закончить работу перед тем, как память
  будет освобождена.
  Модальные формы "прекращают свой модальный статус", когда вы устанавливаете
  свойство ModalResult формы в любое значение, большее, чем нуль. Если вы
  поместите кнопку на модальную форму и установите свойство ModalResult для
  кнопки в некоторое значение, то, когда пользователь нажмет на эту кнопку,
  форма закроется с результатом, который вы определили.  Этот результат можно
  узнать вызывая  ShowModal как функцию. То есть,  Result := Form.ShowModal;

2.5 Я создаю toolbar , у меня есть иконки, но нет картинок в виде bitmap.
     Помогите !

  Лучше иметь что-нибудь вроде HiJaak, который может преобразовывать форматы
  напрямую. Еще проще сделать это при помощи Borland Resource WorkShop,
  который поставляется вместе со всеми компиляторами фирмы Borland, а также
  в RAD Pack for Delphi.

  Однако, будем считать, что у вас нет ничего, кроме Windows и Delphi.
  Следующая процедура может использоваться чтобы преобразовывать иконку в
  bitmap:

  Покажите на экране иконку. Не имеет значения, как вы это сделаете. Нажмите
  Alt-PrintScreen, чтобы скопировать текущее окно в буфер ClipBoard.
  Загрузите Paintbrush и сделайте Edit/Paste. Выберите нужный кусок
  изображения и сделайте Edit/Copy. Перейдите к пункту Options/Image
  Attributes и установите размер области 32x32 точки. Снова сделайте
  Edit/Paste. Сохраните результат как BMP файл.

  Вместе с Delphi поставляется средство для редактирования ресурсов -
  ImageEditor. Но мы не рекомендуем им пользоваться, даже после применения
  патча.


2.6 Когда используется свойство Glyph, как узнать, какой цвет прозрачный?

  Delphi всегда принимает, что цвет пикселя в левом нижнем углу картинки
  является фоновым цветом и должен отображаться на экране как прозрачный.
  Это нигде не задокументировано, но если у вас есть исходники VCL, вы можете
  посмотреть код в BUTTONS.PAS .

2.7 Как заставить приложение Delphi отвечать на сообщения Windows?

  Используем WM_WININICHANGED в качестве примера :

   Объявление метода в TForm позволит вам обрабатывать сообщение
   WM_WININICHANGED:

   procedure WMWinIniChange(var Message: TMessage); message WM_WININICHANGE;

  Код в  implementation может выглядеть так:

      procedure TForm1.WMWinIniChange(var Message: TMessage);
      begin
        inherited;
        {.. ваша реакция на событе ..}
      end;

  Вызов "Inherited" важен. Обратите внимание также на то, что после
  "Inherited" нет имени наследуемой процедуры, потому что она может быть
  неизвестна или вообще отсутствовать (в этом случае вы в действительности
  вызываете DefaultHandler).

2.8 Как можно зааллокировать блоки памяти больше, чем 64 КБ ?

  Используйте GlobalAlloc и GlobalLock из WinProcs модуля.

2.9 Возможно ли написать Screen Saver для Windows в Delphi ?


  Для создания Screen Saver:

  A) В проектном файле (* .dpr) напишите {$D SCRNSAVE <saver name>}
     после Uses;

  B) На главной форме выключите Border и иконки. Установите свойства Left и
     Top в 0, WindowState в wsMaximize.

  C) В обработчике события OnCreate, установите Application.OnMessage на
     процедуру деактивации Screen saver. Установите Application.OnIdle на
     любую процедуру для рисования на экране.

  D) В обработчике OnCreate должна проверяться командная строка на наличие
     ключей /c и /s. Эти параметры определяют, нужно ли запускать сам Screen
     Saver или его конфигурацию (/c - конфигурация).

  E) Скомпилируйте программу  и переименуйте из .exe в .scr ;  поместите файл
     в каталог Windows - Screen Saver должен появиться на панели управления
     (Control Panel).


2.10 Есть ли простой способ перехватить exception ?

  Создайте метод для формы, перехватывающий exception. Этот
  метод будет вызываться обработчиком OnExeption для объекта Application.
  В вашем методе проверьте, тот ли это exception, что вы ожидаете, к
  примеру EDatabaseError.  Почитайте  on-line help для события OnException
  Там есть информация, как вызвать собственный метод для события.
  Пример:

  Procedure TForm1.MyExcept(Sender:TObject; E:Exception);
  begin
     If E is EDatabaseError then MessageDlg('Поймали exception',
	mtInformation, [mbOk], 0)
     else {это не то, сделайте raise}
       raise E;
  end;

  procedure TForm1.FormCreate(Sender: TObject);
  begin
     Application.OnException := MyExcept;
     {здесь вы указываете, что событие OnException выполнит ваш метод}
  end;

2.11 Перемещение существующих компонент на Панели, Группы и т.п.
 Я поместил кнопку (или что-то другое) на форму, затем поместил
 панель, и решил переместить кнопку на панель, но ничего не
 получилось.

 A. Действительно, чтобы поместить кнопку на панель, необходимо
 на форму сначала поместить панель, выбрать ее, а затем уже помещать
 кнопку.

 Но и в вашей ситуации есть решение. Скопируйте (Copy) или
 вырежьте (Cut) нужный компонент, выберите панель, и сделайте вставку
 (Paste). Рекомендуется предварительно "подогнать" копируемый
 компонент в левый верхний угол формы, иначе компонент на панели
 может выпасть из "пределов видимости" панели (или любого другого
 группового компонента).

 Если компонент все-таки "выпал" из пределов видимости - найдите этот
 компонент в Инспекторе Объектов, и установите нужные значения Left
 и Top.

 Используя группы компонент можно огранизовать форму-шаблон, на
 которой можно складывать (например в NoteBook) компоненты с
 предварительно заданными свойствами, отличными от стандартных.  Это
 решение проще чем добавлять такие компоненты в палитру компонент -
 не увеличивается размер COMPLIB.DCL и не загромождается палитра
 компонент.

 Учтите, что при копировании компонент с такого шаблона их имя меняется на
 автоматическое (Button1, Button2 и т.д.), а методы не копируются.


2.12 Как поместить BLOb Memo в компонент TMemo ?

  Попробуйте так:

   procedure TForm1.Button1Click(Sender: TObject);
   var
     S: TBlobStream;
   begin
     S := TBlobStream.Create(Table1BBBMemo, bmRead);
     Memo1.Lines.LoadFromStream(S);
     S.Free;
   end;

 где:

 1. Table1BBBMemo - имя поля BLOb Memo (TMemoField).
 2. Memo1 - имя компонента TMemo.

 Естественно, что этим-же способом можно обмениваться информацией с
 BLOb-полями произвольного типа.


2.13 Как включить символ & в надпись (Caption) ?

 Попробуйте: &&

2.14. Как сделать окно (TForm) без заголовка (Caption) ?

 Попробуйте использовать следующий код:

 constructor TPanelForm.Create(AOwner : TComponent);
  { Вызов SetWindowLong API для изменения стиля окна главной формы.
   Берется существующий стиль и убирается флаг WS_CAPTION }

   var lStyle : longint;
    begin
     inherited Create(AOwner);

     BorderIcons := [];

     lStyle := GetWindowLong(Handle, GWL_STYLE);
     lStyle := lStyle And Not WS_CAPTION;
     SetWindowLong(Handle, GWL_STYLE, lStyle);

     { Перерисуем окно }
     ForceRepaint;
    end;


procedure TPanelForm.ForceRepaint;
var
  rectWnd : TRect;
  wwidth, wheight : Integer;
begin
  { получаем размер окна }
  GetWindowRect(Handle, rectWnd);
  wwidth := rectWnd.right - rectWnd.left;
  wheight := rectWnd.bottom - rectWnd.top;

  { Форсируем полную перерисовку. Это должен делать InvalidateRect()
    но почему-то не делает :( }

  { "сожмем" окно }
  SetWindowPos(Handle,HWND_TOP, 0, 0, 0, 0, SWP_NOMOVE);
  { восстановим окно }
  SetWindowPos(Handle,HWND_TOP, 0, 0, wwidth, wheight, SWP_NOMOVE);
 end;


 Можно поступить другим способом - выставить у формы property
 BorderStyle=bsNone, и написать следующий обработчик OnPaint

 procedure TForm1.FormPaint(Sender: TObject);
  begin
   canvas.brush.style:=bsClear;
   canvas.rectangle (0,0,width,height);
  end;

2.15. Почему некоторые компоненты типа TPanel и TEdit не имеют
 свойства Canvas?

  Все наследники TCustomControl имеют Canvas, однако, в большинстве случаев
   это св-во объявлено protected для предотвращения рисования 'чужаками'
   на компоненте. Наследники компоненты всегда могут получить доступ к
   унаследованным protected свойствам (типа Canvas), но пользователь
   компонента-никогда.

   type
     TCanvasPanel = class(TPanel)
     public
       property Canvas;
     end;

   Если вы хотите рисовать на компоненте, у которого нет public св-ва Canvas,
   то используйте, например, компонент TPaintBox : положите его на панель
   (TPanel), сделайте Align = Client  и рисуйте на TPaintBox.

2.16. Как получить горизонтальный scrollbar нв ListBox?

  Пошлите сообщение LB_SetHorizontalExtent в ListBox.
   Например, сообщение может быть отослано в момент создания формы:

   procedure TForm1.FormCreate(Sender: TObject);
   begin
     SendMessage(Listbox1.Handle, LB_SetHorizontalExtent, 1000, Longint(0));
   end;

2.17. Как можно добавить новый компонент на страницу TTabbedNoteBook во
 время выполнения программы?  Как нужно определить parent для этого
 компонента?

  Для того, чтобы добавить компонент на страницу TabbedNotebook, свойству
   Parent нового компонента нужно присвоить указатель на требуемую страницу.
   Способ для доступа к любой странице TTabbedNotebook во время выполнения -
   массив свойств Objects у свойства Pages компонента TTabbedNotebook.
   Другими словами, страницы сохранены в виде объектов в свойстве Pages
   (тип TStringList).  Пример демонстрирует создание кнопки button на второй
   странице TabbedNotebook1:

   var
     NewButton : TButton;
   begin
     NewButton := TButton.Create(Self);
     NewButton.Parent := TWinControl(TabbedNotebook1.Pages.Objects[1])
     ...

   This is how a TNotebook page would be used as a parent to a newly
   created component on that page:

   NewButton.Parent := TWinControl(Notebook1.Pages.Objects[1])

   This is how a TTabSet tab page would be used as a parent to a
   newly created component on that tab page:

   NewButton.Parent := TWinControl(TabSet1.Tabs.Objects[1])

2.18. Есть ли у TDBGrid события OnMouseDown, OnMouseUp и OnMouseMove?

 Они есть, но не объявлены published. Очевидно, это ошибка разработчиков -
 TDBGrid на самом деле не имеет собственных свойств или методов, а
 всего-лишь объявляет как published некоторые типы событий. Вы можете создать
 наследника TDBGrid и сделать нужные события published.

2.19. Можно ли окно, в котором находится форма или изображение выравнять по
   границе байта (byte-aligned)?

  Перепишите (override) метод CreateParams:

   procedure TMyForm.CreateParams(var Params:TCreateParams);
   begin
     inherited CreateParams(Params);
     Style := Style or CS_BYTEALIGNWINDOW;
   end;

   !!!!: Это имеет значение только для режимов: monochrome, EGA,
   и VGA 16 colors. В остальных режимах более высокого разрешения окна
   всегда byte-aligned.

 2.20. В каком порядке происходят события при создании и показе окна?

 При создании окна обработчики событий выполняются в следующем порядке:
   OnCreate, OnShow, OnPaint, OnActivate, OnResize и снова OnPaint.


  2.21. Что нужно предусмотреть при разработке приложения, которое
 будет работать при различном разрешении дисплея?


  * На ранней стадии создания приложения решите для себя хотите ли вы
    позволить форме масштабироваться. Преимущество немасштабируемой формы в
    том, что ничего не меняется во время выполнения. В этом же заключается и
    недостаток (ваша форма может бать слишком маленькой или слишком большой
    в некоторых случаях).

  * Если вы НЕ собираетесь делать форму масштабируемой, установите св-во
    Scaled=False и дальше не читайте.

  * В противном случае Scaled=True.

  * Установите AutoScroll=False.  AutoScroll = True означает 'не менять
    размер окна формы при выполнении ' что не очень хорошо выглядит, когда
    содержимое формы размер меняет.

  * Установите фонты в форме на TrueType фонты, например Arial.
    !!!!: Если такого фонта не окажется на пользовательском компьютере,
    то Windows выберет альтернативный фонт из того же семейства. Этот
    фонт может не совпадать по размеру, что вызовет проблемы.

  * Установите св-во Position в любое значение, отличное от poDesigned.
    poDesigned оставляет форму там, где она была во время дизайна, и,
    например, при разрешении 1280x1024 форма окажется в левом верхнем углу
    и совершенно за экраном при 640x480.

  * Оставляйте по-крайней мере 4 точки между компонентами, чтобы при смене
    положения границы на одну позицию компоненты не "наезжали" друг на
    друга.

  * Для однострочных меток (TLabel) с выравниванием alLeft или alRight
    установите AutoSize=True.  Иначе AutoSize=False.

  * Убедитесь, что достаточно пустого места у TLabel для изменения ширины
    фонта - 25% пустого места многовато, зато безопасно. При AutoSize=False
    Убедитесь, что ширина метки правильная, при AutoSize=True убедитесь, что
    есть ссвободное место для роста метки.

  * Для многострочных меток (word-wrapped labels), оставьте хотя бы одну
    пустую строку снизу.

  * Будьте осторожны при открытии проекта в среде Delphi при разных
    разрешениях. Свойство PixelsPerInch меняется при открытии формы.
    Лучше тестировать приложения при разных разрешениях, запуская
    готовый скомпилированный проект, а редактировать его при одном
    разрешении. Иначе это вызовет проблемы с размерами.

  * Не изменяйте свойство PixelsPerInch !

  * В общем, нет необходимости тестировать приложение для каждого разрешения
    в отдельности, но стоит проверить его на 640x480 с маленькими и большими
    фонтами и на более высоком разрешении перед продажей.

  * Уделите пристальное внимание принципиально однострочным компонентам типа
    TDBLookupCombo. Многострочные компоненты всегда показывают только
    целые строки, а TEdit покажет урезанную снизу строку. Каждый компонент
    лучше сделать на несколько точек больше.

 2.22. Как определить текущую колонку и строку каретки в компоненте TMemo?

 Вы можете использовать сообщения Windows API  EM_LINEFROMCHAR и
   EM_LINEINDEX для определения положения.

   var
     LineNum: longint;
     CharsBeforeLine: longint;
   begin
     LineNum := SendMessage(Memo1.Handle, EM_LINEFROMCHAR, Memo1.SelStart,0);
     CharsBeforeLine := SendMessage(Memo1.Handle, EM_LINEINDEX, LineNum, 0);
     Label1.Caption := 'Line ' + IntToStr(LineNum +1)
     Lebel2.Caption := 'Position ' + IntToStr((Memo1.SelStart - CharsBeforeLine) + 1);
   end;

 2.23. Как узнать количество точек на дюйм для принтера?

 Например:

   VertPixelsPerInch := GetDeviceCaps(Printer.Handle, LogPixelsX);
   HorzPixelsPerInch := GetDeviceCaps(Printer.Handle, LogPixelsY);

 2.24.  Как показать содержимое MEMO поля в DBGrid?

  Используйте нижеследующий код для обработки события OnDrawDataCell
    для DBGrid.
    !! Перед запуском программы создайте объект TMemoField для memo поля
    в Fields Editor.

    procedure TForm1.DBGrid1DrawDataCell(Sender: TObject; const Rect: TRect;
      Field: TField; State: TGridDrawState);
    var
      P  : array [0..50] of char;   {буфер для memo поля}
      BS : tBlobStream;
      S  : String;
    begin
      If Field is TMemoField then begin
      with (Sender as TDBGrid).Canvas do
        begin
          {Table1Notes is the TMemoField}
          BS := tBlobStream.Create(Table1Notes, bmRead);
          FillChar(P,SizeOf(P),#0);
          BS.Read(P, 50);
          BS.Free;
          S := StrPas(P);
          while Pos(#13, S) > 0 do              {remove carriage returns and}
            S[Pos(#13, S)] := ' ';              {line feeds}
          While Pos(#10, S) > 0 do
            S[Pos(#10, S)] := ' ';
          FillRect(Rect);                          {clear the cell}
          TextOut(Rect.Left, Rect.Top, S);         {fill cell with memo data}
        end;
      end;
    end;

  2.25. Можно ли использовать клавишу ENTER при вводе данных для перехода от
    поля к полю?

  Используйте данный код для события OnKeyPress компонента TEdit.

    procedure TForm1.Edit1KeyPress(Sender: TObject; var Key: Char);
    begin
      If Key = #13 Then
      Begin
        SelectNext(Sender as tWinControl, True, True );
        Key := #0;
      end;
    end;

    Теперь Enter ведет себя как Tab.  Затем, выберите все объекты,
    которые должны вести себя как Edit1 (за исключением кнопок) и в
    Object Inspector установите обработчик OnKeyPress в Edit1KeyPress.
    Каждый выбранный вами объект воспринимает Enter как Tab.
    Если вы хотите обрабатывать событие на уровне формы (а не в каждом
    отдельном компоненте), уберите обработчики события у всех компонент
    и создайте FormKeyPress - обработчик OnKeyPress для формы:

    procedure TForm1.FormKeyPress(Sender: TObject; var Key: Char);
    begin
      If Key = #13 Then
      begin
        SelectNext(ActiveControl as tWinControl, True, True );
        Key := #0;
      end;
    end;

    Все объекты на форме будут воспринимать Enter как Tab.

2.26. Как установить фокус на определенное поле в TDBGrid?

  Используйте код:

     DBGrid1.SelectedField := Table1SomeField;
     DBGrid1.SetFocus;

2.27.  Как создать форму, которая выглядит одинаково, независимо от того,
    какое разрешение в данный момент?

  Здесь приведен код, как это делается:

     const
       ScreenHeight: real = 800; {Форма создана в моде 800x600}
       ScreenWidth: real = 600;

     procedure TForm1.FormCreate(Sender: TObject);
     var
       x, y: LongInt; {Integers will not not a large enough value.}

     begin
       form1.scaled := true;
       x := getSystemMetrics(SM_CXSCREEN);
       y := getSystemMetrics(SM_CYSCREEN);
       if (x <> ScreenHeight) or (y <> ScreenWidth) then
	 begin
	   form1.height := form1.height * x DIV ScreenHeight;
	   form1.width := form1.width * y DIV ScreenWidth;
	   scaleBy(x, ScreenHeight);
	 end;
     end;

    !!!!: Вы можете добавить код для изменения размера фонтов.


2.28.  Как считать даты для вычисляемых полей?

  При вычислении дат важно удостовериться в том, что все используемые
    значения подходят по типу. Метод Double (не описан в доке) приводит
    значения к типу, который можно использовать.

    В примере, d1 и d2 (поля в table1) могут быть типа или Date, или
    dateTime,  а d3 - поле типа integer.

     procedure TForm1.Table1CalcFields(DataSet: TDataset);
     var
       t1, t2: tDateTime;
     begin
       table1d1.asDateTime := Date + 2; {or table1d1.value := date + 2;}
       table1d2.asDateTime := Date - 2;
       t1 := table1d1.asDateTime;
       t2 := table1d2.asDateTime;
       table1d3.asInteger := trunc(double(t1) - double(t2));
     end;


  2.29.  Как определить из обработчика события OnClick в popup MenuItem, для
     какого объекта это произошло?

   Используйте свойство PopupComponent компонента PopupMenu для определения,
     где была нажата правая кнопка.

     procedure TForm1.PopupItem1Click(Sender: TObject);
     begin
       Label1.Caption := PopupMenu1.PopupComponent.ClassName;
     end;

     Свойство ActiveControl для формы тоже можно использовать, однако,
     ActiveControl не обязательно является тем элементом, для которого
     произошло событие.


   2.30.  Как перехватить сообщения Windows и обработать их перед тем, как
     выплнится строка application.run?

   Пример проекта показывает, как получить сообщения Window в данном случае.
     Это редкий случай, в большинстве случаев переопределение процедуры
     Application.OnMessage будет делать то же самое.

     program Project1;

     uses
       Forms, messages, wintypes, winprocs,
       Unit1 in 'UNIT1.PAS' {Form1};


     {$R *.RES}

     var
	 OldWndProc: TFarProc;

     function NewWndProc(hWndAppl: HWnd; Msg, wParam: Word;
                  lParam: Longint): Longint; export;
     begin
	 result := 0; { Default WndProc return value }
	 {*** Handle messages here; The message number is in Msg ***}
	 result := CallWindowProc(OldWndProc, hWndAppl, Msg,                 			wParam, lParam);
     end;

     begin
	 Application.CreateForm(TForm1, Form1);
	 OldWndProc := TFarProc(GetWindowLong(Application.Handle,
               GWL_WNDPROC));
	 SetWindowLong(Application.Handle, GWL_WNDPROC,
               longint(@NewWndProc));
	 Application.Run;
     end.


    2.31.  Как использовать CASE, чтобы определить, какой объект вызвал процедуру?

   Используйте свойство TAG. Установите значение TAG свое у каждого объекта
     для опознания. (Использование констант, которые описывают объект -
     идеально подходит).

     !!!!:  Предполагается, что только tButton вызывает эту процедуру.

     case (sender as tButton).tag of
       0:  blah;
       1:  blah_blah;
     end;


2.32.  Как установить формат для поля таблицы?

   В Fields Editor выберите поле для форматирования. Используя свойства
     DisplayFormat и EditFormat сделайте то, что нужно. DisplayFormat работает
     для поля, на которое не установлен фокус. EditFormat работает для
     поля, на которое фокус установлен. Форматирование аналогично первому
     параметру в функции FormatFloat, но без скобок.

2.33. Включение и выключение подсказок (Hints) для всех элементов на форме.

 A. Если ваша форма содержит панель подсказки в нижней части формы, то
 вы можете определить подменю для этой панели, и выставлять
 Form.ShowHint в True или False в зависимости от состояния Checked элемента
 меню.
 Например, в TMenuItem.OnClick напишите:

  ShowHint:=not (Sender as TMenuItem).Checked;

  В результате на локальном меню панели будет видно, включены подсказки для
 всех элементов или нет.


2.34. Приложение, написанное на Delphi, не запускается минимизированным.

 A. Проверьте глобальную переменную CmdShow для того чтобы определить,
 в каком состоянии запускается приложение, и модифицируйте ее как вам
 необходимо:

  procedure TForm1.FormCreate(Sender: TObject);
   begin
    if CmdShow = SW_SHOWMINNOACTIVE then
     WindowState := wsMinimized
   end;


 Далее, если необходимо запускать приложение либо минимизированным, либо
 максимизированным, используйте следующий код:

  procedure TForm1.FormCreate(Sender: TObject);
   begin
    if CmdShow = SW_SHOWMINNOACTIVE then
     WindowState := wsMinimized
    else
     WindowState := wsMaximized;
   end;


2.35. Как обрабатывать события от множества однотипных компонент.
  На моей форме находится примерно 10 кнопок. Я хочу обрабатывать нажатие
  на любую из них одним событием, но как их отличить внутри обработчика
  события ?

 A. Для этого базовый класс VCL имеет поле Tag типа longint. В момент
 разработки вы можете присвоить этому полю любое значение, а в момент
 исполнения использовать его (или переопределять). В вашей ситуации
 достаточно присвоить полю ButtonX.Tag значение от 1 до 10 (или от 0 до 9,
 как удобнее), а в обработчике написать примерно следующее:

 procedure MyForm.Button1Click(Sender: TObject);
  begin
   case (Sender as TComponent).Tag of
    1: ...;
    2: ...;
    3: ...;
   end;
  end;

 обратите внимание на приведение типа Sender к TComponent - все визуальные
 компоненты имеют общего предка TComponent, поэтому у всех обязательно есть
 поле Tag.

 При помощи этого поля можно идентифицировать не только кнопки, но и поля
 ввода, элементы меню (TMenuItem) и т.п. объекты.

2.36. Объясните разницу в помещении uses в секцию interface или implementation.

 A. Секция interface - интерфейсная. Туда попадают объявления констант,
типов (в т.ч. и объектов или классов) переменных, процедур и функций.
Поэтому для этой части USES должен содержать ссылки на те модули, которые
используются для объявлений в этой части.

 Секция implementation - описание реализации интерфейсной части, здесь в
USES должны быть упомянуты те модули, которыми ВЫ пользуетесь для написания
кода. Например, Вы хотите в модуле пользоваться функциями API Windows,
для этого добавьте в объявлении implementation строку "uses Wintypes,
WinProcs;". Таким образом, вы явно указываете что данными модулями будете
пользоваться только в секции реализации.

Конечно, можно упоминать модули только в части interface, но
правильная расстановка имен модулей в соответствующем USES гарантирует
исключение циклических ссылок, а также улучшает читаемость программы.


 2.37. Как обработать события от других приложений ?

 A. Попробуйте сделать это следующим образом:
   type
    TForm1 = class(TForm)
    :
    private
      procedure WMNCActivate (var Msg: TMEssage); Message WM_NCActivate;
    :

  procedure TForm1.WMNCActivate (var Msg: TMEssage);
  begin
  : { а здесь обработка принятых событий }
  end;


  2.38. Как разделить обработку OnClick и OnDblClick ? Ведь OnClick будет
 вызываться всегда, и перед DblClick.

 A. Именно так и происходит в Windows - посылаются оба сообщения. Для того
 чтобы обработать только какое-то одно событие необходимо чуть "задержать"
 выполнение OnClick. Сделать это можно следующим способом:

 procedure TForm1.ListBox1Click(Sender:TObject);
  var Msg:TMSG; TargetTime:LongInt;
  begin
   {Get the maximum time to wait for a double-click message}
   TargetTime:=GetTickCount+GetDoubleClickTime;

   {Цикл пока не принят DblClick или время ожидания истечет
   while GetTickCount < TargetTime do
    if PeekMessage(Msg,ListBox1.Handle,WM_LBUTTONDBLCLK,WM_LBUTTONDBLCLK,
                    PM_NOREMOVE)
     then exit; {Double clicked}

   MessageDlg('Single clicked', mtInformation, [mbOK], 0);
 end;


2.39 Как писать эксперты, VCS и т.п. ?

 Это настолько обширная тема, что вряд-ли когда-нибудь будет включена в этот
файл. Подробную информацию вы можете получить, прочитав российский
электронный журнал Delphi Interactive Journal, номера с 1 по 4. Автором
материалов по написанию экспертов является Сергей Орлик, в электронной почте
его можно найти в эхоконференции FIDO RU.DELPHI.




Проблемы--------------------------------------------------------


3.1 Проблема в использовании компонента TCustomGrid:
 Q. Делаю так:
 a) Создаю новый компонент при помощи Эксперта Компонент
 b) Имя класса 'TSampleCalendar'
 c) Имя родителя 'TCustomGrid'
 d) Использую страницу 'Samples'
 e) Сохраняю модуль с именем CALSAMP.PAS
 f) Подключаю к Палитре компонент
 g) Создаю форму, помещаю новый компонент на форму и получаю
         Runtime Error 210
 В чем дело ?

 A. Проблема в том, что TCustomGrid имеет метод DrawCell, который
 является абстрактным. То, что его безусловно надо переписывать у
 любого наследника TCustomGrid, к сожалению, не отражено в документации.
 Создайте этот метод (пусть даже пустой) и ваша проблема исчезнет.

3.2.Проблема с DragDrop для внешних программ.

 Q. Я пишу небольшую программку - "мусорную корзину". В FormCreate
 вызывается DragAcceptFiles(HANDLE, True). Проблема в том, что когда
 размер окна восстанавливается и затем минимизируется Drag/Drop
 перестает работать. Я безуспешно пробовал помещать DragAcceptFiles в
 разные методы формы.
 Однако если сделать вызов DragAcceptFiles(Application.Handle, True)
 в MainForm.Create, то все работает. Как перехватить событие
 WM_DROPFILES ?

 A. Это можно сделать так:

 type
  TMainForm = class(TForm)
    { ... }
    procedure FormCreate(Sender: TObject);
    { ... }
  private
    { ... }
    procedure DropFiles(var Msg : TWMDropFiles); message WM_DROPFILES;
    ...
  end;

 ...

 procedure TMainForm.DropFiles(var Msg : TWMDropFiles);
 ...
   DragQueryPoint(Msg.Drop,Point);
 ...
   NrOfFiles := DragQueryFile(Msg.Drop,Word(-1),FileName,BufSize);
 ...
   DragQueryFile(Msg.Drop,0,FileName,BufSize);
 ...
 end;


 procedure TMainForm.FormCreate(Sender: TObject);
 ...
   DragAcceptFiles(Handle, True);
 ...
 end;

 Подробнее о перехвате событий Windows см. Главу 7 Component Writers
 Guide.


3.3 Использование формата Access 2.0 в Delphi
 A. Подробное описание подключения:

 - Откройте Windows Control Panel, откройте икону ODBC.
 - Добавьте драйвер Access в список доступных, если он не указан в
 - списке текущих драйверов.
 - Укажите какое-либо имя в "Data Source Name".
 - Выберите файл БД кнопкой Select Database. Если вы хотите создать
   новый - вполните пункт Create Database
 - Запустите Database Engine Configuration
 - Нажмите кнопку New ODBC Driver
 - Выберите драйвер типа ACCESS DATA
 - В качестве Default Data Source Name выберите предложенное.
 - Создайте новый псевдоним в разделе Alias
 - Укажите тип драйвера, путь и имя к нужному файлу БД Access.
 - Сохраните изменения и закройте Database Engine Configuration

 Примечание: избегайте русских названий имен таблиц, использования
 пробела в именах таблиц, а также русских имен полей в БД Access.


3.4 Проблемы Delphi с WinG
 Q. Я слышал, что у Delphi проблемы с WinG, однако кто-то их решил ?

 A. Да, Майк Скотт (Mike Scott, 100140.2420@compuserve.com) даже
 написал коммерческий вариант VCL-компонент WinG для Delphi:

 WinG Sprite Kit. Набор компонент, осуществляющих доступ к WinG
 из Delphi. Включает кмопоненты TWinGCanvas для рисования
 WinGDC/Bitmap, TWinGSurface, которые можно поместить на форму
 и спрайтовую компоненту, которую можно помещать на них. $99 EEP

 Существует статья по использованию WinG в Borland Pascal - #5 Pascal
 Magazine. Обзор VCL WinG появится в новом Delphi Magazine. Отошлите
 письмо с вашим почтовым адресом на 70630.717@compuserve.com для
 получения бесплатной копии этих журналов (наверняка из России это
 не сработает :) :(.


3.5 Как спрятать окна MDI Child ?
 Q. Я пытаюсь это сделать, выставляя Form1.Visible:=False, но это не
 помогает.

 A. Windows не позволяет прятать (hide) окна MDI Child.


3.6 Проблемы с полями класса типа TObject, TTable и т.д.

 Q. Я объявляю поле класса как TTable, но при обращении к нему
 происходит ошибка.

 A. Дело в том, что в Delphi все экземпляры объектов, объявленых как
 class(), являются динамическими. Соответственно поле MyTable,
 объявленное как

 type
  MyClass = class(TObject)
   MyTable: TTable;
   ...      ^^^^^^^

 является _указателем_ на класс TTable, и должно быть
 инициализировано в конструкторе вашего объекта следующим образом:

 constructor MyClass.Create...
  begin
   ...
   MyTable:=TTable.Create(nil);
   MyTable.DatabaseName:='DBDEMOS';
   ...
  end;

 подробнее см. Changes in Object Pascal Language в документации или
 OnLine Help.


3.7 Использование кавычек в параметризированном запросе.
 Q. Мой запрос получает параметр. Проблема в том, что строка параметра
 содержит " (двойную кавычку), которая приводит к Runtime Error.

 A. Вам необходимо использовать динамический SQL-запрос, иначе при
 указании например WHERE TABLE.FIELD = 'let"ter' вы получите ошибку.


3.8 Использование TPanel в качестве "индикатора".

 Q. Я пытаюсь использовать TPanel как индикатор процесса обновления
 БД.  Однако надпись на панели не обновляется пока не закончится цикл
 обработки БД. В цикле вызывается Panel.Caption:=...

 A. После присвоения Panel.Caption вызывайте Panel.Refresh или
 Application.ProcessMessages.


3.9 Конвертация TBasicString (VBX) в string

 Q. Я использую VBX и испытываю проблемы с конвертацией TBasicString в
 String. Как это сделать ?

 A. Существует две функции -
  BStrPCopy - принимает Basic string и конвертирует в String
  SetBStr   - принимает String и возвращает Basic string

 Действительно, ссылок на эти функции нет в документации, но имена
 этих функций можно "обнаружить" в VBXCTRL.DCU.


3.10 Возврат значения select max() и подобных SQL-выражений.

 Q. Я хочу выполнить SQL-выражение и получить результат в свою переменную,
  что-то типа

  select max(field_1)
  from table_1
  into :variable_1;

 A. Вам не нужно использовать оператор INTO для программного доступа к
 результату - его можно получить используя свойства Fields или
 FieldByName соответствующего компонента TQuery.

  TQuery1.Add('select max(field_1) from table_1');
  TQuery.Open;

  lResult:=TQuery1.Fields[0];

  Или, если результат нужно визуализировать, достаточно подключить к
  используемому TQuery компоненты TDataSource и TDBText.

3.11 Автоматический подсчет сумм при помощи TQuery.
 Q. Меня интересует возможность подсчета суммы по таблицам, которые
 уже находятся на форме.

 A. Есть очень простой способ - предположим, что у вас есть
 на форме Query1, DataSource1, DBGrid1.
 Добавьте на эту-же форму компоненты Query2, DataSource2, DBText1.
 Установите property Query2.DataSource:=DataSource1; В Query2.SQL
 напишите select sum(field_name) from table_name, где table_name -
 имя той-же таблицы что и у Query1, а field_name - имя столбца по
 которому производится подсуммирование. Далее свяжите между собой
 Query2, DataSource2 и DBText1.

 При изменении Query1 (если конечно Query1.RequestLive=True) будет
 автоматически перевыполняться Query2. Это решение хоть и простое,
 но неэкономичное - особенно при большом количестве записей в исходной
 таблице. Более того, запрос Query2 должен иметь WHERE идентичный
 Query1.

 Для подсчета сумм правильнее использовать событие
 TQuery.OnCalcFields.  Хорошим примером является
 X:\DELPHI\DEMOS\DB\MASTAPP\MASTAPP.DPR.


3.12 Поиск компонента в форме по имени.
 Q. Я хочу делать текущими в форме произвольные компоненты. Как
 выставить фокус у конкретного компонента ясно - ListBox1.setFocus. А
 если я хочу обращаться к некоему компоненту по имени (Name propery)?

 A. TForm.Components - массив компонент формы, который и нужен вам.
 Вы можете перемещаться по этому массиву пока не найдете компонент с
 нужным Name. Например:

   procedure TForm1.DooDah;
   var
     Cnt: Integer;
   begin
     while (Cnt <= ComponentCount) and (Components[Cnt - 1] <> 'Button1' do
       Inc(Cnt)
     TButton(Components[Cnt - 1]).SetFocus;
   end;

 или еще проще:

   procedure TForm1.DooDah;
   var
     Target: TComponent;
   begin
     Target := FindComponent('Button1');
     TButton(Target).SetFocus;
   end;

 Оба этих примера показывают как найти компонент TButton с именем
 Button1, и вызвать его метод setFocus.


3.13 Предел буфера редактирования в 32K для TMemo
 Q. Почему в документации написано, что TMemo может редактировать
 тексты до 256К, а на деле получается не более 32К ?

 A. В документации ошибка. 32К - это ограничение Windows. В Windows
 все стандартные редакторы используют общий буфер в 32К, компонент
 TMemo использует другую технику, позволяющуюу _каждому_ TMemo иметь
 буфер в 32К. Остается надеяться, что в Windows95 эта проблема будет
 решена.


3.14 GPF при старте отладки программы, использующей BDE
 (Error initializing BDE $2C09 или что-то в этом роде)
Q. Когда я пытаюсь отладить программу в среде, возникает GPF прямо на
 begin в файле проекта. Если я компилирую программу, и запускаю
 отдельно - она работает совершенно нормально.

 A. Скорее всего у вас не загружена программа SHARE. Поместите ее
 вызов в AUTOEXEC.BAT.


3.15 Как обрабатывать WM_DROPFILES (Drag/Drop) ?

 A. Следующий код показывает как обрабатывать это событие.
 Обрабатываются имена всех "брошенных" файлов. Для загрузки каждого
 файла вызывается CreateChild(fname).
 В обработчике OnCreate данной формы вы должны вызвать
 DragAcceptFiles().

 type
  TFrameForm = class(TForm)
  ...
  protected
    { Protected declarations }
    procedure WMDropFiles(var msg : TMessage); message WM_DROPFILES;
  ...
  end;

 ..

 procedure TFrameForm.WMDropFiles(var msg : TMessage);
 var
  i, n  : word;
  size  : word;
  fname : string;
  hdrop : word;
 begin
  hdrop := msg.WParam;
  n := DragQueryFile(hdrop, $ffff, nil, 0);
  for i := 0 to (n - 1) do begin
    size := DragQueryFile(hdrop, i, nil, 0);
    if size < 255 then begin  {255 char. string limit - not really a problem}
      fname[0] := Chr(size);
      DragQueryFile(hdrop, i, @fname[1], size + 1);
      CreateChild(fname);
    end;
  end;
  msg.Result := 0;
  inherited;
 end;


3.16 Почему компонент TGauge так медленно работает (медленнее, чем
gauge.vbx) ?

 Компонент Gauge - просто пример, и ничего более. В нем отсутствует
 даже намек на оптимизацию перерисовок. Если вы посмотрите на код
 процедуры SetProgress, то увидите

 fCurValue:=Value;
 Refresh;

 Это означает, что как только положение изменилось, весь компонент
 будет перерисован. Тем не менее, есть пути для того, чтобы сделать
 компонент более быстрым:

 a) не присваивать Progress каждый раз (напр. 3000 раз), т.е. делать
 обновление менне часто

 b) проверять, действительно-ли позиция на экране изменится. Например,
 в SetProgress сделать следующее:

  if abs(fCurValue - fLastDrawn) >= fDisplayDelta then begin
    Refresh;
    fLastDrawn:=fCurValue;
  end;

 где fDisplayDelta что-то вроде (fMaxValue-fMinValue)/Width (идеально
 было-бы учитывать реальный размер экрана.

 c) Обновлять только часть индикатора, которая действительно меняется.
 Процедура Refresh стирает и перерисовыает весь компонент, Можно
 сделать вызов InvalidateRect (Windows API) и вызвать Update.

 d) Если вы сделали как в пункте c, вы дополнительно можете
 оптимизировать процедуру перерисовки, чтобы не перерисовывать
 неизменяющийся участок.


 3.17 Я создаю событие по SpeedButton1.OnDblClick, но оно, похоже,
вообще никогда не возникает. OnClick работает. Что делать?

 На самом деле работает, только в определенных ситуациях.
 Если вы помещаете на панель несколько кнопок, то по умолчанию они
 независимы и соответственно не фиксируются в нажатом состоянии.
 Поскольку одиночное нажатие мыши на кнопку отрабатывается
 немедленно, двойной щелчок мыши воспринимается как ДВА нажатия и
 отпускания. Поэтому OnDblClick и не срабатывает.

 Если-же кнопки связаны в группу (GroupIndex <> 0), то они могут
 фиксироваться, и соответственно могут воспринимать двойной щелчок
 мыши.


  3.18 Проблемы с именами таблиц в ODBC-драйверах.

 При использовании ODBC-драйверов, если у вас появляются ошибки
 при открытии таблицы - установите порядок сортировки (SORT ORDER)
 хотя-бы Paradox ascii. Это, например, помогает при доступе к базам
 данных Lotus Notes (ODBC-драйвер фирмы Casahl).

  3.19 GPF в ToolHelp.DLL в Win-OS/2 2.1

 Поставьте FixPack, или сделайте Upgrade на OS/2 Warp 3 FullPack.

  3.20 Проблема с property типа REAL

  Да, свойства (properties) могут быть любого вещественного типа
 кроме REAL. Дело в том, что тип REAL в общем-то не является
 стандартным, в то время как остальные соответствуют стандарту IEEE.

   3.21 UpCase для русского языка.

 A. Данная функция (UpCase) производит преобразование только латинских
 символов в верхний регистр. Для правильного преобразования необходимо
 использовать функции Windows API, поскольку именно Windows должна "знать"
 о кодировке национальных символов. Причем к конфигурации BDE кодровка
 Windows не имеет никакого отношения - имея английские Windows без
 русификатора и выставив в BDE кодировку Paradox ANSII Cyrillic нормальных
 русских букв получить не удастся.

 А функции для преобразования следующие - OEMToAnsi, AnsiToOem,
 OemToAnsiBuf, AnsiToOemBuf. Они находятся в модуле WinProcs.

   3.22 Почему при уничтожении компонента в методе OnClick происходит GPF ?

 A. Допустим, вы поместили на форму кнопку, и создали медод OnClick в
 котором вызываете Button1.Free. Вы видите, что это метод формы -
 казалось-бы, какие препятствия для правильного уничтожения кнопки ?

 На самом деле Button1.OnClick является property и после запуска вашего
 приложения содержит адрес метода Form1.Button1Click. Именно кнопка
 вызывает этот метод как свой собственный. А это означает, что кнопка не
 может удалить себя в своем-же методе. Даже если вы попытаетесь удалить
 ссылку в OnClick

  Button1.OnClick:=nil;
  Button1.Free;

 то это не поможет - стек настроен на возврат в обработчик TButton, который
 и вызвал OnClick. Поскольку к моменту возврата объект разрушен - возникает
 GPF.


4. Полезные хитрости

 4.1.  Может ли редактор текстов в Delphi вырезать и вставлять
прямоугольные фрагменты текста?

  Конечно, может: Нажмите кроме Shift еще и Alt и режьте на здоровье.
  Alt можно сразу отпустить. Чтобы вернуться в старый режим, нужно вы-
  делить что-либо мышкой.

  У редактора в Delphi есть огромное количество функций, а клавиши, которые
  их выполняют, зависят от настройки редактора в Options/Environment.
  Если вы уже привыкли к среде BP, то лучше всего использовать раскладку
  Classic.

  Все раскладки описаны в OnLine Help, нужно их только найти. Правда, большое
  количество клавиш не описано вообще. Например, по закладкам (страницам)
  редактора и инспектора объектов можно перемещаться при помощи Ctrl-Tab. В
  Инспекторе Объектов попасть в список компонент текущей формы - Ctrl-Down.
  Для быстрого поиска свойств или событий в Инспекторе Объектов - нажать Tab
  и нужную букву, затем опять Tab.

  Если нужно на форму положить большое число компонент одного типа, то нужно
  нажать Shift, щелкнуть мышью на нужный компонент, и на форме останется
  только нажать столько раз мышью, сколько нужно компонент.

  Отметить несколько компонент на форме можно как "обведя" их мышью, так и
  помечатя нужные, удерживая Shift. При этом Инспектор Объектов будет
  показывать только те свойства и события, которые есть у всех выбранных
  компонент. Так можно одновременно поменять ширину нескольких кнопок,
  псевдоним (alias) у компонент TTable и TQuery и т.д.

 МЫ ЖЕЛАЕМ УДАЧИ ВАШИМ РАЗРАБОТКАМ!!!

ДемоЦентр по клиент/серверным технологиям Borland
