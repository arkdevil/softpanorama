Journal:    Computer Language  Feb 1993 v10 n2 p35(3)
* Full Text COPYRIGHT Miller Freeman Inc. 1993.
-------------------------------------------------------------------------
Title:     In the beginning, there was SCCS....
             (the source code control system revision control system in
             UNIX System V)(includes related articles on the CLMFORUM and
             CASEFORUM, and on the book, 'Winning With Case: Managing
             Modern Software Development,' by Robert L. Dixon) (Tools of
             the Trade)
Author:    Keuffel, Warren


Abstract:  The source code control system (SCCS) revision control system
           in UNIX System V was the first such system to gain widespread
           use, in part because it was included with the UNIX versions
           provided for free to academic institutions.  Walter Tichy at
           Purdue University developed a competing version control system
           for Berkeley UNIX called RCS; an RCS package from Mortice Kern
           Systems is examined.  The commands listed in the SCCS of UNIX
           System V version 4 are cdc, comb, delta, get, prs, rmdel,
           sccsdiff, unget, val, sact and admin; each is described.  SCCS
           requires that users specify whether the modified file will be
           a new branch or not with the 'get' command; older versions do
           not allow users to combine two deltas or branches into a new
           version, which is a primary reason for RCS's popularity.  RCS
           commands include ci, co, merge, rcs, rcsclean, rcsmenu and
           rlog; each is described.  The strengths, weaknesses and
           similarities of SCCS and RCS are examined.
-------------------------------------------------------------------------
Full Text:

Any discussion of the history of  revision control tools must of
necessity begin with the source code control system (SCCS) that is
included with every AT&T (now UNIX Systems Laboratories) System V UNIX
system.  SCCS was the first revision control system that achieved any
degree of widespread usage.  One reason for SCCS's popularity, of course,
was that it was included with the AT&T UNIX variants that were provided
to academic institutions free of charge; a generation of university
students thus grew up with SCCS.

Those familiar with the parallel development of the Berkeley variant of
UNIX at the University of California will recall that a competing version
control system was developed for Berkeley UNIX by Walter Tichy at Purdue
University.  Called RCS, it was an adaptation of the earlier SCCS.
Because most current version control software is derived from RCS, this
month we will look at an RCS package from Mortice Kern Systems (MKS).  By
doing so we'll not only get some insights into how MKS RCS functions, but
we'll also gain an appreciation for how other vendors have extended RCS.

Let's take a look at SCCS before we get into a discussion of RCS in
general and MKS RCS in particular.

SCCS, as implemented on UNIX System V v. 4, lists these commands in the
permuted index as related to SCCS:

*  cdc.  Change the delta comment of an SCCS delta.

*  comb.  Combine SCCS deltas.

*  delta.  make a delta (change) to an SCCS file.

*  get.  Get a version of an SCCS file.

*  prs.  Print an SCCS file.

*  rmdel.  Remove a delta from an SCCS file.

*  sccsdiff.  Compare two versions of an SCCS file.

*  unget.  Undo a previous get of an SCCS file.

*  val.  Validate an SCCS file.

*  sact.  Print current SCCS file editing activity.

*  admin.  Create and administer SCCS files.

Remember, the basic purpose of software configuration management is to
answer the question, "What program is this?" Typically, an engineer will
check out (get) a file of source code, make modifications, and check the
module back two commands represent the heart of version control; the
remaining commands exist for administrative or convenience purposes.
Let's take a closer look at the options available with the get and delta
commands.

When you get a file from SCCS, 16 options are available.  Some of the
more important ones are:

*  -rSID.  Specify the unique 51D (SCCS identification string) of the
version to be retrieved.

*  -ccutoff Don't include versions created after the date specified in
cutoff in the generated file.

*  -e.  Locks the SCCS file so others can't make changes to it until your
changes have been applied.

*  -b.  Used with the -e option; when the modified file is checked back
in, a new branch is created.

*  -t.  Access the most recently created delta in a release.  When you
delta (check back in) a modified file, seven options are available.  In
addition to the -rSID option also supported in the get command, the two
most important options are:

*  -mmrlist.  Require input of a modification request number that points
to the reason why the new delta was created.

*  -ycomment.  Allow input of freeform text to further describe the
particular delta.

One important feature of SCCS is that you must specify whether the
modified file will be a new branch or not with the get command; that is,
you can't (easily) wait until the modifications are finished before
deciding whether or not it will be a new branch or not.  This shouldn't
present problems for those who plan ahead, but it is the least flexible
function provided with any of the products we'll be looking at.

Also keep in mind that older versions of SCCS have not permitted the user
to combine two deltas or branches into a new version, which is a major
reason why RCS has proven more popular.  The camb command is a recent
addition to the SCCS command set.

The deltas (changes) to a source code file are incorporated in the file
itself.  The original file is modified by the insertion of five SCCS
control sections at the beginning of the file, followed by a sixth
section, the text of the file.  An important characteristic of the text
portion of the file is that the changes are written into the text portion
of the SCCS file- as opposed to being stored in a separate revision file
or as a group at the bottom of the file.  Thus, the six sections of an
SCCS file are:

*  The checksum (of all characters in the file)

*  The delta table, where the 51D, modification request, comments, and so
on are stored (but not the actual changes)

*  The user names or the list of users who are authorized to make changes
to the file

*  The flags, which are used internally by SCCS

*  Comments describing the SCCS file as a whole

*  The body, containing the original text and control lines defining the
modifications.

Now, let's turn to a dicussion of RCS focusing on the MKS RCS, although
the UNIX version is almost identical (a major difference is that the MKS
RCS supports binary files --for example, word processor or spreadsheet
files--whereas the UNIX version does not).  Since RCS is derived from
SCCS, there are several similarities.  Some of the more interesting RCS
commands are:

*  ci.  Check in a file under RCS.

*  co. Check out a file under RCS.

*  Merge.  Three-way file merge.  If two engineers are independently
working on changes to one  base-line module, merge will apply both
changes to create a new delta.  However, if the engineers have changed
any of the same code, Merge will show both changes and leave it up to the
engineers to reconcile the conflict.

*  rcs.  Create new RCS files or change attributes of existing ones.

*  resclean.  Remove working files that were checked out but never
modified.

*  resmenu.  MKS's menu interface to RCS.

*  rlog.  Displays historical and administrative information about an RCS
file.

As you can see, the RCS ci and ca commands are functionally equivalent to
the SCCSget and delta commands.  And with the exception of the merge
command, the rest of the RCS command set, as with SCCS, is designed to
ease the administrative burden.  The two significant differences between
SCCS and RCS, aside from the ability to merge two deltas, are how the
changes are stored in the SCS and RCS files and how SCCS and RCS handle
revision numbering.

SCCS, as described previously, stores each change to the source code as a
line in the body portion of the file at the place where the change
occurs.  It's not difficult to imagine situations that would cause
revisions to stumble all over each other and make manual fixes to the
file virtually impossible.

RCS, by contrast, stores each revision's changes as a separate section
following the original file.  In addition, for those UNIX programmers who
use lex..and yacc, the format of the RCS file is defined as a grammar.
Of course, there is far more flexibility with RCS than with SCCS, both in
the standard product and for those who write their own RCS file access
routines to meet special needs.

Neither SCCS nor RCS does a very good job of handling revision numbering.
 Wayne Babich, in Software Configuration Management: Coordination For
Team Productivity (Addison-Wesley, 1986), has this to say about SCCS and
RCS version numbering

"Naming of versions is a sore point in both SCCS and RCS, although RCS is
cleaner...[when] there are only two development paths, the four digit
numbers are intelligible (though not convenient).  But when there are a
greater number of variations, the numbering schemes become completely
hopeless.  SCCS assigns numbers in such a way that the relationship of a
number to its position in the development is indeterminate--it is not
possible to look at the name of a version and understand how it relates
to the other versions.  RCS provides a determinate (though complex)
numbering system and also allows you to refer to a development path using
an English designation.  You might, for example, refer to one variation
as development and the other as public  so that no one has to memorize
the numbers for each."

When Babich refers to the RCS determinate numbering scheme, he is
describing how branches from the main trunk get numbered.  Consider this
example: a project begins with 1.1, is modified and becomes 1.2, 1.3,
1.4, and so on.  Suppose we want to start a new branch from revision 1.3?
The first version in this branch will not be numbered 1.3.1 as one might
expect, but instead as 1.3.1.1.

With this background on these two pioneering version control software
packages in hand, we'll next look at how various vendors have taken the
SCCS and RCS concepts and extended them to create unique products.

Warren Keuffel is a software engineer fir Unisys Corp. in Salt Lake City,
Utah, He is founding member of The Pathfinder Guild, which provides
training in software engineering electronically.  Contact him on
CompuServe at 76702,525, or on Internet at wpk@unislc.slc.  unisys.  com,
or write to him in care of COMPUTER LANGUAGE, 600 Hamson St., San
Francisco, Calif, 94107.

COMPUTER LANGUAGE is more than words on paper that get delivered to your
mailbox every month.  It is also a community of software engineers that
meets daily on CompuServe.  If you're not availing yourself of the
opportunities in CLMFORUM or CASEFORUM, you're missing out on a great
deal of very useful information and opportunities to network with your
peers.

CLMFORUM, managed by Jim Kyle and Jeff Brenton, is still living up to its
well-deserved reputation as the "software engineer's pub." CLMFORUM is
the kind of place where you can ask a question about literally
anything--related to software engineering or not--and within hours have a
reply.  The denizens of this forum are an amazingly eclectic bunch who
have managed to avoid the tunnel vision that afflicts too many engineers.

Study groups are probably the single most important benefit that CLMFORUM
and CASEFORUM can offer you.  The Software Engineering Study Group
(SESG), which Rich Cohen moderated on CLMFORUM for several years, has
recently moved to CASEFORUM, which is managed by myself and Deborah
Dewey.  We've split the SESG into two new study groups, the software
management study group and the software methods study group.

As I write this, the management study group is finishing up Jerry
Weinberg's Quality Software Management, Volume I: Systems Thinking
(Dorset House, 1992) and then will read Peopleware by Tom Demarco and Tim
Lister (Dorset House, 1987).  Meanwhile, the methods study group will be
starting Wicked Problems, Righteous Solutions by Peter DeGrace and Leslie
Stahl (Prentice Hail, 1990).  In CLMFORUM, sysop Rudyard Merriam is
leading a spirited discussion of Object-Oriented Modeling And Design by
James Rumbaugh, Michael Blaha, William Premerlani, Frederick Eddy, and
William Lorensen (Prentice Hall, 1991).  Incidentally, authors of study
group selections often join in the discussion of their books.

CASEFORUM also features a guest of the month who is usually a CASE tool
vendor representative, an author, or consultant.  Previous guests have
included Jeff Jacobs, who discussed Oracle's CASE tools and Chris Bird
from Model Systems.

There's lots happening in CLMFORUM and CASEFORUM that can help you not
only advance your professional development, but also have fun while doing
it.  So, get on CompuServe already and join us!

The WorkBench book for this month is a book I wish I'd written.  In fact,
that is what I told the author when I read it in galleys last year, but
now that I've seen the finished product, I doubt that I could have done
as good a job with the material, so I' m happy to recommend to you Robert
k Dixon' s Winning With Case: Managing Modern Software Development
(McGraw-Hill, 1992).  Dixon, who was with Levi Strauss in San Francisco,
Calif., and is now a principal in a Bay Area consulting firm, is a
frequent speaker on CASE and methodology development at Software
Development conferences.  If you have a chance to hear As Dixon suggests
in his introduction, "Clearly not everything [with software development
methods] is wrong.  There's a lot of good software written today ...[but]
no single approach does it all....In fact, there are many ways and many
vehicles to move you along....Instead of junking old methods for the new,
we need to think about synthesizing them.  We talk a lot about reusing
software; now let's think about reusing software development methods."

Dixon, more than any other author I've read to date, accomplishes the
difficult marriage of providing useful information about CASE technology,
while at the same time emphasizing the necessity for designing a
development environment and architecture, identifying the appropriate
methodologies to be used in development, and coordinating it all with
project management techniques.  Once these tasks have been completed,
Dixon offers advice on choosing an appropriate tool for the environment
you've created.

Readers should be aware, though, that Dixon believes heavily in the
advantages of I-CASE--that is, integrated CASE tools that provide support
for the full software development life cycle.  In particular, Dixon uses
the Texas Instruments Information Engineering Facility (IEF) heavily in
hi8 consulting practice.  However, Winning With Case is not focused on
IEF as much as it is on the benefits of diagram-to-code tools.  Because
of this emphasis, some readers may feel that Winning With Case is more
suited to the MIS environment--but I disagree, Dixon's emphasis on
synergy, appropriate methodologies, and project management makes this
book a winner for anyone considering using CASE tools in his or her
organization.
-------------------------------------------------------------------------
Type:      column
Product:   Unix System V
Topic:     UNIX-Like Operating Systems
           Software Design
           Source Code
           Program Development Software
           Program Development Techniques
           Enhancements
           Comparison
           Version and Release Control


Record#:   13 334 464.
                              *** End ***
