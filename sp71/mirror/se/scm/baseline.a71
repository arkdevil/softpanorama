From: giles@fig.nacto.lkg.dec.com (Leslie Giles)
Newsgroups: comp.software.config-mgmt
Subject: Re:
Date: 17 Jan 1995 15:09:12 GMT
Organization: Digital Equipment Corporation
Message-ID: <3fgmio$2ku@nntpd.lkg.dec.com>



In article <3fe61h$23s@newsbf02.news.aol.com>, jean1112@aol.com (Jean1112) writes:
|> Lezz Giles writes:
|> 
|> >Can you explain?  What is wrong with just storing the source code and
|> >the methods for deriving the binaries?  If your build process is
|> well-defined
|> >and you control the compilers, linkers, and all other tools (which you
|> >need to do anyway in order to be able to build bugfix releases), then
|> >why do you need to control binaries?
|>  
|> The types of binaries we control through CMVC are those generated
|> through other tools (not our compiler).  For example, we store code
|> created by the GUI-generator and by the Sybase Multi-media GEL 
|> code generator.  We are NOT storing the object code generated by
|> the C compiler (though I know other projects that do).
|> 
|> We also store (when it is reasonable) the source models used by the
|> various generators to create the binaries.  Some of these models can
|> only be stored in the form of backup tapes, they are not modifiable
|> unless viewed through their native code-generator environment.
|> 
|> >What I'm doing at the moment (which is the same as was done on all the
|> >projects I worked on) is to just store source in the repository, but
|> >dump each fully-built baseline to tape.  That way I can reproduce a
|> baseline
|> >from the repository for day-to-day work including working on bugfix
|> >releases, and from tape for disaster recovery.  (In fact I'm cheating
|> >slightly because we're using the native compiler on our DECstations
|> >and I am not storing any SCM information for the compiler - but then
|> again
|> >I've only been here a few months and there's still plenty of time to get
|> >that level of control...).
|> 
|> >Another detail of our current system is that we have a totally different
|> >database that is used by manufacturing, and the released binaries live
|> >in that database.  Our release process is, in fact, just the process of
|> >putting the binaries into that database.
|> 
|> I think that is the difference.  Our environment includes manufacturing.
|> We also have to maintain the system for a variety of platforms and
|> some users are using back levels of the code so we maintain that in 
|> parallel as well.  It becomes really critical to keep the various
|> components in sync with each other.  For example, we want to be sure
|> that the particular version of the GUI is put on the release tape with
|> the corresponding version of the application code.  By putting them
|> all in the same CMVC level, they are released in sync.
|> 
|> Does this make more sense?  Perhaps I should explain more about
|> the code generators?

No - I think I understand.  The problem is that in the cases you mention,
the "source code" is actually an engineer sitting down in front of, for
example, a GUI builder arranging windows and buttons.  Another question -
if you want to, say, move a button 2 inches to the right in the next
release, how do you do it?  Does somebody need to sit down and completely
re-layout the GUI screen, or is it possible to somehow feed the display
description back into the GUI builder?

On my last project I was getting upset because some of our "source" files
were generated from a database, and there was no way to version-control
the contents of the database.  What was even more upsetting was that (a)
there was only one database in a central location, (b) the database
contained release-specific information, i.e. it couldn't support two
releases, and (c) we were going to have different releases in the field
simultaneously.  Fortunately (?) the project was cancelled before we
really got ourselves screwed.  However with my simplified view of
SCM and baselines I just couldn't cope with this complication.

Getting back to the earlier discussion, this all raises questions about
the relationship between version control and baselines.  I'd always had
the philosophically pure view that a baseline could always be completely
regenerated from version controlled source code, however I'm now beginning
to acknowledge that life is never that simple.  First there are binaries
that you just can't get the source for.  Then there are things like the
GUI-builder output that you mention.  Then there is the compiler and
libraries.  Then there is the version of the OS and the system that
you used to build the baseline (speaking as somebody using Ultrix
on a DECstation, this is an important consideration).  In order to be
able to fully regenerate a baseline you need to have all four
categories of non-readable input under control.  The first two sources
can be version-controlled, though not in the classic sense with deltas.
The last two are more of the nature of baseline-related information that
needs to be recorded.

Your reply also mentions that your releases are held in your version
control repository.  Having thought about it (and I know these thoughts
are not original), there seem to be four levels of version control:
- Private, used during coding and initial testing where the changes are
  not shared with anybody else (except possibly a code inspection);
- Shared, used during integration;
- Baselined
- Released
I've typically seen the last two seperated into different systems; your
current system puts them into the same repository.  There are questions
about what should be controlled at the four different levels, for example
should even source code be version controlled at the private level?  And
should executables be controlled at the baseline level?

Lezz Giles





