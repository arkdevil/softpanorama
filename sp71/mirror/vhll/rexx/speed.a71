Newsgroups: comp.lang.rexx
Message-ID: <REXXLIST%94122014564177@UGA.CC.UGA.EDU>
Date: Tue, 20 Dec 1994 20:00:59 GMT
From: Mike Cowlishaw <mfc@VNET.IBM.COM>
Subject: Execution penalties using REXX

Ref: Post from m8716@sparc2.abc.se (Mats Liljegren)

The 'simple' answer is that it all depends on your 'platform' (hardware
and operating system).  But here's a couple of pieces of string:

 -- on a 'Pentium' class machine, Rexx interpreters typically run at
    40,000 or more Rexx clauses per second.  That means there's a lot of
    customization that you can do in sub-second response time (and you
    probably won't be using the hardware floating-point arithmetic unit,
    either).

 -- I have an application (GoServe) that's a World-Wide Web server using
    Rexx as the script language.  For a useful script, the time spent
    in the Rexx interpreter is dwarfed by the time spent in the TCP/IP
    and network overheads (by roughly an order of magnitude).

Mike Cowlishaw
IBM UK Laboratories

From ankh.iia.org!uunet!news.mathworks.com!udel!news.sprintlink.net!nwnexus!news.halcyon.com!chinook!sbr Fri Dec 23 19:50:31 1994
Path: ankh.iia.org!uunet!news.mathworks.com!udel!news.sprintlink.net!nwnexus!news.halcyon.com!chinook!sbr
From: sbr@chinook.halcyon.com (Stephen Rondeau)
Newsgroups: comp.lang.rexx
Subject: Re: Execution penalties using REXX
Followup-To: comp.lang.rexx
Date: 20 Dec 1994 21:19:19 GMT
Organization: NW NEXUS, Inc. -- Internet Made Easy (206) 455-3505
Lines: 42
Sender: sbr@halcyon.com
Distribution: inet
Message-ID: <3d7hon$pqg@news.halcyon.com>
References: <0v9ykCA5K3oA070yn@sparc2.abc.se>
NNTP-Posting-Host: chinook.halcyon.com

In article <0v9ykCA5K3oA070yn@sparc2.abc.se>,
Mats Liljegren <m8716@sparc2.abc.se> wrote:
>Simple. The whole program consist of nothing else than a bunch of DLL:s, and
>you write REXX-scripts to make things happen the way you want. But the
>question is, what will the penalties for this solution be?  How much slower
>will the program get? Other problems involved?

First, there is the load time for various DLLs. Of course, these can be
pre-loaded. Then there is the overhead involved in looking up a
function, converting arguments from string to whatever is needed, and
converting results back into strings. Some of this can be avoided if you
don't require the user to manipulate the data passed -- keep it in
binary form.

People will use compound variables as a substitute for arrays. Stem
indexing involves significantly greater overhead than normal array
indexing... though stem indexing/compound variables are much more
powerful. Some REXX interpreters don't do a good job with loop
counting variables, introducing a lot of unnecessary conversions. I
think OS/2 REXX is reasonable about this, but ARexx is not (it also
has poor performance for external function calls).

Any compound variable access will need to pass through the API, since
stems cannot be passed through argument lists. This is very slow,
compared to passing an array in a language like C. And the question arises
of how to pass indices or "tails" that are not conventional positive
integers (for which you can use the convention of stem.0 holding the number of
elements and the elements being numbered from stem.1 to stem.n, where n
is the value of stem.0; however, you need to extend this to handle
multiple dimensions (e.g., point.10.32.65) to be general).

And I think you need to consider that REXX doesn't have structures,
although they can be simulated in various ways.

As long as OS/2 calls DLL functions in an efficient manner, I think that
you can get reasonable performance out of this. The more
compute-intensive stuff you can handle in your DLL functions, the better
off you will be, in my opinion.

Stephen Rondeau



