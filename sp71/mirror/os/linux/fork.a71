From: rockwell@nova.umd.edu (Raul Deluth Miller)
Newsgroups: alt.fan.bill-gates,comp.os.ms-windows.nt.misc,comp.os.ms-windows.advocacy,comp.unix.advocacy
Subject: Re: UNIX login when telnet Microsoft.com
Date: 16 Dec 1994 12:46:55 -0500
Organization: University of Maryland University College
Message-ID: <ROCKWELL.94Dec16124653@nova.umd.edu>

Mike Lipsie:
: I fear we are working with different definitions of "hack".
:
: In my book, "fork" is a hack.  
:
: What do I want to do?  Start another process to do something.  So
: what does fork() do?  Clones *this* process.

Yeah, I get your drift...

What do I want to do?  Balance my checkbook.  So what does fork() do?
Clones *this* process.

Yep.. yep.. yep....



Lecture alert.

fork(), as originally designed, gives a simple abstraction: it creates
a process.  Furthermore, it lets you associate some arbitrary set of
code and data with that process.  Given copy-on-write semantics, and
some reasonable bit of scheduling (child runs for a timeslice before
parent may run), you've got a fairly clean mechanism for starting an
arbitrarily defined independent piece of code.

Which is not to say other abstractions are not desirable.  For
example, persistent processes which live across machine reboots.  For
example, atomic message passing of arbitrarily large messages.  For
example, incremental code generation.  etc.. fork() doesn't really
address these issues.

Personally, my definition of a "hack" is code that's poorly factored,
or that has a cluttered interface.  X Windows comes to mind :-/ For
that matter, so does MS Windows.

-- 
Raul D. Miller          N=:((*/pq)&|)@                 NB. public e, y, n=:*/pq
<rockwell@nova.umd.edu> P=:*N/@:#               NB. */-.,e e.&factors t=:*/<:pq
                        1=t|e*d    NB. (,-:<:)pq is four large primes, e medium
x-:d P,:y=:e P,:x                  NB. (d P,:y)-:D P*:N^:(i.#D)y [. D=:|.@#.d

From ankh.iia.org!uunet!newshost.marcam.com!news.mathworks.com!udel!gatech!howland.reston.ans.net!vixen.cso.uiuc.edu!qualcomm.com!eldritch!ianm Sat Dec 17 14:33:33 1994
Path: ankh.iia.org!uunet!newshost.marcam.com!news.mathworks.com!udel!gatech!howland.reston.ans.net!vixen.cso.uiuc.edu!qualcomm.com!eldritch!ianm
From: ianm@qualcomm.com (Ian McCloghrie)
Newsgroups: alt.fan.bill-gates,comp.os.ms-windows.nt.misc,comp.os.ms-windows.advocacy,comp.unix.advocacy
Subject: Re: UNIX login when telnet Microsoft.com
Date: 16 Dec 1994 11:36:34 -0800
Organization: QUALCOMM, Incorporated; San Diego, CA, USA
Lines: 26
Message-ID: <ianm.787606240@eldritch>
References: <3cn3pm$t7k@george.inhouse.compuserve.com> <3cnrgo$lc3@news-2.csn.net> <3cpt62$anu@mhaal.inhouse.compuserve.com> <3cpvq4$er3@mail.fwi.uva.nl> <3cshu8$dmq@rdm51.ca.merl.com>
NNTP-Posting-Host: eldritch.qualcomm.com
Xref: ankh.iia.org alt.fan.bill-gates:5898 comp.os.ms-windows.nt.misc:23775 comp.os.ms-windows.advocacy:30668 comp.unix.advocacy:2249

mlipsie@ca.merl.com (Mike Lipsie MPU) writes:

>I fear we are working with different definitions of "hack".

>In my book, "fork" is a hack.  

>What do I want to do?  Start another process to do something.
>So what does fork() do?  Clones *this* process.

Paired with the vairous exec() calls to replace this process with
another, it gives the most flexibility with the least system calls.
What if I *want* another copy the current process?  I know of a number
of pieces of software which use fork() not to start up a different
program, but to checkpoint an in-memory database to disk.  Even if
your only interest is to start up a new process off disk,
by separating StartNewProces() into fork() and exec() you get added
flexibility in terms of what file descriptors are opened/closed/etc.

--
Ian McCloghrie    work: ianm@qualcomm.com     home: ian@egbt.org
  ____   GCS d-- H- s+:+ !g p?+ au a- w+ v- C+++$ UL++++ US++$ P+>++
  \bi/   L+++ 3 E+ N++ K--- !W--- M-- V-- -po+ Y+ t+ 5+++ jx R G''''
   \/    tv- b+++ D- B--- e- u* h- f+ r n+ y*

The above represents my personal opinions and not necessarily those
of my employer, Qualcomm Inc.

From ankh.iia.org!uunet!bah.com!proto.ida.org!sol.ctr.columbia.edu!howland.reston.ans.net!news.sprintlink.net!hookup!news.kei.com!ub!csn!csnnews!teal.csn.org!bediger Sat Dec 17 14:34:41 1994
Path: ankh.iia.org!uunet!bah.com!proto.ida.org!sol.ctr.columbia.edu!howland.reston.ans.net!news.sprintlink.net!hookup!news.kei.com!ub!csn!csnnews!teal.csn.org!bediger
From: bediger@teal.csn.org (Bruce Ediger)
Newsgroups: alt.fan.bill-gates,comp.os.ms-windows.nt.misc,comp.os.ms-windows.advocacy,comp.unix.advocacy
Subject: Re: UNIX login when telnet Microsoft.com
Date: 16 Dec 1994 19:54:40 GMT
Organization: False September
Lines: 16
Message-ID: <3csra0$a16@news-2.csn.net>
References: <3cpt62$anu@mhaal.inhouse.compuserve.com> <3cpvq4$er3@mail.fwi.uva.nl> <3cshu8$dmq@rdm51.ca.merl.com>
NNTP-Posting-Host: 199.117.27.22
Xref: ankh.iia.org alt.fan.bill-gates:5901 comp.os.ms-windows.nt.misc:23792 comp.os.ms-windows.advocacy:30673 comp.unix.advocacy:2250

mlipsie@ca.merl.com (Mike Lipsie MPU) wrote:
:In my book, "fork" is a hack.  
:
:What do I want to do?  Start another process to do something.
:So what does fork() do?  Clones *this* process.

Fine.  I'm going to call:

The first guy that said fork() is a hack and Mike Lipsie, write function
prototypes of a "CreateProcess()" or a "Spawn()" or whatever.  Post them.
We can then judge if you can come up with a function, or a small number (n < 4)
of functions, that can equal the flexibility and power of the fork()
exec() combo.  Post the WIN32 (or acronym de jure, I don't keep up) manual
page(s) on the topic.  Put up or shut up.  Show us how fork()/exec() should
be changed or could be changed so that they're more flexible, or more
powerful.

From ankh.iia.org!babbage.ece.uc.edu!news.kei.com!news.mathworks.com!uhog.mit.edu!bloom-beacon.mit.edu!gatech!gt-news!prism!prism!not-for-mail Sat Dec 17 14:37:25 1994
Path: ankh.iia.org!babbage.ece.uc.edu!news.kei.com!news.mathworks.com!uhog.mit.edu!bloom-beacon.mit.edu!gatech!gt-news!prism!prism!not-for-mail
From: gt6977b@prism.gatech.edu (David Charles Leblanc)
Newsgroups: alt.fan.bill-gates,comp.os.ms-windows.advocacy,comp.unix.advocacy
Subject: Re: UNIX login when telnet Microsoft.com
Date: 17 Dec 1994 00:20:25 -0500
Organization: Georgia Institute of Technology
Lines: 467
Sender: gt6977b@prism.gatech.edu
Message-ID: <3ctsep$mdq@acmex.gatech.edu>
References: <3cshu8$dmq@rdm51.ca.merl.com> <3csra0$a16@news-2.csn.net> <3csvcb$p8l@acmex.gatech.edu> <3ct445$djh@news-2.csn.net>
NNTP-Posting-Host: acmex.gatech.edu
Xref: ankh.iia.org alt.fan.bill-gates:5922 comp.os.ms-windows.advocacy:30719 comp.unix.advocacy:2259

bediger@teal.csn.org (Bruce Ediger) writes:

>gt6977b@prism.gatech.edu (David Charles Leblanc) wrote:
>:heh - we are able to call exec() as well as CreateProcess().  So we can
>:do what you can do and more -> NT is more flexible.  We also have the
>:option of creating a Win16, DOS, and presumably OS/2 (16-bit) or POSIX
>:processes from the Win32 parent process.

>That's not an answer to the question.  Perhaps the question bears
>repeating:

>Here's the question again:
>:>page(s) on the topic.  Put up or shut up.  Show us how fork()/exec() should
>:>be changed or could be changed so that they're more flexible, or more
>:>powerful.

>Seems simple enough for something as self evident as you guys say it is.

>I'm not entirely sure that "creating different kinds of processes, most
>of them backward compatible with operating systems my box never ran in
>the first place" counts as extra Elegance for CreateProcess().  It might
>count as extra flexibility, but since you didn't bother to show us a
>function prototype, I personally have no idea whether CreateProcess()
>takes a flag to do this, or there's 4 more CreateProcess() variants.
>What does the audience say?

Here you go - this is the man page on CreateProcess - it looks like a
very useful function to me - YMMV.

CreateProcess

The CreateProcess function creates a new process and its primary thread.
The new process 
executes the specified executable file. 

BOOL CreateProcess(

    LPCTSTR  lpszImageName,	// address of module name 
    LPCTSTR  lpszCommandLine,	// address of command line 
    LPSECURITY_ATTRIBUTES  lpsaProcess,	// address of process security
attributes 
    LPSECURITY_ATTRIBUTES  lpsaThread,	// address of thread security
attributes 
    BOOL  fInheritHandles,	// new process inherits handles 
    DWORD  fdwCreate,	// creation flags 
    LPVOID  lpvEnvironment,	// address of new environment block 
    LPCTSTR  lpszCurDir,	// address of current directory name 
    LPSTARTUPINFO  lpsiStartInfo,	// address of STARTUPINFO 
    LPPROCESS_INFORMATION  lppiProcInfo 	// address of
PROCESS_INFORMATION  
   );	

Parameters

lpszImageName

Points to a null-terminated string specifying the full path and filename
of the module to 
execute. If a partial name is specified, the current drive and current
directory are used by 
default. If this parameter is NULL, the module name must be the first
white 
space-delimited token in the lpszCommandLine string. The specified
module can be a 
Win32-based application, or it can be some other type of module (for
example, MS-DOS 
or OS/2) if the appropriate subsystem is available on the local
computer. 

lpszCommandLine

Points to a null-terminated string specifying the command line for the
application to be 
executed. If this parameter is NULL, the lpszImageName string is used as
the command 
line. If both lpszImageName and lpszCommandLine are non-NULL,
lpszImageName 
specifies the module to execute and lpszCommandLine is used as the
command line. The 
new process can use GetCommandLine to retrieve the entire command line;
or C 
runtime processes can use the argc/argv mechanism. 
If lpszImageName is NULL, the first white space-delimited token of the
command line 
specifies the module name. If the filename does not contain an
extension, .EXE is 
assumed. If the filename ends in a "." with no extension, or the
filename contains a path, 
.EXE is not appended. If the filename does not contain a directory path,
Windows 
searches for the executable file in the following sequence: 

	1.	The directory from which the application loaded. 
	2.	The current directory. 
	3.	The 32-bit Windows system directory. Use the
GetSystemDirectory function to 
obtain the path of this directory. The name of this directory is
SYSTEM32.
	4.	The 16-bit Windows system directory. There is no Win32
function that obtains the 
path of this directory, but it is searched. The name of this directory
is SYSTEM.
	5.	The Windows directory. Use the GetWindowsDirectory
function to obtain the path of 
this directory. 
	6.	The directories that are listed in the PATH environment
variable. 

If the process to be created is an MS-DOS - based or Windows-based
application, 
lpszCommandLine should be a full command line in which the first element
is the 
application name. Because this also works well for Win32-based
applications, it is the 
most robust way to set lpszCommandLine. 

lpsaProcess

Points to a SECURITY_ATTRIBUTES structure that specifies the security
attributes for 
the created process. 
If lpsaProcess is NULL, the process is created with a default security
descriptor, and the 
resulting handle is not inherited. 

lpsaThread

Points to a SECURITY_ATTRIBUTES structure that specifies the security
attributes for 
the primary thread of the new process. If lpsaThread is NULL, the
process is created 
with a default security descriptor, and the resulting handle is not
inherited. 

fInheritHandles

Indicates whether the new process inherits handles from the calling
process. If TRUE, 
each inheritable open handle in the calling process is inherited by the
new process. 
Inherited handles have the same value and access privileges as the
original handles. 

fdwCreate

Specifies additional flags that control the priority class and the
creation of the process. 
The following creation flags can be specified in any combination, except
as noted: 

Value	Meaning
CREATE_DEFAULT_ERROR_MODE	
	The new process does not inherit the error mode of the calling
process. Instead, CreateProcess gives the new process the current
default error mode. An application sets the current default error mode
by calling SetErrorMode.This flag is particularly useful for
multi-threaded shell applications that run with hard errors disabled.
The default behavior for CreateProcess is for the new process to inherit
the error mode of the caller. Setting this flag changes that default
behavior.
CREATE_NEW_CONSOLE	
	The new process has a new console, instead of inheriting the
parent's console. This flag cannot be used with the DETACHED_PROCESS
flag.
CREATE_NEW_PROCESS_GROUP	
	The new process is the root process of a new process group. The
process group includes all processes that are descendants of this root
process. The process ID of the new process group is the same as the
process ID, which is returned in the lppiProcInfo parameter. Process
groups are used by the GenerateConsoleCtrlEvent function to enable
sending a CTRL+C or CTRL+BREAK signal to a group of console processes.
CREATE_SEPARATE_WOW_VDM	
	This flag is only valid only launching a 16-bit Windows program.
If set, the new process is run in a private Virtual DOS Machine (VDM).
By default, all 16-bit Windows programs are run in a single, shared VDM.
The advantage of running separately is that a crash only kills the
single VDM; any other programs running in distinct VDMs continue to
function normally.  Also, 16-bit Windows applications which are run in
separate VDMs have separate input queues. That means that if one
application hangs momentarily, applications in separate VDMs continue to
receive input.
CREATE_SUSPENDED	
	The primary thread of the new process is created in a suspended
state, and does not run until the ResumeThread function is called.
CREATE_UNICODE_ENVIRONMENT	
	If set, the environment block pointed to by lpvEnvironment uses
Unicode characters. If clear, the environment block uses ANSI
characters.
DEBUG_PROCESS	
	If set, the calling process is treated as a debugger, and the
new process is a process being debugged. The system notifies the
debugger of all debug events that occur in the process being debugged.
DEBUG_ONLY_THIS_PROCESS	
	If not set and the calling process is being debugged, the new
process becomes another process being debugged by the calling process's
debugger. If the calling process is not a process being debugged, no
debugging-related actions occur.
DETACHED_PROCESS	
	For console processes, the new process does not have access to
the console of the parent process. The new process can call AllocConsole
if it later wants to create a new console. This flag cannot be used with
the CREATE_NEW_CONSOLE flag.
The fdwCreate parameter also controls the new process's priority class,
which is used in 
determining the scheduling priorities of the process's threads. If none
of the following 
priority class flags is specified, the priority class defaults to 
NORMAL_PRIORITY_CLASS unless the priority class of the creating process
is 
IDLE_PRIORITY_CLASS. In this case the default priority class of the
child process is 
IDLE_PRIORITY_CLASS. One of the following flags can be specified: 

Priority	Meaning
HIGH_PRIORITY_CLASS	Indicates a process that performs time-critical
tasks that must be executed immediately for it to run correctly. The
threads of a high-priority class process preempt the threads of
normal-priority or idle-priority class processes. An example is Windows
Task List, which must respond quickly when called by the user,
regardless of the load on the operating system. Use extreme care when
using the high-priority class, because a high-priority class CPU-bound
application can use nearly all available cycles.
IDLE_PRIORITY_CLASS	Indicates a process whose threads run only when
the system is idle and are preempted by the threads of any process
running in a higher priority class. An example is a screen saver. The
idle priority class is inherited by child processes.
NORMAL_PRIORITY_CLASS	Indicates a normal process with no special
scheduling needs.
REALTIME_PRIORITY_CLASS	Indicates a process that has the highest
possible priority. The threads of a real-time priority class process
preempt the threads of all other processes, including operating system
processes performing important tasks. For example, a real-time process
that executes for more than a very brief interval can cause disk caches
not to flush or cause the mouse to be unresponsive.


lpvEnvironment

Points to an environment block for the new process. If this parameter is
NULL, the new 
process uses the environment of the calling process. 
An environment block consists of a null-terminated block of
null-terminated strings. Each 
string is in the form: 

name=value


Because the equal sign is used as a separator, it must not be used in
the name of an 
environment variable. 
If an application provides an environment block, rather than passing
NULL for this 
parameter, the current directory information of the system drives is not
automatically 
propagated to the new process. See the following Remarks section for a
discussion of this 
situation and how to handle it. 
An environment block can contain Unicode or ANSI characters.If the
environment block 
pointed to by lpvEnvironment contains Unicode characters, the fdwCreate
field's 
CREATE_UNICODE_ENVIRONMENT flag will be set. If the block contains ANSI
characters, that flag will be clear.
Note that an ANSI environment block is terminated by two zero bytes: one
for the last 
string, one more to terminate the block. A Unicode environment block is
terminated by 
four zero bytes: two for the last string, two more to terminate the
block.
lpszCurDir

Points to a null-terminated string that specifies the current drive and
directory for the new 
process. The string must be a full path and filename that includes a
drive letter. If this 
parameter is NULL, the new process is created with the same current
drive and directory 
as the calling process. This option is provided primarily for shells
that need to start an 
application and specify its initial drive and working directory. 

lpsiStartInfo

Points to a STARTUPINFO structure that specifies how the main window for
the new 
process should appear. 

lppiProcInfo

Points to a PROCESS_INFORMATION structure that receives identification 
information about the new process. 



Return Value

If the function succeeds, the return value is TRUE.
If the function fails, the return value is FALSE. To get extended error
information, call 
GetLastError. 

Remarks

The CreateProcess function is used to run a new program. The WinExec and
LoadModule
 functions are still available, but they are implemented as calls to
CreateProcess. 
In addition to creating a process, CreateProcess also creates a thread
object. The thread is 
created with an initial stack whose size is described in the image
header of the specified 
program's executable file. The thread begins execution at the image's
entry point. 
The new process and the new thread handles are created with full access
rights. For either 
handle, if a security descriptor is not provided, the handle can be used
in any function that 
requires an object handle of that type. When a security descriptor is
provided, an access 
check is performed on all subsequent uses of the handle before access is
granted. If the 
access check denies access, the requesting process is not able to use
the handle to gain 
access to the thread. 

The process is assigned a 32-bit process identifier. The ID is valid
until the process 
terminates. It can be used to identify the process, or specified in the
OpenProcess function 
to open a handle to the process. The initial thread in the process is
also assigned a 32-bit 
thread identifier. The ID is valid until the thread terminates and can
be used to uniquely 
identify the thread within the system. These identifiers are returned in
the 
PROCESS_INFORMATION structure. 
When specifying an application name in the lpszImageName or
lpszCommandLine strings, it 
doesn't matter whether the application name includes the filename
extension, with one 
exception: an MS-DOS - based or Windows-based application whose filename
extension is 
.COM. 
The calling thread can use the WaitForInputIdle function to wait until
the new process has 
finished its initialization and is waiting for user input with no input
pending. This can be 
useful for synchronization between parent and child processes, because
CreateProcess 
returns without waiting for the new process to finish its
initialization. For example, the 
creating process would use WaitForInputIdle before trying to find a
window associated 
with the new process. 

The preferred way to shut down a process is by using the ExitProcess
function, because this 
function notifies all DLLs attached to the process of the approaching
termination. Other 
means of shutting down a process do not notify the attached DLLs. Note
that when a thread 
calls ExitProcess, other threads of the process are terminated without
an opportunity to 
execute any additional code (including the thread termination code of
attached DLLs). 
ExitProcess, ExitThread, CreateThread, CreateRemoteThread, and a process
that is 
starting (as the result of a call by CreateProcess) are serialized
between each other within a 
process. Only one of these events can happen in an address space at a
time. This means the 
following restrictions hold: 

·	During process startup and DLL initialization routines, new
threads can be created, but 
they do not begin execution until DLL initialization is done for the
process. 
·	Only one thread in a process can be in a DLL initialization or
detach routine at a time. 
·	The ExitProcess function does not return until no threads are in
their DLL initialization or 
detach routines. 
The created process remains in the system until all threads within the
process have 
terminated and all handles to the process and any of its threads have
been closed through 
calls to CloseHandle. The handles for both the process and the main
thread must be closed 
through calls to CloseHandle. If these handles are not needed, it is
best to close them 
immediately after the process is created. 
When the last thread in a process terminates, the following events
occur: 

·	All objects opened by the process are implicitly closed. 
·	The process's termination status (which is returned by
GetExitCodeProcess) changes 
from its initial value of STILL_ACTIVE to the termination status of the
last thread to 
terminate. 
·	The thread object of the main thread is set to the signaled
state, satisfying any threads that 
were waiting on the object. 
·	The process object is set to the signaled state, satisfying any
threads that were waiting on 
the object. 



If the current directory on drive C is \MSVC\MFC, there is an
environment variable called 
=C: whose value is C:\MSVC\MFC. As noted in the previous description of
lpvEnvironment, 
such current directory information for a system's drives does not
automatically propagate to 
a new process when the CreateProcess function's lpvEnvironment parameter
is non-NULL. 
An application must manually pass the current directory information to
the new process. To 
do so, the application must explicitly create the =X environment
variable strings, get them 
into alphabetical order (because Windows NT uses a sorted environment),
and then put them 
into the environment block specified by lpvEnvironment. Typically, they
will go at the front 
of the environment block, due to the previously mentioned Windows NT
environment block 
sorting. 

One way to obtain the current directory variable for a drive X is to
call GetFullPathName(
"X:",. .). That avoids an application having to scan the environment
block. If the full path 
returned is X:\, there is no need to pass that value on as environment
data, since the root 
directory is the default current directory for drive X of a new process.

The handle returned by the CreateProcess function has PROCESS_ALL_ACCESS
access 
to the process object. 
When a process is created with CREATE_NEW_PROCESS_GROUP specified, an
implicit 
call to SetConsoleCtrlHandler(NULL,TRUE) is made on behalf of the new
process; this 
means that the new process has Ctrl-C disabled. This lets good shells
handle Ctrl-C themselves, 
and selectively pass that signal on to sub-processes. Ctrl-BREAK is not
disabled, and may be 
used to interrupt the process/process group. 

See Also



AllocConsole, CloseHandle, CreateRemoteThread, CreateThread,
ExitProcess, 
ExitThread, GetCommandLine, GetEnvironmentStrings, GetExitCodeProcess, 
GetStartupInfo, GetSystemDirectory, GetWindowsDirectory, OpenProcess, 
ResumeThread, TerminateProcess 



-- 
David Charles LeBlanc
Georgia Institute of Technology, Atlanta Georgia, 30332
Internet: gt6977b@acme.gatech.edu

